name: Update Protos + Open PR

on:
  workflow_dispatch:
    inputs:
      api_version:
        description: "The API version, including the `v`"
        type: string
        required: true
  repository_dispatch:
    types:
      - protos-updated

jobs:
  update-protos:
    if: github.repository_owner == 'viamrobotics'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v5
        with:
          token: ${{ secrets.REPO_READ_TOKEN }}
      - uses: bufbuild/buf-setup-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
      - uses: arduino/setup-protoc@v3
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          version: "29.2"
      - name: Install uv
        uses: astral-sh/setup-uv@v7
        with:
          python-version: "3.13"
          enable-cache: true

      - name: API Version - Repository Dispatch
        if: github.event.client_payload.tag != ''
        run: |
          echo "API_VERSION=${{github.event.client_payload.tag}}" >> $GITHUB_ENV

      - name: API Version - User Input
        if: inputs.api_version != ''
        run: |
          echo "API_VERSION=${{inputs.api_version}}" >> $GITHUB_ENV

      - name: prune origin
        run: git remote prune origin

      - name: Setup Python
        run: uv python install

      - name: Store API version
        run: |
          uv run python3 etc/_update_version_metadata.py src/viam/version_metadata.py ${{ env.API_VERSION }}
          echo "Updated API version to ${{ env.API_VERSION }} in src/viam/version_metadata.py"

      - name: Generate buf
        run: uv run make buf
        env:
          BUF_TOKEN: ${{ secrets.BUF_TOKEN }}

      - name: Install OpenCode CLI
        run: |
          curl -fsSL https://opencode.ai/install | bash
          echo "$HOME/.opencode/bin" >> $GITHUB_PATH

      - name: Update Python Wrappers with OpenCode CLI
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          cat > /tmp/opencode_prompt.txt << 'PROMPT_EOF'
            The protobuf definitions have been updated and compiled into Python files in `src/viam/gen/`.

            ## IMPORTANT: Use git diff to identify changes

            Run `git diff src/viam/gen/` to see what changed in the generated protobuf files.
            DO NOT read through every proto file. ONLY look at the diff to understand what needs to be updated.

            Based on the diff, update the corresponding Python wrapper functions to reflect ONLY the changes shown.

            ## Context
            This repository wraps protobuf messages and gRPC calls into native Python functions for ergonomic, Pythonic usage.

            ## Wrapper Architecture

            ### Components and Services
            For each component/service, there are typically four files:
            1. **Abstract base class** (`src/viam/components/<name>/<name>.py` or `src/viam/services/<name>/<name>.py`)
               - Defines the Python API contract with abstract methods
            2. **Client wrapper** (`src/viam/components/<name>/client.py` or `src/viam/services/<name>/client.py`)
               - Wraps gRPC client calls into Pythonic async methods
               - Inherits from the abstract base and ReconfigurableResourceRPCClientBase
            3. **Server wrapper** (`src/viam/components/<name>/service.py` or `src/viam/services/<name>/service.py`)
               - Handles incoming gRPC calls and delegates to Python implementations
               - Inherits from Unimplemented<Name>ServiceBase and ResourceRPCServiceBase
            4. **Test file** (`tests/test_<name>.py` or `tests/test_<name>_service.py`)
               - Tests both client and server wrappers
               - Uses pytest fixtures and grpclib.testing.ChannelFor

            ### App API Clients
            The `src/viam/app/` directory contains clients for the application API (data, billing, provisioning, ML training, etc.):
            - **Client files** (`src/viam/app/<name>_client.py`)
              - Wrap gRPC calls to app services (from `src/viam/gen/app/`)
              - Do NOT inherit from component base classes
              - Take `channel` and `metadata` in constructor (metadata is for auth)
              - Methods directly call the service stub and return protobuf responses
            - **Test files** (`tests/test_<name>_client.py`)
              - Test the app client methods
              - Use mock services from `tests/mocks/services.py`

            ## Your Task

            1. **First, check the diff**: Run `git diff src/viam/gen/` to see what changed
            2. **Identify affected wrappers**: Based on the diff, determine which wrapper files need updates
            3. **Apply changes**: For ONLY the files shown in the diff:

            ### For Components and Services (`src/viam/components/` and `src/viam/services/`)
            - **New RPC methods** in the diff → Add abstract method + client wrapper + server wrapper + tests
            - **Modified RPC methods** in the diff → Update method signatures, parameters, and tests
            - **Removed RPC methods** in the diff → Remove from base class, client, server, and tests

            ### For App API Clients (`src/viam/app/`)
            - **New RPC methods** in the diff → Add method to client + tests
            - **Modified RPC methods** in the diff → Update method signatures and tests
            - **Removed RPC methods** in the diff → Remove method and tests

            ## Wrapper Patterns to Follow

            ### For Components/Services

            #### Client-side pattern (in `client.py`):
            ```python
            async def method_name(
                self,
                param1: Type1,
                param2: Type2,
                *,
                extra: Optional[Dict[str, Any]] = None,
                timeout: Optional[float] = None,
                **kwargs,
            ) -> ReturnType:
                md = kwargs.get("metadata", self.Metadata()).proto
                request = MethodRequest(
                    name=self.name,
                    field1=param1,
                    field2=param2,
                    extra=dict_to_struct(extra)
                )
                response: MethodResponse = await self.client.Method(
                    request, timeout=timeout, metadata=md
                )
                return response.result_field  # or appropriate transformation
            ```

            ### Server-side pattern (in `service.py`):
            ```python
            async def Method(self, stream: Stream[MethodRequest, MethodResponse]) -> None:
                request = await stream.recv_message()
                assert request is not None
                resource = self.get_resource(request.name)
                timeout = stream.deadline.time_remaining() if stream.deadline else None
                result = await resource.method_name(
                    request.field1,
                    request.field2,
                    extra=struct_to_dict(request.extra),
                    timeout=timeout,
                    metadata=stream.metadata
                )
                await stream.send_message(MethodResponse(result_field=result))
            ```

            #### Abstract base class pattern (in `<name>.py`):
            ```python
            @abc.abstractmethod
            async def method_name(
                self,
                param1: Type1,
                param2: Type2,
                *,
                extra: Optional[Dict[str, Any]] = None,
                timeout: Optional[float] = None,
                **kwargs,
            ) -> ReturnType:
                """
                Brief description of what this method does.

                Args:
                    param1: Description
                    param2: Description

                Returns:
                    Description of return value
                """
                ...
            ```

            #### Test pattern (in `tests/test_<name>.py`):
            ```python
            from typing import cast
            from unittest.mock import AsyncMock
            import pytest
            from grpclib.testing import ChannelFor
            from viam.components.<name> import <Name>, <Name>Client
            from viam.components.<name>.service import <Name>RPCService
            from viam.proto.component.<name> import <Name>ServiceStub, MethodRequest
            from viam.resource.manager import ResourceManager
            from viam.utils import dict_to_struct

            @pytest.fixture(scope="function")
            def <name>() -> <Name>:
                mock = create_mock_subclass(<Name>)
                return mock(name="<name>")

            @pytest.fixture(scope="function")
            def service(<name>) -> <Name>RPCService:
                manager = ResourceManager([<name>])
                return <Name>RPCService(manager)

            class TestService:
                async def test_method_name(self, <name>: <Name>, service: <Name>RPCService):
                    async with ChannelFor([service]) as channel:
                        request = MethodRequest(name=<name>.name, field1=value1, extra=dict_to_struct({"a": "b"}))
                        client = <Name>ServiceStub(channel)
                        await client.Method(request, timeout=1.82)
                        cast(AsyncMock, <name>.method_name).assert_called_once_with(
                            value1, timeout=expected_grpc_timeout(1.82), extra={"a": "b"}, metadata={}
                        )

            class TestClient:
                # Similar pattern for testing client methods
            ```

            ### For App API Clients

            #### App client pattern (in `src/viam/app/<name>_client.py`):
            ```python
            from typing import Optional
            from grpclib.client import Channel
            from viam.proto.app.<service> import (
                <Service>ServiceStub,
                MethodRequest,
                MethodResponse,
            )

            class <Name>Client:
                """gRPC client for <purpose> from app."""

                def __init__(self, channel: Channel, metadata: Mapping[str, str]):
                    self._metadata = metadata
                    self._client = <Service>ServiceStub(channel)
                    self._channel = channel

                async def method_name(
                    self,
                    param1: Type1,
                    timeout: Optional[float] = None
                ) -> MethodResponse:
                    """Method description.

                    Args:
                        param1: Description
                        timeout: Optional timeout

                    Returns:
                        Description of return value
                    """
                    request = MethodRequest(field1=param1)
                    return await self._client.Method(request, metadata=self._metadata, timeout=timeout)
            ```

            #### App client test pattern (in `tests/test_<name>_client.py`):
            ```python
            import pytest
            from grpclib.testing import ChannelFor
            from viam.app.<name>_client import <Name>Client
            from viam.proto.app.<service> import MethodResponse
            from .mocks.services import Mock<Name>

            AUTH_TOKEN = "auth_token"
            METADATA = {"authorization": f"Bearer {AUTH_TOKEN}"}

            @pytest.fixture(scope="function")
            def service() -> Mock<Name>:
                return Mock<Name>(expected_response=MethodResponse(...))

            class TestClient:
                async def test_method_name(self, service: Mock<Name>):
                    async with ChannelFor([service]) as channel:
                        client = <Name>Client(channel, METADATA)
                        response = await client.method_name(param1="value")
                        assert response == expected_response
                        assert service.param1 == "value"
            ```

            ## Key Guidelines

            ### For Components/Services:
            - Use snake_case for Python method names (convert from PascalCase RPC names)
            - Keep the signature pattern: required params, then `*`, then `extra`, `timeout`, `**kwargs`
            - Always extract metadata: `md = kwargs.get("metadata", self.Metadata()).proto`
            - Use `dict_to_struct()` for extra fields going to protobuf
            - Use `struct_to_dict()` for extra fields coming from protobuf
            - Import new Request/Response types at the top of the file
            - Maintain consistent error handling and type hints
            - For methods that return void, don't return anything in the client wrapper
            - For methods that return values, extract and return the appropriate field from the response
            - Tests should use `grpclib.testing.ChannelFor` for mocking
            - Tests should use `create_mock_subclass` from `tests.mocks` for creating mock resources
            - Tests should verify method calls with `cast(AsyncMock, resource.method).assert_called_once_with(...)`

            ### For App API Clients:
            - Methods take direct parameters (not `extra`, `**kwargs` patterns)
            - Always pass `self._metadata` and optional `timeout` to stub calls
            - Return protobuf response objects directly (minimal transformation)
            - Constructor takes `channel: Channel` and `metadata: Mapping[str, str]`
            - Store stub in `self._client`, channel in `self._channel`, metadata in `self._metadata`
            - Tests use mock services from `tests/mocks/services.py`
            - Tests verify request parameters by checking service attributes

            ## Output Requirements
            - Do NOT create any new files. Only update existing wrapper and test files.
            - Make focused, surgical changes - only modify what's necessary based on the git diff.
            - Do NOT read through every proto file. Use git diff to identify changes.
            - Ensure all imports are updated to include new Request/Response types.
            - Follow the established patterns in the repository.

            ## Verification
            After making changes, verify that:
            - All new RPC methods from the diff have corresponding Python wrappers
            - All updated RPC methods from the diff reflect the new message structure
            - All removed RPC methods from the diff are deleted from wrappers
            - Tests are added/updated/removed for all wrapper changes
            - Both component/service wrappers AND app API client wrappers are updated
          PROMPT_EOF

          opencode run --model anthropic/claude-sonnet-4-5-20250929 --agent build "$(cat /tmp/opencode_prompt.txt)"

      - name: Format
        run: uv run make format

      - name: Add + Commit + Open PR
        id: cpr
        uses: peter-evans/create-pull-request@v7
        with:
          commit-message: "[WORKFLOW] Updating protos from ${{ github.event.client_payload.repo_name }}, commit: ${{ github.event.client_payload.sha }}"
          branch: "workflow/update-proto"
          delete-branch: true
          base: main
          title: Automated Protos Update
          body: This is an auto-generated PR to update proto definitions. Check the commits to see which repos and commits are responsible for the changes
          assignees: njooma
          reviewers: njooma
          token: ${{ secrets.GIT_ACCESS_TOKEN }}

      - name: Notify slack of failure
        uses: slackapi/slack-github-action@v1.24.0
        if: ${{ failure() }}
        with:
          payload: |
            {
              "text": "Python SDK update protos job has failed",
              "username": "Python SDK",
              "icon_url": "https://media.tenor.com/bZMubztJxGkAAAAe/charlie-brown-walking-charlie-brown.png"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_TEAM_SDK_WEBHOOK_URL }}
