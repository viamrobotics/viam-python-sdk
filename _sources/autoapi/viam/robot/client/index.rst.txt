viam.robot.client
=================

.. py:module:: viam.robot.client


Attributes
----------

.. autoapisummary::

   viam.robot.client.RESOURCE_TYPE_COMPONENT
   viam.robot.client.RESOURCE_TYPE_SERVICE
   viam.robot.client.LOGGER


Exceptions
----------

.. autoapisummary::

   viam.robot.client.ResourceNotFoundError


Classes
-------

.. autoapisummary::

   viam.robot.client.ComponentBase
   viam.robot.client.LogEntry
   viam.robot.client.PoseInFrame
   viam.robot.client.ResourceName
   viam.robot.client.Transform
   viam.robot.client.BlockForOperationRequest
   viam.robot.client.CancelOperationRequest
   viam.robot.client.DiscoverComponentsRequest
   viam.robot.client.DiscoverComponentsResponse
   viam.robot.client.Discovery
   viam.robot.client.DiscoveryQuery
   viam.robot.client.FrameSystemConfig
   viam.robot.client.FrameSystemConfigRequest
   viam.robot.client.FrameSystemConfigResponse
   viam.robot.client.GetCloudMetadataRequest
   viam.robot.client.GetCloudMetadataResponse
   viam.robot.client.GetOperationsRequest
   viam.robot.client.GetOperationsResponse
   viam.robot.client.GetStatusRequest
   viam.robot.client.GetStatusResponse
   viam.robot.client.LogRequest
   viam.robot.client.Operation
   viam.robot.client.ResourceNamesRequest
   viam.robot.client.ResourceNamesResponse
   viam.robot.client.RobotServiceStub
   viam.robot.client.ShutdownRequest
   viam.robot.client.StopAllRequest
   viam.robot.client.StopExtraParameters
   viam.robot.client.TransformPoseRequest
   viam.robot.client.TransformPoseResponse
   viam.robot.client.ResourceBase
   viam.robot.client.ResourceManager
   viam.robot.client.Registry
   viam.robot.client.ReconfigurableResourceRPCClientBase
   viam.robot.client.ResourceRPCClientBase
   viam.robot.client.Subtype
   viam.robot.client.DialOptions
   viam.robot.client.ViamChannel
   viam.robot.client.ServiceBase
   viam.robot.client.SessionsClient
   viam.robot.client.RobotClient


Functions
---------

.. autoapisummary::

   viam.robot.client.dial
   viam.robot.client.datetime_to_timestamp
   viam.robot.client.dict_to_struct


Module Contents
---------------

.. py:class:: ComponentBase(name: str)

   Bases: :py:obj:`abc.ABC`, :py:obj:`viam.resource.base.ResourceBase`


   Base component.
   All components must inherit from this class.


   .. py:attribute:: SUBTYPE
      :type:  ClassVar[viam.resource.types.Subtype]


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/services/frame-system/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:exception:: ResourceNotFoundError(resource: str, name: str)

   Bases: :py:obj:`ViamGRPCError`


   Exception raised when a resource is not found in the registry


.. py:class:: LogEntry(*, host: str = ..., level: str = ..., time: google.protobuf.timestamp_pb2.Timestamp | None = ..., logger_name: str = ..., message: str = ..., caller: google.protobuf.struct_pb2.Struct | None = ..., stack: str = ..., fields: collections.abc.Iterable[google.protobuf.struct_pb2.Struct] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: host
      :type:  str


   .. py:attribute:: level
      :type:  str


   .. py:attribute:: logger_name
      :type:  str


   .. py:attribute:: message
      :type:  str


   .. py:attribute:: stack
      :type:  str


   .. py:property:: time
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: caller
      :type: google.protobuf.struct_pb2.Struct



   .. py:property:: fields
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.struct_pb2.Struct]



   .. py:method:: HasField(field_name: Literal['caller', b'caller', 'time', b'time']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: PoseInFrame(*, reference_frame: str = ..., pose: global___Pose | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   PoseInFrame contains a pose and the and the reference frame in which it was observed


   .. py:attribute:: reference_frame
      :type:  str


   .. py:property:: pose
      :type: global___Pose



   .. py:method:: HasField(field_name: Literal['pose', b'pose']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ResourceName(*, namespace: str = ..., type: str = ..., subtype: str = ..., name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: namespace
      :type:  str


   .. py:attribute:: type
      :type:  str


   .. py:attribute:: subtype
      :type:  str


   .. py:attribute:: name
      :type:  str


.. py:class:: Transform(*, reference_frame: str = ..., pose_in_observer_frame: global___PoseInFrame | None = ..., physical_object: global___Geometry | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Transform contains a pose and two reference frames. The first reference frame is the starting reference frame, and the second reference
   frame is the observer reference frame. The second reference frame has a pose which represents the pose of an object in the first
   reference frame as observed within the second reference frame.


   .. py:attribute:: reference_frame
      :type:  str

      the name of a given reference frame


   .. py:property:: pose_in_observer_frame
      :type: global___PoseInFrame

      the pose of the above reference frame with respect to a different observer reference frame


   .. py:property:: physical_object
      :type: global___Geometry



   .. py:method:: HasField(field_name: Literal['_physical_object', b'_physical_object', 'physical_object', b'physical_object', 'pose_in_observer_frame', b'pose_in_observer_frame']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_physical_object', b'_physical_object']) -> Literal['physical_object'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: BlockForOperationRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: CancelOperationRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: DiscoverComponentsRequest(*, queries: collections.abc.Iterable[global___DiscoveryQuery] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: queries
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___DiscoveryQuery]



.. py:class:: DiscoverComponentsResponse(*, discovery: collections.abc.Iterable[global___Discovery] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: discovery
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Discovery]



.. py:class:: Discovery(*, query: global___DiscoveryQuery | None = ..., results: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: query
      :type: global___DiscoveryQuery



   .. py:property:: results
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['query', b'query', 'results', b'results']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DiscoveryQuery(*, subtype: str = ..., model: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Discovery


   .. py:attribute:: subtype
      :type:  str


   .. py:attribute:: model
      :type:  str


.. py:class:: FrameSystemConfig(*, frame: viam.gen.common.v1.common_pb2.Transform | None = ..., kinematics: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   this is an experimental API message


   .. py:property:: frame
      :type: viam.gen.common.v1.common_pb2.Transform



   .. py:property:: kinematics
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['frame', b'frame', 'kinematics', b'kinematics']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: FrameSystemConfigRequest(*, supplemental_transforms: collections.abc.Iterable[viam.gen.common.v1.common_pb2.Transform] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: supplemental_transforms
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.Transform]

      pose information on any additional reference frames that are needed
      to supplement the robot's frame system


.. py:class:: FrameSystemConfigResponse(*, frame_system_configs: collections.abc.Iterable[global___FrameSystemConfig] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: frame_system_configs
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FrameSystemConfig]



.. py:class:: GetCloudMetadataRequest

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: GetCloudMetadataResponse(*, robot_part_id: str = ..., primary_org_id: str = ..., location_id: str = ..., machine_id: str = ..., machine_part_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: robot_part_id
      :type:  str

      use machine_part_id field.

      :type: Deprecated


   .. py:attribute:: primary_org_id
      :type:  str


   .. py:attribute:: location_id
      :type:  str


   .. py:attribute:: machine_id
      :type:  str


   .. py:attribute:: machine_part_id
      :type:  str


.. py:class:: GetOperationsRequest

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: GetOperationsResponse(*, operations: collections.abc.Iterable[global___Operation] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: operations
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Operation]



.. py:class:: GetStatusRequest(*, resource_names: collections.abc.Iterable[viam.gen.common.v1.common_pb2.ResourceName] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: resource_names
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.ResourceName]



.. py:class:: GetStatusResponse(*, status: collections.abc.Iterable[global___Status] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: status
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Status]



.. py:class:: LogRequest(*, logs: collections.abc.Iterable[viam.gen.common.v1.common_pb2.LogEntry] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: logs
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.LogEntry]



.. py:class:: Operation(*, id: str = ..., method: str = ..., arguments: google.protobuf.struct_pb2.Struct | None = ..., started: google.protobuf.timestamp_pb2.Timestamp | None = ..., session_id: str | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: method
      :type:  str


   .. py:attribute:: session_id
      :type:  str


   .. py:property:: arguments
      :type: google.protobuf.struct_pb2.Struct



   .. py:property:: started
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:method:: HasField(field_name: Literal['_session_id', b'_session_id', 'arguments', b'arguments', 'session_id', b'session_id', 'started', b'started']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_session_id', b'_session_id']) -> Literal['session_id'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: ResourceNamesRequest

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: ResourceNamesResponse(*, resources: collections.abc.Iterable[viam.gen.common.v1.common_pb2.ResourceName] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: resources
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.ResourceName]



.. py:class:: RobotServiceStub(channel: grpclib.client.Channel)

.. py:class:: ShutdownRequest

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: StopAllRequest(*, extra: collections.abc.Iterable[global___StopExtraParameters] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: extra
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StopExtraParameters]



.. py:class:: StopExtraParameters(*, name: viam.gen.common.v1.common_pb2.ResourceName | None = ..., params: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: name
      :type: viam.gen.common.v1.common_pb2.ResourceName



   .. py:property:: params
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['name', b'name', 'params', b'params']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: TransformPoseRequest(*, source: viam.gen.common.v1.common_pb2.PoseInFrame | None = ..., destination: str = ..., supplemental_transforms: collections.abc.Iterable[viam.gen.common.v1.common_pb2.Transform] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: destination
      :type:  str

      the reference frame into which the source pose should be transformed,
      if unset this defaults to the "world" reference frame


   .. py:property:: source
      :type: viam.gen.common.v1.common_pb2.PoseInFrame

      the original pose to transform along with the reference frame in
      which it was observed


   .. py:property:: supplemental_transforms
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.Transform]

      pose information on any additional reference frames that are needed
      to perform the transform


   .. py:method:: HasField(field_name: Literal['source', b'source']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: TransformPoseResponse(*, pose: viam.gen.common.v1.common_pb2.PoseInFrame | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: pose
      :type: viam.gen.common.v1.common_pb2.PoseInFrame



   .. py:method:: HasField(field_name: Literal['pose', b'pose']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ResourceBase

   Bases: :py:obj:`Protocol`


   The base requirements for a Resource.


   .. py:attribute:: SUBTYPE
      :type:  ClassVar[viam.resource.types.Subtype]

      The Subtype of the Resource


   .. py:attribute:: name
      :type:  str

      The name of the Resource


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      :abstractmethod:


      Get the Resource named ``name`` from the provided robot.

      ::

          # Can be used with any resource, using an arm as an example
          my_arm = Arm.from_robot(robot, "my_arm")

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the Resource
      :type name: str

      :returns: The Resource, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: ResourceManager(components: List[viam.resource.base.ResourceBase] = [])

   Registry containing all components registered to this server.


   .. py:attribute:: resources
      :type:  Dict[viam.proto.common.ResourceName, viam.resource.base.ResourceBase]


   .. py:method:: register(resource: viam.resource.base.ResourceBase)

      Register a new resource with the registry.
      Resources may not have the same name.
      If a resource is remote and the short name is unique, save a short name version.

      :raises DuplicateResourceError: Error if attempting to register resource
          with the name of an existing resource
      :raises ResourceNotFoundError: Raised if the subtype of the resource is not registered

      :param resource: The resource to register
      :type resource: ResourceBase



   .. py:method:: get_resource(of_type: Type[ResourceType], name: viam.proto.common.ResourceName) -> ResourceType

      Return a resource from the registry.
      If a unique short name version is given, return a remote resource with the name.

      :param of_type: The type of the resource
      :type of_type: Type[ResourceType]
      :param name: The name of the resource
      :type name: viam.proto.common.ResourceName

      :raises ResourceNotFoundError: Error if resource with the given type
          and name does not exist in the registry

      :returns: The resource
      :rtype: ResourceType



   .. py:method:: remove_resource(name: viam.proto.common.ResourceName)
      :async:


      Remove the resource with the specified ```ResourceName```.

      :param name: The ResourceName of the resource
      :type name: viam.proto.common.ResourceName



   .. py:method:: close()
      :async:


      Close the resourcce manager by removing all resources.
      Please note that any errors will not raise an exception. Errors will still be logged.



.. py:class:: Registry

   The global registry of robotic parts.

   **NB** The Registry should almost never be used directly

   The Registry keeps track of the types of Resources that are available on robots using this SDK. All the base resource types are
   pre-registered (for example Arm, Motor).

   If you create a new resource type that is not an extension of any of the existing base resource types, then you must register said
   resource using ``Registry.register(...)``.


   .. py:method:: register_subtype(registration: ResourceRegistration[Resource])
      :classmethod:


      Register a Subtype with the Registry

      :param registration: Object containing registration data for the subtype
      :type registration: ResourceRegistration

      :raises DuplicateResourceError: Raised if the Subtype to register is already in the registry
      :raises ValidationError: Raised if registration is missing any necessary parameters



   .. py:method:: register_resource_creator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model, registration: ResourceCreatorRegistration)
      :classmethod:


      Register a specific ``Model`` and validator function for the specific resource ``Subtype`` with the Registry

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model
      :param registration: The registration functions of the model
      :type registration: ResourceCreatorRegistration

      :raises DuplicateResourceError: Raised if the Subtype and Model pairing is already registered
      :raises ValidationError: Raised if registration does not have creator



   .. py:method:: lookup_subtype(subtype: viam.resource.types.Subtype) -> ResourceRegistration
      :classmethod:


      Lookup and retrieve a registered Subtype by its name

      :param subtype: The subtype of the resource
      :type subtype: str

      :raises ResourceNotFoundError: Raised if the Subtype is not registered

      :returns: The registration object of the resource
      :rtype: ResourceRegistration



   .. py:method:: lookup_resource_creator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model) -> viam.resource.types.ResourceCreator
      :classmethod:


      Lookup and retrieve a registered resource creator by its subtype and model

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model

      :raises ResourceNotFoundError: Raised if the Subtype Model pairing is not registered

      :returns: The function to create the resource
      :rtype: ResourceCreator



   .. py:method:: lookup_validator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model) -> viam.resource.types.Validator
      :classmethod:


      Lookup and retrieve a registered validator function by its subtype and model. If there is none, return None

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model

      :returns: The function to validate the resource
      :rtype: Validator



   .. py:method:: REGISTERED_SUBTYPES() -> Mapping[viam.resource.types.Subtype, ResourceRegistration]
      :classmethod:


      The dictionary of all registered resources
      - Key: Subtype of the resource
      - Value: The registration object for the resource

      :returns: All registered resources
      :rtype: Mapping[Subtype, ResourceRegistration]



   .. py:method:: REGISTERED_RESOURCE_CREATORS() -> Mapping[str, ResourceCreatorRegistration]
      :classmethod:


      The dictionary of all registered resources
      - Key: subtype/model
      - Value: The ResourceCreatorRegistration for the resource

      :returns: All registered resources
      :rtype: Mapping[str, ResourceCreatorRegistration]



.. py:class:: ReconfigurableResourceRPCClientBase

   Bases: :py:obj:`ResourceRPCClientBase`


   A base RPC client that can reset its channel.

   Useful if connection is lost and then regained.


   .. py:method:: reset_channel(channel: grpclib.client.Channel)

      Called when the RPC channel was reset. Passes in the new channel.

      :param channel: The new RPC Channel
      :type channel: Channel



.. py:class:: ResourceRPCClientBase

   Bases: :py:obj:`Protocol`


   Base RPC client for a resource.
   Resource RPC clients must inherit from this class


   .. py:attribute:: channel
      :type:  grpclib.client.Channel


   .. py:attribute:: client
      :type:  Any


.. py:data:: RESOURCE_TYPE_COMPONENT
   :value: 'component'


.. py:data:: RESOURCE_TYPE_SERVICE
   :value: 'service'


.. py:class:: Subtype(namespace: str, resource_type: str, resource_subtype: str)

   Represents a known component/service (resource) API


   .. py:attribute:: namespace
      :type:  str

      The namespace of the resource


   .. py:attribute:: resource_type
      :type:  str

      The type of the resource, for example `component` or `service`


   .. py:attribute:: resource_subtype
      :type:  str

      The subtype of the resource for example `servo`, `arm`, `vision`


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __hash__() -> int

      Return hash(self).



   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: from_resource_name(resource_name: viam.proto.common.ResourceName) -> typing_extensions.Self
      :classmethod:


      Convert a ```ResourceName``` into a ```Subtype```

      :param resource_name: The ResourceName to convert
      :type resource_name: viam.proto.common.ResourceName

      :returns: A new Subtype
      :rtype: Self



   .. py:method:: from_string(string: str) -> typing_extensions.Self
      :classmethod:


      Create a ```Subtype``` from its string representation (namespace:resource_type:resource_subtype)

      :param string: The Subtype as a string
      :type string: str

      :raises ValueError: Raised if the string does not represent a valid Subtype

      :returns: A new Subtype
      :rtype: Self



.. py:class:: DialOptions(*, disable_webrtc: bool = False, auth_entity: Optional[str] = None, credentials: Optional[Credentials] = None, insecure: bool = False, allow_insecure_downgrade: bool = False, allow_insecure_with_creds_downgrade: bool = False, max_reconnect_attempts: int = 3, timeout: float = 20)

   .. py:attribute:: disable_webrtc
      :type:  bool

      Bypass Web RTC and connect directly to the robot.


   .. py:attribute:: auth_entity
      :type:  Optional[str]

      The URL to authenticate against. Should be used if the address passed in and FQDN of the server do not match.


   .. py:attribute:: credentials
      :type:  Optional[Credentials]

      Credentials for connecting to the robot


   .. py:attribute:: insecure
      :type:  bool
      :value: False


      Determine if the RPC connection is TLS based. Must be provided to
      establish an insecure connection. Otherwise, a TLS based connection
      will be assumed.


   .. py:attribute:: allow_insecure_downgrade
      :type:  bool
      :value: False


      Allow the RPC connection to be downgraded to an insecure connection
      if detected. This is only used when credentials are not present.


   .. py:attribute:: allow_insecure_with_creds_downgrade
      :type:  bool
      :value: False


      Allow the RPC connection to be downgraded to an insecure connection
      if detected, even with credentials present. This is generally
      unsafe to use, but can be requested.


   .. py:attribute:: max_reconnect_attempts
      :type:  int
      :value: 3


      Max number of times the client attempts to reconnect when connection is lost


   .. py:attribute:: timeout
      :type:  float
      :value: 20


      Number of seconds before the dial connection times out
      Set to 20sec to match _defaultOfferDeadline in goutils/rpc/wrtc_call_queue.go


   .. py:method:: with_api_key(api_key: str, api_key_id: str) -> typing_extensions.Self
      :classmethod:


      Create DialOptions with an API key for credentials and default values for other arguments.

      :param api_key: your API key
      :type api_key: str
      :param api_key_id: your API key ID. Must be a valid UUID
      :type api_key_id: str

      :raises ValueError: Raised if the api_key_id is not a valid UUID

      :returns: the DialOptions
      :rtype: Self



.. py:class:: ViamChannel

   .. py:attribute:: channel
      :type:  grpclib.client.Channel


   .. py:attribute:: release
      :type:  Callable[[], None]


   .. py:method:: close()


   .. py:method:: __del__()


   .. py:method:: __aenter__()
      :async:



   .. py:method:: __aexit__(exc_type, exc_value, traceback)
      :async:



.. py:function:: dial(address: str, options: Optional[DialOptions] = None) -> ViamChannel
   :async:


.. py:class:: ServiceBase(name: str)

   Bases: :py:obj:`abc.ABC`, :py:obj:`viam.resource.base.ResourceBase`


   This class describes the base functionality required for a Viam Service.
   All services must inherit from this class.


   .. py:attribute:: SUBTYPE
      :type:  ClassVar[viam.resource.types.Subtype]


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the service named ``name`` from the provided robot.

      ::

          async def connect() -> ViamClient:
              # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
              dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
              return await ViamClient.create_from_dial_options(dial_options)

          async def main():
              robot = await connect()

              # Can be used with any resource, using the motion service as an example
              motion = MotionClient.from_robot(robot=robot, name="builtin")

              robot.close()

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service
      :type name: str

      :returns: The service, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:

      :async:


      Send/receive arbitrary commands.

      ::

          motion = MotionClient.from_robot(robot, "builtin")

          my_command = {
            "cmnd": "dosomething",
            "someparameter": 52
          }

          # Can be used with any resource, using the motion service as an example
          await motion.do_command(command=my_command)

      :param command: The command to execute
      :type command: Dict[str, ValueTypes]

      :returns: Result of the executed command
      :rtype: Dict[str, ValueTypes]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: SessionsClient(channel: grpclib.client.Channel, direct_dial_address: str, dial_options: Optional[viam.rpc.dial.DialOptions], *, disabled: bool = False)

   A Session allows a client to express that it is actively connected and
   supports stopping actuating components when it's not.


   .. py:attribute:: channel
      :type:  grpclib.client.Channel


   .. py:attribute:: client
      :type:  viam.proto.robot.RobotServiceStub


   .. py:method:: reset()


   .. py:property:: metadata
      :type: grpclib.metadata._MetadataLike



.. py:function:: datetime_to_timestamp(dt: Optional[datetime.datetime]) -> Optional[google.protobuf.timestamp_pb2.Timestamp]

.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:data:: LOGGER

.. py:class:: RobotClient

   gRPC client for a Robot. This class should be used for all interactions with a robot.

   There are 2 ways to instantiate a robot client::

       RobotClient.at_address(...)
       RobotClient.with_channel(...)

   You can use the client standalone or within a context::

       robot = await RobotClient.at_address(...)
       async with await RobotClient.with_channel(...) as robot: ...

   You must ``close()`` the robot to release resources.

   Note: Robots used within a context are automatically closed UNLESS created with a channel. Robots created using ``with_channel`` are
   not automatically closed.

   Establish a Connection::

       import asyncio

       from viam.rpc.dial import DialOptions, Credentials
       from viam.robot.client import RobotClient


       async def connect():
           opts = RobotClient.Options.with_api_key(
               # Replace "<API-KEY>" (including brackets) with your machine's API key
               api_key='<API-KEY>',
               # Replace "<API-KEY-ID>" (including brackets) with your machine's API key ID
               api_key_id='<API-KEY-ID>'
           )
           return await RobotClient.at_address('<ADDRESS-FROM-THE-VIAM-APP>', opts)


       async def main():
           # Make a RobotClient
           robot = await connect()
           print('Resources:')
           print(robot.resource_names)
           await robot.close()

       if __name__ == '__main__':
           asyncio.run(main())

   For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.


   .. py:class:: Options

      .. py:attribute:: refresh_interval
         :type:  int
         :value: 0


         How often to refresh the status/parts of the robot in seconds.
         If not set, the robot will not be refreshed automatically


      .. py:attribute:: dial_options
         :type:  Optional[viam.rpc.dial.DialOptions]
         :value: None


         Options used to connect clients to gRPC servers


      .. py:attribute:: log_level
         :type:  int

         The log level to output


      .. py:attribute:: check_connection_interval
         :type:  int
         :value: 10


         The frequency (in seconds) at which to check if the robot is still connected. 0 (zero) signifies no connection checks


      .. py:attribute:: attempt_reconnect_interval
         :type:  int
         :value: 1


         The frequency (in seconds) at which to attempt to reconnect a disconnected robot. 0 (zero) signifies no reconnection attempts


      .. py:attribute:: disable_sessions
         :type:  bool
         :value: False


         Whether sessions are disabled


      .. py:method:: with_api_key(api_key: str, api_key_id: str, **kwargs) -> typing_extensions.Self
         :classmethod:


         Create RobotClient.Options with an API key for credentials and default values for other arguments.

         ::

             # Replace "<API-KEY>" (including brackets) with your machine's API key
             api_key = '<API-KEY>'
             # Replace "<API-KEY-ID>" (including brackets) with your machine's API key ID
             api_key_id = '<API-KEY-ID>'

             opts = RobotClient.Options.with_api_key(api_key, api_key_id)

             robot = await RobotClient.at_address('<ADDRESS-FROM-THE-VIAM-APP>', opts)

         :param api_key: your API key
         :type api_key: str
         :param api_key_id: your API key ID. Must be a valid UUID
         :type api_key_id: str

         :raises ValueError: Raised if the api_key_id is not a valid UUID

         :returns: the RobotClient.Options
         :rtype: Self

         For more information, see `Establish a connection <https://docs.viam.com/appendix/apis/robot/#establish-a-connection>`_.




   .. py:method:: at_address(address: str, options: Options) -> typing_extensions.Self
      :classmethod:

      :async:


      Create a robot client that is connected to the robot at the provided address.

      ::

          async def connect():

              opts = RobotClient.Options.with_api_key(
                  # Replace "<API-KEY>" (including brackets) with your machine's API key
                  api_key='<API-KEY>',
                  # Replace "<API-KEY-ID>" (including brackets) with your machine's API key ID
                  api_key_id='<API-KEY-ID>'
              )
              return await RobotClient.at_address('ADDRESS FROM THE VIAM APP', opts)


          async def main():
              # Make a RobotClient
              robot = await connect()

      :param address: Address of the robot (IP address, URL, etc.)
      :type address: str
      :param options: Options for connecting and refreshing
      :type options: Options

      :returns: the RobotClient
      :rtype: Self

      For more information, see `Establish a connection <https://docs.viam.com/appendix/apis/robot/#establish-a-connection>`_.



   .. py:method:: with_channel(channel: Union[grpclib.client.Channel, viam.rpc.dial.ViamChannel], options: Options) -> typing_extensions.Self
      :classmethod:

      :async:


      Create a robot that is connected to a robot over the given channel.

      Any robots created using this method will *NOT* automatically close the channel upon exit.

      ::

          from viam.robot.client import RobotClient
          from viam.rpc.dial import DialOptions, dial


          async def connect_with_channel() -> RobotClient:
              async with await dial('ADDRESS', DialOptions()) as channel:
                  return await RobotClient.with_channel(channel, RobotClient.Options())

          robot = await connect_with_channel()

      :param channel: The channel that is connected to a robot, obtained by ``viam.rpc.dial``
      :type channel: ViamChannel
      :param options: Options for refreshing. Any connection options will be ignored.
      :type options: Options

      :returns: the RobotClient
      :rtype: Self

      For more information, see `Establish a connection <https://docs.viam.com/appendix/apis/robot/#establish-a-connection>`_.



   .. py:method:: refresh()
      :async:


      Manually refresh the underlying parts of this robot

      ::

          await robot.refresh()

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: get_component(name: viam.proto.common.ResourceName) -> viam.components.component_base.ComponentBase

      Get a component using its ResourceName.

      This function should not be called directly except in specific cases. The method ``Component.from_robot(...)`` is the preferred
      method for obtaining components.
      ::

          arm = Arm.from_robot(robot=robot, name="my_arm")

      Because this function returns a generic ``ComponentBase`` rather than the specific
      component type, it will be necessary to cast the returned component to the desired component. This can be done using a few
      different methods:

      - Assertion::

          arm = robot.get_component(Arm.get_resource_name("my_arm"))
          assert isinstance(arm, Arm)
          end_pos = await arm.get_end_position()

      - Explicit cast::

          from typing import cast
          arm = robot.get_component(Arm.get_resource_name("my_arm"))
          arm = cast(Arm, arm)
          end_pos = await arm.get_end_position()

      - Declare type on variable assignment.

          - Note: If using an IDE, a type error may be shown which can be ignored.
          ::

              arm: Arm = robot.get_component(Arm.get_resource_name("my_arm"))  # type: ignore
              end_pos = await arm.get_end_position()

      :param name: The component's ResourceName
      :type name: viam.proto.common.ResourceName

      :raises ValueError: Raised if the requested resource is not a component
      :raises ComponentNotFoundError: Error if component with the given type and name does not exist in the registry

      :returns: The component
      :rtype: ComponentBase

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: get_service(name: viam.proto.common.ResourceName) -> viam.services.service_base.ServiceBase

      Get a service using its ResourceName

      This function should not be called directly except in specific cases. The method ``Service.from_robot(...)`` is the preferred
      method for obtaining services.
      ::

          service = MyService.from_robot(robot=robot, name="my_service")

      Because this function returns a generic ``ServiceBase`` rather than a specific service type, it will be necessary to cast the
      returned service to the desired service. This can be done using a few methods:

      - Assertion::

          service = robot.get_service(MyService.get_resource_name("my_service"))
          assert isinstance(service, MyService)

      - Explicit cast::

          from typing import cast
          service = robot.get_service(MyService.get_resource_name("my_service"))
          service = cast(MyService, my_service)

      - Declare type on variable assignment

          - Note: If using an IDE, a type error may be shown which can be ignored.
          ::

              service: MyService = robot.get_service(MyService.get_resource_name("my_service"))  # type: ignore

      :param name: The service's ResourceName
      :type name: viam.proto.common.ResourceName

      :raises ValueError: Raised if the requested resource is not a component
      :raises ComponentNotFoundError: Error if component with the given type and name does not exist in the registry

      :returns: The service
      :rtype: ServiceBase

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:property:: resource_names
      :type: List[viam.proto.common.ResourceName]

      Get a list of all resource names

      ::

          resource_names = robot.resource_names

      :returns: The list of resource names
      :rtype: List[viam.proto.common.ResourceName]

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.


   .. py:method:: close()
      :async:


      Cleanly close the underlying connections and stop any periodic tasks.

      ::

          await robot.close()

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: __aenter__()
      :async:



   .. py:method:: __aexit__(exc_type, exc_value, traceback)
      :async:



   .. py:method:: get_status(components: Optional[List[viam.proto.common.ResourceName]] = None)
      :async:


      Get the status of the robot's components. You can optionally
      provide a list of ``ResourceName`` for which you want statuses.

      ::

          # Get the status of the resources on the machine.
          statuses = await robot.get_status()

      :param components: Optional list of
                         ``ResourceName`` for components you want statuses.
      :type components: Optional[List[viam.proto.common.ResourceName]]

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: get_operations() -> List[viam.proto.robot.Operation]
      :async:


      Get the list of operations currently running on the robot.

      ::

          operations = await robot.get_operations()

      :returns: The list of operations currently running on a given robot.
      :rtype: List[viam.proto.robot.Operation]

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: cancel_operation(id: str)
      :async:


      Cancels the specified operation on the robot.

      ::

          await robot.cancel_operation("INSERT OPERATION ID")

      :param id: ID of operation to cancel.
      :type id: str

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: block_for_operation(id: str)
      :async:


      Blocks on the specified operation on the robot. This function will only return when the specific operation
      has finished or has been cancelled.

      ::

          await robot.block_for_operation("INSERT OPERATION ID")

      :param id: ID of operation to block on.
      :type id: str

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: get_frame_system_config(additional_transforms: Optional[List[viam.proto.common.Transform]] = None) -> List[viam.proto.robot.FrameSystemConfig]
      :async:


      Get the configuration of the frame system of a given robot.

      ::

          # Get a list of each of the reference frames configured on the machine.
          frame_system = await robot.get_frame_system_config()
          print(f"frame system configuration: {frame_system}")

      :returns: The configuration of a given robot's frame system.
      :rtype: List[viam.proto.robot.FrameSystemConfig]

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: transform_pose(query: viam.proto.common.PoseInFrame, destination: str, additional_transforms: Optional[List[viam.proto.common.Transform]] = None) -> viam.proto.common.PoseInFrame
      :async:


      Transform a given source Pose from the reference frame to a new specified destination which is a reference frame.

      ::

          pose = await robot.transform_pose(PoseInFrame(), "origin")

      :param query: The pose that should be transformed.
      :type query: viam.proto.common.PoseInFrame
      :param destination: The name of the reference frame to transform the given pose to.
      :type destination: str

      :returns: The pose and the reference frame for the new destination.
      :rtype: PoseInFrame

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: transform_point_cloud()
      :abstractmethod:

      :async:



   .. py:method:: discover_components(queries: List[viam.proto.robot.DiscoveryQuery]) -> List[viam.proto.robot.Discovery]
      :async:


      Get the list of discovered component configurations.

      ::

          # Define a new discovery query.
          q = robot.DiscoveryQuery(subtype=acme.API, model="some model")

          # Define a list of discovery queries.
          qs = [q]

          # Get component configurations with these queries.
          component_configs = await robot.discover_components(qs)

      :param queries: The list of component models to lookup configurations for.
      :type queries: List[viam.proto.robot.DiscoveryQuery]

      :returns: A list of discovered component configurations.
      :rtype: List[Discovery]

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: stop_all(extra: Dict[viam.proto.common.ResourceName, Dict[str, Any]] = {})
      :async:


      Cancel all current and outstanding operations for the robot and stop all actuators and movement.

      ::

          # Cancel all current and outstanding operations for the robot and stop all actuators and movement.
          await robot.stop_all()

      ::

          await robot.stop_all()

      :param extra: Any extra parameters to pass to the resources' ``stop`` methods,
                    keyed on the resource's ``ResourceName``.
      :type extra: Dict[viam.proto.common.ResourceName, Dict[str, Any]]

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: log(name: str, level: str, time: datetime.datetime, message: str, stack: str)
      :async:


      Send log from Python module over gRPC.

      Create a LogEntry object from the log to send to RDK.

      :param name: The logger's name.
      :type name: str
      :param level: The level of the log.
      :type level: str
      :param time: The log creation time.
      :type time: datetime
      :param message: The log message.
      :type message: str
      :param stack: The stack information of the log.
      :type stack: str

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: get_cloud_metadata() -> viam.proto.robot.GetCloudMetadataResponse
      :async:


      Get app-related information about the robot.

      ::

          metadata = machine.get_cloud_metadata()
          print(metadata.machine_id)
          print(metadata.machine_part_id)
          print(metadata.primary_org_id)
          print(metadata.location_id)

      :returns: App-related metadata.
      :rtype: viam.proto.robot.GetCloudMetadataResponse

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



   .. py:method:: shutdown()
      :async:


      Shutdown shuts down the machine.

      :raises GRPCError: Raised with DeadlineExceeded status if shutdown request times out, or if
          robot server shuts down before having a chance to send a response. Raised with
          status Unavailable if server is unavailable, or if robot server is in the process of
          shutting down when response is ready.

      For more information, see `Machine Management API <https://docs.viam.com/appendix/apis/robot/>`_.



