:py:mod:`viam.utils`
====================

.. py:module:: viam.utils


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   viam.utils.PointerCounter



Functions
~~~~~~~~~

.. autoapisummary::

   viam.utils.primitive_to_value
   viam.utils.value_to_primitive
   viam.utils.resource_names_for_resource
   viam.utils.message_to_struct
   viam.utils.struct_to_message
   viam.utils.dict_to_struct
   viam.utils.struct_to_dict
   viam.utils.datetime_to_timestamp
   viam.utils.get_geometries
   viam.utils.sensor_readings_native_to_value
   viam.utils.sensor_readings_value_to_native
   viam.utils.to_thread
   viam.utils.from_dm_from_extra
   viam.utils.create_filter



Attributes
~~~~~~~~~~

.. autoapisummary::

   viam.utils.ValueTypes
   viam.utils.SensorReading


.. py:data:: ValueTypes

   Types that can be encoded into a protobuf `Value`

.. py:data:: SensorReading

   Types that can be returned from a sensor

.. py:function:: primitive_to_value(v: ValueTypes) -> google.protobuf.struct_pb2.Value

   Create a new google.protobuf.struct_pb2.Value
   Supports primitive types of
   - None
   - Number
   - Bool
   - String
   - Dict
   - List
   - Bytes

   :param v: object to convert to a Value
   :type v: ValueTypes

   :raises TypeError: If the object cannot be converted

   :returns: a protobuf Value instance of the object
   :rtype: Value


.. py:function:: value_to_primitive(value: google.protobuf.struct_pb2.Value) -> ValueTypes


.. py:function:: resource_names_for_resource(resource: viam.resource.base.ResourceBase) -> List[viam.proto.common.ResourceName]


.. py:function:: message_to_struct(message: google.protobuf.message.Message) -> google.protobuf.struct_pb2.Struct


.. py:function:: struct_to_message(struct: google.protobuf.struct_pb2.Struct, message_type: Type[_T]) -> _T


.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct


.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]


.. py:function:: datetime_to_timestamp(dt: Optional[datetime.datetime]) -> Optional[google.protobuf.timestamp_pb2.Timestamp]


.. py:function:: get_geometries(client: viam.resource.types.SupportsGetGeometries, name: str, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
   :async:


.. py:function:: sensor_readings_native_to_value(readings: Mapping[str, Any]) -> Mapping[str, google.protobuf.struct_pb2.Value]


.. py:function:: sensor_readings_value_to_native(readings: Mapping[str, google.protobuf.struct_pb2.Value]) -> Mapping[str, SensorReading]


.. py:class:: PointerCounter


   .. py:property:: count
      :type: int


   .. py:method:: increment() -> int


   .. py:method:: decrement() -> int


   .. py:method:: wait() -> None
      :async:



.. py:function:: to_thread(func: collections.abc.Callable[_P, _R], *args: _P, **kwargs: _P) -> _R
   :async:

   Asynchronously run a function in a separate thread.

   This is a copy of the function defined in the python source,
   which is only available in python >= 3.9.

   See: https://github.com/python/cpython/blob/main/Lib/asyncio/threads.py


.. py:function:: from_dm_from_extra(extra: Optional[Dict[str, Any]]) -> bool

   Used in modular filter components to get the 'fromDataManagement' value from an extra map.


.. py:function:: create_filter(component_name: Optional[str] = None, component_type: Optional[str] = None, method: Optional[str] = None, robot_name: Optional[str] = None, robot_id: Optional[str] = None, part_name: Optional[str] = None, part_id: Optional[str] = None, location_ids: Optional[List[str]] = None, organization_ids: Optional[List[str]] = None, mime_type: Optional[List[str]] = None, start_time: Optional[datetime.datetime] = None, end_time: Optional[datetime.datetime] = None, tags: Optional[List[str]] = None, bbox_labels: Optional[List[str]] = None) -> viam.proto.app.data.Filter

   Create a `Filter`.

   :param component_name: Optional name of the component that captured the data being filtered (e.g., "left_motor").
   :type component_name: Optional[str]
   :param component_type: Optional type of the componenet that captured the data being filtered (e.g., "motor").
   :type component_type: Optional[str]
   :param method: Optional name of the method used to capture the data being filtered (e.g., "IsPowered").
   :type method: Optional[str]
   :param robot_name: Optional name of the robot associated with the data being filtered (e.g., "viam_rover_1").
   :type robot_name: Optional[str]
   :param robot_id: Optional ID of the robot associated with the data being filtered.
   :type robot_id: Optional[str]
   :param part_name: Optional name of the system part associated with the data being filtered (e.g., "viam_rover_1-main").
   :type part_name: Optional[str]
   :param part_id: Optional ID of the system part associated with the data being filtered.
   :type part_id: Optional[str]
   :param location_ids: Optional list of location IDs associated with the data being filtered.
   :type location_ids: Optional[List[str]]
   :param organization_ids: Optional list of organization IDs associated with the data being filtered.
   :type organization_ids: Optional[List[str]]
   :param mime_type: Optional mime type of data being filtered (e.g., "image/png").
   :type mime_type: Optional[List[str]]
   :param start_time: Optional start time of an interval to filter data by.
   :type start_time: Optional[datetime.datetime]
   :param end_time: Optional end time of an interval to filter data by.
   :type end_time: Optional[datetime.datetime]
   :param tags: Optional list of tags attached to the data being filtered (e.g., ["test"]).
   :type tags: Optional[List[str]]
   :param bbox_labels: Optional list of bounding box labels attached to the data being filtered (e.g., ["square",
                       "circle"]).
   :type bbox_labels: Optional[List[str]]

   :returns: The `Filter` object.
   :rtype: viam.proto.app.data.Filter


