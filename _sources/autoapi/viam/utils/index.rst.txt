viam.utils
==========

.. py:module:: viam.utils


Attributes
----------

.. autoapisummary::

   viam.utils.ValueTypes
   viam.utils.SensorReading


Classes
-------

.. autoapisummary::

   viam.utils.CaptureInterval
   viam.utils.Filter
   viam.utils.TagsFilter
   viam.utils.Geometry
   viam.utils.GeoPoint
   viam.utils.GetGeometriesRequest
   viam.utils.GetGeometriesResponse
   viam.utils.Orientation
   viam.utils.ResourceName
   viam.utils.Vector3
   viam.utils.ResourceBase
   viam.utils.Registry
   viam.utils.Subtype
   viam.utils.SupportsGetGeometries
   viam.utils.PointerCounter


Functions
---------

.. autoapisummary::

   viam.utils.primitive_to_value
   viam.utils.value_to_primitive
   viam.utils.resource_names_for_resource
   viam.utils.message_to_struct
   viam.utils.struct_to_message
   viam.utils.dict_to_struct
   viam.utils.struct_to_dict
   viam.utils.datetime_to_timestamp
   viam.utils.get_geometries
   viam.utils.sensor_readings_native_to_value
   viam.utils.sensor_readings_value_to_native
   viam.utils.to_thread
   viam.utils.from_dm_from_extra
   viam.utils.create_filter


Module Contents
---------------

.. py:class:: CaptureInterval(*, start: google.protobuf.timestamp_pb2.Timestamp | None = ..., end: google.protobuf.timestamp_pb2.Timestamp | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   CaptureInterval describes the start and end time of the capture in this file.


   .. py:property:: start
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: end
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:method:: HasField(field_name: Literal['end', b'end', 'start', b'start']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: Filter(*, component_name: str = ..., component_type: str = ..., method: str = ..., robot_name: str = ..., robot_id: str = ..., part_name: str = ..., part_id: str = ..., location_ids: collections.abc.Iterable[str] | None = ..., organization_ids: collections.abc.Iterable[str] | None = ..., mime_type: collections.abc.Iterable[str] | None = ..., interval: global___CaptureInterval | None = ..., tags_filter: global___TagsFilter | None = ..., bbox_labels: collections.abc.Iterable[str] | None = ..., dataset_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Filter defines the fields over which we can filter data using a logic AND.
   For example, if component_type and robot_id are specified, only data from that `robot_id` of
   type `component_type` is returned. However, we logical OR over the specified tags and bounding
   box labels, such that if component_type, robot_id, tagA, tagB are specified,
   we return data from that `robot_id` of type `component_type` with `tagA` or `tagB`.


   .. py:attribute:: component_name
      :type:  str


   .. py:attribute:: component_type
      :type:  str


   .. py:attribute:: method
      :type:  str


   .. py:attribute:: robot_name
      :type:  str


   .. py:attribute:: robot_id
      :type:  str


   .. py:attribute:: part_name
      :type:  str


   .. py:attribute:: part_id
      :type:  str


   .. py:attribute:: dataset_id
      :type:  str


   .. py:property:: location_ids
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:property:: organization_ids
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:property:: mime_type
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:property:: interval
      :type: global___CaptureInterval



   .. py:property:: tags_filter
      :type: global___TagsFilter



   .. py:property:: bbox_labels
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]

      bbox_labels are used to match documents with the specified bounding box labels (using logical OR).


   .. py:method:: HasField(field_name: Literal['interval', b'interval', 'tags_filter', b'tags_filter']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: TagsFilter(*, type: global___TagsFilterType = ..., tags: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   TagsFilter defines the type of filtering and, if applicable, over which tags to perform a logical OR.


   .. py:attribute:: type
      :type:  global___TagsFilterType


   .. py:property:: tags
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]

      Tags are used to match documents if `type` is UNSPECIFIED or MATCH_BY_OR.


.. py:class:: Geometry(*, center: global___Pose | None = ..., sphere: global___Sphere | None = ..., box: global___RectangularPrism | None = ..., capsule: global___Capsule | None = ..., label: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Geometry contains the dimensions of a given geometry and the pose of its center. The geometry is one of either a sphere or a box.


   .. py:attribute:: label
      :type:  str

      Label of the geometry. If none supplied, will be an empty string.


   .. py:property:: center
      :type: global___Pose

      Pose of a geometries center point


   .. py:property:: sphere
      :type: global___Sphere



   .. py:property:: box
      :type: global___RectangularPrism



   .. py:property:: capsule
      :type: global___Capsule



   .. py:method:: HasField(field_name: Literal['box', b'box', 'capsule', b'capsule', 'center', b'center', 'geometry_type', b'geometry_type', 'sphere', b'sphere']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['geometry_type', b'geometry_type']) -> Literal['sphere', 'box', 'capsule'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: GeoPoint(*, latitude: float = ..., longitude: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: latitude
      :type:  float


   .. py:attribute:: longitude
      :type:  float


.. py:class:: GetGeometriesRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      The component name


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetGeometriesResponse(*, geometries: collections.abc.Iterable[global___Geometry] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: geometries
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Geometry]

      All geometries associated with the component, in their current configuration, in the frame of that component.


.. py:class:: Orientation(*, o_x: float = ..., o_y: float = ..., o_z: float = ..., theta: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: o_x
      :type:  float

      x component of a vector defining axis of rotation


   .. py:attribute:: o_y
      :type:  float

      y component of a vector defining axis of rotation


   .. py:attribute:: o_z
      :type:  float

      z component of a vector defining axis of rotation


   .. py:attribute:: theta
      :type:  float

      degrees


.. py:class:: ResourceName(*, namespace: str = ..., type: str = ..., subtype: str = ..., name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: namespace
      :type:  str


   .. py:attribute:: type
      :type:  str


   .. py:attribute:: subtype
      :type:  str


   .. py:attribute:: name
      :type:  str


.. py:class:: Vector3(*, x: float = ..., y: float = ..., z: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: x
      :type:  float


   .. py:attribute:: y
      :type:  float


   .. py:attribute:: z
      :type:  float


.. py:class:: ResourceBase

   Bases: :py:obj:`Protocol`


   The base requirements for a Resource.


   .. py:attribute:: SUBTYPE
      :type:  ClassVar[viam.resource.types.Subtype]

      The Subtype of the Resource


   .. py:attribute:: name
      :type:  str

      The name of the Resource


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      :abstractmethod:


      Get the Resource named ``name`` from the provided robot.

      ::

          # Can be used with any resource, using an arm as an example
          my_arm = Arm.from_robot(robot, "my_arm")

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the Resource
      :type name: str

      :returns: The Resource, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: Registry

   The global registry of robotic parts.

   **NB** The Registry should almost never be used directly

   The Registry keeps track of the types of Resources that are available on robots using this SDK. All the base resource types are
   pre-registered (for example Arm, Motor).

   If you create a new resource type that is not an extension of any of the existing base resource types, then you must register said
   resource using ``Registry.register(...)``.


   .. py:method:: register_subtype(registration: ResourceRegistration[Resource])
      :classmethod:


      Register a Subtype with the Registry

      :param registration: Object containing registration data for the subtype
      :type registration: ResourceRegistration

      :raises DuplicateResourceError: Raised if the Subtype to register is already in the registry
      :raises ValidationError: Raised if registration is missing any necessary parameters



   .. py:method:: register_resource_creator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model, registration: ResourceCreatorRegistration)
      :classmethod:


      Register a specific ``Model`` and validator function for the specific resource ``Subtype`` with the Registry

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model
      :param registration: The registration functions of the model
      :type registration: ResourceCreatorRegistration

      :raises DuplicateResourceError: Raised if the Subtype and Model pairing is already registered
      :raises ValidationError: Raised if registration does not have creator



   .. py:method:: lookup_subtype(subtype: viam.resource.types.Subtype) -> ResourceRegistration
      :classmethod:


      Lookup and retrieve a registered Subtype by its name

      :param subtype: The subtype of the resource
      :type subtype: str

      :raises ResourceNotFoundError: Raised if the Subtype is not registered

      :returns: The registration object of the resource
      :rtype: ResourceRegistration



   .. py:method:: lookup_resource_creator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model) -> viam.resource.types.ResourceCreator
      :classmethod:


      Lookup and retrieve a registered resource creator by its subtype and model

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model

      :raises ResourceNotFoundError: Raised if the Subtype Model pairing is not registered

      :returns: The function to create the resource
      :rtype: ResourceCreator



   .. py:method:: lookup_validator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model) -> viam.resource.types.Validator
      :classmethod:


      Lookup and retrieve a registered validator function by its subtype and model. If there is none, return None

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model

      :returns: The function to validate the resource
      :rtype: Validator



   .. py:method:: REGISTERED_SUBTYPES() -> Mapping[viam.resource.types.Subtype, ResourceRegistration]
      :classmethod:


      The dictionary of all registered resources
      - Key: Subtype of the resource
      - Value: The registration object for the resource

      :returns: All registered resources
      :rtype: Mapping[Subtype, ResourceRegistration]



   .. py:method:: REGISTERED_RESOURCE_CREATORS() -> Mapping[str, ResourceCreatorRegistration]
      :classmethod:


      The dictionary of all registered resources
      - Key: subtype/model
      - Value: The ResourceCreatorRegistration for the resource

      :returns: All registered resources
      :rtype: Mapping[str, ResourceCreatorRegistration]



.. py:class:: Subtype(namespace: str, resource_type: str, resource_subtype: str)

   Represents a known component/service (resource) API


   .. py:attribute:: namespace
      :type:  str

      The namespace of the resource


   .. py:attribute:: resource_type
      :type:  str

      The type of the resource, for example `component` or `service`


   .. py:attribute:: resource_subtype
      :type:  str

      The subtype of the resource for example `servo`, `arm`, `vision`


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __hash__() -> int

      Return hash(self).



   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: from_resource_name(resource_name: viam.proto.common.ResourceName) -> typing_extensions.Self
      :classmethod:


      Convert a ```ResourceName``` into a ```Subtype```

      :param resource_name: The ResourceName to convert
      :type resource_name: viam.proto.common.ResourceName

      :returns: A new Subtype
      :rtype: Self



   .. py:method:: from_string(string: str) -> typing_extensions.Self
      :classmethod:


      Create a ```Subtype``` from its string representation (namespace:resource_type:resource_subtype)

      :param string: The Subtype as a string
      :type string: str

      :raises ValueError: Raised if the string does not represent a valid Subtype

      :returns: A new Subtype
      :rtype: Self



.. py:class:: SupportsGetGeometries

   Bases: :py:obj:`Protocol`


   The SupportsGetGeometries protocol defines the requirements for a resource to call get_geometries.


   .. py:method:: GetGeometries(request: viam.proto.common.GetGeometriesRequest, *, timeout: Optional[float] = None) -> viam.proto.common.GetGeometriesResponse
      :async:



.. py:data:: ValueTypes

   Types that can be encoded into a protobuf `Value`

.. py:data:: SensorReading

   Types that can be returned from a sensor

.. py:function:: primitive_to_value(v: ValueTypes) -> google.protobuf.struct_pb2.Value

   Create a new google.protobuf.struct_pb2.Value
   Supports primitive types of
   - None
   - Number
   - Bool
   - String
   - Dict
   - List
   - Bytes

   :param v: object to convert to a Value
   :type v: ValueTypes

   :raises TypeError: If the object cannot be converted

   :returns: a protobuf Value instance of the object
   :rtype: Value


.. py:function:: value_to_primitive(value: google.protobuf.struct_pb2.Value) -> ValueTypes

.. py:function:: resource_names_for_resource(resource: viam.resource.base.ResourceBase) -> List[viam.proto.common.ResourceName]

.. py:function:: message_to_struct(message: google.protobuf.message.Message) -> google.protobuf.struct_pb2.Struct

.. py:function:: struct_to_message(struct: google.protobuf.struct_pb2.Struct, message_type: Type[_T]) -> _T

.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:function:: datetime_to_timestamp(dt: Optional[datetime.datetime]) -> Optional[google.protobuf.timestamp_pb2.Timestamp]

.. py:function:: get_geometries(client: viam.resource.types.SupportsGetGeometries, name: str, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
   :async:


.. py:function:: sensor_readings_native_to_value(readings: Mapping[str, Any]) -> Mapping[str, google.protobuf.struct_pb2.Value]

.. py:function:: sensor_readings_value_to_native(readings: Mapping[str, google.protobuf.struct_pb2.Value]) -> Mapping[str, SensorReading]

.. py:class:: PointerCounter

   .. py:method:: increment() -> int


   .. py:method:: decrement() -> int


   .. py:method:: wait() -> None
      :async:



   .. py:property:: count
      :type: int



.. py:function:: to_thread(func: collections.abc.Callable[_P, _R], *args: _P, **kwargs: _P) -> _R
   :async:


   Asynchronously run a function in a separate thread.

   This is a copy of the function defined in the python source,
   which is only available in python >= 3.9.

   See: https://github.com/python/cpython/blob/main/Lib/asyncio/threads.py


.. py:function:: from_dm_from_extra(extra: Optional[Dict[str, Any]]) -> bool

   Used in modular filter components to get the 'fromDataManagement' value from an extra map.


.. py:function:: create_filter(component_name: Optional[str] = None, component_type: Optional[str] = None, method: Optional[str] = None, robot_name: Optional[str] = None, robot_id: Optional[str] = None, part_name: Optional[str] = None, part_id: Optional[str] = None, location_ids: Optional[List[str]] = None, organization_ids: Optional[List[str]] = None, mime_type: Optional[List[str]] = None, start_time: Optional[datetime.datetime] = None, end_time: Optional[datetime.datetime] = None, tags: Optional[List[str]] = None, bbox_labels: Optional[List[str]] = None, dataset_id: Optional[str] = None) -> viam.proto.app.data.Filter

   Create a `Filter`.

   :param component_name: Optional name of the component that captured the data being filtered (for example, "left_motor").
   :type component_name: Optional[str]
   :param component_type: Optional type of the componenet that captured the data being filtered (for example, "motor").
   :type component_type: Optional[str]
   :param method: Optional name of the method used to capture the data being filtered (for example, "IsPowered").
   :type method: Optional[str]
   :param robot_name: Optional name of the robot associated with the data being filtered (for example, "viam_rover_1").
   :type robot_name: Optional[str]
   :param robot_id: Optional ID of the robot associated with the data being filtered.
   :type robot_id: Optional[str]
   :param part_name: Optional name of the system part associated with the data being filtered (for example,
                     "viam_rover_1-main").
   :type part_name: Optional[str]
   :param part_id: Optional ID of the system part associated with the data being filtered.
   :type part_id: Optional[str]
   :param location_ids: Optional list of location IDs associated with the data being filtered.
   :type location_ids: Optional[List[str]]
   :param organization_ids: Optional list of organization IDs associated with the data being filtered.
   :type organization_ids: Optional[List[str]]
   :param mime_type: Optional mime type of data being filtered (for example, "image/png").
   :type mime_type: Optional[List[str]]
   :param start_time: Optional start time of an interval to filter data by.
   :type start_time: Optional[datetime.datetime]
   :param end_time: Optional end time of an interval to filter data by.
   :type end_time: Optional[datetime.datetime]
   :param tags: Optional list of tags attached to the data being filtered (for example, ["test"]).
   :type tags: Optional[List[str]]
   :param bbox_labels: Optional list of bounding box labels attached to the data being filtered (for example, ["square",
                       "circle"]).
   :type bbox_labels: Optional[List[str]]
   :param dataset_id: Optional ID of dataset associated with data being filtered
   :type dataset_id: Optional[str]

   :returns: The `Filter` object.
   :rtype: viam.proto.app.data.Filter


