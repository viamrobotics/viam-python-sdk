viam.app.data_client
====================

.. py:module:: viam.app.data_client


Attributes
----------

.. autoapisummary::

   viam.app.data_client.ValueTypes
   viam.app.data_client.LOGGER


Classes
-------

.. autoapisummary::

   viam.app.data_client.AddBinaryDataToDatasetByIDsRequest
   viam.app.data_client.AddBoundingBoxToImageByIDRequest
   viam.app.data_client.AddBoundingBoxToImageByIDResponse
   viam.app.data_client.AddTagsToBinaryDataByFilterRequest
   viam.app.data_client.AddTagsToBinaryDataByIDsRequest
   viam.app.data_client.BinaryData
   viam.app.data_client.BinaryDataByFilterRequest
   viam.app.data_client.BinaryDataByFilterResponse
   viam.app.data_client.BinaryDataByIDsRequest
   viam.app.data_client.BinaryDataByIDsResponse
   viam.app.data_client.BinaryID
   viam.app.data_client.BoundingBoxLabelsByFilterRequest
   viam.app.data_client.BoundingBoxLabelsByFilterResponse
   viam.app.data_client.CaptureMetadata
   viam.app.data_client.ConfigureDatabaseUserRequest
   viam.app.data_client.DataRequest
   viam.app.data_client.DataServiceStub
   viam.app.data_client.DeleteBinaryDataByFilterRequest
   viam.app.data_client.DeleteBinaryDataByFilterResponse
   viam.app.data_client.DeleteBinaryDataByIDsRequest
   viam.app.data_client.DeleteBinaryDataByIDsResponse
   viam.app.data_client.DeleteTabularDataRequest
   viam.app.data_client.DeleteTabularDataResponse
   viam.app.data_client.Filter
   viam.app.data_client.GetDatabaseConnectionRequest
   viam.app.data_client.GetDatabaseConnectionResponse
   viam.app.data_client.Order
   viam.app.data_client.RemoveBinaryDataFromDatasetByIDsRequest
   viam.app.data_client.RemoveBoundingBoxFromImageByIDRequest
   viam.app.data_client.RemoveTagsFromBinaryDataByFilterRequest
   viam.app.data_client.RemoveTagsFromBinaryDataByFilterResponse
   viam.app.data_client.RemoveTagsFromBinaryDataByIDsRequest
   viam.app.data_client.RemoveTagsFromBinaryDataByIDsResponse
   viam.app.data_client.TabularDataByFilterRequest
   viam.app.data_client.TabularDataByFilterResponse
   viam.app.data_client.TabularDataByMQLRequest
   viam.app.data_client.TabularDataByMQLResponse
   viam.app.data_client.TabularDataBySQLRequest
   viam.app.data_client.TabularDataBySQLResponse
   viam.app.data_client.TagsByFilterRequest
   viam.app.data_client.TagsByFilterResponse
   viam.app.data_client.CreateDatasetRequest
   viam.app.data_client.CreateDatasetResponse
   viam.app.data_client.Dataset
   viam.app.data_client.DatasetServiceStub
   viam.app.data_client.DeleteDatasetRequest
   viam.app.data_client.ListDatasetsByIDsRequest
   viam.app.data_client.ListDatasetsByIDsResponse
   viam.app.data_client.ListDatasetsByOrganizationIDRequest
   viam.app.data_client.ListDatasetsByOrganizationIDResponse
   viam.app.data_client.RenameDatasetRequest
   viam.app.data_client.DataCaptureUploadMetadata
   viam.app.data_client.DataCaptureUploadRequest
   viam.app.data_client.DataCaptureUploadResponse
   viam.app.data_client.DataSyncServiceStub
   viam.app.data_client.DataType
   viam.app.data_client.FileData
   viam.app.data_client.FileUploadRequest
   viam.app.data_client.FileUploadResponse
   viam.app.data_client.SensorData
   viam.app.data_client.SensorMetadata
   viam.app.data_client.StreamingDataCaptureUploadRequest
   viam.app.data_client.StreamingDataCaptureUploadResponse
   viam.app.data_client.UploadMetadata
   viam.app.data_client.DataClient


Functions
---------

.. autoapisummary::

   viam.app.data_client.create_filter
   viam.app.data_client.datetime_to_timestamp
   viam.app.data_client.struct_to_dict


Module Contents
---------------

.. py:class:: AddBinaryDataToDatasetByIDsRequest(*, binary_ids: collections.abc.Iterable[global___BinaryID] | None = ..., dataset_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   AddBinaryDataToDatasetByIDsRequest adds the binary data with the given binary IDs to a dataset with dataset_id.


   .. py:attribute:: dataset_id
      :type:  str


   .. py:property:: binary_ids
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BinaryID]



.. py:class:: AddBoundingBoxToImageByIDRequest(*, binary_id: global___BinaryID | None = ..., label: str = ..., x_min_normalized: float = ..., y_min_normalized: float = ..., x_max_normalized: float = ..., y_max_normalized: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   AddBoundingBoxToImageByIDRequest specifies the binary ID to which a bounding box
   with the associated label and position in normalized coordinates will be added.


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: x_min_normalized
      :type:  float


   .. py:attribute:: y_min_normalized
      :type:  float


   .. py:attribute:: x_max_normalized
      :type:  float


   .. py:attribute:: y_max_normalized
      :type:  float


   .. py:property:: binary_id
      :type: global___BinaryID



   .. py:method:: HasField(field_name: Literal['binary_id', b'binary_id']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: AddBoundingBoxToImageByIDResponse(*, bbox_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   AddBoundingBoxToImageByIDResponse returns the bounding box ID of the successfully added bounding box.


   .. py:attribute:: bbox_id
      :type:  str


.. py:class:: AddTagsToBinaryDataByFilterRequest(*, filter: global___Filter | None = ..., tags: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   AddTagsToBinaryDataByFilterRequest requests adding all specified tags to each of the files when a filter is provided.


   .. py:property:: filter
      :type: global___Filter



   .. py:property:: tags
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:method:: HasField(field_name: Literal['filter', b'filter']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: AddTagsToBinaryDataByIDsRequest(*, binary_ids: collections.abc.Iterable[global___BinaryID] | None = ..., tags: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   AddTagsToBinaryDataByIDsRequest requests adding all specified tags to each of the files when binary ids are provided.


   .. py:property:: binary_ids
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BinaryID]



   .. py:property:: tags
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



.. py:class:: BinaryData(*, binary: bytes = ..., metadata: global___BinaryMetadata | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   BinaryData contains data and metadata associated with binary data.


   .. py:attribute:: binary
      :type:  bytes


   .. py:property:: metadata
      :type: global___BinaryMetadata



   .. py:method:: HasField(field_name: Literal['metadata', b'metadata']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: BinaryDataByFilterRequest(*, data_request: global___DataRequest | None = ..., include_binary: bool = ..., count_only: bool = ..., include_internal_data: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   BinaryDataByFilterRequest requests the data and metadata of binary (image + file) data when a filter is provided.


   .. py:attribute:: include_binary
      :type:  bool


   .. py:attribute:: count_only
      :type:  bool


   .. py:attribute:: include_internal_data
      :type:  bool


   .. py:property:: data_request
      :type: global___DataRequest



   .. py:method:: HasField(field_name: Literal['data_request', b'data_request']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: BinaryDataByFilterResponse(*, data: collections.abc.Iterable[global___BinaryData] | None = ..., count: int = ..., last: str = ..., total_size_bytes: int = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   BinaryDataByFilterResponse provides the data and metadata of binary (image + file) data when a filter is provided.


   .. py:attribute:: count
      :type:  int


   .. py:attribute:: last
      :type:  str


   .. py:attribute:: total_size_bytes
      :type:  int


   .. py:property:: data
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BinaryData]



.. py:class:: BinaryDataByIDsRequest(*, include_binary: bool = ..., binary_ids: collections.abc.Iterable[global___BinaryID] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   BinaryDataByFilterRequest requests the data and metadata of binary (image + file) data by binary ids.


   .. py:attribute:: include_binary
      :type:  bool


   .. py:property:: binary_ids
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BinaryID]



.. py:class:: BinaryDataByIDsResponse(*, data: collections.abc.Iterable[global___BinaryData] | None = ..., count: int = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   BinaryDataByIDsResponse provides the data and metadata of binary (image + file) data when a filter is provided.


   .. py:attribute:: count
      :type:  int


   .. py:property:: data
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BinaryData]



.. py:class:: BinaryID(*, file_id: str = ..., organization_id: str = ..., location_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   BinaryID is the unique identifier for a file that one can request to be retrieved or modified.


   .. py:attribute:: file_id
      :type:  str


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: location_id
      :type:  str


.. py:class:: BoundingBoxLabelsByFilterRequest(*, filter: global___Filter | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   BoundingBoxLabelsByFilterRequest requests all the labels of the bounding boxes from files from a given filter.


   .. py:property:: filter
      :type: global___Filter



   .. py:method:: HasField(field_name: Literal['filter', b'filter']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: BoundingBoxLabelsByFilterResponse(*, labels: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   BoundingBoxLabelsByFilterRequest returns all the labels of the bounding boxes from files from a given filter.


   .. py:property:: labels
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



.. py:class:: CaptureMetadata(*, organization_id: str = ..., location_id: str = ..., robot_name: str = ..., robot_id: str = ..., part_name: str = ..., part_id: str = ..., component_type: str = ..., component_name: str = ..., method_name: str = ..., method_parameters: collections.abc.Mapping[str, google.protobuf.any_pb2.Any] | None = ..., tags: collections.abc.Iterable[str] | None = ..., mime_type: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   CaptureMetadata contains information on the settings used for the data capture.


   .. py:class:: MethodParametersEntry(*, key: str = ..., value: google.protobuf.any_pb2.Any | None = ...)

      Bases: :py:obj:`google.protobuf.message.Message`


      Abstract base class for protocol messages.

      Protocol message classes are almost always generated by the protocol
      compiler.  These generated types subclass Message and implement the methods
      shown below.


      .. py:attribute:: key
         :type:  str


      .. py:property:: value
         :type: google.protobuf.any_pb2.Any



      .. py:method:: HasField(field_name: Literal['value', b'value']) -> bool

         Checks if a certain field is set for the message.

         For a oneof group, checks if any field inside is set. Note that if the
         field_name is not defined in the message descriptor, :exc:`ValueError` will
         be raised.

         :param field_name: The name of the field to check for presence.
         :type field_name: str

         :returns: Whether a value has been set for the named field.
         :rtype: bool

         :raises ValueError: if the `field_name` is not a member of this message.




   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: location_id
      :type:  str


   .. py:attribute:: robot_name
      :type:  str


   .. py:attribute:: robot_id
      :type:  str


   .. py:attribute:: part_name
      :type:  str


   .. py:attribute:: part_id
      :type:  str


   .. py:attribute:: component_type
      :type:  str


   .. py:attribute:: component_name
      :type:  str


   .. py:attribute:: method_name
      :type:  str


   .. py:attribute:: mime_type
      :type:  str


   .. py:property:: method_parameters
      :type: google.protobuf.internal.containers.MessageMap[str, google.protobuf.any_pb2.Any]



   .. py:property:: tags
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



.. py:class:: ConfigureDatabaseUserRequest(*, organization_id: str = ..., password: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   ConfigureDatabaseUserRequest accepts a Viam organization ID and a password for the database user
   being configured. Viam uses gRPC over TLS, so the entire request will be encrypted while in
   flight, including the password.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: password
      :type:  str


.. py:class:: DataRequest(*, filter: global___Filter | None = ..., limit: int = ..., last: str = ..., sort_order: global___Order = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DataRequest encapsulates the filter for the data, a limit on the maximum results returned,
   a last string associated with the last returned document, and the sorting order by time.
   last is returned in the responses TabularDataByFilterResponse and BinaryDataByFilterResponse
   from the API calls TabularDataByFilter and BinaryDataByFilter, respectively.
   We can then use the last string from the previous API calls in the subsequent request
   to get the next set of ordered documents.


   .. py:attribute:: limit
      :type:  int


   .. py:attribute:: last
      :type:  str


   .. py:attribute:: sort_order
      :type:  global___Order


   .. py:property:: filter
      :type: global___Filter



   .. py:method:: HasField(field_name: Literal['filter', b'filter']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DataServiceStub(channel: grpclib.client.Channel)

.. py:class:: DeleteBinaryDataByFilterRequest(*, filter: global___Filter | None = ..., include_internal_data: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DeleteBinaryDataByFilterRequest deletes the data and metadata of binary data when a filter is provided.


   .. py:attribute:: include_internal_data
      :type:  bool


   .. py:property:: filter
      :type: global___Filter



   .. py:method:: HasField(field_name: Literal['filter', b'filter']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DeleteBinaryDataByFilterResponse(*, deleted_count: int = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DeleteBinaryDataByFilterResponse returns the number of binary files deleted when a filter is provided.


   .. py:attribute:: deleted_count
      :type:  int


.. py:class:: DeleteBinaryDataByIDsRequest(*, binary_ids: collections.abc.Iterable[global___BinaryID] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DeleteBinaryDataByIDsRequest deletes the data and metadata of binary data when binary ids are provided.


   .. py:property:: binary_ids
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BinaryID]



.. py:class:: DeleteBinaryDataByIDsResponse(*, deleted_count: int = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DeleteBinaryDataByIDsResponse returns the number of binary files deleted when binary ids are provided.


   .. py:attribute:: deleted_count
      :type:  int


.. py:class:: DeleteTabularDataRequest(*, organization_id: str = ..., delete_older_than_days: int = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DeleteTabularDataRequest deletes the data from the organization that is older than `delete_older_than_days`.
   For example if `delete_older_than_days` is 10, this deletes any data that was captured up to 10 days ago.
   If it is 0, all existing data is deleted.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: delete_older_than_days
      :type:  int


.. py:class:: DeleteTabularDataResponse(*, deleted_count: int = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DeleteBinaryDataResponse returns the number of tabular datapoints deleted.


   .. py:attribute:: deleted_count
      :type:  int


.. py:class:: Filter(*, component_name: str = ..., component_type: str = ..., method: str = ..., robot_name: str = ..., robot_id: str = ..., part_name: str = ..., part_id: str = ..., location_ids: collections.abc.Iterable[str] | None = ..., organization_ids: collections.abc.Iterable[str] | None = ..., mime_type: collections.abc.Iterable[str] | None = ..., interval: global___CaptureInterval | None = ..., tags_filter: global___TagsFilter | None = ..., bbox_labels: collections.abc.Iterable[str] | None = ..., dataset_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Filter defines the fields over which we can filter data using a logic AND.
   For example, if component_type and robot_id are specified, only data from that `robot_id` of
   type `component_type` is returned. However, we logical OR over the specified tags and bounding
   box labels, such that if component_type, robot_id, tagA, tagB are specified,
   we return data from that `robot_id` of type `component_type` with `tagA` or `tagB`.


   .. py:attribute:: component_name
      :type:  str


   .. py:attribute:: component_type
      :type:  str


   .. py:attribute:: method
      :type:  str


   .. py:attribute:: robot_name
      :type:  str


   .. py:attribute:: robot_id
      :type:  str


   .. py:attribute:: part_name
      :type:  str


   .. py:attribute:: part_id
      :type:  str


   .. py:attribute:: dataset_id
      :type:  str


   .. py:property:: location_ids
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:property:: organization_ids
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:property:: mime_type
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:property:: interval
      :type: global___CaptureInterval



   .. py:property:: tags_filter
      :type: global___TagsFilter



   .. py:property:: bbox_labels
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]

      bbox_labels are used to match documents with the specified bounding box labels (using logical OR).


   .. py:method:: HasField(field_name: Literal['interval', b'interval', 'tags_filter', b'tags_filter']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetDatabaseConnectionRequest(*, organization_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   GetDatabaseConnectionRequest requests the database connection hostname.


   .. py:attribute:: organization_id
      :type:  str


.. py:class:: GetDatabaseConnectionResponse(*, hostname: str = ..., mongodb_uri: str = ..., has_database_user: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   GetDatabaseConnectionResponse returns the database connection hostname endpoint. It also returns
   a URI that can be used to connect to the database instance through MongoDB clients, as well as
   information on whether the Viam organization has a database user configured.


   .. py:attribute:: hostname
      :type:  str


   .. py:attribute:: mongodb_uri
      :type:  str


   .. py:attribute:: has_database_user
      :type:  bool


.. py:class:: Order

   Bases: :py:obj:`_Order`


   Order specifies the order in which data is returned.


.. py:class:: RemoveBinaryDataFromDatasetByIDsRequest(*, binary_ids: collections.abc.Iterable[global___BinaryID] | None = ..., dataset_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   RemoveBinaryDataFromDatasetByIDsRequest removes the specified binary IDs from a dataset with dataset_id.


   .. py:attribute:: dataset_id
      :type:  str


   .. py:property:: binary_ids
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BinaryID]



.. py:class:: RemoveBoundingBoxFromImageByIDRequest(*, binary_id: global___BinaryID | None = ..., bbox_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   RemoveBoundingBoxFromImageByIDRequest removes the bounding box with specified bbox ID for the file represented by the binary id.


   .. py:attribute:: bbox_id
      :type:  str


   .. py:property:: binary_id
      :type: global___BinaryID



   .. py:method:: HasField(field_name: Literal['binary_id', b'binary_id']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RemoveTagsFromBinaryDataByFilterRequest(*, filter: global___Filter | None = ..., tags: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   RemoveTagsFromBinaryDataByFilterRequest requests removing the given tags value from each file when a filter is provided.


   .. py:property:: filter
      :type: global___Filter



   .. py:property:: tags
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:method:: HasField(field_name: Literal['filter', b'filter']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RemoveTagsFromBinaryDataByFilterResponse(*, deleted_count: int = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   RemoveTagsFromBinaryDataByFilterResponse returns the number of binary files which had tags removed.


   .. py:attribute:: deleted_count
      :type:  int


.. py:class:: RemoveTagsFromBinaryDataByIDsRequest(*, binary_ids: collections.abc.Iterable[global___BinaryID] | None = ..., tags: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   RemoveTagsFromBinaryDataByIDsRequest requests removing the given tags value from each file when binary ids are provided.


   .. py:property:: binary_ids
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BinaryID]



   .. py:property:: tags
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



.. py:class:: RemoveTagsFromBinaryDataByIDsResponse(*, deleted_count: int = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   RemoveTagsFromBinaryDataByIDsResponse returns the number of binary files which had tags removed


   .. py:attribute:: deleted_count
      :type:  int


.. py:class:: TabularDataByFilterRequest(*, data_request: global___DataRequest | None = ..., count_only: bool = ..., include_internal_data: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   TabularDataByFilterRequest requests tabular data based on filter values.


   .. py:attribute:: count_only
      :type:  bool


   .. py:attribute:: include_internal_data
      :type:  bool


   .. py:property:: data_request
      :type: global___DataRequest



   .. py:method:: HasField(field_name: Literal['data_request', b'data_request']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: TabularDataByFilterResponse(*, metadata: collections.abc.Iterable[global___CaptureMetadata] | None = ..., data: collections.abc.Iterable[global___TabularData] | None = ..., count: int = ..., last: str = ..., total_size_bytes: int = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   TabularDataByFilterResponse provides the data and metadata of tabular data.


   .. py:attribute:: count
      :type:  int


   .. py:attribute:: last
      :type:  str


   .. py:attribute:: total_size_bytes
      :type:  int


   .. py:property:: metadata
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CaptureMetadata]



   .. py:property:: data
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TabularData]



.. py:class:: TabularDataByMQLRequest(*, organization_id: str = ..., mql_binary: collections.abc.Iterable[bytes] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   TabularDataByMQLRequest requests tabular data using an MQL query.


   .. py:attribute:: organization_id
      :type:  str


   .. py:property:: mql_binary
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[bytes]

      mql_binary accepts a MongoDB aggregation pipeline as a list of BSON documents, where each
      document is one stage in the pipeline. The pipeline is run on the "sensorData.readings"
      namespace, which holds the Viam organization's tabular data.


.. py:class:: TabularDataByMQLResponse(*, data: collections.abc.Iterable[google.protobuf.struct_pb2.Struct] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   TabularDataByMQLResponse provides unified tabular data and metadata, queried with MQL.


   .. py:property:: data
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.struct_pb2.Struct]



.. py:class:: TabularDataBySQLRequest(*, organization_id: str = ..., sql_query: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   TabularDataBySQLRequest requests tabular data using a SQL query.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: sql_query
      :type:  str

      sql_query accepts any valid SQL SELECT statement. Tabular data is held in a database
      called "sensorData" and a table called readings, so queries should select from "readings"
      or "sensorData.readings".


.. py:class:: TabularDataBySQLResponse(*, data: collections.abc.Iterable[google.protobuf.struct_pb2.Struct] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   TabularDataBySQLResponse provides unified tabular data and metadata, queried with SQL.


   .. py:property:: data
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.struct_pb2.Struct]



.. py:class:: TagsByFilterRequest(*, filter: global___Filter | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   TagsByFilterRequest requests the unique tags from data based on given filter.


   .. py:property:: filter
      :type: global___Filter



   .. py:method:: HasField(field_name: Literal['filter', b'filter']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: TagsByFilterResponse(*, tags: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   TagsByFilterResponse returns the unique tags from data based on given filter.


   .. py:property:: tags
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



.. py:class:: CreateDatasetRequest(*, name: str = ..., organization_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   CreateDatasetRequest defines the name and organization ID of a dataset.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: organization_id
      :type:  str


.. py:class:: CreateDatasetResponse(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   CreateDatasetResponse returns the dataset ID of the created dataset.


   .. py:attribute:: id
      :type:  str


.. py:class:: Dataset(*, id: str = ..., name: str = ..., organization_id: str = ..., time_created: google.protobuf.timestamp_pb2.Timestamp | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Dataset stores the metadata of a dataset.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: organization_id
      :type:  str


   .. py:property:: time_created
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:method:: HasField(field_name: Literal['time_created', b'time_created']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DatasetServiceStub(channel: grpclib.client.Channel)

.. py:class:: DeleteDatasetRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DeleteDatasetRequest deletes the dataset specified by the dataset ID.


   .. py:attribute:: id
      :type:  str


.. py:class:: ListDatasetsByIDsRequest(*, ids: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   ListDatasetsByIDsRequest requests all of the datasets by their dataset IDs.


   .. py:property:: ids
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



.. py:class:: ListDatasetsByIDsResponse(*, datasets: collections.abc.Iterable[global___Dataset] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   ListDatasetsByIDsResponse returns all the dataset metadata for the associated dataset IDs.


   .. py:property:: datasets
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Dataset]



.. py:class:: ListDatasetsByOrganizationIDRequest(*, organization_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   ListDatasetsByOrganizationIDRequest requests all of the datasets for an organization.


   .. py:attribute:: organization_id
      :type:  str


.. py:class:: ListDatasetsByOrganizationIDResponse(*, datasets: collections.abc.Iterable[global___Dataset] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   ListDatasetsByOrganizationIDResponse returns all the dataset metadata for the organization.


   .. py:property:: datasets
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Dataset]



.. py:class:: RenameDatasetRequest(*, id: str = ..., name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   RenameDatasetRequest applies the new name to the dataset specified by the dataset ID.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


.. py:class:: DataCaptureUploadMetadata(*, upload_metadata: global___UploadMetadata | None = ..., sensor_metadata: global___SensorMetadata | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DataCaptureUploadMetadata contains the metadata for streaming binary (image + file) data.


   .. py:property:: upload_metadata
      :type: global___UploadMetadata



   .. py:property:: sensor_metadata
      :type: global___SensorMetadata



   .. py:method:: HasField(field_name: Literal['sensor_metadata', b'sensor_metadata', 'upload_metadata', b'upload_metadata']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DataCaptureUploadRequest(*, metadata: global___UploadMetadata | None = ..., sensor_contents: collections.abc.Iterable[global___SensorData] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DataCaptureUploadRequest requests to upload the contents and metadata for tabular data.


   .. py:property:: metadata
      :type: global___UploadMetadata



   .. py:property:: sensor_contents
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SensorData]



   .. py:method:: HasField(field_name: Literal['metadata', b'metadata']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DataCaptureUploadResponse(*, file_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DataCaptureUploadResponse returns the file id of the uploaded contents and metadata for tabular data.


   .. py:attribute:: file_id
      :type:  str


.. py:class:: DataSyncServiceStub(channel: grpclib.client.Channel)

.. py:class:: DataType

   Bases: :py:obj:`_DataType`


   DataType specifies the type of data uploaded.


.. py:class:: FileData(*, data: bytes = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   FileData contains the contents of binary (image + file) data.


   .. py:attribute:: data
      :type:  bytes


.. py:class:: FileUploadRequest(*, metadata: global___UploadMetadata | None = ..., file_contents: global___FileData | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   FileUploadRequest requests to upload the contents and metadata for binary (image + file) data.
   The first packet must be the UploadMetadata associated with the binary data.


   .. py:property:: metadata
      :type: global___UploadMetadata



   .. py:property:: file_contents
      :type: global___FileData



   .. py:method:: HasField(field_name: Literal['file_contents', b'file_contents', 'metadata', b'metadata', 'upload_packet', b'upload_packet']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['upload_packet', b'upload_packet']) -> Literal['metadata', 'file_contents'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: FileUploadResponse(*, file_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   FileUploadResponse returns the file id of the uploaded contents and metadata for binary (image + file) data.


   .. py:attribute:: file_id
      :type:  str


.. py:class:: SensorData(*, metadata: global___SensorMetadata | None = ..., struct: google.protobuf.struct_pb2.Struct | None = ..., binary: bytes = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   SensorData contains the contents and metadata for tabular data.


   .. py:attribute:: binary
      :type:  bytes


   .. py:property:: metadata
      :type: global___SensorMetadata



   .. py:property:: struct
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['binary', b'binary', 'data', b'data', 'metadata', b'metadata', 'struct', b'struct']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['data', b'data']) -> Literal['struct', 'binary'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: SensorMetadata(*, time_requested: google.protobuf.timestamp_pb2.Timestamp | None = ..., time_received: google.protobuf.timestamp_pb2.Timestamp | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   SensorMetadata contains the time the sensor data was requested and was received.


   .. py:property:: time_requested
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: time_received
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:method:: HasField(field_name: Literal['time_received', b'time_received', 'time_requested', b'time_requested']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: StreamingDataCaptureUploadRequest(*, metadata: global___DataCaptureUploadMetadata | None = ..., data: bytes = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   StreamingDataCaptureUploadRequest requests to upload the contents and metadata for streaming binary (image + file) data.
   The first packet must be the DataCaptureUploadMetadata associated with the data.


   .. py:attribute:: data
      :type:  bytes


   .. py:property:: metadata
      :type: global___DataCaptureUploadMetadata



   .. py:method:: HasField(field_name: Literal['data', b'data', 'metadata', b'metadata', 'upload_packet', b'upload_packet']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['upload_packet', b'upload_packet']) -> Literal['metadata', 'data'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: StreamingDataCaptureUploadResponse(*, file_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   StreamingDataCaptureUploadResponse returns the file id of the uploaded contents and metadata for streaming binary (image + file) data.


   .. py:attribute:: file_id
      :type:  str


.. py:class:: UploadMetadata(*, part_id: str = ..., component_type: str = ..., component_name: str = ..., method_name: str = ..., type: global___DataType = ..., file_name: str = ..., method_parameters: collections.abc.Mapping[str, google.protobuf.any_pb2.Any] | None = ..., file_extension: str = ..., tags: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   UploadMetadata contains the metadata for binary (image + file) data.


   .. py:class:: MethodParametersEntry(*, key: str = ..., value: google.protobuf.any_pb2.Any | None = ...)

      Bases: :py:obj:`google.protobuf.message.Message`


      Abstract base class for protocol messages.

      Protocol message classes are almost always generated by the protocol
      compiler.  These generated types subclass Message and implement the methods
      shown below.


      .. py:attribute:: key
         :type:  str


      .. py:property:: value
         :type: google.protobuf.any_pb2.Any



      .. py:method:: HasField(field_name: Literal['value', b'value']) -> bool

         Checks if a certain field is set for the message.

         For a oneof group, checks if any field inside is set. Note that if the
         field_name is not defined in the message descriptor, :exc:`ValueError` will
         be raised.

         :param field_name: The name of the field to check for presence.
         :type field_name: str

         :returns: Whether a value has been set for the named field.
         :rtype: bool

         :raises ValueError: if the `field_name` is not a member of this message.




   .. py:attribute:: part_id
      :type:  str


   .. py:attribute:: component_type
      :type:  str


   .. py:attribute:: component_name
      :type:  str


   .. py:attribute:: method_name
      :type:  str


   .. py:attribute:: type
      :type:  global___DataType


   .. py:attribute:: file_name
      :type:  str


   .. py:attribute:: file_extension
      :type:  str


   .. py:property:: method_parameters
      :type: google.protobuf.internal.containers.MessageMap[str, google.protobuf.any_pb2.Any]



   .. py:property:: tags
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



.. py:data:: ValueTypes

   Types that can be encoded into a protobuf `Value`

.. py:function:: create_filter(component_name: Optional[str] = None, component_type: Optional[str] = None, method: Optional[str] = None, robot_name: Optional[str] = None, robot_id: Optional[str] = None, part_name: Optional[str] = None, part_id: Optional[str] = None, location_ids: Optional[List[str]] = None, organization_ids: Optional[List[str]] = None, mime_type: Optional[List[str]] = None, start_time: Optional[datetime.datetime] = None, end_time: Optional[datetime.datetime] = None, tags: Optional[List[str]] = None, bbox_labels: Optional[List[str]] = None, dataset_id: Optional[str] = None) -> viam.proto.app.data.Filter

   Create a `Filter`.

   :param component_name: Optional name of the component that captured the data being filtered (for example, "left_motor").
   :type component_name: Optional[str]
   :param component_type: Optional type of the componenet that captured the data being filtered (for example, "motor").
   :type component_type: Optional[str]
   :param method: Optional name of the method used to capture the data being filtered (for example, "IsPowered").
   :type method: Optional[str]
   :param robot_name: Optional name of the robot associated with the data being filtered (for example, "viam_rover_1").
   :type robot_name: Optional[str]
   :param robot_id: Optional ID of the robot associated with the data being filtered.
   :type robot_id: Optional[str]
   :param part_name: Optional name of the system part associated with the data being filtered (for example,
                     "viam_rover_1-main").
   :type part_name: Optional[str]
   :param part_id: Optional ID of the system part associated with the data being filtered.
   :type part_id: Optional[str]
   :param location_ids: Optional list of location IDs associated with the data being filtered.
   :type location_ids: Optional[List[str]]
   :param organization_ids: Optional list of organization IDs associated with the data being filtered.
   :type organization_ids: Optional[List[str]]
   :param mime_type: Optional mime type of data being filtered (for example, "image/png").
   :type mime_type: Optional[List[str]]
   :param start_time: Optional start time of an interval to filter data by.
   :type start_time: Optional[datetime.datetime]
   :param end_time: Optional end time of an interval to filter data by.
   :type end_time: Optional[datetime.datetime]
   :param tags: Optional list of tags attached to the data being filtered (for example, ["test"]).
   :type tags: Optional[List[str]]
   :param bbox_labels: Optional list of bounding box labels attached to the data being filtered (for example, ["square",
                       "circle"]).
   :type bbox_labels: Optional[List[str]]
   :param dataset_id: Optional ID of dataset associated with data being filtered
   :type dataset_id: Optional[str]

   :returns: The `Filter` object.
   :rtype: viam.proto.app.data.Filter


.. py:function:: datetime_to_timestamp(dt: Optional[datetime.datetime]) -> Optional[google.protobuf.timestamp_pb2.Timestamp]

.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:data:: LOGGER

.. py:class:: DataClient(channel: grpclib.client.Channel, metadata: Mapping[str, str])

   gRPC client for uploading and retrieving data from app.

   Constructor is used by `ViamClient` to instantiate relevant service stubs. Calls to `DataClient` methods should be made through
   `ViamClient`.

   Establish a Connection::

       import asyncio

       from viam.rpc.dial import DialOptions, Credentials
       from viam.app.viam_client import ViamClient


       async def connect() -> ViamClient:
           # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
           dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
           return await ViamClient.create_from_dial_options(dial_options)


       async def main():
           # Make a ViamClient
           viam_client = await connect()
           # Instantiate a DataClient to run data client API methods on
           data_client = viam_client.data_client

           viam_client.close()

       if __name__ == '__main__':
           asyncio.run(main())



   .. py:class:: TabularData

      Class representing a piece of tabular data and associated metadata.


      .. py:attribute:: data
         :type:  Mapping[str, Any]

         The requested data


      .. py:attribute:: metadata
         :type:  viam.proto.app.data.CaptureMetadata

         The metadata associated with the data


      .. py:attribute:: time_requested
         :type:  datetime.datetime

         The time the data were requested


      .. py:attribute:: time_received
         :type:  datetime.datetime

         The time the data were received


      .. py:method:: __str__() -> str

         Return str(self).



      .. py:method:: __eq__(other: object) -> bool

         Return self==value.




   .. py:method:: tabular_data_by_filter(filter: Optional[viam.proto.app.data.Filter] = None, limit: Optional[int] = None, sort_order: Optional[viam.proto.app.data.Order.ValueType] = None, last: Optional[str] = None, count_only: bool = False, include_internal_data: bool = False, dest: Optional[str] = None) -> Tuple[List[TabularData], int, str]
      :async:


      Filter and download tabular data. The data will be paginated into pages of `limit` items, and the pagination ID will be included
      in the returned tuple. If a destination is provided, the data will be saved to that file.
      If the file is not empty, it will be overwritten.

      ::

          from viam.utils import create_filter

          my_data = []
          last = None
          my_filter = create_filter(component_name="left_motor")
          while True:
              tabular_data, count, last = await data_client.tabular_data_by_filter(my_filter, last)
              if not tabular_data:
                  break
              my_data.extend(tabular_data)


      :param filter: Optional `Filter` specifying tabular data to retrieve. No `Filter` implies all tabular
                     data.
      :type filter: viam.proto.app.data.Filter
      :param limit: The maximum number of entries to include in a page. Defaults to 50 if unspecified.
      :type limit: int
      :param sort_order: The desired sort order of the data.
      :type sort_order: viam.proto.app.data.Order
      :param last: Optional string indicating the ID of the last-returned data.
                   If provided, the server will return the next data entries after the `last` ID.
      :type last: str
      :param count_only: Whether to return only the total count of entries.
      :type count_only: bool
      :param include_internal_data: Whether to return the internal data. Internal data is used for Viam-specific data ingestion,
                                    like cloud SLAM. Defaults to `False`
      :type include_internal_data: bool
      :param dest: Optional filepath for writing retrieved data.
      :type dest: str

      :returns: A tuple containing the following:
                List[TabularData]: The tabular data,
                int: The count (number of entries),
                str: The last-returned page ID.
      :rtype: Tuple[List[TabularData], int, str]



   .. py:method:: tabular_data_by_sql(organization_id: str, sql_query: str) -> List[Dict[str, viam.utils.ValueTypes]]
      :async:


      Obtain unified tabular data and metadata, queried with SQL.

      ::

          data = await data_client.tabular_data_by_sql(org_id="<your-org-id>", sql_query="SELECT * FROM readings LIMIT 5")


      :param organization_id: The ID of the organization that owns the data.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str
      :param sql_query: The SQL query to run.
      :type sql_query: str

      :returns: An array of data objects.
      :rtype: List[Dict[str, ValueTypes]]



   .. py:method:: tabular_data_by_mql(organization_id: str, mql_binary: List[bytes]) -> List[Dict[str, viam.utils.ValueTypes]]
      :async:


      Obtain unified tabular data and metadata, queried with MQL.

      ::

          # using bson
          import bson
          tabular_data = await data_client.tabular_data_by_mql(org_id="<your-org-id>", mql_binary=[
              bson.dumps({ '$match': { 'location_id': '<location-id>' } }),
              bson.dumps({ "$limit": 5 })
          ])

          # using pymongo
          import bson
          tabular_data = await data_client.tabular_data_by_mql(org_id="<your-org-id>", mql_binary=[
              bson.encode({ '$match': { 'location_id': '<location-id>' } }),
              bson.encode({ "$limit": 5 })
          ])


      :param organization_id: The ID of the organization that owns the data.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str
      :param mql_binary: The MQL query to run as a list of BSON queries. You can encode your bson queries using a library like
                         `pymongo` or `bson`.
      :type mql_binary: List[bytes]

      :returns: An array of data objects.
      :rtype: List[Dict[str, ValueTypes]]



   .. py:method:: binary_data_by_filter(filter: Optional[viam.proto.app.data.Filter] = None, limit: Optional[int] = None, sort_order: Optional[viam.proto.app.data.Order.ValueType] = None, last: Optional[str] = None, include_binary_data: bool = True, count_only: bool = False, include_internal_data: bool = False, dest: Optional[str] = None) -> Tuple[List[viam.proto.app.data.BinaryData], int, str]
      :async:


      Filter and download binary data. The data will be paginated into pages of `limit` items, and the pagination ID will be included
      in the returned tuple. If a destination is provided, the data will be saved to that file.
      If the file is not empty, it will be overwritten.

      ::

          from viam.utils import create_filter


          my_data = []
          last = None
          my_filter = create_filter(component_name="camera")
          while True:
              data, count, last = await data_client.binary_data_by_filter(my_filter, last)
              if not data:
                  break
              my_data.extend(data)

      :param filter: Optional `Filter` specifying tabular data to retrieve. No `Filter` implies all binary
                     data.
      :type filter: viam.proto.app.data.Filter
      :param limit: The maximum number of entries to include in a page. Defaults to 50 if unspecified.
      :type limit: int
      :param sort_order: The desired sort order of the data.
      :type sort_order: viam.proto.app.data.Order
      :param last: Optional string indicating the ID of the last-returned data.
                   If provided, the server will return the next data entries after the `last` ID.
      :type last: str
      :param include_binary_data: Boolean specifying whether to actually include the binary file data with each retrieved file.
                                  Defaults to true (that is, both the files' data and metadata are returned).
      :type include_binary_data: bool
      :param count_only: Whether to return only the total count of entries.
      :type count_only: bool
      :param include_internal_data: Whether to return the internal data. Internal data is used for Viam-specific data ingestion,
                                    like cloud SLAM. Defaults to `False`
      :type include_internal_data: bool
      :param dest: Optional filepath for writing retrieved data.
      :type dest: str

      :returns: A tuple containing the following:
                List[viam.proto.app.data.BinaryData]: The binary data,
                int: The count (number of entries),
                str: The last-returned page ID.
      :rtype: Tuple[List[viam.proto.app.data.BinaryData], int, str]



   .. py:method:: binary_data_by_ids(binary_ids: List[viam.proto.app.data.BinaryID], dest: Optional[str] = None) -> List[viam.proto.app.data.BinaryData]
      :async:


      Filter and download binary data.

      ::

          from viam.proto.app.data import BinaryID

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_ids = []

          for obj in binary_metadata:
              my_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                  )
              )

          binary_data = await data_client.binary_data_by_ids(my_ids)

      :param binary_ids: `BinaryID` objects specifying the desired data. Must be non-empty.
      :type binary_ids: List[viam.proto.app.data.BinaryID]
      :param dest: Optional filepath for writing retrieved data.
      :type dest: str

      :raises GRPCError: If no `BinaryID` objects are provided.

      :returns: The binary data.
      :rtype: List[viam.proto.app.data.BinaryData]



   .. py:method:: delete_tabular_data(organization_id: str, delete_older_than_days: int) -> int
      :async:


      Delete tabular data older than a specified number of days.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="left_motor")
          days_of_data_to_delete = 10
          tabular_data = await data_client.delete_tabular_data(
              org_id="a12b3c4e-1234-1abc-ab1c-ab1c2d345abc", days_of_data_to_delete)

      :param organization_id: ID of organization to delete data from.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str
      :param delete_older_than_days: Delete data that was captured up to this many days ago. For example if `delete_older_than_days`
                                     is 10, this deletes any data that was captured up to 10 days ago. If it is 0, all existing data is deleted.
      :type delete_older_than_days: int

      :returns: The number of items deleted.
      :rtype: int



   .. py:method:: delete_tabular_data_by_filter(filter: Optional[viam.proto.app.data.Filter]) -> int
      :abstractmethod:

      :async:


      Deprecated: use delete_tabular_data instead.



   .. py:method:: delete_binary_data_by_filter(filter: Optional[viam.proto.app.data.Filter]) -> int
      :async:


      Filter and delete binary data.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="left_motor")
          res = await data_client.delete_binary_data_by_filter(my_filter)

      :param filter: Optional `Filter` specifying binary data to delete. Passing an empty `Filter` will lead to
                     all data being deleted. Exercise caution when using this option.
      :type filter: viam.proto.app.data.Filter

      :returns: The number of items deleted.
      :rtype: int



   .. py:method:: delete_binary_data_by_ids(binary_ids: List[viam.proto.app.data.BinaryID]) -> int
      :async:


      Filter and delete binary data.

      ::

          from viam.proto.app.data import BinaryID

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_ids = []

          for obj in binary_metadata:
              my_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                  )
              )

          binary_data = await data_client.delete_binary_data_by_ids(my_ids)

      :param binary_ids: `BinaryID` objects specifying the data to be deleted. Must be non-empty.
      :type binary_ids: List[viam.proto.app.data.BinaryID]

      :raises GRPCError: If no `BinaryID` objects are provided.

      :returns: The number of items deleted.
      :rtype: int



   .. py:method:: add_tags_to_binary_data_by_ids(tags: List[str], binary_ids: List[viam.proto.app.data.BinaryID]) -> None
      :async:


      Add tags to binary data.

      ::

          from viam.proto.app.data import BinaryID

          tags = ["tag1", "tag2"]

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_ids = []

          for obj in binary_metadata:
              my_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                  )
              )

          binary_data = await data_client.add_tags_to_binary_data_by_ids(tags, my_ids)

      :param tags: List of tags to add to specified binary data. Must be non-empty.
      :type tags: List[str]
      :param binary_ids: List of `BinaryID` objects specifying binary data to tag. Must be non-empty.
      :type binary_ids: List[viam.app.proto.BinaryID]

      :raises GRPCError: If no `BinaryID` objects or tags are provided.



   .. py:method:: add_tags_to_binary_data_by_filter(tags: List[str], filter: Optional[viam.proto.app.data.Filter] = None) -> None
      :async:


      Add tags to binary data.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="my_camera")
          tags = ["tag1", "tag2"]
          res = await data_client.add_tags_to_binary_data_by_filter(tags, my_filter)

      :param tags: List of tags to add to specified binary data. Must be non-empty.
      :type tags: List[str]
      :param filter: `Filter` specifying binary data to tag. If no `Filter` is provided, all data will be
                     tagged.
      :type filter: viam.proto.app.data.Filter

      :raises GRPCError: If no tags are provided.



   .. py:method:: remove_tags_from_binary_data_by_ids(tags: List[str], binary_ids: List[viam.proto.app.data.BinaryID]) -> int
      :async:


      Remove tags from binary data by IDs.

      ::

          from viam.proto.app.data import BinaryID

          tags = ["tag1", "tag2"]

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_ids = []

          for obj in binary_metadata:
              my_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                  )
              )

          binary_data = await data_client.remove_tags_from_binary_data_by_ids(
              tags, my_ids)

      :param tags: List of tags to remove from specified binary data. Must be non-empty.
      :type tags: List[str]
      :param binary_ids: List of `BinaryID` objects specifying binary data to untag. Must be non-empty.
      :type binary_ids: List[BinaryID]

      :raises GRPCError: If no binary_ids or tags are provided.

      :returns: The number of tags removed.
      :rtype: int



   .. py:method:: remove_tags_from_binary_data_by_filter(tags: List[str], filter: Optional[viam.proto.app.data.Filter] = None) -> int
      :async:


      Remove tags from binary data.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="my_camera")
          tags = ["tag1", "tag2"]
          res = await data_client.remove_tags_from_binary_data_by_filter(tags, my_filter)

      :param tags: List of tags to remove from specified binary data.
      :type tags: List[str]
      :param filter: `Filter` specifying binary data to untag. If no `Filter` is provided, all data will be
                     untagged.
      :type filter: viam.proto.app.data.Filter

      :raises GRPCError: If no tags are provided.

      :returns: The number of tags removed.
      :rtype: int



   .. py:method:: tags_by_filter(filter: Optional[viam.proto.app.data.Filter] = None) -> List[str]
      :async:


      Get a list of tags using a filter.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="my_camera")
          tags = await data_client.tags_by_filter(my_filter)

      :param filter: `Filter` specifying data to retrieve from. If no `Filter` is provided, all data tags will
                     return.
      :type filter: viam.proto.app.data.Filter

      :returns: The list of tags.
      :rtype: List[str]



   .. py:method:: add_bounding_box_to_image_by_id(binary_id: viam.proto.app.data.BinaryID, label: str, x_min_normalized: float, y_min_normalized: float, x_max_normalized: float, y_max_normalized: float) -> str
      :async:


      Add a bounding box to an image.

      ::

          from viam.proto.app.data import BinaryID

          MY_BINARY_ID = BinaryID(
              file_id=your-file_id,
              organization_id=your-org-id,
              location_id=your-location-id
          )

          bbox_label = await data_client.add_bounding_box_to_image_by_id(
              binary_id=MY_BINARY_ID,
              label="label",
              x_min_normalized=0,
              y_min_normalized=.1,
              x_max_normalized=.2,
              y_max_normalized=.3
          )

          print(bbox_label)

      :param binary_id: The ID of the image to add the bounding box to.
      :type binary_id: viam.proto.app.data.BinaryID
      :param label: A label for the bounding box.
      :type label: str
      :param x_min_normalized: Min X value of the bounding box normalized from 0 to 1.
      :type x_min_normalized: float
      :param y_min_normalized: Min Y value of the bounding box normalized from 0 to 1.
      :type y_min_normalized: float
      :param x_max_normalized: Max X value of the bounding box normalized from 0 to 1.
      :type x_max_normalized: float
      :param y_max_normalized: Max Y value of the bounding box normalized from 0 to 1.
      :type y_max_normalized: float

      :raises GRPCError: If the X or Y values are outside of the [0, 1] range.

      :returns: The bounding box ID.
      :rtype: str



   .. py:method:: remove_bounding_box_from_image_by_id(bbox_id: str, binary_id: viam.proto.app.data.BinaryID) -> None
      :async:


      Removes a bounding box from an image.

      ::

          from viam.proto.app.data import BinaryID

          MY_BINARY_ID = BinaryID(
              file_id=your-file_id,
              organization_id=your-org-id,
              location_id=your-location-id
          )

          await data_client.remove_bounding_box_from_image_by_id(
          binary_id=MY_BINARY_ID,
          bbox_id="your-bounding-box-id-to-delete"
          )

      :param bbox_id: The ID of the bounding box to remove.
      :type bbox_id: str
      :param binary_id: Binary ID of the image to to remove the bounding box from.
      :type binary_id: viam.proto.arr.data.BinaryID



   .. py:method:: bounding_box_labels_by_filter(filter: Optional[viam.proto.app.data.Filter] = None) -> List[str]
      :async:


      Get a list of bounding box labels using a `Filter`.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="my_camera")
          bounding_box_labels = await data_client.bounding_box_labels_by_filter(
              my_filter)

      :param filter: `Filter` specifying data to retrieve from. If no `Filter` is provided, all labels will
                     return.
      :type filter: viam.proto.app.data.Filter

      :returns: The list of bounding box labels.
      :rtype: List[str]



   .. py:method:: get_database_connection(organization_id: str) -> str
      :async:


      Get a connection to access a MongoDB Atlas Data federation instance.

      ::

          data_client.get_database_connection(org_id="a12b3c4e-1234-1abc-ab1c-ab1c2d345abc")

      :param organization_id: Organization to retrieve the connection for.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str

      :returns: The hostname of the federated database.
      :rtype: str



   .. py:method:: configure_database_user(organization_id: str, password: str) -> None
      :async:


      Configure a database user for the Viam organization's MongoDB Atlas Data Federation instance. It can also be used to reset the
      password of the existing database user.

      ::

          await data_client.configure_database_user(
              organization_id="<your-org-id>",
              password="your_password"
          )

      :param organization_id: The ID of the organization.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str
      :param password: The password of the user.
      :type password: str



   .. py:method:: create_dataset(name: str, organization_id: str) -> str
      :async:


      Create a new dataset.

      ::

          name = await data_client.create_dataset(
              name="<dataset-name>",
              organization_id="<your-org-id>"
          )
          print(name)

      :param name: The name of the dataset being created.
      :type name: str
      :param organization_id: The ID of the organization where the dataset is being created.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str

      :returns: The dataset ID of the created dataset.
      :rtype: str



   .. py:method:: list_dataset_by_ids(ids: List[str]) -> Sequence[viam.proto.app.dataset.Dataset]
      :async:


      Get a list of datasets using their IDs.

      ::

          datasets = await data_client.list_dataset_by_ids(
              ids=["abcd-1234xyz-8765z-123abc"]
          )
          print(datasets)

      :param ids: The IDs of the datasets being called for. To retrieve these IDs,
                  navigate to your dataset's page in the Viam app,
                  click **...** in the left-hand menu, and click **Copy dataset ID**.
      :type ids: List[str]

      :returns: The list of datasets.
      :rtype: Sequence[Dataset]



   .. py:method:: list_datasets_by_organization_id(organization_id: str) -> Sequence[viam.proto.app.dataset.Dataset]
      :async:


      Get the datasets in an organization.

      ::

          datasets = await data_client.list_dataset_by_organization_id(
              organization_id=[""a12b3c4e-1234-1abc-ab1c-ab1c2d345abc""]
          )
          print(datasets)

      :param organization_id: The ID of the organization.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str

      :returns: The list of datasets in the organization.
      :rtype: Sequence[Dataset]



   .. py:method:: rename_dataset(id: str, name: str) -> None
      :async:


      Rename a dataset specified by the dataset ID.

      ::

          await data_client.rename_dataset(
              id="abcd-1234xyz-8765z-123abc",
              name="<dataset-name>"
          )

      :param id: The ID of the dataset.
      :type id: str
      :param name: The new name of the dataset.
      :type name: str



   .. py:method:: delete_dataset(id: str) -> None
      :async:


      Delete a dataset.

      ::

          await data_client.delete_dataset(
              id="abcd-1234xyz-8765z-123abc"
          )

      :param id: The ID of the dataset.
      :type id: str



   .. py:method:: add_binary_data_to_dataset_by_ids(binary_ids: List[viam.proto.app.data.BinaryID], dataset_id: str) -> None
      :async:


      Add the BinaryData to the provided dataset.

      This BinaryData will be tagged with the VIAM_DATASET_{id} label.

      ::

          from viam.proto.app.data import BinaryID

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_binary_ids = []

          for obj in binary_metadata:
              my_binary_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                      )
                  )

          await data_client.add_binary_data_to_dataset_by_ids(
              binary_ids=my_binary_ids,
              dataset_id="abcd-1234xyz-8765z-123abc"
          )

      :param binary_ids: The IDs of binary data to add to dataset. To retrieve these IDs,
                         navigate to your dataset's page in the Viam app,
                         click **...** in the left-hand menu, and click **Copy dataset ID**.
      :type binary_ids: List[BinaryID]
      :param dataset_id: The ID of the dataset to be added to.
      :type dataset_id: str



   .. py:method:: remove_binary_data_from_dataset_by_ids(binary_ids: List[viam.proto.app.data.BinaryID], dataset_id: str) -> None
      :async:


      Remove the BinaryData from the provided dataset.

      This BinaryData will lose the VIAM_DATASET_{id} tag.

      ::

          from viam.proto.app.data import BinaryID

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_binary_ids = []

          for obj in binary_metadata:
              my_binary_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                  )
              )

          await data_client.remove_binary_data_from_dataset_by_ids(
              binary_ids=my_binary_ids,
              dataset_id="abcd-1234xyz-8765z-123abc"
          )

      :param binary_ids: The IDs of binary data to remove from dataset. To retrieve these IDs,
                         navigate to your dataset's page in the Viam app,
                         click **...** in the left-hand menu, and click **Copy dataset ID**.
      :type binary_ids: List[BinaryID]
      :param dataset_id: The ID of the dataset to be removed from.
      :type dataset_id: str



   .. py:method:: binary_data_capture_upload(binary_data: bytes, part_id: str, component_type: str, component_name: str, method_name: str, file_extension: str, method_parameters: Optional[Mapping[str, Any]] = None, tags: Optional[List[str]] = None, data_request_times: Optional[Tuple[datetime.datetime, datetime.datetime]] = None) -> str
      :async:


      Upload binary sensor data.

      Upload binary data collected on a robot through a specific component (for example, a motor) along with the relevant metadata to
      app.viam.com. Binary data can be found under the "Files" subtab of the Data tab on app.viam.com.

      ::

          time_requested = datetime(2023, 6, 5, 11)
          time_received = datetime(2023, 6, 5, 11, 0, 3)

          file_id = await data_client.binary_data_capture_upload(
              part_id="INSERT YOUR PART ID",
              component_type='camera',
              component_name='my_camera',
              method_name='GetImages',
              method_parameters=None,
              tags=["tag_1", "tag_2"],
              data_request_times=[time_requested, time_received],
              file_extension=".jpg",
              binary_data=b"Encoded image bytes"
          )

      :param binary_data: The data to be uploaded, represented in bytes.
      :type binary_data: bytes
      :param part_id: Part ID of the component used to capture the data.
      :type part_id: str
      :param component_type: Type of the component used to capture the data (for example, "movement_sensor").
      :type component_type: str
      :param component_name: Name of the component used to capture the data.
      :type component_name: str
      :param method_name: Name of the method used to capture the data.
      :type method_name: str
      :param file_extension: The file extension of binary data including the period, for example .jpg, .png, .pcd.
                             The backend will route the binary to its corresponding mime type based on this extension. Files with a .jpeg, .jpg,
                             or .png extension will be saved to the images tab.
      :type file_extension: str
      :param method_parameters: Optional dictionary of method parameters. No longer in active use.
      :type method_parameters: Optional[Mapping[str, Any]]
      :param tags: Optional list of tags to allow for tag-based data filtering when retrieving data.
      :type tags: Optional[List[str]]
      :param data_request_times: Optional tuple containing `datetime`s objects
                                 denoting the times this data was requested[0] by the robot and received[1] from the appropriate sensor.
      :type data_request_times: Optional[Tuple[datetime.datetime, datetime.datetime]]

      :raises GRPCError: If an invalid part ID is passed.

      :returns: The file_id of the uploaded data.
      :rtype: str



   .. py:method:: tabular_data_capture_upload(tabular_data: List[Mapping[str, Any]], part_id: str, component_type: str, component_name: str, method_name: str, method_parameters: Optional[Mapping[str, Any]] = None, tags: Optional[List[str]] = None, data_request_times: Optional[List[Tuple[datetime.datetime, datetime.datetime]]] = None) -> str
      :async:


      Upload tabular sensor data.

      Upload tabular data collected on a robot through a specific component (for example, a motor) along with the relevant metadata to
      app.viam.com. Tabular data can be found under the "Sensors" subtab of the Data tab on app.viam.com.

      ::

          time_requested = datetime(2023, 6, 5, 11)
          time_received = datetime(2023, 6, 5, 11, 0, 3)

          file_id = await data_client.tabular_data_capture_upload(
              part_id="INSERT YOUR PART ID",
              component_type='motor',
              component_name='left_motor',
              method_name='IsPowered',
              tags=["tag_1", "tag_2"],
              data_request_times=[(time_requested, time_received)],
              tabular_data=[{'PowerPCT': 0, 'IsPowered': False}]
          )

      :param tabular_data: List of the data to be uploaded, represented tabularly as a collection of dictionaries.
      :type tabular_data: List[Mapping[str, Any]]
      :param part_id: Part ID of the component used to capture the data.
      :type part_id: str
      :param component_type: Type of the component used to capture the data (for example, "movement_sensor").
      :type component_type: str
      :param component_name: Name of the component used to capture the data.
      :type component_name: str
      :param method_name: Name of the method used to capture the data.
      :type method_name: str
      :param method_parameters: Optional dictionary of method parameters. No longer in active use.
      :type method_parameters: Optional[Mapping[str, Any]]
      :param tags: Optional list of tags to allow for tag-based data filtering when retrieving data.
      :type tags: Optional[List[str]]
      :param data_request_times: Optional list of tuples, each containing
                                 `datetime` objects denoting the times this data was requested[0] by the robot and received[1] from the appropriate sensor.
                                 Passing a list of tabular data and Timestamps with length n > 1 will result in n datapoints being uploaded, all tied to the
                                 same metadata.
      :type data_request_times: Optional[List[Tuple[datetime.datetime, datetime.datetime]]]

      :raises GRPCError: If an invalid part ID is passed.
      :raises ValueError: If a list of `Timestamp` objects is provided and its length does not match the length of the list of tabular
          data.

      :returns: The file_id of the uploaded data.
      :rtype: str



   .. py:method:: streaming_data_capture_upload(data: bytes, part_id: str, file_ext: str, component_type: Optional[str] = None, component_name: Optional[str] = None, method_name: Optional[str] = None, method_parameters: Optional[Mapping[str, Any]] = None, data_request_times: Optional[Tuple[datetime.datetime, datetime.datetime]] = None, tags: Optional[List[str]] = None) -> str
      :async:


      Uploads the metadata and contents of streaming binary data.

      ::

          time_requested = datetime(2023, 6, 5, 11)
          time_received = datetime(2023, 6, 5, 11, 0, 3)

          file_id = await data_client.streaming_data_capture_upload(
              data="byte-data-to-upload",
              part_id="INSERT YOUR PART ID",
              file_ext="png",
              component_type='motor',
              component_name='left_motor',
              method_name='IsPowered',
              data_request_times=[(time_requested, time_received)],
              tags=["tag_1", "tag_2"]
          )

      :param data: the data to be uploaded.
      :type data: bytes
      :param part_id: Part ID of the resource associated with the file.
      :type part_id: str
      :param file_ext: file extension type for the data. required for determining MIME type.
      :type file_ext: str
      :param component_type: Optional type of the component associated with the file (for example, "movement_sensor").
      :type component_type: Optional[str]
      :param component_name: Optional name of the component associated with the file.
      :type component_name: Optional[str]
      :param method_name: Optional name of the method associated with the file.
      :type method_name: Optional[str]
      :param method_parameters: Optional dictionary of the method parameters. No longer in active use.
      :type method_parameters: Optional[str]
      :param data_request_times: Optional tuple containing `datetime`s objects
                                 denoting the times this data was requested[0] by the robot and received[1] from the appropriate sensor.
      :type data_request_times: Optional[Tuple[datetime.datetime, datetime.datetime]]
      :param tags: Optional list of tags to allow for tag-based filtering when retrieving data.
      :type tags: Optional[List[str]]

      :raises GRPCError: If an invalid part ID is passed.

      :returns: The file_id of the uploaded data.
      :rtype: str



   .. py:method:: file_upload(part_id: str, data: bytes, component_type: Optional[str] = None, component_name: Optional[str] = None, method_name: Optional[str] = None, file_name: Optional[str] = None, method_parameters: Optional[Mapping[str, Any]] = None, file_extension: Optional[str] = None, tags: Optional[List[str]] = None) -> str
      :async:


      Upload arbitrary file data.

      Upload file data that may be stored on a robot along with the relevant metadata to app.viam.com. File data can be found under the
      "Files" subtab of the Data tab on app.viam.com.

      ::

          file_id = await data_client.file_upload(
              data=b"Encoded image bytes",
              part_id="INSERT YOUR PART ID",
              tags=["tag_1", "tag_2"],
              file_name="your-file",
              file_extension=".txt"
          )

      :param part_id: Part ID of the resource associated with the file.
      :type part_id: str
      :param data: Bytes representing file data to upload.
      :type data: bytes
      :param component_type: Optional type of the component associated with the file (for example, "movement_sensor").
      :type component_type: Optional[str]
      :param component_name: Optional name of the component associated with the file.
      :type component_name: Optional[str]
      :param method_name: Optional name of the method associated with the file.
      :type method_name: Optional[str]
      :param file_name: Optional name of the file. The empty string "" will be assigned as the file name if one isn't
                        provided.
      :type file_name: Optional[str]
      :param method_parameters: Optional dictionary of the method parameters. No longer in active use.
      :type method_parameters: Optional[str]
      :param file_extension: Optional file extension. The empty string "" will be assigned as the file extension if one isn't
                             provided. Files with a .jpeg, .jpg, or .png extension will be saved to the images tab.
      :type file_extension: Optional[str]
      :param tags: Optional list of tags to allow for tag-based filtering when retrieving data.
      :type tags: Optional[List[str]]

      :raises GRPCError: If an invalid part ID is passed.

      :returns: ID of the new file.
      :rtype: str



   .. py:method:: file_upload_from_path(filepath: str, part_id: str, component_type: Optional[str] = None, component_name: Optional[str] = None, method_name: Optional[str] = None, method_parameters: Optional[Mapping[str, Any]] = None, tags: Optional[List[str]] = None) -> str
      :async:


      Upload arbitrary file data.

      Upload file data that may be stored on a robot along with the relevant metadata to app.viam.com. File data can be found under the
      "Files" subtab of the Data tab on app.viam.com.

      ::

          file_id = await data_client.file_upload_from_path(
              part_id="INSERT YOUR PART ID",
              tags=["tag_1", "tag_2"],
              filepath="/Users/<your-username>/<your-directory>/<your-file.txt>"
          )

      :param filepath: Absolute filepath of file to be uploaded.
      :type filepath: str
      :param part_id: Part ID of the component associated with the file.
      :type part_id: str
      :param component_type: Optional type of the component associated with the file (for example, "movement_sensor").
      :type component_type: Optional[str]
      :param component_name: Optional name of the component associated with the file.
      :type component_name: Optional[str]
      :param method_name: Optional name of the method associated with the file.
      :type method_name: Optional[str]
      :param method_parameters: Optional dictionary of the method parameters. No longer in active use.
      :type method_parameters: Optional[str]
      :param tags: Optional list of tags to allow for tag-based filtering when retrieving data.
      :type tags: Optional[List[str]]

      :raises GRPCError: If an invalid part ID is passed.
      :raises FileNotFoundError: If the provided filepath is not found.

      :returns: ID of the new file.
      :rtype: str



   .. py:method:: create_filter(component_name: Optional[str] = None, component_type: Optional[str] = None, method: Optional[str] = None, robot_name: Optional[str] = None, robot_id: Optional[str] = None, part_name: Optional[str] = None, part_id: Optional[str] = None, location_ids: Optional[List[str]] = None, organization_ids: Optional[List[str]] = None, mime_type: Optional[List[str]] = None, start_time: Optional[datetime.datetime] = None, end_time: Optional[datetime.datetime] = None, tags: Optional[List[str]] = None, bbox_labels: Optional[List[str]] = None, dataset_id: Optional[str] = None) -> viam.proto.app.data.Filter
      :staticmethod:



