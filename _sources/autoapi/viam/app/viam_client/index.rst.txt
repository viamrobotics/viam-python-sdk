viam.app.viam_client
====================

.. py:module:: viam.app.viam_client


Attributes
----------

.. autoapisummary::

   viam.app.viam_client.LOGGER


Classes
-------

.. autoapisummary::

   viam.app.viam_client.AppClient
   viam.app.viam_client.BillingClient
   viam.app.viam_client.DataClient
   viam.app.viam_client.MLTrainingClient
   viam.app.viam_client.ProvisioningClient
   viam.app.viam_client.DialOptions
   viam.app.viam_client.ViamClient


Module Contents
---------------

.. py:class:: AppClient(channel: grpclib.client.Channel, metadata: Mapping[str, str], location_id: Optional[str] = None)

   gRPC client for method calls to app.

   Constructor is used by `ViamClient` to instantiate relevant service stub. Calls to `AppClient`  methods should be made through
   `ViamClient`.

   Establish a Connection::

       import asyncio

       from viam.rpc.dial import DialOptions, Credentials
       from viam.app.viam_client import ViamClient


       async def connect() -> ViamClient:
           # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
           dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
           return await ViamClient.create_from_dial_options(dial_options)


       async def main():

           # Make a ViamClient
           viam_client = await connect()
           # Instantiate an AppClient called "cloud" to run cloud app API methods on
           cloud = viam_client.app_client

           viam_client.close()

       if __name__ == '__main__':
           asyncio.run(main())



   .. py:method:: get_user_id_by_email(email: str) -> str
      :async:


      Get the ID of a user by email.

      ::

          id = await cloud.get_user_id_by_email("youremail@email.com")

      :param email: The email of the user.
      :type email: str

      :returns: The ID of the user.
      :rtype: str



   .. py:method:: create_organization(name: str) -> viam.proto.app.Organization
      :async:


      Create an organization.

      ::

          organization = await cloud.create_organization("name")

      :param name: The name of the organization.
      :type name: str

      :returns: The created organization.
      :rtype: Organization



   .. py:method:: list_organizations() -> List[viam.proto.app.Organization]
      :async:


      List the organization(s) the user is an authorized owner of.

      ::

          org_list = await cloud.list_organizations()

      :returns: The list of organizations.
      :rtype: List[viam.proto.app.Organization]



   .. py:method:: get_organizations_with_access_to_location(location_id: str) -> List[viam.proto.app.OrganizationIdentity]
      :async:


      Get all organizations that have access to a location.

      ::

          org_list = await cloud.get_organization_with_access_to_location("location-id")

      :param location_id: The ID of the location.
      :type location_id: str

      :returns: The list of organizations.
      :rtype: List[viam.proto.app.OrganizationIdentity]



   .. py:method:: list_organizations_by_user(user_id: str) -> List[viam.proto.app.OrgDetails]
      :async:


      List the organizations a user belongs to.

      ::

          org_list = await cloud.list_organizations_by_user("user-id")

      :param user_id: The ID of the user
      :type user_id: str

      :returns: The list of organizations.
      :rtype: List[OrgDetails]



   .. py:method:: get_organization(org_id: str) -> viam.proto.app.Organization
      :async:


      Return details about the requested organization.

      :param org_id: The ID of the organization to query.
      :type org_id: str

      :raises GRPCError: If the provided org_id is invalid, or not currently authed to.

      :returns: The requested organization.
      :rtype: viam.proto.app.Organization



   .. py:method:: get_organization_namespace_availability(public_namespace: str) -> bool
      :async:


      Check the availability of an organization namespace.

      ::

          available = await cloud.get_organization_namespace_availability(
              public_namespace="my-cool-organization")

      :param public_namespace: Organization namespace to check. Namespaces can only contain lowercase lowercase alphanumeric and dash
                               characters.
      :type public_namespace: str

      :raises GRPCError: If an invalid namespace (for example, "") is provided.

      :returns: True if the provided namespace is available.
      :rtype: bool



   .. py:method:: update_organization(org_id: str, name: Optional[str] = None, public_namespace: Optional[str] = None, region: Optional[str] = None, cid: Optional[str] = None) -> viam.proto.app.Organization
      :async:


      Updates organization details.

      :param org_id: The ID of the organization to update.
      :type org_id: str
      :param name: If provided, updates the org's name.
      :type name: Optional[str]
      :param public_namespace: If provided, sets the org's namespace if it hasn't already been set.
      :type public_namespace: Optional[str]
      :param region: If provided, updates the org's region.
      :type region: Optional[str]
      :param cid: If provided, update's the org's CRM ID.
      :type cid: Optional[str]

      :raises GRPCError: If the org's namespace has already been set, or if the provided namespace is already taken.

      :returns: The updated organization.
      :rtype: viam.proto.app.Organization



   .. py:method:: delete_organization(org_id: str) -> None
      :async:


      Delete an organization

      ::
          await cloud.delete_organization("org-id")

      :param org_id: The ID of the organization.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str



   .. py:method:: list_organization_members(org_id: str) -> Tuple[List[viam.proto.app.OrganizationMember], List[viam.proto.app.OrganizationInvite]]
      :async:


      List the members and invites of the currently authed-to organization.

      ::

          member_list, invite_list = await cloud.list_organization_members("org-id")

      :param org_id: The ID of the organization to list members of.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str

      :returns: A tuple containing two lists; the first
                [0] of organization members, and the second [1] of organization invites.
      :rtype: Tuple[List[viam.proto.app.OrganizationMember], List[viam.proto.app.OrganizationInvite]]



   .. py:method:: create_organization_invite(org_id: str, email: str, authorizations: Optional[List[viam.proto.app.Authorization]] = None, send_email_invite: bool = True) -> viam.proto.app.OrganizationInvite
      :async:


      Creates an organization invite and sends it via email.

      ::

          await cloud.create_organization_invite("org-id", "youremail@email.com")

      :param org_id: The ID of the organization to create an invite for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param email: The email address to send the invite to.
      :type email: str
      :param authorizations: Specifications of the
                             authorizations to include in the invite. If not provided, full owner permissions will
                             be granted.
      :type authorizations: Optional[List[viam.proto.app.Authorization]]
      :param send_email_invite: Whether or not an email should be sent to the recipient of an invite.
                                The user must accept the email to be added to the associated authorizations.
                                When set to false, the user automatically receives the associated authorization
                                on the next login of the user with the associated email address.
      :type send_email_invite: Optional[bool]

      :raises GRPCError: if an invalid email is provided, or if the user is already a member of the org.

      :returns: The organization invite.
      :rtype: OrganizationInvite



   .. py:method:: update_organization_invite_authorizations(org_id: str, email: str, add_authorizations: Optional[List[viam.proto.app.Authorization]] = None, remove_authorizations: Optional[List[viam.proto.app.Authorization]] = None) -> viam.proto.app.OrganizationInvite
      :async:


      Update the authorizations attached to an organization invite that has already been created.

      Note that an invite can only have one authorization at each resource (for example, organization, location, robot, etc.) level and
      must have at least one authorization overall.

      ::

          from viam.proto.app import Authorization

          authorization_to_add = Authorization(
              authorization_type="some type of auth",
              authorization_id="identifier",
              resource_type="abc",
              resource_id="resource-identifier123",
              identity_id="id12345",
              organization_id="org_id_123"
          )

          update_invite = await cloud.update_organization_invite_authorizations(
              org_id="org_id_123",
              email="notarealemail@viam.com",
              add_authorizations =[authorization_to_add]
          )

      :param org_id: The ID of the organization that the invite is for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param email: Email of the user the invite was sent to.
      :type email: str
      :param add_authorizations: Optional list of authorizations to add to the invite.
      :type add_authorizations: Optional[List[viam.proto.app.Authorization]]
      :param remove_authorizations: Optional list of authorizations to remove from the invite.
      :type remove_authorizations: Optional[List[viam.proto.app.Authorization]]

      :raises GRPCError: If no authorizations are passed or if an invalid combination of authorizations is passed (for example an
          authorization to remove when the invite only contains one authorization).

      :returns: The updated invite.
      :rtype: viam.proto.app.OrganizationInvite



   .. py:method:: delete_organization_member(org_id: str, user_id: str) -> None
      :async:


      Remove a member from the organization.

      ::

          member_list, invite_list = await cloud.list_organization_members()
          first_user_id = member_list[0].user_id

          await cloud.delete_organization_member(org_id="org_id", user_id=first_user_id)

      :param org_id: The ID of the org to remove the user from.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param user_id: The ID of the user to remove.
      :type user_id: str



   .. py:method:: delete_organization_invite(org_id: str, email: str) -> None
      :async:


      Deletes a pending organization invite.

      ::

          await cloud.delete_organization_invite("org-id", "youremail@email.com")

      :param org_id: The ID of the organization that the invite to delete was for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param email: The email address the pending invite was sent to.
      :type email: str

      :raises GRPCError: If no pending invite is associated with the provided email address.



   .. py:method:: resend_organization_invite(org_id: str, email: str) -> viam.proto.app.OrganizationInvite
      :async:


      Re-sends a pending organization invite email.

      ::

          org_invite = await cloud.resend_organization_invite("org-id", "youremail@email.com")

      :param org_id: The ID of the organization that the invite to resend was for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param email: The email address associated with the invite.
      :type email: str

      :raises GRPCError: If no pending invite is associated with the provided email address.

      :returns: The organization invite sent.
      :rtype: viam.proto.app.OrganizationInvite



   .. py:method:: create_location(org_id: str, name: str, parent_location_id: Optional[str] = None) -> viam.proto.app.Location
      :async:


      Create and name a location under the currently authed-to organization and the specified parent location.

      ::

          my_new_location = await cloud.create_location(org_id="org-id", name="Robotville", parent_location_id="111ab12345")

      :param org_id: The ID of the organization to create the location under.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param name: Name of the location.
      :type name: str
      :param parent_location_id: Optional parent location to put the location under. Defaults to a root-level location if no
                                 location ID is provided.
      :type parent_location_id: Optional[str]

      :raises GRPCError: If either an invalid name (for example, ""), or parent location ID (for example, a nonexistent ID) is passed.

      :returns: The newly created location.
      :rtype: viam.proto.app.Location



   .. py:method:: get_location(location_id: Optional[str] = None) -> viam.proto.app.Location
      :async:


      Get a location.

      ::

          location = await cloud.get_location(location_id="123ab12345")

      :param location_id: ID of the location to get. Defaults to the location ID provided at `AppClient` instantiation.
      :type location_id: Optional[str]

      :raises GRPCError: If an invalid location ID is passed or if one isn't passed and there was no location ID provided at `AppClient`
          instantiation.

      :returns: The location.
      :rtype: viam.proto.app.Location



   .. py:method:: update_location(location_id: str, name: Optional[str] = None, parent_location_id: Optional[str] = None) -> viam.proto.app.Location
      :async:


      Change the name of a location and/or assign it a new parent location.

      ::

          # The following line takes the location with ID "abc12abcde" and moves it to be a
          # sub-location of the location with ID "xyz34xxxxx"
          my_updated_location = await cloud.update_location(
              location_id="abc12abcde",
              name="",
              parent_location_id="xyz34xxxxx",
          )

          # The following line changes the name of the location without changing its parent location
          my_updated_location = await cloud.update_location(
              location_id="abc12abcde",
              name="Land Before Robots"
          )

          # The following line moves the location back up to be a top level location without changing its name
          my_updated_location = await cloud.update_location(
              location_id="abc12abcde",
              name="",
              parent_location_id=""
          )

      :param location_id: ID of the location to update. Must be specified.
      :type location_id: str
      :param name: Optional new name to be updated on the location. Defaults to the empty string "" (that is, the name
                   doesn't change).
      :type name: Optional[str]
      :param parent_location_id: Optional ID of new parent location to move the location under. Defaults to the empty string
                                 "" (that is, no new parent location is assigned).
      :type parent_location_id: Optional[str]

      :raises GRPCError: If either an invalid location ID, name, or parent location ID is passed.

      :returns: The newly updated location.
      :rtype: viam.proto.app.Location



   .. py:method:: delete_location(location_id: str) -> None
      :async:


      Delete a location.

      ::

          await cloud.delete_location(location_id="abc12abcde")

      :param location_id: ID of the location to delete. Must be specified.
      :type location_id: str

      :raises GRPCError: If an invalid location ID is passed.



   .. py:method:: list_locations(org_id: str) -> List[viam.proto.app.Location]
      :async:


      Get a list of all locations under the currently authed-to organization.

      ::

          locations = await cloud.list_locations("org-id")

      :param org_id: The ID of the org to list locations for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str

      :returns: The list of locations.
      :rtype: List[viam.proto.app.Location]



   .. py:method:: share_location(organization_id: str, location_id: str) -> None
      :async:


      Share a location with an organization.

      ::

          await cloud.share_location("organization-id", "location-id")

      :param organization_id: The ID of the organization.
      :type organization_id: str
      :param location_id: The ID of the location.
      :type location_id: str



   .. py:method:: unshare_location(organization_id: str, location_id: str) -> None
      :async:


      Stop sharing a location with an organization.

      ::

          await cloud.unshare_location("organization-id", "location-id")

      :param organization_id: The ID of the organization.
      :type organization_id: str
      :param location_id: The ID of the location.
      :type location_id: str



   .. py:method:: location_auth(location_id: Optional[str] = None) -> viam.proto.app.LocationAuth
      :async:


      Get a location's `LocationAuth` (location secret(s)).

      ::

          loc_auth = await cloud.location_auth(location_id="123xy12345")

      :param location_id: ID of the location to retrieve `LocationAuth` from. Defaults to the location ID provided at `AppClient`
                          instantiation.
      :type location_id: str

      :raises GRPCError: If an invalid location ID is passed or if one isn't passed and there was no location ID provided at `AppClient`
          instantiation.

      :returns: The `LocationAuth` containing location secrets.
      :rtype: viam.proto.app.LocationAuth



   .. py:method:: create_location_secret(location_id: Optional[str] = None) -> viam.proto.app.LocationAuth
      :async:


      Create a new location secret.

      ::

          new_loc_auth = await cloud.create_location_secret()

      :param location_id: ID of the location to generate a new secret for. Defaults to the location ID provided at
                          `AppClient` instantiation.
      :type location_id: Optional[str]

      :raises GRPCError: If an invalid location ID is passed or one isn't passed and there was no location ID provided at `AppClient`
          instantiation.

      :returns: The specified location's `LocationAuth` containing the newly created secret.
      :rtype: viam.proto.app.LocationAuth



   .. py:method:: delete_location_secret(secret_id: str, location_id: Optional[str] = None) -> None
      :async:


      Delete a location secret.

      ::

          await cloud.delete_location_secret(
              secret_id="abcd123-456-7890ab-cxyz98-989898xyzxyz")

      :param location_id: ID of the location to delete secret from. Defaults to the location ID provided at `AppClient` instantiation.
      :type location_id: str
      :param secret_id: ID of the secret to delete.
      :type secret_id: str

      :raises GRPCError: If either an invalid location ID or secret ID is passed or a location ID isn't passed and there was no location
          ID provided at `AppClient` instantiation.



   .. py:method:: get_robot(robot_id: str) -> viam.proto.app.Robot
      :async:


      Get a robot.

      ::

          robot = await cloud.get_robot(robot_id="1a123456-x1yz-0ab0-a12xyzabc")

      :param robot_id: ID of the robot to get.
      :type robot_id: str

      :raises GRPCError: If an invalid robot ID is passed.

      :returns: The robot.
      :rtype: viam.proto.app.Robot



   .. py:method:: get_rover_rental_robots(org_id: str) -> List[viam.proto.app.RoverRentalRobot]
      :async:


      Returns a list of rover rental robots within an org.

      ::

          rental_robots = await cloud.get_rover_rental_robots()

      :param org_id: The ID of the organization to list rover rental robots for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str

      :returns: The list of rover rental robots.
      :rtype: List[viam.proto.app.RoverRentalRobot]



   .. py:method:: get_robot_parts(robot_id: str) -> List[RobotPart]
      :async:


      Get a list of all the parts under a specific robot.

      ::

          list_of_parts = await cloud.get_robot_parts(
              robot_id="1a123456-x1yz-0ab0-a12xyzabc")

      :param robot_id: ID of the robot to get parts from.
      :type robot_id: str

      :raises GRPCError: If an invalid robot ID is passed.

      :returns: The list of robot parts.
      :rtype: List[viam.app.app_client.RobotPart]



   .. py:method:: get_robot_part(robot_part_id: str, dest: Optional[str] = None, indent: int = 4) -> RobotPart
      :async:


      Get a robot part.

      ::

          my_robot_part = await cloud.get_robot_part(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to get.
      :type robot_part_id: str
      :param dest: Optional filepath to write the robot part's config file in JSON format to.
      :type dest: Optional[str]
      :param indent: Size (in number of spaces) of indent when writing config to `dest`. Defaults to 4.
      :type indent: int

      :raises GRPCError: If an invalid robot part ID is passed.

      :returns: The robot part.
      :rtype: viam.app.app_client.RobotPart



   .. py:method:: get_robot_part_logs(robot_part_id: str, filter: Optional[str] = None, dest: Optional[str] = None, log_levels: List[str] = [], num_log_entries: int = 100) -> List[LogEntry]
      :async:


      Get the logs associated with a robot part.

      ::

          part_logs = await cloud.get_robot_part_logs(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22", num_log_entries=20)

      :param robot_part_id: ID of the robot part to get logs from.
      :type robot_part_id: str
      :param filter: Only include logs with messages that contain the string `filter`. Defaults to empty string "" (that is,
                     no filter).
      :type filter: Optional[str]
      :param dest: Optional filepath to write the log entries to.
      :type dest: Optional[str]
      :param log_levels: List of log levels for which entries should be returned. Defaults to empty list, which returns all logs.
      :type log_levels: List[str]
      :param num_log_entries: Number of log entries to return. Passing 0 returns all logs. Defaults to 100. All logs or the first
                              `num_log_entries` logs will be returned, whichever comes first.
      :type num_log_entries: int

      :raises GRPCError: If an invalid robot part ID is passed.

      :returns: The list of log entries.
      :rtype: List[viam.app.app_client.LogEntry]



   .. py:method:: tail_robot_part_logs(robot_part_id: str, errors_only: bool = True, filter: Optional[str] = None) -> viam.app._logs._LogsStream[List[LogEntry]]
      :async:


      Get an asynchronous iterator that receives live robot part logs.

      ::

          logs_stream = await cloud.tail_robot_part_logs(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to retrieve logs from.
      :type robot_part_id: str
      :param errors_only: Boolean specifying whether or not to only include error logs. Defaults to True.
      :type errors_only: bool
      :param filter: Only include logs with messages that contain the string `filter`. Defaults to empty string "" (that is,
                     no filter).
      :type filter: Optional[str]

      :returns: The asynchronous iterator receiving live robot part logs.
      :rtype: _LogsStream[List[LogEntry]]



   .. py:method:: get_robot_part_history(robot_part_id: str) -> List[RobotPartHistoryEntry]
      :async:


      Get a list containing the history of a robot part.

      ::

          part_history = await cloud.get_robot_part_history(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to retrieve history from.
      :type robot_part_id: str

      :raises GRPCError: If an invalid robot part ID is provided.

      :returns: The list of the robot part's history.
      :rtype: List[viam.app.app_client.RobotPartHistoryEntry]



   .. py:method:: update_robot_part(robot_part_id: str, name: str, robot_config: Optional[Mapping[str, Any]] = None) -> RobotPart
      :async:


      Change the name and assign an optional new configuration to a robot part.

      ::

          my_robot_part = await cloud.update_robot_part(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to update.
      :type robot_part_id: str
      :param name: New name to be updated on the robot part.
      :type name: str
      :param robot_config: Optional new config represented as a dictionary to be updated on the robot part. The robot
                           part's config will remain as is (no change) if one isn't passed.
      :type robot_config: Mapping[str, Any]

      :raises GRPCError: If either an invalid robot part ID, name, or config is passed.

      :returns: The newly updated robot part.
      :rtype: viam.app.app_client.RobotPart



   .. py:method:: new_robot_part(robot_id: str, part_name: str) -> str
      :async:


      Create a new robot part.

      ::

          new_part_id = await cloud.new_robot_part(
              robot_id="1a123456-x1yz-0ab0-a12xyzabc", part_name="myNewSubPart")

      :param robot_id: ID of the the robot to create a new part for.
      :type robot_id: str
      :param part_name: Name of the new part.
      :type part_name: str

      :raises GRPCError: If either an invalid robot ID or name is passed.

      :returns: The new robot part's ID.
      :rtype: str



   .. py:method:: delete_robot_part(robot_part_id: str) -> None
      :async:


      Delete the specified robot part.

      ::

          await cloud.delete_robot_part(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to delete. Must be specified.
      :type robot_part_id: str

      :raises GRPCError: If an invalid robot part ID is passed.



   .. py:method:: get_robot_api_keys(robot_id: str) -> List[viam.proto.app.APIKeyWithAuthorizations]
      :async:


      Gets the Robot API Keys for the robot.

      ::

          await cloud.get_robot_api_keys(robot_id="robot-id")

      :param robot_id: The ID of the robot
      :type robot_id: str

      :returns: The list of API keys.
      :rtype: List[APIKeyWithAuthorizations]



   .. py:method:: mark_part_as_main(robot_part_id: str) -> None
      :async:


      Mark a robot part as the main part of a robot.

      ::

          await cloud.mark_part_as_main(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to mark as main.
      :type robot_part_id: str

      :raises GRPCError: If an invalid robot part ID is passed.



   .. py:method:: mark_part_for_restart(robot_part_id: str) -> None
      :async:


      Mark the specified robot part for restart.

      ::

          await cloud.mark_part_for_restart(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to mark for restart.
      :type robot_part_id: str

      :raises GRPCError: If an invalid robot part ID is passed.



   .. py:method:: create_robot_part_secret(robot_part_id: str) -> RobotPart
      :async:


      Create a robot part secret.

      ::

          part_with_new_secret = await cloud.create_robot_part_secret(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to create a secret for.
      :type robot_part_id: str

      :raises GRPCError: If an invalid robot part ID is passed.

      :returns: The robot part the new secret was generated for.
      :rtype: viam.app.app_client.RobotPart



   .. py:method:: delete_robot_part_secret(robot_part_id: str, secret_id: str) -> None
      :async:


      Delete a robot part secret.

      ::

          await cloud.delete_robot_part_secret(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22",
              secret_id="123xyz12-abcd-4321-12ab-12xy1xyz12xy")

      :param robot_part_id: ID of the robot part to delete the secret from.
      :type robot_part_id: str
      :param secret_id: ID of the secret to delete.
      :type secret_id: str

      :raises GRPCError: If an invalid robot part ID or secret ID is passed.



   .. py:method:: list_robots(location_id: Optional[str] = None) -> List[viam.proto.app.Robot]
      :async:


      Get a list of all robots under the specified location.

      ::

          list_of_machines = await cloud.list_robots(location_id="123ab12345")

      :param location_id: ID of the location to retrieve the robots from. Defaults to the location ID provided at
                          `AppClient` instantiation.
      :type location_id: Optional[str]

      :raises GRPCError: If an invalid location ID is passed or one isn't passed and there was no location ID provided at `AppClient`
          instantiation.

      :returns: The list of robots.
      :rtype: List[viam.proto.app.Robot]



   .. py:method:: new_robot(name: str, location_id: Optional[str] = None) -> str
      :async:


      Create a new robot.

      ::

          new_machine_id = await cloud.new_robot(name="beepboop")

      :param name: Name of the new robot.
      :type name: str
      :param location_id: ID of the location under which to create the robot. Defaults to the current authorized location.
      :type location_id: Optional[str]

      :raises GRPCError: If an invalid location ID is passed or one isn't passed and there was no location ID provided at `AppClient`
          instantiation.

      :returns: The new robot's ID.
      :rtype: str



   .. py:method:: update_robot(robot_id: str, name: str, location_id: Optional[str] = None) -> viam.proto.app.Robot
      :async:


      Change the name of an existing robot.

      ::

          updated_robot = await cloud.update_robot(
              robot_id="1a123456-x1yz-0ab0-a12xyzabc",
              name="Orange-Robot")

      :param robot_id: ID of the robot to update.
      :type robot_id: str
      :param name: New name to be updated on the robot.
      :type name: str
      :param location_id: ID of the location under which the robot exists. Defaults to the location ID provided at
                          `AppClient` instantiation
      :type location_id: Optional[str]

      :raises GRPCError: If either an invalid robot ID, name, or location ID is passed or a location ID isn't passed and there was no location
          ID provided at `AppClient` instantiation.

      :returns: The newly updated robot.
      :rtype: viam.proto.app.Robot



   .. py:method:: delete_robot(robot_id: str) -> None
      :async:


      Delete the specified robot.

      ::

          await cloud.delete_robot(robot_id="1a123456-x1yz-0ab0-a12xyzabc")

      :param robot_id: ID of the robot to delete.
      :type robot_id: str

      :raises GRPCError: If an invalid robot ID is passed.



   .. py:method:: list_fragments(org_id: str, show_public: bool = True) -> List[Fragment]
      :async:


      Get a list of fragments under the currently authed-to organization.

      ::

          fragments_list = await cloud.list_fragments(org_id="org-id", show_public=False)

      :param org_id: The ID of the organization to list fragments for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param show_public: Optional boolean specifying whether or not to only show public fragments. If True, only public fragments will
                          return. If False, only private fragments will return. Defaults to True.

      :returns: The list of fragments.
      :rtype: List[viam.app.app_client.Fragment]



   .. py:method:: get_fragment(fragment_id: str) -> Fragment
      :async:


      Get a fragment.

      ::

          # Get a fragment and print its name and when it was created.
          the_fragment = await cloud.get_fragment(
              fragment_id="12a12ab1-1234-5678-abcd-abcd01234567")
          print("Name: ", the_fragment.name, "\nCreated on: ", the_fragment.created_on)

      :param fragment_id: ID of the fragment to get.
      :type fragment_id: str

      :raises GRPCError: If an invalid fragment ID is passed.

      :returns: The fragment.
      :rtype: viam.app.app_client.Fragment



   .. py:method:: create_fragment(org_id: str, name: str, config: Optional[Mapping[str, Any]] = None) -> Fragment
      :async:


      Create a new private fragment.

      ::

          new_fragment = await cloud.create_fragment(org_id="org-id", name="cool_smart_machine_to_configure_several_of")

      :param org_id: The ID of the organization to create the fragment within.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param name: Name of the fragment.
      :type name: str
      :param config: Optional Dictionary representation of new config to assign to specified fragment. Can be
                     assigned by updating the fragment.
      :type config: Optional[Mapping[str, Any]]

      :raises GRPCError: If an invalid name is passed.

      :returns: The newly created fragment.
      :rtype: viam.app.app_client.Fragment



   .. py:method:: update_fragment(fragment_id: str, name: str, config: Optional[Mapping[str, Any]] = None, public: Optional[bool] = None) -> Fragment
      :async:


      Update a fragment name AND its config and/or visibility.

      ::

          updated_fragment = await cloud.update_fragment(
              fragment_id="12a12ab1-1234-5678-abcd-abcd01234567",
              name="better_name")

      :param fragment_id: ID of the fragment to update.
      :type fragment_id: str
      :param name: New name to associate with the fragment.
      :type name: str
      :param config: Optional Dictionary representation of new config to assign to specified fragment. Not
                     passing this parameter will leave the fragment's config unchanged.
      :type config: Optional[Mapping[str, Any]]
      :param public: Boolean specifying whether the fragment is public. Not passing this parameter will leave the fragment's
                     visibility unchanged. A fragment is private by default when created.
      :type public: bool

      :raises GRPCError: if an invalid ID, name, or config is passed.

      :returns: The newly updated fragment.
      :rtype: viam.app.app_client.Fragment



   .. py:method:: delete_fragment(fragment_id: str) -> None
      :async:


      Delete a fragment.

      ::

          await cloud.delete_fragment(
              fragment_id="12a12ab1-1234-5678-abcd-abcd01234567")

      :param fragment_id: ID of the fragment to delete.
      :type fragment_id: str

      :raises GRPCError: If an invalid fragment ID is passed.



   .. py:method:: add_role(org_id: str, identity_id: str, role: Union[Literal['owner'], Literal['operator']], resource_type: Union[Literal['organization'], Literal['location'], Literal['robot']], resource_id: str) -> None
      :async:


      Add a role under the currently authed-to organization.

      ::

          await cloud.add_role(
              org_id="org-id",
              identity_id="abc01234-0123-4567-ab12-a11a00a2aa22",
              role="owner",
              resource_type="location",
              resource_id="111ab12345")

      :param org_id: The ID of the organization to create the role in.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param identity_id: ID of the entity the role belongs to (for example, a user ID).
      :type identity_id: str
      :param role: The role to add.
      :type role: Union[Literal["owner"], Literal["operator"]]
      :param resource_type: Type of the resource to add role to.
                            Must match `resource_id`.
      :type resource_type: Union[Literal["organization"], Literal["location"], Literal["robot"]]
      :param resource_id: ID of the resource the role applies to (that is, either an organization, location, or robot ID).
      :type resource_id: str

      :raises GRPCError: If either an invalid identity ID, role ID, resource type, or resource ID is passed.



   .. py:method:: remove_role(org_id: str, identity_id: str, role: Union[Literal['owner'], Literal['operator']], resource_type: Union[Literal['organization'], Literal['location'], Literal['robot']], resource_id: str) -> None
      :async:


      Remove a role under the currently authed-to organization.

      ::

          await cloud.remove_role(
              org_id="org-id",
              identity_id="abc01234-0123-4567-ab12-a11a00a2aa22",
              role="owner",
              resource_type="location",
              resource_id="111ab12345")

      :param org_id: The ID of the organization the role exists in.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param identity_id: ID of the entity the role belongs to (for example, a user ID).
      :type identity_id: str
      :param role: The role to remove.
      :type role: Union[Literal["owner"], Literal["operator"]]
      :param resource_type: Type of the resource the role is being
                            removed from. Must match `resource_id`.
      :type resource_type: Union[Literal["organization"], Literal["location"], Literal["robot"]]
      :param resource_id: ID of the resource the role applies to (that is, either an organization, location, or robot ID).
      :type resource_id: str

      :raises GRPCError: If either an invalid identity ID, role ID, resource type, or resource ID or is passed.



   .. py:method:: change_role(organization_id: str, old_identity_id: str, old_role: Union[Literal['owner'], Literal['operator']], old_resource_type: Union[Literal['organization'], Literal['location'], Literal['robot']], old_resource_id: str, new_identity_id: str, new_role: Union[Literal['owner'], Literal['operator']], new_resource_type: Union[Literal['organization'], Literal['location'], Literal['robot']], new_resource_id: str) -> None
      :async:


      Changes a role to a new role.

      ::

          await cloud.change_role(
              organization_id="organization-id",
              old_identity_id="abc01234-0123-4567-ab12-a11a00a2aa22",
              old_role="operator",
              old_resource_type="location",
              old_resource_id="111ab12345",
              new_identity_id="abc01234-0123-4567-ab12-a11a00a2aa22",
              new_role="owner",s
              new_resource_type="organization",
              new_resource_id="abc12345")

      :param organization_id: ID of the organization
      :type organization_id: str
      :param old_identity_id: ID of the entity the role belongs to (for example, a user ID).
      :type old_identity_id: str
      :param old_role: The role to be changed.
      :type old_role: Union[Literal["owner"], Literal["operator"]]
      :param old_resource_type: Type of the resource the role is
                                added to. Must match `old_resource_id`.
      :type old_resource_type: Union[Literal["organization"], Literal["location"], Literal["robot"]]
      :param old_resource_id: ID of the resource the role applies to (that is, either an organization, location, or robot ID).
      :type old_resource_id: str
      :param new_identity_id: New ID of the entity the role blongs to (for example, a user ID).
      :type new_identity_id: str
      :param new_role: The new role.
      :type new_role: Union[Literal["owner"], Literal["operator"]]
      :param new_resource_type: Type of the resource to add role to.
                                Must match `new_resource_id`.
      :type new_resource_type: Union[Literal["organization"], Literal["location"], Literal["robot"]]
      :param new_resource_id: New ID of the resource the role applies to (that is, either an organization, location, or robot ID).
      :type new_resource_id: str



   .. py:method:: list_authorizations(org_id: str, resource_ids: Optional[List[str]] = None) -> List[viam.proto.app.Authorization]
      :async:


      List all authorizations under a specific resource (or resources) within the currently authed-to organization. If no resource IDs
      are provided, all resource authorizations within the organizations are returned.

      ::

          list_of_auths = await cloud.list_authorizations(
              org_id="org-id",
              resource_ids=["1a123456-x1yz-0ab0-a12xyzabc"])

      :param org_id: The ID of the organization to list authorizations for.
      :param resource_ids: IDs of the resources to retrieve authorizations from.
                           If None, defaults to all resources.
      :type resource_ids: Optional[List[str]]

      :raises GRPCError: If an invalid resource ID is passed.

      :returns: The list of authorizations.
      :rtype: List[viam.proto.app.Authorization]



   .. py:method:: check_permissions(permissions: List[viam.proto.app.AuthorizedPermissions]) -> List[viam.proto.app.AuthorizedPermissions]
      :async:


      Checks validity of a list of permissions.

      ::

          from viam.proto.app import AuthorizedPermissions

          # Check whether the entity you're currently authenticated to has permission to control and/or
          # read logs from robots in the "organization-identifier123" org
          permissions = [AuthorizedPermissions(resource_type="organization",
                                               resource_id="organization-identifier123",
                                               permissions=["control_robot",
                                                            "read_robot_logs"])]

          filtered_permissions = await cloud.check_permissions(permissions)

      :param permissions: the permissions to validate
                          (for example, "read_organization", "control_robot")
      :type permissions: List[viam.proto.app.AuthorizedPermissions]

      :raises GRPCError: If the list of permissions to validate is empty.

      :returns: The permissions argument, with invalid permissions filtered out.
      :rtype: List[viam.proto.app.AuthorizedPermissions]



   .. py:method:: get_registry_item(item_id: str) -> viam.proto.app.RegistryItem
      :async:


      Get registry item by ID.

      ::

          item = await cloud.get_registry_item("item-id")

      :param item_id: The ID of the registry item.
      :type item_id: str

      :returns: The registry item.
      :rtype: RegistryItem



   .. py:method:: create_registry_item(organization_id: str, name: str, type: viam.proto.app.packages.PackageType.ValueType) -> None
      :async:


      Create a registry item

      ::

          await cloud.create_registry_item("org-id", "name", PackageType.PACKAGE_TYPE_ML_MODEL)

      :param organization_id: The organization to create the registry item under.
      :type organization_id: str
      :param name: The name of the registry item, which must be unique within your org.
      :type name: str
      :param type: The type of the item in the registry.
      :type type: PackageType.ValueType



   .. py:method:: update_registry_item(item_id: str, type: viam.proto.app.packages.PackageType.ValueType, description: str, visibility: viam.proto.app.Visibility.ValueType) -> None
      :async:


      Update a registry item.

      ::

          await cloud.update_registry_item("item-id", PackageType.PACKAGE_TYPE_ML_TRAINING, "description", Visibility.VISIBILITY_PUBLIC)

      :param item_id: The ID of the registry item.
      :type item_id: str
      :param type: The type of the item in the registry.
      :type type: PackageType.ValueType
      :param description: The description of the registry item.
      :type description: str
      :param visibility: The visibility of the registry item.
      :type visibility: Visibility.ValueType



   .. py:method:: list_registry_items(organization_id: str, types: List[viam.proto.app.packages.PackageType.ValueType], visibilities: List[viam.proto.app.Visibility.ValueType], platforms: List[str], statuses: List[viam.proto.app.RegistryItemStatus.ValueType], search_term: Optional[str] = None, page_token: Optional[str] = None) -> List[viam.proto.app.RegistryItem]
      :async:


      List the registry items in an organization.

      :param organization_id: The ID of the organization to return registry items for.
      :type organization_id: str
      :param types: The types of registry items.
      :type types: List[PackageType.ValueType]
      :param visibilities: The visibilities of registry items.
      :type visibilities: List[Visibility.ValueType]
      :param platforms: The platforms of registry items.
      :type platforms: List[str]
      :param statuses: The types of the items in the registry.
      :type statuses: List[RegistryItemStatus.ValueType]
      :param search_term: The search term of the registry items.
      :type search_term: Optional[str]
      :param page_token: The page token of the registry items.
      :type page_token: Optional[str]

      :returns: The list of registry items.
      :rtype: List[RegistryItem]



   .. py:method:: delete_registry_item(item_id: str) -> None
      :async:


      Delete a registry item

      ::

          await cloud.delete_registry_item("item-id")

      :param item_id: The ID of the registry item.
      :type item_id: str



   .. py:method:: create_module(org_id: str, name: str) -> Tuple[str, str]
      :async:


      Create a module under the currently authed-to organization.

      ::

          new_module = await cloud.create_module(org_id="org-id", name="cool_new_hoverboard_module")
          print("Module ID:", new_module[0])

      :param org_id: The ID of the organization to create the module under.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param name: The name of the module. Must be unique within your organization.
      :type name: str

      :raises GRPCError: If an invalid name (for example, "") is passed.

      :returns: A tuple containing the ID [0] of the new module and its URL [1].
      :rtype: Tuple[str, str]



   .. py:method:: update_module(module_id: str, url: str, description: str, models: Optional[List[viam.proto.app.Model]], entrypoint: str, public: bool = False) -> str
      :async:


      Update the documentation URL, description, models, entrypoint, and/or the visibility of a module.

      ::

          url_of_my_module = await cloud.update_module(
              module_id="my-group:cool_new_hoverboard_module",
              url="https://docsformymodule.viam.com",
              description="A base to support hoverboards.",
              entrypoint="exec")

      :param module_id: ID of the module being updated, containing module name (for example, "my-module") or namespace and module name
                        (for example, "my-org:my-module").
      :type module_id: str
      :param url: The url to reference for documentation and code (NOT the url of the module itself).
      :type url: str
      :param description: A short description of the module that explains its purpose.
      :type description: str
      :param models: list of models that are available in the module.
      :type models: Optional[List[viam.proto.app.Model]]
      :param entrypoint: The executable to run to start the module program.
      :type entrypoint: str
      :param public: The visibility that should be set for the module. Defaults to False (private).
      :type public: bool

      :raises GRPCError: If either an invalid module ID, URL, list of models, or organization ID is passed.

      :returns: The URL of the newly updated module.
      :rtype: str



   .. py:method:: upload_module_file(module_file_info: Optional[viam.proto.app.ModuleFileInfo], file: bytes) -> str
      :async:


      Upload a module file

      ::

          file_id = await cloud.upload_module_file(file=b"<file>")

      :param module_file_info: Relevant metadata.
      :type module_file_info: Optional[viam.proto.app.ModuleFileInfo]
      :param file: Bytes of file to upload.
      :type file: bytes

      :returns: ID of uploaded file.
      :rtype: str



   .. py:method:: get_module(module_id: str) -> viam.proto.app.Module
      :async:


      Get a module.

      ::

          the_module = await cloud.get_module(module_id="my-cool-modular-base")

      :param module_id: ID of the module being retrieved, containing module name or namespace and module name.
      :type module_id: str

      :raises GRPCError: If an invalid module ID is passed.

      :returns: The module.
      :rtype: viam.proto.app.Module



   .. py:method:: list_modules(org_id: str) -> List[viam.proto.app.Module]
      :async:


      List the modules under the currently authed-to organization.

      ::

          modules_list = await cloud.list_modules("org-id")

      :param org_id: The ID of the organization to list modules for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str

      :returns: The list of modules.
      :rtype: List[viam.proto.app.Module]



   .. py:method:: create_key(org_id: str, authorizations: List[APIKeyAuthorization], name: Optional[str] = None) -> Tuple[str, str]
      :async:


      Creates a new API key.

      ::

          from viam.app.app_client import APIKeyAuthorization

          auth = APIKeyAuthorization(
          role="owner",
          resource_type="robot",
          resource_id="your-robot-id123"
          )

          api_key, api_key_id = cloud.create_key([auth], "my_key")

      :param org_id: The ID of the organization to create the key for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param authorizations: A list of authorizations to associate
                             with the key.
      :type authorizations: List[viam.proto.app.Authorization]
      :param name: A name for the key. If None, defaults to the current timestamp.
      :type name: Optional[str]

      :raises GRPCError: If the authorizations list is empty.

      :returns: The api key and api key ID.
      :rtype: Tuple[str, str]



   .. py:method:: delete_key(id: str) -> None
      :async:


      Delete a API key.

      ::

          await cloud.delete_key("key-id")

      :param id: The ID of the API key.
      :type id: str



   .. py:method:: create_key_from_existing_key_authorizations(id: str) -> Tuple[str, str]
      :async:


      Creates a new API key with an existing key's authorizations

      ::

          api_key, api_key_id = await cloud.create_key_from_existing_key_authorizations(
              id="INSERT YOUR API KEY ID")

      :param id: the ID of the API key to duplication authorizations from
      :type id: str

      :returns: The API key and API key id
      :rtype: Tuple[str, str]



   .. py:method:: list_keys(org_id: str) -> List[viam.proto.app.APIKeyWithAuthorizations]
      :async:


      Lists all keys for the currently-authed-to org.

      ::

          keys = await cloud.list_keys()

      :param org_id: The ID of the organization to list API keys for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str

      :returns: The existing API keys and authorizations.
      :rtype: List[viam.proto.app.APIKeyWithAuthorizations]



   .. py:method:: rotate_key(id: str) -> Tuple[str, str]
      :async:


      Rotate an API key.

      ::

          id, key = await cloud.rotate_key("key-id")

      :param id: The ID of the key to be rotated.
      :type id: str

      :returns: The API key and API key id
      :rtype: Tuple[str, str]



.. py:class:: BillingClient(channel: grpclib.client.Channel, metadata: Mapping[str, str])

   gRPC client for retrieving billing data from app.

   Constructor is used by `ViamClient` to instantiate relevant service stubs. Calls to
   `BillingClient` methods should be made through `ViamClient`.

   Establish a Connection::

       import asyncio

       from viam.rpc.dial import DialOptions, Credentials
       from viam.app.viam_client import ViamClient


       async def connect() -> ViamClient:
           # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
           dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
           return await ViamClient.create_from_dial_options(dial_options)


       async def main():
           # Make a ViamClient
           viam_client = await connect()
           # Instantiate a BillingClient to run billing client API methods on
           billing_client = viam_client.billing_client

           viam_client.close()

       if __name__ == '__main__':
           asyncio.run(main())



   .. py:method:: get_current_month_usage(org_id: str, timeout: Optional[float] = None) -> viam.proto.app.billing.GetCurrentMonthUsageResponse
      :async:


      Access data usage information for the current month for a given organization.

      ::

         usage = await viam_client.billing_client.get_current_month_usage("<ORG-ID>")

      :param org_id: the ID of the organization to request usage data for
      :type org_id: str

      :returns: Current month usage information
      :rtype: viam.proto.app.billing.GetCurrentMonthUsageResponse



   .. py:method:: get_invoice_pdf(invoice_id: str, org_id: str, dest: str, timeout: Optional[float] = None) -> None
      :async:


      Access invoice PDF data and optionally save it to a provided file path.

      ::

          await viam_client.billing_client.get_invoice_pdf("<INVOICE-ID>", "<ORG-ID>", "<FILENAME>")

      :param invoice_id: the ID of the invoice being requested
      :type invoice_id: str
      :param org_id: the ID of the org to request data from
      :type org_id: str
      :param dest: filepath to save the invoice to
      :type dest: str



   .. py:method:: get_invoices_summary(org_id: str, timeout: Optional[float] = None) -> viam.proto.app.billing.GetInvoicesSummaryResponse
      :async:


      Access total outstanding balance plus invoice summaries for a given org.

      ::

          summary = await viam_client.billing_client.get_invoices_summary("<ORG-ID>")

      :param org_id: the ID of the org to request data for
      :type org_id: str

      :returns: Summary of org invoices
      :rtype: viam.proto.app.billing.GetInvoicesSummaryResponse



   .. py:method:: get_org_billing_information(org_id: str, timeout: Optional[float] = None) -> viam.proto.app.billing.GetOrgBillingInformationResponse
      :async:


      Access billing information (payment method, billing tier, etc.) for a given org.

      ::

          information = await viam_client.billing_client.get_org_billing_information("<ORG-ID>")

      :param org_id: the ID of the org to request data for
      :type org_id: str

      :returns: The org billing information
      :rtype: viam.proto.app.billing.GetOrgBillingInformationResponse



.. py:class:: DataClient(channel: grpclib.client.Channel, metadata: Mapping[str, str])

   gRPC client for uploading and retrieving data from app.

   Constructor is used by `ViamClient` to instantiate relevant service stubs. Calls to `DataClient` methods should be made through
   `ViamClient`.

   Establish a Connection::

       import asyncio

       from viam.rpc.dial import DialOptions, Credentials
       from viam.app.viam_client import ViamClient


       async def connect() -> ViamClient:
           # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
           dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
           return await ViamClient.create_from_dial_options(dial_options)


       async def main():
           # Make a ViamClient
           viam_client = await connect()
           # Instantiate a DataClient to run data client API methods on
           data_client = viam_client.data_client

           viam_client.close()

       if __name__ == '__main__':
           asyncio.run(main())



   .. py:class:: TabularData

      Class representing a piece of tabular data and associated metadata.


      .. py:attribute:: data
         :type:  Mapping[str, Any]

         The requested data


      .. py:attribute:: metadata
         :type:  viam.proto.app.data.CaptureMetadata

         The metadata associated with the data


      .. py:attribute:: time_requested
         :type:  datetime.datetime

         The time the data were requested


      .. py:attribute:: time_received
         :type:  datetime.datetime

         The time the data were received


      .. py:method:: __str__() -> str

         Return str(self).



      .. py:method:: __eq__(other: object) -> bool

         Return self==value.




   .. py:method:: tabular_data_by_filter(filter: Optional[viam.proto.app.data.Filter] = None, limit: Optional[int] = None, sort_order: Optional[viam.proto.app.data.Order.ValueType] = None, last: Optional[str] = None, count_only: bool = False, include_internal_data: bool = False, dest: Optional[str] = None) -> Tuple[List[TabularData], int, str]
      :async:


      Filter and download tabular data. The data will be paginated into pages of `limit` items, and the pagination ID will be included
      in the returned tuple. If a destination is provided, the data will be saved to that file.
      If the file is not empty, it will be overwritten.

      ::

          from viam.utils import create_filter

          my_data = []
          last = None
          my_filter = create_filter(component_name="left_motor")
          while True:
              tabular_data, count, last = await data_client.tabular_data_by_filter(my_filter, last)
              if not tabular_data:
                  break
              my_data.extend(tabular_data)


      :param filter: Optional `Filter` specifying tabular data to retrieve. No `Filter` implies all tabular
                     data.
      :type filter: viam.proto.app.data.Filter
      :param limit: The maximum number of entries to include in a page. Defaults to 50 if unspecified.
      :type limit: int
      :param sort_order: The desired sort order of the data.
      :type sort_order: viam.proto.app.data.Order
      :param last: Optional string indicating the ID of the last-returned data.
                   If provided, the server will return the next data entries after the `last` ID.
      :type last: str
      :param count_only: Whether to return only the total count of entries.
      :type count_only: bool
      :param include_internal_data: Whether to return the internal data. Internal data is used for Viam-specific data ingestion,
                                    like cloud SLAM. Defaults to `False`
      :type include_internal_data: bool
      :param dest: Optional filepath for writing retrieved data.
      :type dest: str

      :returns: A tuple containing the following:
                List[TabularData]: The tabular data,
                int: The count (number of entries),
                str: The last-returned page ID.
      :rtype: Tuple[List[TabularData], int, str]



   .. py:method:: tabular_data_by_sql(organization_id: str, sql_query: str) -> List[Dict[str, viam.utils.ValueTypes]]
      :async:


      Obtain unified tabular data and metadata, queried with SQL.

      ::

          data = await data_client.tabular_data_by_sql(org_id="<your-org-id>", sql_query="SELECT * FROM readings LIMIT 5")


      :param organization_id: The ID of the organization that owns the data.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str
      :param sql_query: The SQL query to run.
      :type sql_query: str

      :returns: An array of data objects.
      :rtype: List[Dict[str, ValueTypes]]



   .. py:method:: tabular_data_by_mql(organization_id: str, mql_binary: List[bytes]) -> List[Dict[str, viam.utils.ValueTypes]]
      :async:


      Obtain unified tabular data and metadata, queried with MQL.

      ::

          # using bson
          import bson
          tabular_data = await data_client.tabular_data_by_mql(org_id="<your-org-id>", mql_binary=[
              bson.dumps({ '$match': { 'location_id': '<location-id>' } }),
              bson.dumps({ "$limit": 5 })
          ])

          # using pymongo
          import bson
          tabular_data = await data_client.tabular_data_by_mql(org_id="<your-org-id>", mql_binary=[
              bson.encode({ '$match': { 'location_id': '<location-id>' } }),
              bson.encode({ "$limit": 5 })
          ])


      :param organization_id: The ID of the organization that owns the data.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str
      :param mql_binary: The MQL query to run as a list of BSON queries. You can encode your bson queries using a library like
                         `pymongo` or `bson`.
      :type mql_binary: List[bytes]

      :returns: An array of data objects.
      :rtype: List[Dict[str, ValueTypes]]



   .. py:method:: binary_data_by_filter(filter: Optional[viam.proto.app.data.Filter] = None, limit: Optional[int] = None, sort_order: Optional[viam.proto.app.data.Order.ValueType] = None, last: Optional[str] = None, include_binary_data: bool = True, count_only: bool = False, include_internal_data: bool = False, dest: Optional[str] = None) -> Tuple[List[viam.proto.app.data.BinaryData], int, str]
      :async:


      Filter and download binary data. The data will be paginated into pages of `limit` items, and the pagination ID will be included
      in the returned tuple. If a destination is provided, the data will be saved to that file.
      If the file is not empty, it will be overwritten.

      ::

          from viam.utils import create_filter


          my_data = []
          last = None
          my_filter = create_filter(component_name="camera")
          while True:
              data, count, last = await data_client.binary_data_by_filter(my_filter, last)
              if not data:
                  break
              my_data.extend(data)

      :param filter: Optional `Filter` specifying tabular data to retrieve. No `Filter` implies all binary
                     data.
      :type filter: viam.proto.app.data.Filter
      :param limit: The maximum number of entries to include in a page. Defaults to 50 if unspecified.
      :type limit: int
      :param sort_order: The desired sort order of the data.
      :type sort_order: viam.proto.app.data.Order
      :param last: Optional string indicating the ID of the last-returned data.
                   If provided, the server will return the next data entries after the `last` ID.
      :type last: str
      :param include_binary_data: Boolean specifying whether to actually include the binary file data with each retrieved file.
                                  Defaults to true (that is, both the files' data and metadata are returned).
      :type include_binary_data: bool
      :param count_only: Whether to return only the total count of entries.
      :type count_only: bool
      :param include_internal_data: Whether to return the internal data. Internal data is used for Viam-specific data ingestion,
                                    like cloud SLAM. Defaults to `False`
      :type include_internal_data: bool
      :param dest: Optional filepath for writing retrieved data.
      :type dest: str

      :returns: A tuple containing the following:
                List[viam.proto.app.data.BinaryData]: The binary data,
                int: The count (number of entries),
                str: The last-returned page ID.
      :rtype: Tuple[List[viam.proto.app.data.BinaryData], int, str]



   .. py:method:: binary_data_by_ids(binary_ids: List[viam.proto.app.data.BinaryID], dest: Optional[str] = None) -> List[viam.proto.app.data.BinaryData]
      :async:


      Filter and download binary data.

      ::

          from viam.proto.app.data import BinaryID

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_ids = []

          for obj in binary_metadata:
              my_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                  )
              )

          binary_data = await data_client.binary_data_by_ids(my_ids)

      :param binary_ids: `BinaryID` objects specifying the desired data. Must be non-empty.
      :type binary_ids: List[viam.proto.app.data.BinaryID]
      :param dest: Optional filepath for writing retrieved data.
      :type dest: str

      :raises GRPCError: If no `BinaryID` objects are provided.

      :returns: The binary data.
      :rtype: List[viam.proto.app.data.BinaryData]



   .. py:method:: delete_tabular_data(organization_id: str, delete_older_than_days: int) -> int
      :async:


      Delete tabular data older than a specified number of days.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="left_motor")
          days_of_data_to_delete = 10
          tabular_data = await data_client.delete_tabular_data(
              org_id="a12b3c4e-1234-1abc-ab1c-ab1c2d345abc", days_of_data_to_delete)

      :param organization_id: ID of organization to delete data from.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str
      :param delete_older_than_days: Delete data that was captured up to this many days ago. For example if `delete_older_than_days`
                                     is 10, this deletes any data that was captured up to 10 days ago. If it is 0, all existing data is deleted.
      :type delete_older_than_days: int

      :returns: The number of items deleted.
      :rtype: int



   .. py:method:: delete_tabular_data_by_filter(filter: Optional[viam.proto.app.data.Filter]) -> int
      :abstractmethod:

      :async:


      Deprecated: use delete_tabular_data instead.



   .. py:method:: delete_binary_data_by_filter(filter: Optional[viam.proto.app.data.Filter]) -> int
      :async:


      Filter and delete binary data.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="left_motor")
          res = await data_client.delete_binary_data_by_filter(my_filter)

      :param filter: Optional `Filter` specifying binary data to delete. Passing an empty `Filter` will lead to
                     all data being deleted. Exercise caution when using this option.
      :type filter: viam.proto.app.data.Filter

      :returns: The number of items deleted.
      :rtype: int



   .. py:method:: delete_binary_data_by_ids(binary_ids: List[viam.proto.app.data.BinaryID]) -> int
      :async:


      Filter and delete binary data.

      ::

          from viam.proto.app.data import BinaryID

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_ids = []

          for obj in binary_metadata:
              my_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                  )
              )

          binary_data = await data_client.delete_binary_data_by_ids(my_ids)

      :param binary_ids: `BinaryID` objects specifying the data to be deleted. Must be non-empty.
      :type binary_ids: List[viam.proto.app.data.BinaryID]

      :raises GRPCError: If no `BinaryID` objects are provided.

      :returns: The number of items deleted.
      :rtype: int



   .. py:method:: add_tags_to_binary_data_by_ids(tags: List[str], binary_ids: List[viam.proto.app.data.BinaryID]) -> None
      :async:


      Add tags to binary data.

      ::

          from viam.proto.app.data import BinaryID

          tags = ["tag1", "tag2"]

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_ids = []

          for obj in binary_metadata:
              my_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                  )
              )

          binary_data = await data_client.add_tags_to_binary_data_by_ids(tags, my_ids)

      :param tags: List of tags to add to specified binary data. Must be non-empty.
      :type tags: List[str]
      :param binary_ids: List of `BinaryID` objects specifying binary data to tag. Must be non-empty.
      :type binary_ids: List[viam.app.proto.BinaryID]

      :raises GRPCError: If no `BinaryID` objects or tags are provided.



   .. py:method:: add_tags_to_binary_data_by_filter(tags: List[str], filter: Optional[viam.proto.app.data.Filter] = None) -> None
      :async:


      Add tags to binary data.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="my_camera")
          tags = ["tag1", "tag2"]
          res = await data_client.add_tags_to_binary_data_by_filter(tags, my_filter)

      :param tags: List of tags to add to specified binary data. Must be non-empty.
      :type tags: List[str]
      :param filter: `Filter` specifying binary data to tag. If no `Filter` is provided, all data will be
                     tagged.
      :type filter: viam.proto.app.data.Filter

      :raises GRPCError: If no tags are provided.



   .. py:method:: remove_tags_from_binary_data_by_ids(tags: List[str], binary_ids: List[viam.proto.app.data.BinaryID]) -> int
      :async:


      Remove tags from binary data by IDs.

      ::

          from viam.proto.app.data import BinaryID

          tags = ["tag1", "tag2"]

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_ids = []

          for obj in binary_metadata:
              my_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                  )
              )

          binary_data = await data_client.remove_tags_from_binary_data_by_ids(
              tags, my_ids)

      :param tags: List of tags to remove from specified binary data. Must be non-empty.
      :type tags: List[str]
      :param binary_ids: List of `BinaryID` objects specifying binary data to untag. Must be non-empty.
      :type binary_ids: List[BinaryID]

      :raises GRPCError: If no binary_ids or tags are provided.

      :returns: The number of tags removed.
      :rtype: int



   .. py:method:: remove_tags_from_binary_data_by_filter(tags: List[str], filter: Optional[viam.proto.app.data.Filter] = None) -> int
      :async:


      Remove tags from binary data.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="my_camera")
          tags = ["tag1", "tag2"]
          res = await data_client.remove_tags_from_binary_data_by_filter(tags, my_filter)

      :param tags: List of tags to remove from specified binary data.
      :type tags: List[str]
      :param filter: `Filter` specifying binary data to untag. If no `Filter` is provided, all data will be
                     untagged.
      :type filter: viam.proto.app.data.Filter

      :raises GRPCError: If no tags are provided.

      :returns: The number of tags removed.
      :rtype: int



   .. py:method:: tags_by_filter(filter: Optional[viam.proto.app.data.Filter] = None) -> List[str]
      :async:


      Get a list of tags using a filter.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="my_camera")
          tags = await data_client.tags_by_filter(my_filter)

      :param filter: `Filter` specifying data to retrieve from. If no `Filter` is provided, all data tags will
                     return.
      :type filter: viam.proto.app.data.Filter

      :returns: The list of tags.
      :rtype: List[str]



   .. py:method:: add_bounding_box_to_image_by_id(binary_id: viam.proto.app.data.BinaryID, label: str, x_min_normalized: float, y_min_normalized: float, x_max_normalized: float, y_max_normalized: float) -> str
      :async:


      Add a bounding box to an image.

      ::

          from viam.proto.app.data import BinaryID

          MY_BINARY_ID = BinaryID(
              file_id=your-file_id,
              organization_id=your-org-id,
              location_id=your-location-id
          )

          bbox_label = await data_client.add_bounding_box_to_image_by_id(
              binary_id=MY_BINARY_ID,
              label="label",
              x_min_normalized=0,
              y_min_normalized=.1,
              x_max_normalized=.2,
              y_max_normalized=.3
          )

          print(bbox_label)

      :param binary_id: The ID of the image to add the bounding box to.
      :type binary_id: viam.proto.app.data.BinaryID
      :param label: A label for the bounding box.
      :type label: str
      :param x_min_normalized: Min X value of the bounding box normalized from 0 to 1.
      :type x_min_normalized: float
      :param y_min_normalized: Min Y value of the bounding box normalized from 0 to 1.
      :type y_min_normalized: float
      :param x_max_normalized: Max X value of the bounding box normalized from 0 to 1.
      :type x_max_normalized: float
      :param y_max_normalized: Max Y value of the bounding box normalized from 0 to 1.
      :type y_max_normalized: float

      :raises GRPCError: If the X or Y values are outside of the [0, 1] range.

      :returns: The bounding box ID.
      :rtype: str



   .. py:method:: remove_bounding_box_from_image_by_id(bbox_id: str, binary_id: viam.proto.app.data.BinaryID) -> None
      :async:


      Removes a bounding box from an image.

      ::

          from viam.proto.app.data import BinaryID

          MY_BINARY_ID = BinaryID(
              file_id=your-file_id,
              organization_id=your-org-id,
              location_id=your-location-id
          )

          await data_client.remove_bounding_box_from_image_by_id(
          binary_id=MY_BINARY_ID,
          bbox_id="your-bounding-box-id-to-delete"
          )

      :param bbox_id: The ID of the bounding box to remove.
      :type bbox_id: str
      :param binary_id: Binary ID of the image to to remove the bounding box from.
      :type binary_id: viam.proto.arr.data.BinaryID



   .. py:method:: bounding_box_labels_by_filter(filter: Optional[viam.proto.app.data.Filter] = None) -> List[str]
      :async:


      Get a list of bounding box labels using a `Filter`.

      ::

          from viam.utils import create_filter

          my_filter = create_filter(component_name="my_camera")
          bounding_box_labels = await data_client.bounding_box_labels_by_filter(
              my_filter)

      :param filter: `Filter` specifying data to retrieve from. If no `Filter` is provided, all labels will
                     return.
      :type filter: viam.proto.app.data.Filter

      :returns: The list of bounding box labels.
      :rtype: List[str]



   .. py:method:: get_database_connection(organization_id: str) -> str
      :async:


      Get a connection to access a MongoDB Atlas Data federation instance.

      ::

          data_client.get_database_connection(org_id="a12b3c4e-1234-1abc-ab1c-ab1c2d345abc")

      :param organization_id: Organization to retrieve the connection for.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str

      :returns: The hostname of the federated database.
      :rtype: str



   .. py:method:: configure_database_user(organization_id: str, password: str) -> None
      :async:


      Configure a database user for the Viam organization's MongoDB Atlas Data Federation instance. It can also be used to reset the
      password of the existing database user.

      ::

          await data_client.configure_database_user(
              organization_id="<your-org-id>",
              password="your_password"
          )

      :param organization_id: The ID of the organization.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str
      :param password: The password of the user.
      :type password: str



   .. py:method:: create_dataset(name: str, organization_id: str) -> str
      :async:


      Create a new dataset.

      ::

          name = await data_client.create_dataset(
              name="<dataset-name>",
              organization_id="<your-org-id>"
          )
          print(name)

      :param name: The name of the dataset being created.
      :type name: str
      :param organization_id: The ID of the organization where the dataset is being created.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str

      :returns: The dataset ID of the created dataset.
      :rtype: str



   .. py:method:: list_dataset_by_ids(ids: List[str]) -> Sequence[viam.proto.app.dataset.Dataset]
      :async:


      Get a list of datasets using their IDs.

      ::

          datasets = await data_client.list_dataset_by_ids(
              ids=["abcd-1234xyz-8765z-123abc"]
          )
          print(datasets)

      :param ids: The IDs of the datasets being called for. To retrieve these IDs,
                  navigate to your dataset's page in the Viam app,
                  click **...** in the left-hand menu, and click **Copy dataset ID**.
      :type ids: List[str]

      :returns: The list of datasets.
      :rtype: Sequence[Dataset]



   .. py:method:: list_datasets_by_organization_id(organization_id: str) -> Sequence[viam.proto.app.dataset.Dataset]
      :async:


      Get the datasets in an organization.

      ::

          datasets = await data_client.list_dataset_by_organization_id(
              organization_id=[""a12b3c4e-1234-1abc-ab1c-ab1c2d345abc""]
          )
          print(datasets)

      :param organization_id: The ID of the organization.
                              You can obtain your organization ID from the Viam app's organization settings page.
      :type organization_id: str

      :returns: The list of datasets in the organization.
      :rtype: Sequence[Dataset]



   .. py:method:: rename_dataset(id: str, name: str) -> None
      :async:


      Rename a dataset specified by the dataset ID.

      ::

          await data_client.rename_dataset(
              id="abcd-1234xyz-8765z-123abc",
              name="<dataset-name>"
          )

      :param id: The ID of the dataset.
      :type id: str
      :param name: The new name of the dataset.
      :type name: str



   .. py:method:: delete_dataset(id: str) -> None
      :async:


      Delete a dataset.

      ::

          await data_client.delete_dataset(
              id="abcd-1234xyz-8765z-123abc"
          )

      :param id: The ID of the dataset.
      :type id: str



   .. py:method:: add_binary_data_to_dataset_by_ids(binary_ids: List[viam.proto.app.data.BinaryID], dataset_id: str) -> None
      :async:


      Add the BinaryData to the provided dataset.

      This BinaryData will be tagged with the VIAM_DATASET_{id} label.

      ::

          from viam.proto.app.data import BinaryID

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_binary_ids = []

          for obj in binary_metadata:
              my_binary_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                      )
                  )

          await data_client.add_binary_data_to_dataset_by_ids(
              binary_ids=my_binary_ids,
              dataset_id="abcd-1234xyz-8765z-123abc"
          )

      :param binary_ids: The IDs of binary data to add to dataset. To retrieve these IDs,
                         navigate to your dataset's page in the Viam app,
                         click **...** in the left-hand menu, and click **Copy dataset ID**.
      :type binary_ids: List[BinaryID]
      :param dataset_id: The ID of the dataset to be added to.
      :type dataset_id: str



   .. py:method:: remove_binary_data_from_dataset_by_ids(binary_ids: List[viam.proto.app.data.BinaryID], dataset_id: str) -> None
      :async:


      Remove the BinaryData from the provided dataset.

      This BinaryData will lose the VIAM_DATASET_{id} tag.

      ::

          from viam.proto.app.data import BinaryID

          binary_metadata = await data_client.binary_data_by_filter(
              include_file_data=False
          )

          my_binary_ids = []

          for obj in binary_metadata:
              my_binary_ids.append(
                  BinaryID(
                      file_id=obj.metadata.id,
                      organization_id=obj.metadata.capture_metadata.organization_id,
                      location_id=obj.metadata.capture_metadata.location_id
                  )
              )

          await data_client.remove_binary_data_from_dataset_by_ids(
              binary_ids=my_binary_ids,
              dataset_id="abcd-1234xyz-8765z-123abc"
          )

      :param binary_ids: The IDs of binary data to remove from dataset. To retrieve these IDs,
                         navigate to your dataset's page in the Viam app,
                         click **...** in the left-hand menu, and click **Copy dataset ID**.
      :type binary_ids: List[BinaryID]
      :param dataset_id: The ID of the dataset to be removed from.
      :type dataset_id: str



   .. py:method:: binary_data_capture_upload(binary_data: bytes, part_id: str, component_type: str, component_name: str, method_name: str, file_extension: str, method_parameters: Optional[Mapping[str, Any]] = None, tags: Optional[List[str]] = None, data_request_times: Optional[Tuple[datetime.datetime, datetime.datetime]] = None) -> str
      :async:


      Upload binary sensor data.

      Upload binary data collected on a robot through a specific component (for example, a motor) along with the relevant metadata to
      app.viam.com. Binary data can be found under the "Files" subtab of the Data tab on app.viam.com.

      ::

          time_requested = datetime(2023, 6, 5, 11)
          time_received = datetime(2023, 6, 5, 11, 0, 3)

          file_id = await data_client.binary_data_capture_upload(
              part_id="INSERT YOUR PART ID",
              component_type='camera',
              component_name='my_camera',
              method_name='GetImages',
              method_parameters=None,
              tags=["tag_1", "tag_2"],
              data_request_times=[time_requested, time_received],
              file_extension=".jpg",
              binary_data=b"Encoded image bytes"
          )

      :param binary_data: The data to be uploaded, represented in bytes.
      :type binary_data: bytes
      :param part_id: Part ID of the component used to capture the data.
      :type part_id: str
      :param component_type: Type of the component used to capture the data (for example, "movement_sensor").
      :type component_type: str
      :param component_name: Name of the component used to capture the data.
      :type component_name: str
      :param method_name: Name of the method used to capture the data.
      :type method_name: str
      :param file_extension: The file extension of binary data including the period, for example .jpg, .png, .pcd.
                             The backend will route the binary to its corresponding mime type based on this extension. Files with a .jpeg, .jpg,
                             or .png extension will be saved to the images tab.
      :type file_extension: str
      :param method_parameters: Optional dictionary of method parameters. No longer in active use.
      :type method_parameters: Optional[Mapping[str, Any]]
      :param tags: Optional list of tags to allow for tag-based data filtering when retrieving data.
      :type tags: Optional[List[str]]
      :param data_request_times: Optional tuple containing datetime objects
                                 denoting the times this data was requested[0] by the robot and received[1] from the appropriate sensor.
      :type data_request_times: Optional[Tuple[datetime.datetime, datetime.datetime]]

      :raises GRPCError: If an invalid part ID is passed.

      :returns: The file_id of the uploaded data.
      :rtype: str



   .. py:method:: tabular_data_capture_upload(tabular_data: List[Mapping[str, Any]], part_id: str, component_type: str, component_name: str, method_name: str, method_parameters: Optional[Mapping[str, Any]] = None, tags: Optional[List[str]] = None, data_request_times: Optional[List[Tuple[datetime.datetime, datetime.datetime]]] = None) -> str
      :async:


      Upload tabular sensor data.

      Upload tabular data collected on a robot through a specific component (for example, a motor) along with the relevant metadata to
      app.viam.com. Tabular data can be found under the "Sensors" subtab of the Data tab on app.viam.com.

      ::

          time_requested = datetime(2023, 6, 5, 11)
          time_received = datetime(2023, 6, 5, 11, 0, 3)

          file_id = await data_client.tabular_data_capture_upload(
              part_id="INSERT YOUR PART ID",
              component_type='motor',
              component_name='left_motor',
              method_name='IsPowered',
              tags=["tag_1", "tag_2"],
              data_request_times=[(time_requested, time_received)],
              tabular_data=[{'PowerPCT': 0, 'IsPowered': False}]
          )

      :param tabular_data: List of the data to be uploaded, represented tabularly as a collection of dictionaries.
      :type tabular_data: List[Mapping[str, Any]]
      :param part_id: Part ID of the component used to capture the data.
      :type part_id: str
      :param component_type: Type of the component used to capture the data (for example, "movement_sensor").
      :type component_type: str
      :param component_name: Name of the component used to capture the data.
      :type component_name: str
      :param method_name: Name of the method used to capture the data.
      :type method_name: str
      :param method_parameters: Optional dictionary of method parameters. No longer in active use.
      :type method_parameters: Optional[Mapping[str, Any]]
      :param tags: Optional list of tags to allow for tag-based data filtering when retrieving data.
      :type tags: Optional[List[str]]
      :param data_request_times: Optional list of tuples, each containing
                                 `datetime` objects denoting the times this data was requested[0] by the robot and received[1] from the appropriate sensor.
                                 Passing a list of tabular data and Timestamps with length n > 1 will result in n datapoints being uploaded, all tied to the
                                 same metadata.
      :type data_request_times: Optional[List[Tuple[datetime.datetime, datetime.datetime]]]

      :raises GRPCError: If an invalid part ID is passed.
      :raises ValueError: If a list of `Timestamp` objects is provided and its length does not match the length of the list of tabular
          data.

      :returns: The file_id of the uploaded data.
      :rtype: str



   .. py:method:: streaming_data_capture_upload(data: bytes, part_id: str, file_ext: str, component_type: Optional[str] = None, component_name: Optional[str] = None, method_name: Optional[str] = None, method_parameters: Optional[Mapping[str, Any]] = None, data_request_times: Optional[Tuple[datetime.datetime, datetime.datetime]] = None, tags: Optional[List[str]] = None) -> str
      :async:


      Uploads the metadata and contents of streaming binary data.

      ::

          time_requested = datetime(2023, 6, 5, 11)
          time_received = datetime(2023, 6, 5, 11, 0, 3)

          file_id = await data_client.streaming_data_capture_upload(
              data="byte-data-to-upload",
              part_id="INSERT YOUR PART ID",
              file_ext="png",
              component_type='motor',
              component_name='left_motor',
              method_name='IsPowered',
              data_request_times=[(time_requested, time_received)],
              tags=["tag_1", "tag_2"]
          )

      :param data: the data to be uploaded.
      :type data: bytes
      :param part_id: Part ID of the resource associated with the file.
      :type part_id: str
      :param file_ext: file extension type for the data. required for determining MIME type.
      :type file_ext: str
      :param component_type: Optional type of the component associated with the file (for example, "movement_sensor").
      :type component_type: Optional[str]
      :param component_name: Optional name of the component associated with the file.
      :type component_name: Optional[str]
      :param method_name: Optional name of the method associated with the file.
      :type method_name: Optional[str]
      :param method_parameters: Optional dictionary of the method parameters. No longer in active use.
      :type method_parameters: Optional[str]
      :param data_request_times: Optional tuple containing datetime objects
                                 denoting the times this data was requested[0] by the robot and received[1] from the appropriate sensor.
      :type data_request_times: Optional[Tuple[datetime.datetime, datetime.datetime]]
      :param tags: Optional list of tags to allow for tag-based filtering when retrieving data.
      :type tags: Optional[List[str]]

      :raises GRPCError: If an invalid part ID is passed.

      :returns: The file_id of the uploaded data.
      :rtype: str



   .. py:method:: file_upload(part_id: str, data: bytes, component_type: Optional[str] = None, component_name: Optional[str] = None, method_name: Optional[str] = None, file_name: Optional[str] = None, method_parameters: Optional[Mapping[str, Any]] = None, file_extension: Optional[str] = None, tags: Optional[List[str]] = None) -> str
      :async:


      Upload arbitrary file data.

      Upload file data that may be stored on a robot along with the relevant metadata to app.viam.com. File data can be found under the
      "Files" subtab of the Data tab on app.viam.com.

      ::

          file_id = await data_client.file_upload(
              data=b"Encoded image bytes",
              part_id="INSERT YOUR PART ID",
              tags=["tag_1", "tag_2"],
              file_name="your-file",
              file_extension=".txt"
          )

      :param part_id: Part ID of the resource associated with the file.
      :type part_id: str
      :param data: Bytes representing file data to upload.
      :type data: bytes
      :param component_type: Optional type of the component associated with the file (for example, "movement_sensor").
      :type component_type: Optional[str]
      :param component_name: Optional name of the component associated with the file.
      :type component_name: Optional[str]
      :param method_name: Optional name of the method associated with the file.
      :type method_name: Optional[str]
      :param file_name: Optional name of the file. The empty string "" will be assigned as the file name if one isn't
                        provided.
      :type file_name: Optional[str]
      :param method_parameters: Optional dictionary of the method parameters. No longer in active use.
      :type method_parameters: Optional[str]
      :param file_extension: Optional file extension. The empty string "" will be assigned as the file extension if one isn't
                             provided. Files with a .jpeg, .jpg, or .png extension will be saved to the images tab.
      :type file_extension: Optional[str]
      :param tags: Optional list of tags to allow for tag-based filtering when retrieving data.
      :type tags: Optional[List[str]]

      :raises GRPCError: If an invalid part ID is passed.

      :returns: ID of the new file.
      :rtype: str



   .. py:method:: file_upload_from_path(filepath: str, part_id: str, component_type: Optional[str] = None, component_name: Optional[str] = None, method_name: Optional[str] = None, method_parameters: Optional[Mapping[str, Any]] = None, tags: Optional[List[str]] = None) -> str
      :async:


      Upload arbitrary file data.

      Upload file data that may be stored on a robot along with the relevant metadata to app.viam.com. File data can be found under the
      "Files" subtab of the Data tab on app.viam.com.

      ::

          file_id = await data_client.file_upload_from_path(
              part_id="INSERT YOUR PART ID",
              tags=["tag_1", "tag_2"],
              filepath="/Users/<your-username>/<your-directory>/<your-file.txt>"
          )

      :param filepath: Absolute filepath of file to be uploaded.
      :type filepath: str
      :param part_id: Part ID of the component associated with the file.
      :type part_id: str
      :param component_type: Optional type of the component associated with the file (for example, "movement_sensor").
      :type component_type: Optional[str]
      :param component_name: Optional name of the component associated with the file.
      :type component_name: Optional[str]
      :param method_name: Optional name of the method associated with the file.
      :type method_name: Optional[str]
      :param method_parameters: Optional dictionary of the method parameters. No longer in active use.
      :type method_parameters: Optional[str]
      :param tags: Optional list of tags to allow for tag-based filtering when retrieving data.
      :type tags: Optional[List[str]]

      :raises GRPCError: If an invalid part ID is passed.
      :raises FileNotFoundError: If the provided filepath is not found.

      :returns: ID of the new file.
      :rtype: str



   .. py:method:: create_filter(component_name: Optional[str] = None, component_type: Optional[str] = None, method: Optional[str] = None, robot_name: Optional[str] = None, robot_id: Optional[str] = None, part_name: Optional[str] = None, part_id: Optional[str] = None, location_ids: Optional[List[str]] = None, organization_ids: Optional[List[str]] = None, mime_type: Optional[List[str]] = None, start_time: Optional[datetime.datetime] = None, end_time: Optional[datetime.datetime] = None, tags: Optional[List[str]] = None, bbox_labels: Optional[List[str]] = None, dataset_id: Optional[str] = None) -> viam.proto.app.data.Filter
      :staticmethod:



.. py:class:: MLTrainingClient(channel: grpclib.client.Channel, metadata: Mapping[str, str])

   gRPC client for working with ML training jobs.

   Constructor is used by `ViamClient` to instantiate relevant service stubs.
   Calls to `MLTrainingClient` methods should be made through `ViamClient`.

   Establish a Connection::

       import asyncio

       from viam.rpc.dial import DialOptions, Credentials
       from viam.app.viam_client import ViamClient


       async def connect() -> ViamClient:
           # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
           dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
           return await ViamClient.create_from_dial_options(dial_options)


       async def main():

           # Make a ViamClient
           viam_client = await connect()
           # Instantiate an MLTrainingClient to run ML training client API methods on
           ml_training_client = viam_client.ml_training_client

           viam_client.close()

       if __name__ == '__main__':
           asyncio.run(main())


   .. py:method:: submit_training_job(org_id: str, dataset_id: str, model_name: str, model_version: str, model_type: viam.proto.app.mltraining.ModelType.ValueType, tags: List[str]) -> str
      :async:


      Submit a training job.

      :param org_id: the id of the org to submit the training job to
      :type org_id: str
      :param dataset_id: the id of the dataset
      :type dataset_id: str
      :param model_name: the model name
      :type model_name: str
      :param model_version: the model version
      :type model_version: str
      :param model_type: the model type
      :type model_type: ModelType.ValueType
      :param tags: the tags
      :type tags: List[str]

      :returns: the id of the training job
      :rtype: str



   .. py:method:: submit_custom_training_job(org_id: str, dataset_id: str, registry_item_id: str, model_name: str, model_version: str) -> str
      :async:


      Submit a custom training job.

      :param org_id: the id of the org to submit the training job to
      :type org_id: str
      :param dataset_id: the id of the dataset
      :type dataset_id: str
      :param registry_item_id: the id of the registry item
      :type registry_item_id: List[str]
      :param model_name: the model name
      :type model_name: str
      :param model_version: the model version
      :type model_version: str

      :returns: the id of the training job
      :rtype: str



   .. py:method:: get_training_job(id: str) -> viam.proto.app.mltraining.TrainingJobMetadata
      :async:


      Gets training job data.

      ::

          job_metadata = await ml_training_client.get_training_job(
              id="INSERT YOUR JOB ID")

      :param id: the id of the requested training job.
      :type id: str

      :returns: training job data.
      :rtype: viam.proto.app.mltraining.TrainingJobMetadata



   .. py:method:: list_training_jobs(org_id: str, training_status: Optional[viam.proto.app.mltraining.TrainingStatus.ValueType] = None) -> List[viam.proto.app.mltraining.TrainingJobMetadata]
      :async:


      Returns training job data for all jobs within an org.

      ::

          jobs_metadata = await ml_training_client.list_training_jobs(
              org_id="INSERT YOUR ORG ID")

          first_job_id = jobs_metadata[1].id

      :param org_id: the id of the org to request training job data from.
      :type org_id: str
      :param training_status: status of training jobs to filter the list by.
                              If unspecified, all training jobs will be returned.
      :type training_status: Optional[TrainingStatus]

      :returns: a list of training job data.
      :rtype: List[viam.proto.app.mltraining.TrainingJobMetadata]



   .. py:method:: cancel_training_job(id: str) -> None
      :async:


      Cancels the specified training job.

      ::

          await ml_training_client.cancel_training_job(
              id="INSERT YOUR JOB ID")

      :param id: the id of the job to be canceled.
      :type id: str

      :raises GRPCError: if no training job exists with the given id.



   .. py:method:: delete_completed_training_job(id: str) -> None
      :async:


      Delete a completed training job from the database, whether the job succeeded or failed
      :param id: the id of the training job
      :type id: str



.. py:class:: ProvisioningClient(channel: grpclib.client.Channel, metadata: Mapping[str, str])

   gRPC client for getting and setting smart machine info.

   Constructor is used by `ViamClient` to instantiate relevant service stubs. Calls to
   `ProvisioningClient` methods should be made through `ViamClient`.

   Establish a connection::

       import asyncio

       from viam.rpc.dial import DialOptions, Credentials
       from viam.app.viam_client import ViamClient


       async def connect() -> ViamClient:
           # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
           dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
           return await ViamClient.create_from_dial_options(dial_options)


       async def main():

           # Make a ViamClient
           viam_client = await connect()
           # Instantiate a ProvisioningClient to run provisioning client API methods on
           provisioning_client = viam_client.provisioning_client

           viam_client.close()

       if __name__ == '__main__':
           asyncio.run(main())



   .. py:method:: get_network_list() -> List[viam.proto.provisioning.NetworkInfo]
      :async:


      Returns list of networks that are visible to the Smart Machine.



   .. py:method:: get_smart_machine_status() -> viam.proto.provisioning.GetSmartMachineStatusResponse
      :async:


      Returns the status of the smart machine.



   .. py:method:: set_network_credentials(network_type: str, ssid: str, psk: str) -> None
      :async:


      Sets the network credentials of the Smart Machine.

      :param network_type: The type of the network.
      :type network_type: str
      :param ssid: The SSID of the network.
      :type ssid: str
      :param psk: The network's passkey.
      :type psk: str



   .. py:method:: set_smart_machine_credentials(cloud_config: Optional[viam.proto.provisioning.CloudConfig] = None) -> None
      :async:



.. py:class:: DialOptions(*, disable_webrtc: bool = False, auth_entity: Optional[str] = None, credentials: Optional[Credentials] = None, insecure: bool = False, allow_insecure_downgrade: bool = False, allow_insecure_with_creds_downgrade: bool = False, max_reconnect_attempts: int = 3, timeout: float = 20)

   .. py:attribute:: disable_webrtc
      :type:  bool

      Bypass Web RTC and connect directly to the robot.


   .. py:attribute:: auth_entity
      :type:  Optional[str]

      The URL to authenticate against. Should be used if the address passed in and FQDN of the server do not match.


   .. py:attribute:: credentials
      :type:  Optional[Credentials]

      Credentials for connecting to the robot


   .. py:attribute:: insecure
      :type:  bool
      :value: False


      Determine if the RPC connection is TLS based. Must be provided to
      establish an insecure connection. Otherwise, a TLS based connection
      will be assumed.


   .. py:attribute:: allow_insecure_downgrade
      :type:  bool
      :value: False


      Allow the RPC connection to be downgraded to an insecure connection
      if detected. This is only used when credentials are not present.


   .. py:attribute:: allow_insecure_with_creds_downgrade
      :type:  bool
      :value: False


      Allow the RPC connection to be downgraded to an insecure connection
      if detected, even with credentials present. This is generally
      unsafe to use, but can be requested.


   .. py:attribute:: max_reconnect_attempts
      :type:  int
      :value: 3


      Max number of times the client attempts to reconnect when connection is lost


   .. py:attribute:: timeout
      :type:  float
      :value: 20


      Number of seconds before the dial connection times out
      Set to 20sec to match _defaultOfferDeadline in goutils/rpc/wrtc_call_queue.go


   .. py:method:: with_api_key(api_key: str, api_key_id: str) -> typing_extensions.Self
      :classmethod:


      Create DialOptions with an API key for credentials and default values for other arguments.

      :param api_key: your API key
      :type api_key: str
      :param api_key_id: your API key ID. Must be a valid UUID
      :type api_key_id: str

      :raises ValueError: Raised if the api_key_id is not a valid UUID

      :returns: the DialOptions
      :rtype: Self



.. py:data:: LOGGER

.. py:class:: ViamClient

   gRPC client for all communication and interaction with app.

   `ViamClient` class for creating and managing specialized client instances.
   There is currently 1 way to instantiate a `ViamClient` object::

       ViamClient.create_from_dial_options(...)


   .. py:method:: create_from_dial_options(dial_options: viam.rpc.dial.DialOptions, app_url: Optional[str] = None) -> typing_extensions.Self
      :classmethod:

      :async:


      Create `ViamClient` that establishes a connection to the Viam app.

      ::

          dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
          ViamClient.create_from_dial_options(dial_options)

      :param dial_options: Required information for authorization and connection to app.
                           `creds` and `auth_entity` fields are required.
      :type dial_options: viam.rpc.dial.DialOptions
      :param app_url: (Optional[str]): URL of app. Uses app.viam.com if not specified.

      :raises ValueError: If the input parameters are missing a required field or simply invalid.

      :returns: The `ViamClient`.
      :rtype: Self



   .. py:property:: data_client
      :type: viam.app.data_client.DataClient

      Instantiate and return a `DataClient` object used to make `data` and `data_sync` method calls.
      To use the `DataClient`, you must first instantiate a `ViamClient`.

      ::

          async def connect() -> ViamClient:
              # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
              dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
              return await ViamClient.create_from_dial_options(dial_options)

          async def main():
              viam_client = await connect()

              # Instantiate a DataClient to run data client API methods on
              data_client = viam_client.data_client


   .. py:property:: app_client
      :type: viam.app.app_client.AppClient

      Instantiate and return an `AppClient` used to make  `app` method calls.
      To use the `AppClient`, you must first instantiate a `ViamClient`.

      ::

          async def connect() -> ViamClient:
              # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
              dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
              return await ViamClient.create_from_dial_options(dial_options)


          async def main():
              viam_client = await connect()

              # Instantiate an AppClient called "fleet" to run fleet management API methods on
              fleet = viam_client.app_client


   .. py:property:: ml_training_client
      :type: viam.app.ml_training_client.MLTrainingClient

      Instantiate and return a `MLTrainingClient` used to make `ml_training` method calls.
      To use the `MLTrainingClient`, you must first instantiate a `ViamClient`.

      ::

          async def connect() -> ViamClient:
              # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
              dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
              return await ViamClient.create_from_dial_options(dial_options)


          async def main():
              viam_client = await connect()

              # Instantiate an MLTrainingClient to run ML training client API methods on
              ml_training_client = viam_client.ml_training_client


   .. py:property:: billing_client
      :type: viam.app.billing_client.BillingClient

      



      Instantiate and return a `BillingClient` used to make `billing` method calls.
          To use the `BillingClient`, you must first instantiate a `ViamClient`.

      ::

          async def connect() -> ViamClient:
              # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
              dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
              return await ViamClient.create_from_dial_options(dial_options)


          async def main():
              viam_client = await connect()

              # Instantiate a BillingClient to run billing client API methods on
              billing_client = viam_client.billing_client


   .. py:property:: provisioning_client
      :type: viam.app.provisioning_client.ProvisioningClient

      Instantiate and return a `ProvisioningClient` used to make  `provisioning` method calls.
      To use the `ProvisioningClient`, you must first instantiate a `ViamClient`.

      ::

          async def connect() -> ViamClient:
              # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
              dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
              return await ViamClient.create_from_dial_options(dial_options)


          async def main():
              viam_client = await connect()

              # Instantiate a ProvisioningClient to run provisioning API methods on
              provisioning_client = viam_client.provisioning_client


   .. py:method:: close()

      Close opened channels used for the various service stubs initialized.



