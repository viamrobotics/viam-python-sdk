viam.app.ml_training_client
===========================

.. py:module:: viam.app.ml_training_client


Attributes
----------

.. autoapisummary::

   viam.app.ml_training_client.LOGGER


Classes
-------

.. autoapisummary::

   viam.app.ml_training_client.CancelTrainingJobRequest
   viam.app.ml_training_client.DeleteCompletedTrainingJobRequest
   viam.app.ml_training_client.GetTrainingJobRequest
   viam.app.ml_training_client.GetTrainingJobResponse
   viam.app.ml_training_client.ListTrainingJobsRequest
   viam.app.ml_training_client.ListTrainingJobsResponse
   viam.app.ml_training_client.MLTrainingServiceStub
   viam.app.ml_training_client.ModelType
   viam.app.ml_training_client.SubmitCustomTrainingJobRequest
   viam.app.ml_training_client.SubmitCustomTrainingJobResponse
   viam.app.ml_training_client.SubmitTrainingJobRequest
   viam.app.ml_training_client.SubmitTrainingJobResponse
   viam.app.ml_training_client.TrainingJobMetadata
   viam.app.ml_training_client.TrainingStatus
   viam.app.ml_training_client.MLTrainingClient


Module Contents
---------------

.. py:class:: CancelTrainingJobRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: DeleteCompletedTrainingJobRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: GetTrainingJobRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: GetTrainingJobResponse(*, metadata: global___TrainingJobMetadata | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: metadata
      :type: global___TrainingJobMetadata



   .. py:method:: HasField(field_name: Literal['metadata', b'metadata']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ListTrainingJobsRequest(*, organization_id: str = ..., status: global___TrainingStatus = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: status
      :type:  global___TrainingStatus


.. py:class:: ListTrainingJobsResponse(*, jobs: collections.abc.Iterable[global___TrainingJobMetadata] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: jobs
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TrainingJobMetadata]



.. py:class:: MLTrainingServiceStub(channel: grpclib.client.Channel)

.. py:class:: ModelType

   Bases: :py:obj:`_ModelType`


.. py:class:: SubmitCustomTrainingJobRequest(*, dataset_id: str = ..., registry_item_id: str = ..., registry_item_version: str = ..., organization_id: str = ..., model_name: str = ..., model_version: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: dataset_id
      :type:  str


   .. py:attribute:: registry_item_id
      :type:  str


   .. py:attribute:: registry_item_version
      :type:  str


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: model_name
      :type:  str


   .. py:attribute:: model_version
      :type:  str


.. py:class:: SubmitCustomTrainingJobResponse(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: SubmitTrainingJobRequest(*, dataset_id: str = ..., organization_id: str = ..., model_name: str = ..., model_version: str = ..., model_type: global___ModelType = ..., tags: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: dataset_id
      :type:  str


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: model_name
      :type:  str


   .. py:attribute:: model_version
      :type:  str


   .. py:attribute:: model_type
      :type:  global___ModelType


   .. py:property:: tags
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



.. py:class:: SubmitTrainingJobResponse(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: TrainingJobMetadata(*, request: global___SubmitTrainingJobRequest | None = ..., id: str = ..., dataset_id: str = ..., organization_id: str = ..., model_name: str = ..., model_version: str = ..., model_type: global___ModelType = ..., model_framework: global___ModelFramework = ..., is_custom_job: bool = ..., registry_item_id: str = ..., registry_item_version: str = ..., status: global___TrainingStatus = ..., error_status: google.rpc.status_pb2.Status | None = ..., created_on: google.protobuf.timestamp_pb2.Timestamp | None = ..., last_modified: google.protobuf.timestamp_pb2.Timestamp | None = ..., training_started: google.protobuf.timestamp_pb2.Timestamp | None = ..., training_ended: google.protobuf.timestamp_pb2.Timestamp | None = ..., synced_model_id: str = ..., tags: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: dataset_id
      :type:  str


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: model_name
      :type:  str


   .. py:attribute:: model_version
      :type:  str


   .. py:attribute:: model_type
      :type:  global___ModelType


   .. py:attribute:: model_framework
      :type:  global___ModelFramework


   .. py:attribute:: is_custom_job
      :type:  bool


   .. py:attribute:: registry_item_id
      :type:  str


   .. py:attribute:: registry_item_version
      :type:  str


   .. py:attribute:: status
      :type:  global___TrainingStatus


   .. py:attribute:: synced_model_id
      :type:  str


   .. py:property:: request
      :type: global___SubmitTrainingJobRequest



   .. py:property:: error_status
      :type: google.rpc.status_pb2.Status



   .. py:property:: created_on
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: last_modified
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: training_started
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: training_ended
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: tags
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:method:: HasField(field_name: Literal['created_on', b'created_on', 'error_status', b'error_status', 'last_modified', b'last_modified', 'request', b'request', 'training_ended', b'training_ended', 'training_started', b'training_started']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: TrainingStatus

   Bases: :py:obj:`_TrainingStatus`


.. py:data:: LOGGER

.. py:class:: MLTrainingClient(channel: grpclib.client.Channel, metadata: Mapping[str, str])

   gRPC client for working with ML training jobs.

   Constructor is used by `ViamClient` to instantiate relevant service stubs.
   Calls to `MLTrainingClient` methods should be made through `ViamClient`.

   Establish a Connection::

       import asyncio

       from viam.rpc.dial import DialOptions, Credentials
       from viam.app.viam_client import ViamClient


       async def connect() -> ViamClient:
           # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
           dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
           return await ViamClient.create_from_dial_options(dial_options)


       async def main():

           # Make a ViamClient
           viam_client = await connect()
           # Instantiate an MLTrainingClient to run ML training client API methods on
           ml_training_client = viam_client.ml_training_client

           viam_client.close()

       if __name__ == '__main__':
           asyncio.run(main())


   .. py:method:: submit_training_job(org_id: str, dataset_id: str, model_name: str, model_version: str, model_type: viam.proto.app.mltraining.ModelType.ValueType, tags: List[str]) -> str
      :async:


      Submit a training job.

      :param org_id: the id of the org to submit the training job to
      :type org_id: str
      :param dataset_id: the id of the dataset
      :type dataset_id: str
      :param model_name: the model name
      :type model_name: str
      :param model_version: the model version
      :type model_version: str
      :param model_type: the model type
      :type model_type: ModelType.ValueType
      :param tags: the tags
      :type tags: List[str]

      :returns: the id of the training job
      :rtype: str



   .. py:method:: submit_custom_training_job(org_id: str, dataset_id: str, registry_item_id: str, model_name: str, model_version: str) -> str
      :async:


      Submit a custom training job.

      :param org_id: the id of the org to submit the training job to
      :type org_id: str
      :param dataset_id: the id of the dataset
      :type dataset_id: str
      :param registry_item_id: the id of the registry item
      :type registry_item_id: List[str]
      :param model_name: the model name
      :type model_name: str
      :param model_version: the model version
      :type model_version: str

      :returns: the id of the training job
      :rtype: str



   .. py:method:: get_training_job(id: str) -> viam.proto.app.mltraining.TrainingJobMetadata
      :async:


      Gets training job data.

      ::

          job_metadata = await ml_training_client.get_training_job(
              id="INSERT YOUR JOB ID")

      :param id: the id of the requested training job.
      :type id: str

      :returns: training job data.
      :rtype: viam.proto.app.mltraining.TrainingJobMetadata



   .. py:method:: list_training_jobs(org_id: str, training_status: Optional[viam.proto.app.mltraining.TrainingStatus.ValueType] = None) -> List[viam.proto.app.mltraining.TrainingJobMetadata]
      :async:


      Returns training job data for all jobs within an org.

      ::

          jobs_metadata = await ml_training_client.list_training_jobs(
              org_id="INSERT YOUR ORG ID")

          first_job_id = jobs_metadata[1].id

      :param org_id: the id of the org to request training job data from.
      :type org_id: str
      :param training_status: status of training jobs to filter the list by.
                              If unspecified, all training jobs will be returned.
      :type training_status: Optional[TrainingStatus]

      :returns: a list of training job data.
      :rtype: List[viam.proto.app.mltraining.TrainingJobMetadata]



   .. py:method:: cancel_training_job(id: str) -> None
      :async:


      Cancels the specified training job.

      ::

          await ml_training_client.cancel_training_job(
              id="INSERT YOUR JOB ID")

      :param id: the id of the job to be canceled.
      :type id: str

      :raises GRPCError: if no training job exists with the given id.



   .. py:method:: delete_completed_training_job(id: str) -> None
      :async:


      Delete a completed training job from the database, whether the job succeeded or failed
      :param id: the id of the training job
      :type id: str



