viam.app.app_client
===================

.. py:module:: viam.app.app_client


Attributes
----------

.. autoapisummary::

   viam.app.app_client.LOGGER


Classes
-------

.. autoapisummary::

   viam.app.app_client.AddRoleRequest
   viam.app.app_client.APIKeyWithAuthorizations
   viam.app.app_client.AppServiceStub
   viam.app.app_client.Authorization
   viam.app.app_client.AuthorizedPermissions
   viam.app.app_client.ChangeRoleRequest
   viam.app.app_client.CheckPermissionsRequest
   viam.app.app_client.CheckPermissionsResponse
   viam.app.app_client.CreateFragmentRequest
   viam.app.app_client.CreateFragmentResponse
   viam.app.app_client.CreateKeyFromExistingKeyAuthorizationsRequest
   viam.app.app_client.CreateKeyFromExistingKeyAuthorizationsResponse
   viam.app.app_client.CreateKeyRequest
   viam.app.app_client.CreateKeyResponse
   viam.app.app_client.CreateLocationRequest
   viam.app.app_client.CreateLocationResponse
   viam.app.app_client.CreateLocationSecretRequest
   viam.app.app_client.CreateLocationSecretResponse
   viam.app.app_client.CreateModuleRequest
   viam.app.app_client.CreateModuleResponse
   viam.app.app_client.CreateOrganizationInviteRequest
   viam.app.app_client.CreateOrganizationInviteResponse
   viam.app.app_client.CreateOrganizationRequest
   viam.app.app_client.CreateOrganizationResponse
   viam.app.app_client.CreateRegistryItemRequest
   viam.app.app_client.CreateRobotPartSecretRequest
   viam.app.app_client.CreateRobotPartSecretResponse
   viam.app.app_client.DeleteFragmentRequest
   viam.app.app_client.DeleteKeyRequest
   viam.app.app_client.DeleteLocationRequest
   viam.app.app_client.DeleteLocationSecretRequest
   viam.app.app_client.DeleteOrganizationInviteRequest
   viam.app.app_client.DeleteOrganizationMemberRequest
   viam.app.app_client.DeleteOrganizationRequest
   viam.app.app_client.DeleteRegistryItemRequest
   viam.app.app_client.DeleteRobotPartRequest
   viam.app.app_client.DeleteRobotPartSecretRequest
   viam.app.app_client.DeleteRobotRequest
   viam.app.app_client.FragmentPB
   viam.app.app_client.GetFragmentRequest
   viam.app.app_client.GetFragmentResponse
   viam.app.app_client.GetLocationRequest
   viam.app.app_client.GetLocationResponse
   viam.app.app_client.GetModuleRequest
   viam.app.app_client.GetModuleResponse
   viam.app.app_client.GetOrganizationNamespaceAvailabilityRequest
   viam.app.app_client.GetOrganizationNamespaceAvailabilityResponse
   viam.app.app_client.GetOrganizationRequest
   viam.app.app_client.GetOrganizationResponse
   viam.app.app_client.GetOrganizationsWithAccessToLocationRequest
   viam.app.app_client.GetOrganizationsWithAccessToLocationResponse
   viam.app.app_client.GetRegistryItemRequest
   viam.app.app_client.GetRegistryItemResponse
   viam.app.app_client.GetRobotAPIKeysRequest
   viam.app.app_client.GetRobotAPIKeysResponse
   viam.app.app_client.GetRobotPartHistoryRequest
   viam.app.app_client.GetRobotPartHistoryResponse
   viam.app.app_client.GetRobotPartLogsRequest
   viam.app.app_client.GetRobotPartLogsResponse
   viam.app.app_client.GetRobotPartRequest
   viam.app.app_client.GetRobotPartResponse
   viam.app.app_client.GetRobotPartsRequest
   viam.app.app_client.GetRobotPartsResponse
   viam.app.app_client.GetRobotRequest
   viam.app.app_client.GetRobotResponse
   viam.app.app_client.GetRoverRentalRobotsRequest
   viam.app.app_client.GetRoverRentalRobotsResponse
   viam.app.app_client.GetUserIDByEmailRequest
   viam.app.app_client.GetUserIDByEmailResponse
   viam.app.app_client.ListAuthorizationsRequest
   viam.app.app_client.ListAuthorizationsResponse
   viam.app.app_client.ListFragmentsRequest
   viam.app.app_client.ListFragmentsResponse
   viam.app.app_client.ListKeysRequest
   viam.app.app_client.ListKeysResponse
   viam.app.app_client.ListLocationsRequest
   viam.app.app_client.ListLocationsResponse
   viam.app.app_client.ListModulesRequest
   viam.app.app_client.ListModulesResponse
   viam.app.app_client.ListOrganizationMembersRequest
   viam.app.app_client.ListOrganizationMembersResponse
   viam.app.app_client.ListOrganizationsByUserRequest
   viam.app.app_client.ListOrganizationsByUserResponse
   viam.app.app_client.ListOrganizationsRequest
   viam.app.app_client.ListOrganizationsResponse
   viam.app.app_client.ListRegistryItemsRequest
   viam.app.app_client.ListRegistryItemsResponse
   viam.app.app_client.ListRobotsRequest
   viam.app.app_client.ListRobotsResponse
   viam.app.app_client.Location
   viam.app.app_client.LocationAuth
   viam.app.app_client.LocationAuthRequest
   viam.app.app_client.LocationAuthResponse
   viam.app.app_client.MarkPartAsMainRequest
   viam.app.app_client.MarkPartForRestartRequest
   viam.app.app_client.Model
   viam.app.app_client.Module
   viam.app.app_client.ModuleFileInfo
   viam.app.app_client.NewRobotPartRequest
   viam.app.app_client.NewRobotPartResponse
   viam.app.app_client.NewRobotRequest
   viam.app.app_client.NewRobotResponse
   viam.app.app_client.Organization
   viam.app.app_client.OrganizationIdentity
   viam.app.app_client.OrganizationInvite
   viam.app.app_client.OrganizationMember
   viam.app.app_client.OrgDetails
   viam.app.app_client.RegistryItem
   viam.app.app_client.RegistryItemStatus
   viam.app.app_client.RemoveRoleRequest
   viam.app.app_client.ResendOrganizationInviteRequest
   viam.app.app_client.ResendOrganizationInviteResponse
   viam.app.app_client.Robot
   viam.app.app_client.RobotPartPB
   viam.app.app_client.RobotPartHistoryEntryPB
   viam.app.app_client.RotateKeyRequest
   viam.app.app_client.RotateKeyResponse
   viam.app.app_client.RoverRentalRobot
   viam.app.app_client.SharedSecret
   viam.app.app_client.ShareLocationRequest
   viam.app.app_client.TailRobotPartLogsRequest
   viam.app.app_client.TailRobotPartLogsResponse
   viam.app.app_client.UnshareLocationRequest
   viam.app.app_client.UpdateFragmentRequest
   viam.app.app_client.UpdateFragmentResponse
   viam.app.app_client.UpdateLocationRequest
   viam.app.app_client.UpdateLocationResponse
   viam.app.app_client.UpdateModuleRequest
   viam.app.app_client.UpdateModuleResponse
   viam.app.app_client.UpdateOrganizationInviteAuthorizationsRequest
   viam.app.app_client.UpdateOrganizationInviteAuthorizationsResponse
   viam.app.app_client.UpdateOrganizationRequest
   viam.app.app_client.UpdateOrganizationResponse
   viam.app.app_client.UpdateRegistryItemRequest
   viam.app.app_client.UpdateRobotPartRequest
   viam.app.app_client.UpdateRobotPartResponse
   viam.app.app_client.UpdateRobotRequest
   viam.app.app_client.UpdateRobotResponse
   viam.app.app_client.UploadModuleFileRequest
   viam.app.app_client.Visibility
   viam.app.app_client.PackageType
   viam.app.app_client.LogEntryPB
   viam.app.app_client.RobotPart
   viam.app.app_client.LogEntry
   viam.app.app_client.Fragment
   viam.app.app_client.RobotPartHistoryEntry
   viam.app.app_client.APIKeyAuthorization
   viam.app.app_client.AppClient


Functions
---------

.. autoapisummary::

   viam.app.app_client.datetime_to_timestamp
   viam.app.app_client.dict_to_struct
   viam.app.app_client.struct_to_dict


Module Contents
---------------

.. py:class:: AddRoleRequest(*, authorization: global___Authorization | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: authorization
      :type: global___Authorization



   .. py:method:: HasField(field_name: Literal['authorization', b'authorization']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: APIKeyWithAuthorizations(*, api_key: global___APIKey | None = ..., authorizations: collections.abc.Iterable[global___AuthorizationDetails] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: api_key
      :type: global___APIKey



   .. py:property:: authorizations
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AuthorizationDetails]



   .. py:method:: HasField(field_name: Literal['api_key', b'api_key']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: AppServiceStub(channel: grpclib.client.Channel)

.. py:class:: Authorization(*, authorization_type: str = ..., authorization_id: str = ..., resource_type: str = ..., resource_id: str = ..., identity_id: str = ..., organization_id: str = ..., identity_type: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: authorization_type
      :type:  str


   .. py:attribute:: authorization_id
      :type:  str


   .. py:attribute:: resource_type
      :type:  str


   .. py:attribute:: resource_id
      :type:  str


   .. py:attribute:: identity_id
      :type:  str


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: identity_type
      :type:  str


.. py:class:: AuthorizedPermissions(*, resource_type: str = ..., resource_id: str = ..., permissions: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: resource_type
      :type:  str


   .. py:attribute:: resource_id
      :type:  str


   .. py:property:: permissions
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



.. py:class:: ChangeRoleRequest(*, old_authorization: global___Authorization | None = ..., new_authorization: global___Authorization | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: old_authorization
      :type: global___Authorization



   .. py:property:: new_authorization
      :type: global___Authorization



   .. py:method:: HasField(field_name: Literal['new_authorization', b'new_authorization', 'old_authorization', b'old_authorization']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: CheckPermissionsRequest(*, permissions: collections.abc.Iterable[global___AuthorizedPermissions] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: permissions
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AuthorizedPermissions]



.. py:class:: CheckPermissionsResponse(*, authorized_permissions: collections.abc.Iterable[global___AuthorizedPermissions] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: authorized_permissions
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AuthorizedPermissions]



.. py:class:: CreateFragmentRequest(*, name: str = ..., config: google.protobuf.struct_pb2.Struct | None = ..., organization_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: organization_id
      :type:  str


   .. py:property:: config
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['config', b'config']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: CreateFragmentResponse(*, fragment: global___Fragment | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: fragment
      :type: global___Fragment



   .. py:method:: HasField(field_name: Literal['fragment', b'fragment']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: CreateKeyFromExistingKeyAuthorizationsRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: CreateKeyFromExistingKeyAuthorizationsResponse(*, id: str = ..., key: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: key
      :type:  str


.. py:class:: CreateKeyRequest(*, authorizations: collections.abc.Iterable[global___Authorization] | None = ..., name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:property:: authorizations
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Authorization]



.. py:class:: CreateKeyResponse(*, key: str = ..., id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: key
      :type:  str


   .. py:attribute:: id
      :type:  str


.. py:class:: CreateLocationRequest(*, organization_id: str = ..., name: str = ..., parent_location_id: str | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str

      Organization ID to create the location under.


   .. py:attribute:: name
      :type:  str

      Name of the location.


   .. py:attribute:: parent_location_id
      :type:  str

      The new parent location to move the location under.


   .. py:method:: HasField(field_name: Literal['_parent_location_id', b'_parent_location_id', 'parent_location_id', b'parent_location_id']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_parent_location_id', b'_parent_location_id']) -> Literal['parent_location_id'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: CreateLocationResponse(*, location: global___Location | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: location
      :type: global___Location

      Location object is returned.


   .. py:method:: HasField(field_name: Literal['location', b'location']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: CreateLocationSecretRequest(*, location_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: location_id
      :type:  str

      Location ID to create the secret in.


.. py:class:: CreateLocationSecretResponse(*, auth: global___LocationAuth | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: auth
      :type: global___LocationAuth

      Location's auth after updates.


   .. py:method:: HasField(field_name: Literal['auth', b'auth']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: CreateModuleRequest(*, organization_id: str = ..., name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Modules


   .. py:attribute:: organization_id
      :type:  str

      The organization to create the module under


   .. py:attribute:: name
      :type:  str

      The name of the module, which must be unique within your org


.. py:class:: CreateModuleResponse(*, module_id: str = ..., url: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: module_id
      :type:  str

      name where prefix is the module owner's orgid or namespace)

      :type: The id of the module (formatted as prefix


   .. py:attribute:: url
      :type:  str

      The detail page of the module


.. py:class:: CreateOrganizationInviteRequest(*, organization_id: str = ..., email: str = ..., authorizations: collections.abc.Iterable[global___Authorization] | None = ..., send_email_invite: bool | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: email
      :type:  str


   .. py:attribute:: send_email_invite
      :type:  bool

      Set to true (the default) to send an email to the recipient of an invite. The user must accept the email to be added to the associated authorizations.
      When set to false, the user automatically receives the associated authorization on the next login of the user with the associated email address.


   .. py:property:: authorizations
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Authorization]



   .. py:method:: HasField(field_name: Literal['_send_email_invite', b'_send_email_invite', 'send_email_invite', b'send_email_invite']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_send_email_invite', b'_send_email_invite']) -> Literal['send_email_invite'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: CreateOrganizationInviteResponse(*, invite: global___OrganizationInvite | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: invite
      :type: global___OrganizationInvite



   .. py:method:: HasField(field_name: Literal['invite', b'invite']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: CreateOrganizationRequest(*, name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


.. py:class:: CreateOrganizationResponse(*, organization: global___Organization | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: organization
      :type: global___Organization



   .. py:method:: HasField(field_name: Literal['organization', b'organization']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: CreateRegistryItemRequest(*, organization_id: str = ..., name: str = ..., type: viam.gen.app.packages.v1.packages_pb2.PackageType.ValueType = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str

      The organization to create the registry item under


   .. py:attribute:: name
      :type:  str

      The name of the registry item, which must be unique within your org


   .. py:attribute:: type
      :type:  viam.gen.app.packages.v1.packages_pb2.PackageType.ValueType

      The type of the item in the registry


.. py:class:: CreateRobotPartSecretRequest(*, part_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: part_id
      :type:  str

      Robot Part ID to create the secret in.


.. py:class:: CreateRobotPartSecretResponse(*, part: global___RobotPart | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: part
      :type: global___RobotPart

      Location's auth after updates.


   .. py:method:: HasField(field_name: Literal['part', b'part']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DeleteFragmentRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: DeleteKeyRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: DeleteLocationRequest(*, location_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: location_id
      :type:  str

      Location ID of location to delete.


.. py:class:: DeleteLocationSecretRequest(*, location_id: str = ..., secret_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: location_id
      :type:  str


   .. py:attribute:: secret_id
      :type:  str


.. py:class:: DeleteOrganizationInviteRequest(*, organization_id: str = ..., email: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: email
      :type:  str


.. py:class:: DeleteOrganizationMemberRequest(*, organization_id: str = ..., user_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: user_id
      :type:  str


.. py:class:: DeleteOrganizationRequest(*, organization_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


.. py:class:: DeleteRegistryItemRequest(*, item_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: item_id
      :type:  str

      name where prefix is the owner's orgid or namespace)

      :type: The id of the item (formatted as prefix


.. py:class:: DeleteRobotPartRequest(*, part_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: part_id
      :type:  str


.. py:class:: DeleteRobotPartSecretRequest(*, part_id: str = ..., secret_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: part_id
      :type:  str


   .. py:attribute:: secret_id
      :type:  str


.. py:class:: DeleteRobotRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: FragmentPB(*, id: str = ..., name: str = ..., fragment: google.protobuf.struct_pb2.Struct | None = ..., organization_owner: str = ..., public: bool = ..., created_on: google.protobuf.timestamp_pb2.Timestamp | None = ..., organization_name: str = ..., robot_part_count: int = ..., organization_count: int = ..., only_used_by_owner: bool = ..., visibility: global___FragmentVisibility = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: organization_owner
      :type:  str


   .. py:attribute:: public
      :type:  bool


   .. py:attribute:: organization_name
      :type:  str


   .. py:attribute:: robot_part_count
      :type:  int

      number of robot parts using this fragment


   .. py:attribute:: organization_count
      :type:  int

      number of organizations using this fragment


   .. py:attribute:: only_used_by_owner
      :type:  bool

      whether the organization(s) using this fragment is the same as the fragment org


   .. py:attribute:: visibility
      :type:  global___FragmentVisibility

      the visibility of a fragment; public, private or unlisted


   .. py:property:: fragment
      :type: google.protobuf.struct_pb2.Struct



   .. py:property:: created_on
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:method:: HasField(field_name: Literal['created_on', b'created_on', 'fragment', b'fragment']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetFragmentRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: GetFragmentResponse(*, fragment: global___Fragment | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: fragment
      :type: global___Fragment



   .. py:method:: HasField(field_name: Literal['fragment', b'fragment']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetLocationRequest(*, location_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: location_id
      :type:  str

      Location ID of location to get.


.. py:class:: GetLocationResponse(*, location: global___Location | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: location
      :type: global___Location

      Location object is returned.


   .. py:method:: HasField(field_name: Literal['location', b'location']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetModuleRequest(*, module_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: module_id
      :type:  str

      name where prefix is the module owner's orgid or namespace)

      :type: The id of the module (formatted as prefix


.. py:class:: GetModuleResponse(*, module: global___Module | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: module
      :type: global___Module

      The module object


   .. py:method:: HasField(field_name: Literal['module', b'module']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetOrganizationNamespaceAvailabilityRequest(*, public_namespace: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: public_namespace
      :type:  str


.. py:class:: GetOrganizationNamespaceAvailabilityResponse(*, available: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: available
      :type:  bool


.. py:class:: GetOrganizationRequest(*, organization_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


.. py:class:: GetOrganizationResponse(*, organization: global___Organization | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: organization
      :type: global___Organization



   .. py:method:: HasField(field_name: Literal['organization', b'organization']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetOrganizationsWithAccessToLocationRequest(*, location_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: location_id
      :type:  str


.. py:class:: GetOrganizationsWithAccessToLocationResponse(*, organization_identities: collections.abc.Iterable[global___OrganizationIdentity] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: organization_identities
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OrganizationIdentity]



.. py:class:: GetRegistryItemRequest(*, item_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: item_id
      :type:  str


.. py:class:: GetRegistryItemResponse(*, item: global___RegistryItem | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: item
      :type: global___RegistryItem



   .. py:method:: HasField(field_name: Literal['item', b'item']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetRobotAPIKeysRequest(*, robot_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: robot_id
      :type:  str


.. py:class:: GetRobotAPIKeysResponse(*, api_keys: collections.abc.Iterable[global___APIKeyWithAuthorizations] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: api_keys
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___APIKeyWithAuthorizations]



.. py:class:: GetRobotPartHistoryRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: GetRobotPartHistoryResponse(*, history: collections.abc.Iterable[global___RobotPartHistoryEntry] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: history
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RobotPartHistoryEntry]



.. py:class:: GetRobotPartLogsRequest(*, id: str = ..., errors_only: bool = ..., filter: str | None = ..., page_token: str | None = ..., levels: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: errors_only
      :type:  bool

      Remove this field

      :type: TODO(https

      :type: //viam.atlassian.net/browse/APP-3877)


   .. py:attribute:: filter
      :type:  str


   .. py:attribute:: page_token
      :type:  str


   .. py:property:: levels
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]

      logs of all levels are returned when the levels field is empty


   .. py:method:: HasField(field_name: Literal['_filter', b'_filter', '_page_token', b'_page_token', 'filter', b'filter', 'page_token', b'page_token']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_filter', b'_filter']) -> Literal['filter'] | None
                  WhichOneof(oneof_group: Literal['_page_token', b'_page_token']) -> Literal['page_token'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: GetRobotPartLogsResponse(*, logs: collections.abc.Iterable[viam.gen.common.v1.common_pb2.LogEntry] | None = ..., next_page_token: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: next_page_token
      :type:  str


   .. py:property:: logs
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.LogEntry]



.. py:class:: GetRobotPartRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: GetRobotPartResponse(*, part: global___RobotPart | None = ..., config_json: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: config_json
      :type:  str


   .. py:property:: part
      :type: global___RobotPart



   .. py:method:: HasField(field_name: Literal['part', b'part']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetRobotPartsRequest(*, robot_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: robot_id
      :type:  str


.. py:class:: GetRobotPartsResponse(*, parts: collections.abc.Iterable[global___RobotPart] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: parts
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RobotPart]



.. py:class:: GetRobotRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: GetRobotResponse(*, robot: global___Robot | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: robot
      :type: global___Robot



   .. py:method:: HasField(field_name: Literal['robot', b'robot']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetRoverRentalRobotsRequest(*, org_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: org_id
      :type:  str


.. py:class:: GetRoverRentalRobotsResponse(*, robots: collections.abc.Iterable[global___RoverRentalRobot] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: robots
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RoverRentalRobot]



.. py:class:: GetUserIDByEmailRequest(*, email: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: email
      :type:  str


.. py:class:: GetUserIDByEmailResponse(*, user_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: user_id
      :type:  str


.. py:class:: ListAuthorizationsRequest(*, organization_id: str = ..., resource_ids: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


   .. py:property:: resource_ids
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]

      optional filter


.. py:class:: ListAuthorizationsResponse(*, authorizations: collections.abc.Iterable[global___Authorization] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: authorizations
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Authorization]



.. py:class:: ListFragmentsRequest(*, organization_id: str = ..., show_public: bool = ..., fragment_visibility: collections.abc.Iterable[global___FragmentVisibility] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: show_public
      :type:  bool


   .. py:property:: fragment_visibility
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___FragmentVisibility]



.. py:class:: ListFragmentsResponse(*, fragments: collections.abc.Iterable[global___Fragment] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: fragments
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Fragment]



.. py:class:: ListKeysRequest(*, org_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: org_id
      :type:  str


.. py:class:: ListKeysResponse(*, api_keys: collections.abc.Iterable[global___APIKeyWithAuthorizations] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: api_keys
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___APIKeyWithAuthorizations]



.. py:class:: ListLocationsRequest(*, organization_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str

      Organization ID under which to list all locations.


.. py:class:: ListLocationsResponse(*, locations: collections.abc.Iterable[global___Location] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: locations
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Location]



.. py:class:: ListModulesRequest(*, organization_id: str | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str

      The id of the organization to return private modules for.


   .. py:method:: HasField(field_name: Literal['_organization_id', b'_organization_id', 'organization_id', b'organization_id']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_organization_id', b'_organization_id']) -> Literal['organization_id'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: ListModulesResponse(*, modules: collections.abc.Iterable[global___Module] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: modules
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Module]

      A listed of modules. When authenticated, this API will return modules that are private for this org. Public modules are always returned.


.. py:class:: ListOrganizationMembersRequest(*, organization_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


.. py:class:: ListOrganizationMembersResponse(*, organization_id: str = ..., members: collections.abc.Iterable[global___OrganizationMember] | None = ..., invites: collections.abc.Iterable[global___OrganizationInvite] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


   .. py:property:: members
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OrganizationMember]



   .. py:property:: invites
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OrganizationInvite]



.. py:class:: ListOrganizationsByUserRequest(*, user_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: user_id
      :type:  str


.. py:class:: ListOrganizationsByUserResponse(*, orgs: collections.abc.Iterable[global___OrgDetails] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: orgs
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OrgDetails]



.. py:class:: ListOrganizationsRequest

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: ListOrganizationsResponse(*, organizations: collections.abc.Iterable[global___Organization] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: organizations
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Organization]



.. py:class:: ListRegistryItemsRequest(*, organization_id: str | None = ..., types: collections.abc.Iterable[viam.gen.app.packages.v1.packages_pb2.PackageType.ValueType] | None = ..., visibilities: collections.abc.Iterable[global___Visibility] | None = ..., platforms: collections.abc.Iterable[str] | None = ..., statuses: collections.abc.Iterable[global___RegistryItemStatus] | None = ..., search_term: str | None = ..., page_token: str | None = ..., public_namespaces: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str

      The id of the organization to return registry items for.


   .. py:attribute:: search_term
      :type:  str


   .. py:attribute:: page_token
      :type:  str


   .. py:property:: types
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[viam.gen.app.packages.v1.packages_pb2.PackageType.ValueType]



   .. py:property:: visibilities
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___Visibility]



   .. py:property:: platforms
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:property:: statuses
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___RegistryItemStatus]



   .. py:property:: public_namespaces
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]

      One or more public namespaces to return results for.


   .. py:method:: HasField(field_name: Literal['_organization_id', b'_organization_id', '_page_token', b'_page_token', '_search_term', b'_search_term', 'organization_id', b'organization_id', 'page_token', b'page_token', 'search_term', b'search_term']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_organization_id', b'_organization_id']) -> Literal['organization_id'] | None
                  WhichOneof(oneof_group: Literal['_page_token', b'_page_token']) -> Literal['page_token'] | None
                  WhichOneof(oneof_group: Literal['_search_term', b'_search_term']) -> Literal['search_term'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: ListRegistryItemsResponse(*, items: collections.abc.Iterable[global___RegistryItem] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: items
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RegistryItem]



.. py:class:: ListRobotsRequest(*, location_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: location_id
      :type:  str


.. py:class:: ListRobotsResponse(*, robots: collections.abc.Iterable[global___Robot] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: robots
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Robot]



.. py:class:: Location(*, id: str = ..., name: str = ..., parent_location_id: str = ..., auth: global___LocationAuth | None = ..., organizations: collections.abc.Iterable[global___LocationOrganization] | None = ..., created_on: google.protobuf.timestamp_pb2.Timestamp | None = ..., robot_count: int = ..., config: global___StorageConfig | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str

      Location ID.


   .. py:attribute:: name
      :type:  str

      Location name.


   .. py:attribute:: parent_location_id
      :type:  str

      Location ID of the parent location.


   .. py:attribute:: robot_count
      :type:  int


   .. py:property:: auth
      :type: global___LocationAuth

      Location authentication secrets.


   .. py:property:: organizations
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LocationOrganization]

      Organizations that the location is shared with.


   .. py:property:: created_on
      :type: google.protobuf.timestamp_pb2.Timestamp

      Location creation timestamp.


   .. py:property:: config
      :type: global___StorageConfig

      Config for how data in this location is stored.


   .. py:method:: HasField(field_name: Literal['auth', b'auth', 'config', b'config', 'created_on', b'created_on']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: LocationAuth(*, secret: str = ..., location_id: str = ..., secrets: collections.abc.Iterable[global___SharedSecret] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: secret
      :type:  str

      use secrets field.

      :type: Deprecated


   .. py:attribute:: location_id
      :type:  str

      Location ID containing this LocationAuth.


   .. py:property:: secrets
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SharedSecret]

      List of secrets used to authenticate to the Location.


.. py:class:: LocationAuthRequest(*, location_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: location_id
      :type:  str


.. py:class:: LocationAuthResponse(*, auth: global___LocationAuth | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: auth
      :type: global___LocationAuth



   .. py:method:: HasField(field_name: Literal['auth', b'auth']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: MarkPartAsMainRequest(*, part_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: part_id
      :type:  str


.. py:class:: MarkPartForRestartRequest(*, part_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: part_id
      :type:  str


.. py:class:: Model(*, api: str = ..., model: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: api
      :type:  str

      The colon-delimited-triplet of the api implemented by the model


   .. py:attribute:: model
      :type:  str

      The colon-delimited-triplet of the model


.. py:class:: Module(*, module_id: str = ..., name: str = ..., visibility: global___Visibility = ..., versions: collections.abc.Iterable[global___VersionHistory] | None = ..., url: str = ..., description: str = ..., models: collections.abc.Iterable[global___Model] | None = ..., total_robot_usage: int = ..., total_organization_usage: int = ..., organization_id: str = ..., entrypoint: str = ..., public_namespace: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: module_id
      :type:  str

      name where prefix is the module owner's orgid or namespace)

      :type: The id of the module (formatted as prefix


   .. py:attribute:: name
      :type:  str

      The name of the module


   .. py:attribute:: visibility
      :type:  global___Visibility

      The visibility of the module


   .. py:attribute:: url
      :type:  str

      The url to reference for documentation, code, etc.


   .. py:attribute:: description
      :type:  str

      A short description of the module that explains its purpose


   .. py:attribute:: total_robot_usage
      :type:  int

      The total number of robots using this module


   .. py:attribute:: total_organization_usage
      :type:  int

      The total number of organizations using this module


   .. py:attribute:: organization_id
      :type:  str

      The id of the organization that owns the module


   .. py:attribute:: entrypoint
      :type:  str

      The executable to run to start the module program


   .. py:attribute:: public_namespace
      :type:  str

      The public namespace of the organization that owns the module
      This is empty if no public namespace is set


   .. py:property:: versions
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VersionHistory]

      The versions of the module that are available
      When this is returned from the backend, the versions are sorted in ascending order by the semver version


   .. py:property:: models
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model]

      A list of models that are available in the module


.. py:class:: ModuleFileInfo(*, module_id: str = ..., version: str = ..., platform: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: module_id
      :type:  str

      name where prefix is the module owner's orgid or namespace)

      :type: The id of the module (formatted as prefix


   .. py:attribute:: version
      :type:  str

      The semver string that represents the new major/minor/patch version of the module


   .. py:attribute:: platform
      :type:  str

      The platform that the file is built to run on


.. py:class:: NewRobotPartRequest(*, robot_id: str = ..., part_name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: robot_id
      :type:  str


   .. py:attribute:: part_name
      :type:  str


.. py:class:: NewRobotPartResponse(*, part_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: part_id
      :type:  str


.. py:class:: NewRobotRequest(*, name: str = ..., location: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: location
      :type:  str


.. py:class:: NewRobotResponse(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: Organization(*, id: str = ..., name: str = ..., created_on: google.protobuf.timestamp_pb2.Timestamp | None = ..., public_namespace: str = ..., default_region: str = ..., cid: str | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: public_namespace
      :type:  str


   .. py:attribute:: default_region
      :type:  str

      GCS region of the organization. Locations created under this org will have their GCS region set to this by default and packages
      associated with this org will be stored in this region.


   .. py:attribute:: cid
      :type:  str


   .. py:property:: created_on
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:method:: HasField(field_name: Literal['_cid', b'_cid', 'cid', b'cid', 'created_on', b'created_on']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_cid', b'_cid']) -> Literal['cid'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: OrganizationIdentity(*, id: str = ..., name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Location

   Used for rendering an organization's information on the frontend (limited
   to id, name, or both).


   .. py:attribute:: id
      :type:  str

      Organization ID.


   .. py:attribute:: name
      :type:  str

      Organization name.


.. py:class:: OrganizationInvite(*, organization_id: str = ..., email: str = ..., created_on: google.protobuf.timestamp_pb2.Timestamp | None = ..., authorizations: collections.abc.Iterable[global___Authorization] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: email
      :type:  str


   .. py:property:: created_on
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: authorizations
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Authorization]



   .. py:method:: HasField(field_name: Literal['created_on', b'created_on']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: OrganizationMember(*, user_id: str = ..., emails: collections.abc.Iterable[str] | None = ..., date_added: google.protobuf.timestamp_pb2.Timestamp | None = ..., last_login: google.protobuf.timestamp_pb2.Timestamp | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: user_id
      :type:  str


   .. py:property:: emails
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:property:: date_added
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: last_login
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:method:: HasField(field_name: Literal['_last_login', b'_last_login', 'date_added', b'date_added', 'last_login', b'last_login']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_last_login', b'_last_login']) -> Literal['last_login'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: OrgDetails(*, org_id: str = ..., org_name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: org_id
      :type:  str


   .. py:attribute:: org_name
      :type:  str


.. py:class:: RegistryItem(*, item_id: str = ..., organization_id: str = ..., public_namespace: str = ..., name: str = ..., type: viam.gen.app.packages.v1.packages_pb2.PackageType.ValueType = ..., visibility: global___Visibility = ..., url: str = ..., description: str = ..., total_robot_usage: int = ..., total_external_robot_usage: int = ..., total_organization_usage: int = ..., total_external_organization_usage: int = ..., module_metadata: global___ModuleMetadata | None = ..., ml_model_metadata: global___MLModelMetadata | None = ..., ml_training_metadata: global___MLTrainingMetadata | None = ..., created_at: google.protobuf.timestamp_pb2.Timestamp | None = ..., updated_at: google.protobuf.timestamp_pb2.Timestamp | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: item_id
      :type:  str

      The id of the item, containing either:
      namespace:item_name when a namespace exists on the org.
      org_id:item_name when a namespace does not exist.


   .. py:attribute:: organization_id
      :type:  str

      The id of the organization that owns the item


   .. py:attribute:: public_namespace
      :type:  str

      The public namespace of the organization that owns the module
      This is empty if no public namespace is set


   .. py:attribute:: name
      :type:  str

      The name of the registry item


   .. py:attribute:: type
      :type:  viam.gen.app.packages.v1.packages_pb2.PackageType.ValueType

      The type of the item in the registry


   .. py:attribute:: visibility
      :type:  global___Visibility

      The visibility of the registry item


   .. py:attribute:: url
      :type:  str

      The url to reference for documentation, code, etc.


   .. py:attribute:: description
      :type:  str

      A short description of the item that explains its purpose


   .. py:attribute:: total_robot_usage
      :type:  int

      The total number of robots using this item


   .. py:attribute:: total_external_robot_usage
      :type:  int

      The total number of robots using this item outside of the owning org


   .. py:attribute:: total_organization_usage
      :type:  int

      The total number of organizations using this item


   .. py:attribute:: total_external_organization_usage
      :type:  int

      The total number of organizations using this item outside of the owning org


   .. py:property:: module_metadata
      :type: global___ModuleMetadata



   .. py:property:: ml_model_metadata
      :type: global___MLModelMetadata



   .. py:property:: ml_training_metadata
      :type: global___MLTrainingMetadata



   .. py:property:: created_at
      :type: google.protobuf.timestamp_pb2.Timestamp

      When the item was created


   .. py:property:: updated_at
      :type: google.protobuf.timestamp_pb2.Timestamp

      When the item was last updated, either through an update or upload.


   .. py:method:: HasField(field_name: Literal['created_at', b'created_at', 'metadata', b'metadata', 'ml_model_metadata', b'ml_model_metadata', 'ml_training_metadata', b'ml_training_metadata', 'module_metadata', b'module_metadata', 'updated_at', b'updated_at']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['metadata', b'metadata']) -> Literal['module_metadata', 'ml_model_metadata', 'ml_training_metadata'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: RegistryItemStatus

   Bases: :py:obj:`_RegistryItemStatus`


.. py:class:: RemoveRoleRequest(*, authorization: global___Authorization | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: authorization
      :type: global___Authorization



   .. py:method:: HasField(field_name: Literal['authorization', b'authorization']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ResendOrganizationInviteRequest(*, organization_id: str = ..., email: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: email
      :type:  str


.. py:class:: ResendOrganizationInviteResponse(*, invite: global___OrganizationInvite | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: invite
      :type: global___OrganizationInvite



   .. py:method:: HasField(field_name: Literal['invite', b'invite']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: Robot(*, id: str = ..., name: str = ..., location: str = ..., last_access: google.protobuf.timestamp_pb2.Timestamp | None = ..., created_on: google.protobuf.timestamp_pb2.Timestamp | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: location
      :type:  str


   .. py:property:: last_access
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: created_on
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:method:: HasField(field_name: Literal['created_on', b'created_on', 'last_access', b'last_access']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RobotPartPB(*, id: str = ..., name: str = ..., dns_name: str = ..., secret: str = ..., robot: str = ..., location_id: str = ..., robot_config: google.protobuf.struct_pb2.Struct | None = ..., last_access: google.protobuf.timestamp_pb2.Timestamp | None = ..., user_supplied_info: google.protobuf.struct_pb2.Struct | None = ..., main_part: bool = ..., fqdn: str = ..., local_fqdn: str = ..., created_on: google.protobuf.timestamp_pb2.Timestamp | None = ..., secrets: collections.abc.Iterable[global___SharedSecret] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: dns_name
      :type:  str

      dns_name part name used for fqdn and local fqdn. Anytime the Name is updated this should be sanitized and updated as well.


   .. py:attribute:: secret
      :type:  str


   .. py:attribute:: robot
      :type:  str


   .. py:attribute:: location_id
      :type:  str

      Store the location_id to allow for unique indexes across parts and locations. This filed MUST be updated each time the robots location
      changes.


   .. py:attribute:: main_part
      :type:  bool


   .. py:attribute:: fqdn
      :type:  str


   .. py:attribute:: local_fqdn
      :type:  str


   .. py:property:: robot_config
      :type: google.protobuf.struct_pb2.Struct



   .. py:property:: last_access
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: user_supplied_info
      :type: google.protobuf.struct_pb2.Struct



   .. py:property:: created_on
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: secrets
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SharedSecret]

      List of secrets allowed for authentication.


   .. py:method:: HasField(field_name: Literal['created_on', b'created_on', 'last_access', b'last_access', 'robot_config', b'robot_config', 'user_supplied_info', b'user_supplied_info']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RobotPartHistoryEntryPB(*, part: str = ..., robot: str = ..., when: google.protobuf.timestamp_pb2.Timestamp | None = ..., old: global___RobotPart | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: part
      :type:  str


   .. py:attribute:: robot
      :type:  str


   .. py:property:: when
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: old
      :type: global___RobotPart



   .. py:method:: HasField(field_name: Literal['old', b'old', 'when', b'when']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RotateKeyRequest(*, id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


.. py:class:: RotateKeyResponse(*, id: str = ..., key: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: key
      :type:  str


.. py:class:: RoverRentalRobot(*, robot_id: str = ..., location_id: str = ..., robot_name: str = ..., robot_main_part_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: robot_id
      :type:  str


   .. py:attribute:: location_id
      :type:  str


   .. py:attribute:: robot_name
      :type:  str


   .. py:attribute:: robot_main_part_id
      :type:  str


.. py:class:: SharedSecret(*, id: str = ..., secret: str = ..., created_on: google.protobuf.timestamp_pb2.Timestamp | None = ..., state: global___SharedSecret = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   SharedSecret is a secret used for LocationAuth and RobotParts.


   .. py:class:: State

      Bases: :py:obj:`_State`



   .. py:attribute:: STATE_UNSPECIFIED
      :type:  SharedSecret


   .. py:attribute:: STATE_ENABLED
      :type:  SharedSecret

      Secret is enabled and can be used in authentication.


   .. py:attribute:: STATE_DISABLED
      :type:  SharedSecret

      Secret is disabled and must not be used to authenticate to rpc.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: secret
      :type:  str

      The payload of the secret. Used during authentication to the rpc framework.


   .. py:attribute:: state
      :type:  global___SharedSecret.State.ValueType

      State of the shared secret. In most cases it should be enabled. We may support
      disabling a specific secret while keeping it in the database.


   .. py:property:: created_on
      :type: google.protobuf.timestamp_pb2.Timestamp

      Date/time the secret was first created.


   .. py:method:: HasField(field_name: Literal['created_on', b'created_on']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ShareLocationRequest(*, location_id: str = ..., organization_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: location_id
      :type:  str

      Location ID to be shared.


   .. py:attribute:: organization_id
      :type:  str

      Organization ID to share the location with.


.. py:class:: TailRobotPartLogsRequest(*, id: str = ..., errors_only: bool = ..., filter: str | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: errors_only
      :type:  bool


   .. py:attribute:: filter
      :type:  str


   .. py:method:: HasField(field_name: Literal['_filter', b'_filter', 'filter', b'filter']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_filter', b'_filter']) -> Literal['filter'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: TailRobotPartLogsResponse(*, logs: collections.abc.Iterable[viam.gen.common.v1.common_pb2.LogEntry] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: logs
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.LogEntry]



.. py:class:: UnshareLocationRequest(*, location_id: str = ..., organization_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: location_id
      :type:  str

      Location ID to be unshared.


   .. py:attribute:: organization_id
      :type:  str

      Organization ID to unshare the location with.


.. py:class:: UpdateFragmentRequest(*, id: str = ..., name: str = ..., config: google.protobuf.struct_pb2.Struct | None = ..., public: bool | None = ..., visibility: global___FragmentVisibility | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: public
      :type:  bool


   .. py:attribute:: visibility
      :type:  global___FragmentVisibility


   .. py:property:: config
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['_public', b'_public', '_visibility', b'_visibility', 'config', b'config', 'public', b'public', 'visibility', b'visibility']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_public', b'_public']) -> Literal['public'] | None
                  WhichOneof(oneof_group: Literal['_visibility', b'_visibility']) -> Literal['visibility'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: UpdateFragmentResponse(*, fragment: global___Fragment | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: fragment
      :type: global___Fragment



   .. py:method:: HasField(field_name: Literal['fragment', b'fragment']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: UpdateLocationRequest(*, location_id: str = ..., name: str | None = ..., parent_location_id: str | None = ..., region: str | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: location_id
      :type:  str

      Location ID of location to update.


   .. py:attribute:: name
      :type:  str

      The new name to be updated on location.


   .. py:attribute:: parent_location_id
      :type:  str

      The new parent location to move the location under.


   .. py:attribute:: region
      :type:  str

      The new GCS region to associate the location with.


   .. py:method:: HasField(field_name: Literal['_name', b'_name', '_parent_location_id', b'_parent_location_id', '_region', b'_region', 'name', b'name', 'parent_location_id', b'parent_location_id', 'region', b'region']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_name', b'_name']) -> Literal['name'] | None
                  WhichOneof(oneof_group: Literal['_parent_location_id', b'_parent_location_id']) -> Literal['parent_location_id'] | None
                  WhichOneof(oneof_group: Literal['_region', b'_region']) -> Literal['region'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: UpdateLocationResponse(*, location: global___Location | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: location
      :type: global___Location

      Location object is returned.


   .. py:method:: HasField(field_name: Literal['location', b'location']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: UpdateModuleRequest(*, module_id: str = ..., visibility: global___Visibility = ..., url: str = ..., description: str = ..., models: collections.abc.Iterable[global___Model] | None = ..., entrypoint: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: module_id
      :type:  str

      name where prefix is the module owner's orgid or namespace)

      :type: The id of the module (formatted as prefix


   .. py:attribute:: visibility
      :type:  global___Visibility

      The visibility that should be set for the module


   .. py:attribute:: url
      :type:  str

      The url to reference for documentation, code, etc.


   .. py:attribute:: description
      :type:  str

      A short description of the module that explains its purpose


   .. py:attribute:: entrypoint
      :type:  str

      The executable to run to start the module program


   .. py:property:: models
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model]

      A list of models that are available in the module


.. py:class:: UpdateModuleResponse(*, url: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: url
      :type:  str

      The detail page of the module


.. py:class:: UpdateOrganizationInviteAuthorizationsRequest(*, organization_id: str = ..., email: str = ..., add_authorizations: collections.abc.Iterable[global___Authorization] | None = ..., remove_authorizations: collections.abc.Iterable[global___Authorization] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: email
      :type:  str


   .. py:property:: add_authorizations
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Authorization]



   .. py:property:: remove_authorizations
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Authorization]



.. py:class:: UpdateOrganizationInviteAuthorizationsResponse(*, invite: global___OrganizationInvite | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: invite
      :type: global___OrganizationInvite



   .. py:method:: HasField(field_name: Literal['invite', b'invite']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: UpdateOrganizationRequest(*, organization_id: str = ..., name: str | None = ..., public_namespace: str | None = ..., region: str | None = ..., cid: str | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: organization_id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: public_namespace
      :type:  str


   .. py:attribute:: region
      :type:  str

      The new GCS region to associate the org with.


   .. py:attribute:: cid
      :type:  str


   .. py:method:: HasField(field_name: Literal['_cid', b'_cid', '_name', b'_name', '_public_namespace', b'_public_namespace', '_region', b'_region', 'cid', b'cid', 'name', b'name', 'public_namespace', b'public_namespace', 'region', b'region']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_cid', b'_cid']) -> Literal['cid'] | None
                  WhichOneof(oneof_group: Literal['_name', b'_name']) -> Literal['name'] | None
                  WhichOneof(oneof_group: Literal['_public_namespace', b'_public_namespace']) -> Literal['public_namespace'] | None
                  WhichOneof(oneof_group: Literal['_region', b'_region']) -> Literal['region'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: UpdateOrganizationResponse(*, organization: global___Organization | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: organization
      :type: global___Organization



   .. py:method:: HasField(field_name: Literal['organization', b'organization']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: UpdateRegistryItemRequest(*, item_id: str = ..., type: viam.gen.app.packages.v1.packages_pb2.PackageType.ValueType = ..., description: str = ..., visibility: global___Visibility = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: item_id
      :type:  str


   .. py:attribute:: type
      :type:  viam.gen.app.packages.v1.packages_pb2.PackageType.ValueType


   .. py:attribute:: description
      :type:  str


   .. py:attribute:: visibility
      :type:  global___Visibility


.. py:class:: UpdateRobotPartRequest(*, id: str = ..., name: str = ..., robot_config: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:property:: robot_config
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['robot_config', b'robot_config']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: UpdateRobotPartResponse(*, part: global___RobotPart | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: part
      :type: global___RobotPart



   .. py:method:: HasField(field_name: Literal['part', b'part']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: UpdateRobotRequest(*, id: str = ..., name: str = ..., location: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: location
      :type:  str


.. py:class:: UpdateRobotResponse(*, robot: global___Robot | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: robot
      :type: global___Robot



   .. py:method:: HasField(field_name: Literal['robot', b'robot']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: UploadModuleFileRequest(*, module_file_info: global___ModuleFileInfo | None = ..., file: bytes = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: file
      :type:  bytes

      The file contents to be uploaded


   .. py:property:: module_file_info
      :type: global___ModuleFileInfo

      The information about the module file being uploaded


   .. py:method:: HasField(field_name: Literal['file', b'file', 'module_file', b'module_file', 'module_file_info', b'module_file_info']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['module_file', b'module_file']) -> Literal['module_file_info', 'file'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: Visibility

   Bases: :py:obj:`_Visibility`


.. py:class:: PackageType

   Bases: :py:obj:`_PackageType`


.. py:class:: LogEntryPB(*, host: str = ..., level: str = ..., time: google.protobuf.timestamp_pb2.Timestamp | None = ..., logger_name: str = ..., message: str = ..., caller: google.protobuf.struct_pb2.Struct | None = ..., stack: str = ..., fields: collections.abc.Iterable[google.protobuf.struct_pb2.Struct] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: host
      :type:  str


   .. py:attribute:: level
      :type:  str


   .. py:attribute:: logger_name
      :type:  str


   .. py:attribute:: message
      :type:  str


   .. py:attribute:: stack
      :type:  str


   .. py:property:: time
      :type: google.protobuf.timestamp_pb2.Timestamp



   .. py:property:: caller
      :type: google.protobuf.struct_pb2.Struct



   .. py:property:: fields
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.struct_pb2.Struct]



   .. py:method:: HasField(field_name: Literal['caller', b'caller', 'time', b'time']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:function:: datetime_to_timestamp(dt: Optional[datetime.datetime]) -> Optional[google.protobuf.timestamp_pb2.Timestamp]

.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:data:: LOGGER

.. py:class:: RobotPart

   A class that mirrors the `RobotPart` proto message.

   Use this class to make the attributes of a `viam.proto.app.RobotPart` more accessible and easier to read/interpret.


   .. py:method:: from_proto(robot_part: viam.proto.app.RobotPart) -> typing_extensions.Self
      :classmethod:


      Create a `RobotPart` from the .proto defined `RobotPart`.

      :param robot_part: The object to copy from.
      :type robot_part: viam.proto.app.RobotPart

      :returns: The `RobotPart`.
      :rtype: RobotPart



   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: dns_name
      :type:  str


   .. py:attribute:: secret
      :type:  str


   .. py:attribute:: robot
      :type:  str


   .. py:attribute:: location_id
      :type:  str


   .. py:attribute:: robot_config
      :type:  Optional[Mapping[str, Any]]


   .. py:attribute:: last_access
      :type:  Optional[datetime.datetime]


   .. py:attribute:: user_supplied_info
      :type:  Optional[Mapping[str, Any]]


   .. py:attribute:: main_part
      :type:  bool


   .. py:attribute:: fqdn
      :type:  str


   .. py:attribute:: local_fqdn
      :type:  str


   .. py:attribute:: created_on
      :type:  Optional[datetime.datetime]


   .. py:attribute:: secrets
      :type:  Optional[List[viam.proto.app.SharedSecret]]


   .. py:property:: proto
      :type: viam.proto.app.RobotPart



.. py:class:: LogEntry

   A class that mirrors the `LogEntry` proto message.

   Use this class to make the attributes of a `viam.proto.app.LogEntry` more accessible and easier to read/interpret.


   .. py:method:: from_proto(log_entry: viam.proto.common.LogEntry) -> typing_extensions.Self
      :classmethod:


      Create a `LogEntry` from the .proto defined `LogEntry`.

      :param log_entry: The object to copy from.
      :type log_entry: viam.proto.app.LogEntry

      :returns: The `LogEntry`.
      :rtype: LogEntry



   .. py:attribute:: host
      :type:  str


   .. py:attribute:: level
      :type:  str


   .. py:attribute:: time
      :type:  Optional[datetime.datetime]


   .. py:attribute:: logger_name
      :type:  str


   .. py:attribute:: message
      :type:  str


   .. py:attribute:: caller
      :type:  Optional[Mapping[str, Any]]


   .. py:attribute:: stack
      :type:  str


   .. py:attribute:: fields
      :type:  Optional[List[Mapping[str, Any]]]


   .. py:property:: proto
      :type: viam.proto.common.LogEntry



.. py:class:: Fragment

   A class that mirrors the `Fragment` proto message.

   Use this class to make the attributes of a `viam.proto.app.RobotPart` more accessible and easier to read/interpret.


   .. py:method:: from_proto(fragment: viam.proto.app.Fragment) -> typing_extensions.Self
      :classmethod:


      Create a `Fragment` from the .proto defined `Fragment`.

      :param fragment: The object to copy from.
      :type fragment: viam.proto.app.Fragment

      :returns: The `Fragment`.
      :rtype: Fragment



   .. py:attribute:: id
      :type:  str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: fragment
      :type:  Optional[Mapping[str, Any]]


   .. py:attribute:: organization_owner
      :type:  str


   .. py:attribute:: public
      :type:  bool


   .. py:attribute:: created_on
      :type:  Optional[datetime.datetime]


   .. py:attribute:: organization_name
      :type:  str


   .. py:attribute:: robot_part_count
      :type:  int


   .. py:attribute:: organization_count
      :type:  int


   .. py:attribute:: only_used_by_owner
      :type:  bool


   .. py:property:: proto
      :type: viam.proto.app.Fragment



.. py:class:: RobotPartHistoryEntry

   A class that mirrors the `RobotPartHistoryEntry` proto message.

   Use this class to make the attributes of a `viam.proto.app.RobotPartHistoryEntry` more accessible and easier to read/interpret.


   .. py:method:: from_proto(robot_part_history_entry: viam.proto.app.RobotPartHistoryEntry) -> typing_extensions.Self
      :classmethod:


      Create a `RobotPartHistoryEntry` from the .proto defined `RobotPartHistoryEntry`.

      :param robot_part_history_entry: The object to copy from.
      :type robot_part_history_entry: viam.proto.app.RobotPartHistoryEntry

      :returns: The `RobotPartHistoryEntry`.
      :rtype: RobotPartHistoryEntry



   .. py:attribute:: part
      :type:  str


   .. py:attribute:: robot
      :type:  str


   .. py:attribute:: when
      :type:  Optional[datetime.datetime]


   .. py:attribute:: old
      :type:  Optional[RobotPart]


   .. py:property:: proto
      :type: viam.proto.app.RobotPartHistoryEntry



.. py:class:: APIKeyAuthorization(role: Union[Literal['owner'], Literal['operator']], resource_type: Union[Literal['organization'], Literal['location'], Literal['robot']], resource_id: str)

   A class with the necessary authorization data for creating an API key.

   Use this class when constructing API key authorizations to minimize the risk of malformed or missing data.


.. py:class:: AppClient(channel: grpclib.client.Channel, metadata: Mapping[str, str], location_id: Optional[str] = None)

   gRPC client for method calls to app.

   Constructor is used by `ViamClient` to instantiate relevant service stub. Calls to `AppClient`  methods should be made through
   `ViamClient`.

   Establish a Connection::

       import asyncio

       from viam.rpc.dial import DialOptions, Credentials
       from viam.app.viam_client import ViamClient


       async def connect() -> ViamClient:
           # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
           dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
           return await ViamClient.create_from_dial_options(dial_options)


       async def main():

           # Make a ViamClient
           viam_client = await connect()
           # Instantiate an AppClient called "cloud" to run cloud app API methods on
           cloud = viam_client.app_client

           viam_client.close()

       if __name__ == '__main__':
           asyncio.run(main())



   .. py:method:: get_user_id_by_email(email: str) -> str
      :async:


      Get the ID of a user by email.

      ::

          id = await cloud.get_user_id_by_email("youremail@email.com")

      :param email: The email of the user.
      :type email: str

      :returns: The ID of the user.
      :rtype: str



   .. py:method:: create_organization(name: str) -> viam.proto.app.Organization
      :async:


      Create an organization.

      ::

          organization = await cloud.create_organization("name")

      :param name: The name of the organization.
      :type name: str

      :returns: The created organization.
      :rtype: Organization



   .. py:method:: list_organizations() -> List[viam.proto.app.Organization]
      :async:


      List the organization(s) the user is an authorized owner of.

      ::

          org_list = await cloud.list_organizations()

      :returns: The list of organizations.
      :rtype: List[viam.proto.app.Organization]



   .. py:method:: get_organizations_with_access_to_location(location_id: str) -> List[viam.proto.app.OrganizationIdentity]
      :async:


      Get all organizations that have access to a location.

      ::

          org_list = await cloud.get_organization_with_access_to_location("location-id")

      :param location_id: The ID of the location.
      :type location_id: str

      :returns: The list of organizations.
      :rtype: List[viam.proto.app.OrganizationIdentity]



   .. py:method:: list_organizations_by_user(user_id: str) -> List[viam.proto.app.OrgDetails]
      :async:


      List the organizations a user belongs to.

      ::

          org_list = await cloud.list_organizations_by_user("user-id")

      :param user_id: The ID of the user
      :type user_id: str

      :returns: The list of organizations.
      :rtype: List[OrgDetails]



   .. py:method:: get_organization(org_id: str) -> viam.proto.app.Organization
      :async:


      Return details about the requested organization.

      :param org_id: The ID of the organization to query.
      :type org_id: str

      :raises GRPCError: If the provided org_id is invalid, or not currently authed to.

      :returns: The requested organization.
      :rtype: viam.proto.app.Organization



   .. py:method:: get_organization_namespace_availability(public_namespace: str) -> bool
      :async:


      Check the availability of an organization namespace.

      ::

          available = await cloud.get_organization_namespace_availability(
              public_namespace="my-cool-organization")

      :param public_namespace: Organization namespace to check. Namespaces can only contain lowercase lowercase alphanumeric and dash
                               characters.
      :type public_namespace: str

      :raises GRPCError: If an invalid namespace (e.g., "") is provided.

      :returns: True if the provided namespace is available.
      :rtype: bool



   .. py:method:: update_organization(org_id: str, name: Optional[str] = None, public_namespace: Optional[str] = None, region: Optional[str] = None, cid: Optional[str] = None) -> viam.proto.app.Organization
      :async:


      Updates organization details.

      :param org_id: The ID of the organization to update.
      :type org_id: str
      :param name: If provided, updates the org's name.
      :type name: Optional[str]
      :param public_namespace: If provided, sets the org's namespace if it hasn't already been set.
      :type public_namespace: Optional[str]
      :param region: If provided, updates the org's region.
      :type region: Optional[str]
      :param cid: If provided, update's the org's CRM ID.
      :type cid: Optional[str]

      :raises GRPCError: If the org's namespace has already been set, or if the provided namespace is already taken.

      :returns: The updated organization.
      :rtype: viam.proto.app.Organization



   .. py:method:: delete_organization(org_id: str) -> None
      :async:


      Delete an organization

      ::
          await cloud.delete_organization("org-id")

      :param org_id: The ID of the organization.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str



   .. py:method:: list_organization_members(org_id: str) -> Tuple[List[viam.proto.app.OrganizationMember], List[viam.proto.app.OrganizationInvite]]
      :async:


      List the members and invites of the currently authed-to organization.

      ::

          member_list, invite_list = await cloud.list_organization_members("org-id")

      :param org_id: The ID of the organization to list members of.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str

      :returns: A tuple containing two lists; the first
                [0] of organization members, and the second [1] of organization invites.
      :rtype: Tuple[List[viam.proto.app.OrganizationMember], List[viam.proto.app.OrganizationInvite]]



   .. py:method:: create_organization_invite(org_id: str, email: str, authorizations: Optional[List[viam.proto.app.Authorization]] = None, send_email_invite: bool = True) -> viam.proto.app.OrganizationInvite
      :async:


      Creates an organization invite and sends it via email.

      ::

          await cloud.create_organization_invite("org-id", "youremail@email.com")

      :param org_id: The ID of the organization to create an invite for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param email: The email address to send the invite to.
      :type email: str
      :param authorizations: Specifications of the
                             authorizations to include in the invite. If not provided, full owner permissions will
                             be granted.
      :type authorizations: Optional[List[viam.proto.app.Authorization]]
      :param send_email_invite: Whether or not an email should be sent to the recipient of an invite.
                                The user must accept the email to be added to the associated authorizations.
                                When set to false, the user automatically receives the associated authorization
                                on the next login of the user with the associated email address.
      :type send_email_invite: Optional[bool]

      :raises GRPCError: if an invalid email is provided, or if the user is already a member of the org.

      :returns: The organization invite.
      :rtype: OrganizationInvite



   .. py:method:: update_organization_invite_authorizations(org_id: str, email: str, add_authorizations: Optional[List[viam.proto.app.Authorization]] = None, remove_authorizations: Optional[List[viam.proto.app.Authorization]] = None) -> viam.proto.app.OrganizationInvite
      :async:


      Update the authorizations attached to an organization invite that has already been created.

      Note that an invite can only have one authorization at each resource (e.g., organization, location, robot, etc.) level and must have
      at least one authorization overall.

      ::

          from viam.proto.app import Authorization

          authorization_to_add = Authorization(
              authorization_type="some type of auth",
              authorization_id="identifier",
              resource_type="abc",
              resource_id="resource-identifier123",
              identity_id="id12345",
              organization_id="org_id_123"
          )

          update_invite = await cloud.update_organization_invite_authorizations(
              org_id="org_id_123",
              email="notarealemail@viam.com",
              add_authorizations =[authorization_to_add]
          )

      :param org_id: The ID of the organization that the invite is for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param email: Email of the user the invite was sent to.
      :type email: str
      :param add_authorizations: Optional list of authorizations to add to the invite.
      :type add_authorizations: Optional[List[viam.proto.app.Authorization]]
      :param remove_authorizations: Optional list of authorizations to remove from the invite.
      :type remove_authorizations: Optional[List[viam.proto.app.Authorization]]

      :raises GRPCError: If no authorizations are passed or if an invalid combination of authorizations is passed (e.g. an authorization to
          remove when the invite only contains one authorization).

      :returns: The updated invite.
      :rtype: viam.proto.app.OrganizationInvite



   .. py:method:: delete_organization_member(org_id: str, user_id: str) -> None
      :async:


      Remove a member from the organization.

      ::

          member_list, invite_list = await cloud.list_organization_members()
          first_user_id = member_list[0].user_id

          await cloud.delete_organization_member(org_id="org_id", user_id=first_user_id)

      :param org_id: The ID of the org to remove the user from.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param user_id: The ID of the user to remove.
      :type user_id: str



   .. py:method:: delete_organization_invite(org_id: str, email: str) -> None
      :async:


      Deletes a pending organization invite.

      ::

          await cloud.delete_organization_invite("org-id", "youremail@email.com")

      :param org_id: The ID of the organization that the invite to delete was for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param email: The email address the pending invite was sent to.
      :type email: str

      :raises GRPCError: If no pending invite is associated with the provided email address.



   .. py:method:: resend_organization_invite(org_id: str, email: str) -> viam.proto.app.OrganizationInvite
      :async:


      Re-sends a pending organization invite email.

      ::

          org_invite = await cloud.resend_organization_invite("org-id", "youremail@email.com")

      :param org_id: The ID of the organization that the invite to resend was for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param email: The email address associated with the invite.
      :type email: str

      :raises GRPCError: If no pending invite is associated with the provided email address.

      :returns: The organization invite sent.
      :rtype: viam.proto.app.OrganizationInvite



   .. py:method:: create_location(org_id: str, name: str, parent_location_id: Optional[str] = None) -> viam.proto.app.Location
      :async:


      Create and name a location under the currently authed-to organization and the specified parent location.

      ::

          my_new_location = await cloud.create_location(org_id="org-id", name="Robotville", parent_location_id="111ab12345")

      :param org_id: The ID of the organization to create the location under.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param name: Name of the location.
      :type name: str
      :param parent_location_id: Optional parent location to put the location under. Defaults to a root-level location if no
                                 location ID is provided.
      :type parent_location_id: Optional[str]

      :raises GRPCError: If either an invalid name (e.g., ""), or parent location ID (e.g., a nonexistent ID) is passed.

      :returns: The newly created location.
      :rtype: viam.proto.app.Location



   .. py:method:: get_location(location_id: Optional[str] = None) -> viam.proto.app.Location
      :async:


      Get a location.

      ::

          location = await cloud.get_location(location_id="123ab12345")

      :param location_id: ID of the location to get. Defaults to the location ID provided at `AppClient` instantiation.
      :type location_id: Optional[str]

      :raises GRPCError: If an invalid location ID is passed or if one isn't passed and there was no location ID provided at `AppClient`
          instantiation.

      :returns: The location.
      :rtype: viam.proto.app.Location



   .. py:method:: update_location(location_id: str, name: Optional[str] = None, parent_location_id: Optional[str] = None) -> viam.proto.app.Location
      :async:


      Change the name of a location and/or assign it a new parent location.

      ::

          # The following line takes the location with ID "abc12abcde" and moves it to be a
          # sub-location of the location with ID "xyz34xxxxx"
          my_updated_location = await cloud.update_location(
              location_id="abc12abcde",
              name="",
              parent_location_id="xyz34xxxxx",
          )

          # The following line changes the name of the location without changing its parent location
          my_updated_location = await cloud.update_location(
              location_id="abc12abcde",
              name="Land Before Robots"
          )

          # The following line moves the location back up to be a top level location without changing its name
          my_updated_location = await cloud.update_location(
              location_id="abc12abcde",
              name="",
              parent_location_id=""
          )

      :param location_id: ID of the location to update. Must be specified.
      :type location_id: str
      :param name: Optional new name to be updated on the location. Defaults to the empty string "" (i.e., the name doesn't
                   change).
      :type name: Optional[str]
      :param parent_location_id: Optional ID of new parent location to move the location under. Defaults to the empty string
                                 "" (i.e., no new parent location is assigned).
      :type parent_location_id: Optional[str]

      :raises GRPCError: If either an invalid location ID, name, or parent location ID is passed.

      :returns: The newly updated location.
      :rtype: viam.proto.app.Location



   .. py:method:: delete_location(location_id: str) -> None
      :async:


      Delete a location.

      ::

          await cloud.delete_location(location_id="abc12abcde")

      :param location_id: ID of the location to delete. Must be specified.
      :type location_id: str

      :raises GRPCError: If an invalid location ID is passed.



   .. py:method:: list_locations(org_id: str) -> List[viam.proto.app.Location]
      :async:


      Get a list of all locations under the currently authed-to organization.

      ::

          locations = await cloud.list_locations("org-id")

      :param org_id: The ID of the org to list locations for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str

      :returns: The list of locations.
      :rtype: List[viam.proto.app.Location]



   .. py:method:: share_location(organization_id: str, location_id: str) -> None
      :async:


      Share a location with an organization.

      ::

          await cloud.share_location("organization-id", "location-id")

      :param organization_id: The ID of the organization.
      :type organization_id: str
      :param location_id: The ID of the location.
      :type location_id: str



   .. py:method:: unshare_location(organization_id: str, location_id: str) -> None
      :async:


      Stop sharing a location with an organization.

      ::

          await cloud.unshare_location("organization-id", "location-id")

      :param organization_id: The ID of the organization.
      :type organization_id: str
      :param location_id: The ID of the location.
      :type location_id: str



   .. py:method:: location_auth(location_id: Optional[str] = None) -> viam.proto.app.LocationAuth
      :async:


      Get a location's `LocationAuth` (location secret(s)).

      ::

          loc_auth = await cloud.location_auth(location_id="123xy12345")

      :param location_id: ID of the location to retrieve `LocationAuth` from. Defaults to the location ID provided at `AppClient`
                          instantiation.
      :type location_id: str

      :raises GRPCError: If an invalid location ID is passed or if one isn't passed and there was no location ID provided at `AppClient`
          instantiation.

      :returns: The `LocationAuth` containing location secrets.
      :rtype: viam.proto.app.LocationAuth



   .. py:method:: create_location_secret(location_id: Optional[str] = None) -> viam.proto.app.LocationAuth
      :async:


      Create a new location secret.

      ::

          new_loc_auth = await cloud.create_location_secret()

      :param location_id: ID of the location to generate a new secret for. Defaults to the location ID provided at
                          `AppClient` instantiation.
      :type location_id: Optional[str]

      :raises GRPCError: If an invalid location ID is passed or one isn't passed and there was no location ID provided at `AppClient`
          instantiation.

      :returns: The specified location's `LocationAuth` containing the newly created secret.
      :rtype: viam.proto.app.LocationAuth



   .. py:method:: delete_location_secret(secret_id: str, location_id: Optional[str] = None) -> None
      :async:


      Delete a location secret.

      ::

          await cloud.delete_location_secret(
              secret_id="abcd123-456-7890ab-cxyz98-989898xyzxyz")

      :param location_id: ID of the location to delete secret from. Defaults to the location ID provided at `AppClient` instantiation.
      :type location_id: str
      :param secret_id: ID of the secret to delete.
      :type secret_id: str

      :raises GRPCError: If either an invalid location ID or secret ID is passed or a location ID isn't passed and there was no location
          ID provided at `AppClient` instantiation.



   .. py:method:: get_robot(robot_id: str) -> viam.proto.app.Robot
      :async:


      Get a robot.

      ::

          robot = await cloud.get_robot(robot_id="1a123456-x1yz-0ab0-a12xyzabc")

      :param robot_id: ID of the robot to get.
      :type robot_id: str

      :raises GRPCError: If an invalid robot ID is passed.

      :returns: The robot.
      :rtype: viam.proto.app.Robot



   .. py:method:: get_rover_rental_robots(org_id: str) -> List[viam.proto.app.RoverRentalRobot]
      :async:


      Returns a list of rover rental robots within an org.

      ::

          rental_robots = await cloud.get_rover_rental_robots()

      :param org_id: The ID of the organization to list rover rental robots for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str

      :returns: The list of rover rental robots.
      :rtype: List[viam.proto.app.RoverRentalRobot]



   .. py:method:: get_robot_parts(robot_id: str) -> List[RobotPart]
      :async:


      Get a list of all the parts under a specific robot.

      ::

          list_of_parts = await cloud.get_robot_parts(
              robot_id="1a123456-x1yz-0ab0-a12xyzabc")

      :param robot_id: ID of the robot to get parts from.
      :type robot_id: str

      :raises GRPCError: If an invalid robot ID is passed.

      :returns: The list of robot parts.
      :rtype: List[viam.app.app_client.RobotPart]



   .. py:method:: get_robot_part(robot_part_id: str, dest: Optional[str] = None, indent: int = 4) -> RobotPart
      :async:


      Get a robot part.

      ::

          my_robot_part = await cloud.get_robot_part(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to get.
      :type robot_part_id: str
      :param dest: Optional filepath to write the robot part's config file in JSON format to.
      :type dest: Optional[str]
      :param indent: Size (in number of spaces) of indent when writing config to `dest`. Defaults to 4.
      :type indent: int

      :raises GRPCError: If an invalid robot part ID is passed.

      :returns: The robot part.
      :rtype: viam.app.app_client.RobotPart



   .. py:method:: get_robot_part_logs(robot_part_id: str, filter: Optional[str] = None, dest: Optional[str] = None, log_levels: List[str] = [], num_log_entries: int = 100) -> List[LogEntry]
      :async:


      Get the logs associated with a robot part.

      ::

          part_logs = await cloud.get_robot_part_logs(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22", num_log_entries=20)

      :param robot_part_id: ID of the robot part to get logs from.
      :type robot_part_id: str
      :param filter: Only include logs with messages that contain the string `filter`. Defaults to empty string "" (i.e., no
                     filter).
      :type filter: Optional[str]
      :param dest: Optional filepath to write the log entries to.
      :type dest: Optional[str]
      :param log_levels: List of log levels for which entries should be returned. Defaults to empty list, which returns all logs.
      :type log_levels: List[str]
      :param num_log_entries: Number of log entries to return. Passing 0 returns all logs. Defaults to 100. All logs or the first
                              `num_log_entries` logs will be returned, whichever comes first.
      :type num_log_entries: int

      :raises GRPCError: If an invalid robot part ID is passed.

      :returns: The list of log entries.
      :rtype: List[viam.app.app_client.LogEntry]



   .. py:method:: tail_robot_part_logs(robot_part_id: str, errors_only: bool = True, filter: Optional[str] = None) -> viam.app._logs._LogsStream[List[LogEntry]]
      :async:


      Get an asynchronous iterator that receives live robot part logs.

      ::

          logs_stream = await cloud.tail_robot_part_logs(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to retrieve logs from.
      :type robot_part_id: str
      :param errors_only: Boolean specifying whether or not to only include error logs. Defaults to True.
      :type errors_only: bool
      :param filter: Only include logs with messages that contain the string `filter`. Defaults to empty string "" (i.e., no
                     filter).
      :type filter: Optional[str]

      :returns: The asynchronous iterator receiving live robot part logs.
      :rtype: _LogsStream[List[LogEntry]]



   .. py:method:: get_robot_part_history(robot_part_id: str) -> List[RobotPartHistoryEntry]
      :async:


      Get a list containing the history of a robot part.

      ::

          part_history = await cloud.get_robot_part_history(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to retrieve history from.
      :type robot_part_id: str

      :raises GRPCError: If an invalid robot part ID is provided.

      :returns: The list of the robot part's history.
      :rtype: List[viam.app.app_client.RobotPartHistoryEntry]



   .. py:method:: update_robot_part(robot_part_id: str, name: str, robot_config: Optional[Mapping[str, Any]] = None) -> RobotPart
      :async:


      Change the name and assign an optional new configuration to a robot part.

      ::

          my_robot_part = await cloud.update_robot_part(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to update.
      :type robot_part_id: str
      :param name: New name to be updated on the robot part.
      :type name: str
      :param robot_config: Optional new config represented as a dictionary to be updated on the robot part. The robot
                           part's config will remain as is (no change) if one isn't passed.
      :type robot_config: Mapping[str, Any]

      :raises GRPCError: If either an invalid robot part ID, name, or config is passed.

      :returns: The newly updated robot part.
      :rtype: viam.app.app_client.RobotPart



   .. py:method:: new_robot_part(robot_id: str, part_name: str) -> str
      :async:


      Create a new robot part.

      ::

          new_part_id = await cloud.new_robot_part(
              robot_id="1a123456-x1yz-0ab0-a12xyzabc", part_name="myNewSubPart")

      :param robot_id: ID of the the robot to create a new part for.
      :type robot_id: str
      :param part_name: Name of the new part.
      :type part_name: str

      :raises GRPCError: If either an invalid robot ID or name is passed.

      :returns: The new robot part's ID.
      :rtype: str



   .. py:method:: delete_robot_part(robot_part_id: str) -> None
      :async:


      Delete the specified robot part.

      ::

          await cloud.delete_robot_part(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to delete. Must be specified.
      :type robot_part_id: str

      :raises GRPCError: If an invalid robot part ID is passed.



   .. py:method:: get_robot_api_keys(robot_id: str) -> List[viam.proto.app.APIKeyWithAuthorizations]
      :async:


      Gets the Robot API Keys for the robot.

      ::

          await cloud.get_robot_api_keys(robot_id="robot-id")

      :param robot_id: The ID of the robot
      :type robot_id: str

      :returns: The list of API keys.
      :rtype: List[APIKeyWithAuthorizations]



   .. py:method:: mark_part_as_main(robot_part_id: str) -> None
      :async:


      Mark a robot part as the main part of a robot.

      ::

          await cloud.mark_part_as_main(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to mark as main.
      :type robot_part_id: str

      :raises GRPCError: If an invalid robot part ID is passed.



   .. py:method:: mark_part_for_restart(robot_part_id: str) -> None
      :async:


      Mark the specified robot part for restart.

      ::

          await cloud.mark_part_for_restart(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to mark for restart.
      :type robot_part_id: str

      :raises GRPCError: If an invalid robot part ID is passed.



   .. py:method:: create_robot_part_secret(robot_part_id: str) -> RobotPart
      :async:


      Create a robot part secret.

      ::

          part_with_new_secret = await cloud.create_robot_part_secret(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22")

      :param robot_part_id: ID of the robot part to create a secret for.
      :type robot_part_id: str

      :raises GRPCError: If an invalid robot part ID is passed.

      :returns: The robot part the new secret was generated for.
      :rtype: viam.app.app_client.RobotPart



   .. py:method:: delete_robot_part_secret(robot_part_id: str, secret_id: str) -> None
      :async:


      Delete a robot part secret.

      ::

          await cloud.delete_robot_part_secret(
              robot_part_id="abc12345-1a23-1234-ab12-a22a22a2aa22",
              secret_id="123xyz12-abcd-4321-12ab-12xy1xyz12xy")

      :param robot_part_id: ID of the robot part to delete the secret from.
      :type robot_part_id: str
      :param secret_id: ID of the secret to delete.
      :type secret_id: str

      :raises GRPCError: If an invalid robot part ID or secret ID is passed.



   .. py:method:: list_robots(location_id: Optional[str] = None) -> List[viam.proto.app.Robot]
      :async:


      Get a list of all robots under the specified location.

      ::

          list_of_machines = await cloud.list_robots(location_id="123ab12345")

      :param location_id: ID of the location to retrieve the robots from. Defaults to the location ID provided at
                          `AppClient` instantiation.
      :type location_id: Optional[str]

      :raises GRPCError: If an invalid location ID is passed or one isn't passed and there was no location ID provided at `AppClient`
          instantiation.

      :returns: The list of robots.
      :rtype: List[viam.proto.app.Robot]



   .. py:method:: new_robot(name: str, location_id: Optional[str] = None) -> str
      :async:


      Create a new robot.

      ::

          new_machine_id = await cloud.new_robot(name="beepboop")

      :param name: Name of the new robot.
      :type name: str
      :param location_id: ID of the location under which to create the robot. Defaults to the current authorized location.
      :type location_id: Optional[str]

      :raises GRPCError: If an invalid location ID is passed or one isn't passed and there was no location ID provided at `AppClient`
          instantiation.

      :returns: The new robot's ID.
      :rtype: str



   .. py:method:: update_robot(robot_id: str, name: str, location_id: Optional[str] = None) -> viam.proto.app.Robot
      :async:


      Change the name of an existing robot.

      ::

          updated_robot = await cloud.update_robot(
              robot_id="1a123456-x1yz-0ab0-a12xyzabc",
              name="Orange-Robot")

      :param robot_id: ID of the robot to update.
      :type robot_id: str
      :param name: New name to be updated on the robot.
      :type name: str
      :param location_id: ID of the location under which the robot exists. Defaults to the location ID provided at
                          `AppClient` instantiation
      :type location_id: Optional[str]

      :raises GRPCError: If either an invalid robot ID, name, or location ID is passed or a location ID isn't passed and there was no location
          ID provided at `AppClient` instantiation.

      :returns: The newly updated robot.
      :rtype: viam.proto.app.Robot



   .. py:method:: delete_robot(robot_id: str) -> None
      :async:


      Delete the specified robot.

      ::

          await cloud.delete_robot(robot_id="1a123456-x1yz-0ab0-a12xyzabc")

      :param robot_id: ID of the robot to delete.
      :type robot_id: str

      :raises GRPCError: If an invalid robot ID is passed.



   .. py:method:: list_fragments(org_id: str, show_public: bool = True) -> List[Fragment]
      :async:


      Get a list of fragments under the currently authed-to organization.

      ::

          fragments_list = await cloud.list_fragments(org_id="org-id", show_public=False)

      :param org_id: The ID of the organization to list fragments for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param show_public: Optional boolean specifying whether or not to only show public fragments. If True, only public fragments will
                          return. If False, only private fragments will return. Defaults to True.

      :returns: The list of fragments.
      :rtype: List[viam.app.app_client.Fragment]



   .. py:method:: get_fragment(fragment_id: str) -> Fragment
      :async:


      Get a fragment.

      ::

          # Get a fragment and print its name and when it was created.
          the_fragment = await cloud.get_fragment(
              fragment_id="12a12ab1-1234-5678-abcd-abcd01234567")
          print("Name: ", the_fragment.name, "\nCreated on: ", the_fragment.created_on)

      :param fragment_id: ID of the fragment to get.
      :type fragment_id: str

      :raises GRPCError: If an invalid fragment ID is passed.

      :returns: The fragment.
      :rtype: viam.app.app_client.Fragment



   .. py:method:: create_fragment(org_id: str, name: str, config: Optional[Mapping[str, Any]] = None) -> Fragment
      :async:


      Create a new private fragment.

      ::

          new_fragment = await cloud.create_fragment(org_id="org-id", name="cool_smart_machine_to_configure_several_of")

      :param org_id: The ID of the organization to create the fragment within.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param name: Name of the fragment.
      :type name: str
      :param config: Optional Dictionary representation of new config to assign to specified fragment. Can be
                     assigned by updating the fragment.
      :type config: Optional[Mapping[str, Any]]

      :raises GRPCError: If an invalid name is passed.

      :returns: The newly created fragment.
      :rtype: viam.app.app_client.Fragment



   .. py:method:: update_fragment(fragment_id: str, name: str, config: Optional[Mapping[str, Any]] = None, public: Optional[bool] = None) -> Fragment
      :async:


      Update a fragment name AND its config and/or visibility.

      ::

          updated_fragment = await cloud.update_fragment(
              fragment_id="12a12ab1-1234-5678-abcd-abcd01234567",
              name="better_name")

      :param fragment_id: ID of the fragment to update.
      :type fragment_id: str
      :param name: New name to associate with the fragment.
      :type name: str
      :param config: Optional Dictionary representation of new config to assign to specified fragment. Not
                     passing this parameter will leave the fragment's config unchanged.
      :type config: Optional[Mapping[str, Any]]
      :param public: Boolean specifying whether the fragment is public. Not passing this parameter will leave the fragment's
                     visibility unchanged. A fragment is private by default when created.
      :type public: bool

      :raises GRPCError: if an invalid ID, name, or config is passed.

      :returns: The newly updated fragment.
      :rtype: viam.app.app_client.Fragment



   .. py:method:: delete_fragment(fragment_id: str) -> None
      :async:


      Delete a fragment.

      ::

          await cloud.delete_fragment(
              fragment_id="12a12ab1-1234-5678-abcd-abcd01234567")

      :param fragment_id: ID of the fragment to delete.
      :type fragment_id: str

      :raises GRPCError: If an invalid fragment ID is passed.



   .. py:method:: add_role(org_id: str, identity_id: str, role: Union[Literal['owner'], Literal['operator']], resource_type: Union[Literal['organization'], Literal['location'], Literal['robot']], resource_id: str) -> None
      :async:


      Add a role under the currently authed-to organization.

      ::

          await cloud.add_role(
              org_id="org-id",
              identity_id="abc01234-0123-4567-ab12-a11a00a2aa22",
              role="owner",
              resource_type="location",
              resource_id="111ab12345")

      :param org_id: The ID of the organization to create the role in.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param identity_id: ID of the entity the role belongs to (e.g., a user ID).
      :type identity_id: str
      :param role: The role to add.
      :type role: Union[Literal["owner"], Literal["operator"]]
      :param resource_type: Type of the resource to add role to.
                            Must match `resource_id`.
      :type resource_type: Union[Literal["organization"], Literal["location"], Literal["robot"]]
      :param resource_id: ID of the resource the role applies to (i.e., either an organization, location, or robot ID).
      :type resource_id: str

      :raises GRPCError: If either an invalid identity ID, role ID, resource type, or resource ID is passed.



   .. py:method:: remove_role(org_id: str, identity_id: str, role: Union[Literal['owner'], Literal['operator']], resource_type: Union[Literal['organization'], Literal['location'], Literal['robot']], resource_id: str) -> None
      :async:


      Remove a role under the currently authed-to organization.

      ::

          await cloud.remove_role(
              org_id="org-id",
              identity_id="abc01234-0123-4567-ab12-a11a00a2aa22",
              role="owner",
              resource_type="location",
              resource_id="111ab12345")

      :param org_id: The ID of the organization the role exists in.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param identity_id: ID of the entity the role belongs to (e.g., a user ID).
      :type identity_id: str
      :param role: The role to remove.
      :type role: Union[Literal["owner"], Literal["operator"]]
      :param resource_type: Type of the resource the role is being
                            removed from. Must match `resource_id`.
      :type resource_type: Union[Literal["organization"], Literal["location"], Literal["robot"]]
      :param resource_id: ID of the resource the role applies to (i.e., either an organization, location, or robot ID).
      :type resource_id: str

      :raises GRPCError: If either an invalid identity ID, role ID, resource type, or resource ID or is passed.



   .. py:method:: change_role(organization_id: str, old_identity_id: str, old_role: Union[Literal['owner'], Literal['operator']], old_resource_type: Union[Literal['organization'], Literal['location'], Literal['robot']], old_resource_id: str, new_identity_id: str, new_role: Union[Literal['owner'], Literal['operator']], new_resource_type: Union[Literal['organization'], Literal['location'], Literal['robot']], new_resource_id: str) -> None
      :async:


      Changes a role to a new role.

      ::

          await cloud.change_role(
              organization_id="organization-id",
              old_identity_id="abc01234-0123-4567-ab12-a11a00a2aa22",
              old_role="operator",
              old_resource_type="location",
              old_resource_id="111ab12345",
              new_identity_id="abc01234-0123-4567-ab12-a11a00a2aa22",
              new_role="owner",s
              new_resource_type="organization",
              new_resource_id="abc12345")

      :param organization_id: ID of the organization
      :type organization_id: str
      :param old_identity_id: ID of the entity the role belongs to (e.g., a user ID).
      :type old_identity_id: str
      :param old_role: The role to be changed.
      :type old_role: Union[Literal["owner"], Literal["operator"]]
      :param old_resource_type: Type of the resource the role is
                                added to. Must match `old_resource_id`.
      :type old_resource_type: Union[Literal["organization"], Literal["location"], Literal["robot"]]
      :param old_resource_id: ID of the resource the role applies to (i.e., either an organization, location, or robot ID).
      :type old_resource_id: str
      :param new_identity_id: New ID of the entity the role blongs to (e.g., a user ID).
      :type new_identity_id: str
      :param new_role: The new role.
      :type new_role: Union[Literal["owner"], Literal["operator"]]
      :param new_resource_type: Type of the resource to add role to.
                                Must match `new_resource_id`.
      :type new_resource_type: Union[Literal["organization"], Literal["location"], Literal["robot"]]
      :param new_resource_id: New ID of the resource the role applies to (i.e., either an organization, location, or robot ID).
      :type new_resource_id: str



   .. py:method:: list_authorizations(org_id: str, resource_ids: Optional[List[str]] = None) -> List[viam.proto.app.Authorization]
      :async:


      List all authorizations under a specific resource (or resources) within the currently authed-to organization. If no resource IDs
      are provided, all resource authorizations within the organizations are returned.

      ::

          list_of_auths = await cloud.list_authorizations(
              org_id="org-id",
              resource_ids=["1a123456-x1yz-0ab0-a12xyzabc"])

      :param org_id: The ID of the organization to list authorizations for.
      :param resource_ids: IDs of the resources to retrieve authorizations from.
                           If None, defaults to all resources.
      :type resource_ids: Optional[List[str]]

      :raises GRPCError: If an invalid resource ID is passed.

      :returns: The list of authorizations.
      :rtype: List[viam.proto.app.Authorization]



   .. py:method:: check_permissions(permissions: List[viam.proto.app.AuthorizedPermissions]) -> List[viam.proto.app.AuthorizedPermissions]
      :async:


      Checks validity of a list of permissions.

      ::

          from viam.proto.app import AuthorizedPermissions

          # Check whether the entity you're currently authenticated to has permission to control and/or
          # read logs from robots in the "organization-identifier123" org
          permissions = [AuthorizedPermissions(resource_type="organization",
                                               resource_id="organization-identifier123",
                                               permissions=["control_robot",
                                                            "read_robot_logs"])]

          filtered_permissions = await cloud.check_permissions(permissions)

      :param permissions: the permissions to validate
                          (e.g., "read_organization", "control_robot")
      :type permissions: List[viam.proto.app.AuthorizedPermissions]

      :raises GRPCError: If the list of permissions to validate is empty.

      :returns: The permissions argument, with invalid permissions filtered out.
      :rtype: List[viam.proto.app.AuthorizedPermissions]



   .. py:method:: get_registry_item(item_id: str) -> viam.proto.app.RegistryItem
      :async:


      Get registry item by ID.

      ::

          item = await cloud.get_registry_item("item-id")

      :param item_id: The ID of the registry item.
      :type item_id: str

      :returns: The registry item.
      :rtype: RegistryItem



   .. py:method:: create_registry_item(organization_id: str, name: str, type: viam.proto.app.packages.PackageType.ValueType) -> None
      :async:


      Create a registry item

      ::

          await cloud.create_registry_item("org-id", "name", PackageType.PACKAGE_TYPE_ML_MODEL)

      :param organization_id: The organization to create the registry item under.
      :type organization_id: str
      :param name: The name of the registry item, which must be unique within your org.
      :type name: str
      :param type: The type of the item in the registry.
      :type type: PackageType.ValueType



   .. py:method:: update_registry_item(item_id: str, type: viam.proto.app.packages.PackageType.ValueType, description: str, visibility: viam.proto.app.Visibility.ValueType) -> None
      :async:


      Update a registry item.

      ::

          await cloud.update_registry_item("item-id", PackageType.PACKAGE_TYPE_ML_TRAINING, "description", Visibility.VISIBILITY_PUBLIC)

      :param item_id: The ID of the registry item.
      :type item_id: str
      :param type: The type of the item in the registry.
      :type type: PackageType.ValueType
      :param description: The description of the registry item.
      :type description: str
      :param visibility: The visibility of the registry item.
      :type visibility: Visibility.ValueType



   .. py:method:: list_registry_items(organization_id: str, types: List[viam.proto.app.packages.PackageType.ValueType], visibilities: List[viam.proto.app.Visibility.ValueType], platforms: List[str], statuses: List[viam.proto.app.RegistryItemStatus.ValueType], search_term: Optional[str] = None, page_token: Optional[str] = None) -> List[viam.proto.app.RegistryItem]
      :async:


      List the registry items in an organization.

      :param organization_id: The ID of the organization to return registry items for.
      :type organization_id: str
      :param types: The types of registry items.
      :type types: List[PackageType.ValueType]
      :param visibilities: The visibilities of registry items.
      :type visibilities: List[Visibility.ValueType]
      :param platforms: The platforms of registry items.
      :type platforms: List[str]
      :param statuses: The types of the items in the registry.
      :type statuses: List[RegistryItemStatus.ValueType]
      :param search_term: The search term of the registry items.
      :type search_term: Optional[str]
      :param page_token: The page token of the registry items.
      :type page_token: Optional[str]

      :returns: The list of registry items.
      :rtype: List[RegistryItem]



   .. py:method:: delete_registry_item(item_id: str) -> None
      :async:


      Delete a registry item

      ::

          await cloud.delete_registry_item("item-id")

      :param item_id: The ID of the registry item.
      :type item_id: str



   .. py:method:: create_module(org_id: str, name: str) -> Tuple[str, str]
      :async:


      Create a module under the currently authed-to organization.

      ::

          new_module = await cloud.create_module(org_id="org-id", name="cool_new_hoverboard_module")
          print("Module ID:", new_module[0])

      :param org_id: The ID of the organization to create the module under.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param name: The name of the module. Must be unique within your organization.
      :type name: str

      :raises GRPCError: If an invalid name (e.g., "") is passed.

      :returns: A tuple containing the ID [0] of the new module and its URL [1].
      :rtype: Tuple[str, str]



   .. py:method:: update_module(module_id: str, url: str, description: str, models: Optional[List[viam.proto.app.Model]], entrypoint: str, public: bool = False) -> str
      :async:


      Update the documentation URL, description, models, entrypoint, and/or the visibility of a module.

      ::

          url_of_my_module = await cloud.update_module(
              module_id="my-group:cool_new_hoverboard_module",
              url="https://docsformymodule.viam.com",
              description="A base to support hoverboards.",
              entrypoint="exec")

      :param module_id: ID of the module being updated, containing module name (e.g., "my-module") or namespace and module name (e.g.,
                        "my-org:my-module").
      :type module_id: str
      :param url: The url to reference for documentation and code (NOT the url of the module itself).
      :type url: str
      :param description: A short description of the module that explains its purpose.
      :type description: str
      :param models: list of models that are available in the module.
      :type models: Optional[List[viam.proto.app.Model]]
      :param entrypoint: The executable to run to start the module program.
      :type entrypoint: str
      :param public: The visibility that should be set for the module. Defaults to False (private).
      :type public: bool

      :raises GRPCError: If either an invalid module ID, URL, list of models, or organization ID is passed.

      :returns: The URL of the newly updated module.
      :rtype: str



   .. py:method:: upload_module_file(module_file_info: Optional[viam.proto.app.ModuleFileInfo], file: bytes) -> str
      :async:


      Upload a module file

      ::

          file_id = await cloud.upload_module_file(file=b"<file>")

      :param module_file_info: Relevant metadata.
      :type module_file_info: Optional[viam.proto.app.ModuleFileInfo]
      :param file: Bytes of file to upload.
      :type file: bytes

      :returns: ID of uploaded file.
      :rtype: str



   .. py:method:: get_module(module_id: str) -> viam.proto.app.Module
      :async:


      Get a module.

      ::

          the_module = await cloud.get_module(module_id="my-cool-modular-base")

      :param module_id: ID of the module being retrieved, containing module name or namespace and module name.
      :type module_id: str

      :raises GRPCError: If an invalid module ID is passed.

      :returns: The module.
      :rtype: viam.proto.app.Module



   .. py:method:: list_modules(org_id: str) -> List[viam.proto.app.Module]
      :async:


      List the modules under the currently authed-to organization.

      ::

          modules_list = await cloud.list_modules("org-id")

      :param org_id: The ID of the organization to list modules for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str

      :returns: The list of modules.
      :rtype: List[viam.proto.app.Module]



   .. py:method:: create_key(org_id: str, authorizations: List[APIKeyAuthorization], name: Optional[str] = None) -> Tuple[str, str]
      :async:


      Creates a new API key.

      ::

          from viam.app.app_client import APIKeyAuthorization

          auth = APIKeyAuthorization(
          role="owner",
          resource_type="robot",
          resource_id="your-robot-id123"
          )

          api_key, api_key_id = cloud.create_key([auth], "my_key")

      :param org_id: The ID of the organization to create the key for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str
      :param authorizations: A list of authorizations to associate
                             with the key.
      :type authorizations: List[viam.proto.app.Authorization]
      :param name: A name for the key. If None, defaults to the current timestamp.
      :type name: Optional[str]

      :raises GRPCError: If the authorizations list is empty.

      :returns: The api key and api key ID.
      :rtype: Tuple[str, str]



   .. py:method:: delete_key(id: str) -> None
      :async:


      Delete a API key.

      ::

          await cloud.delete_key("key-id")

      :param id: The ID of the API key.
      :type id: str



   .. py:method:: create_key_from_existing_key_authorizations(id: str) -> Tuple[str, str]
      :async:


      Creates a new API key with an existing key's authorizations

      ::

          api_key, api_key_id = await cloud.create_key_from_existing_key_authorizations(
              id="INSERT YOUR API KEY ID")

      :param id: the ID of the API key to duplication authorizations from
      :type id: str

      :returns: The API key and API key id
      :rtype: Tuple[str, str]



   .. py:method:: list_keys(org_id: str) -> List[viam.proto.app.APIKeyWithAuthorizations]
      :async:


      Lists all keys for the currently-authed-to org.

      ::

          keys = await cloud.list_keys()

      :param org_id: The ID of the organization to list API keys for.
                     You can obtain your organization ID from the Viam app's organization settings page.
      :type org_id: str

      :returns: The existing API keys and authorizations.
      :rtype: List[viam.proto.app.APIKeyWithAuthorizations]



   .. py:method:: rotate_key(id: str) -> Tuple[str, str]
      :async:


      Rotate an API key.

      ::

          id, key = await cloud.rotate_key("key-id")

      :param id: The ID of the key to be rotated.
      :type id: str

      :returns: The API key and API key id
      :rtype: Tuple[str, str]



