viam.module.module
==================

.. py:module:: viam.module.module


Attributes
----------

.. autoapisummary::

   viam.module.module.RESOURCE_TYPE_COMPONENT
   viam.module.module.RESOURCE_TYPE_SERVICE
   viam.module.module.LOGGER


Exceptions
----------

.. autoapisummary::

   viam.module.module.ResourceNotFoundError
   viam.module.module.ValidationError


Classes
-------

.. autoapisummary::

   viam.module.module.ComponentConfig
   viam.module.module.AddResourceRequest
   viam.module.module.HandlerDefinition
   viam.module.module.HandlerMap
   viam.module.module.ReadyRequest
   viam.module.module.ReadyResponse
   viam.module.module.ReconfigureResourceRequest
   viam.module.module.RemoveResourceRequest
   viam.module.module.ValidateConfigRequest
   viam.module.module.ValidateConfigResponse
   viam.module.module.ResourceRPCSubtype
   viam.module.module.ResourceBase
   viam.module.module.Registry
   viam.module.module.Model
   viam.module.module.ResourceName
   viam.module.module.Subtype
   viam.module.module.RobotClient
   viam.module.module.DialOptions
   viam.module.module.Server
   viam.module.module.ModuleRPCService
   viam.module.module.Reconfigurable
   viam.module.module.Stoppable
   viam.module.module.Module


Functions
---------

.. autoapisummary::

   viam.module.module.resource_name_from_string


Module Contents
---------------

.. py:exception:: ResourceNotFoundError(resource: str, name: str)

   Bases: :py:obj:`ViamGRPCError`


   Exception raised when a resource is not found in the registry


.. py:exception:: ValidationError(message: str)

   Bases: :py:obj:`ViamGRPCError`


   Exception raised when there is an error during module validation


.. py:class:: ComponentConfig(*, name: str = ..., namespace: str = ..., type: str = ..., model: str = ..., frame: global___Frame | None = ..., depends_on: collections.abc.Iterable[str] | None = ..., service_configs: collections.abc.Iterable[global___ResourceLevelServiceConfig] | None = ..., attributes: google.protobuf.struct_pb2.Struct | None = ..., api: str = ..., log_configuration: global___LogConfiguration | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: namespace
      :type:  str

      deprecated; use api


   .. py:attribute:: type
      :type:  str

      deprecated; use api


   .. py:attribute:: model
      :type:  str


   .. py:attribute:: api
      :type:  str


   .. py:property:: frame
      :type: global___Frame



   .. py:property:: depends_on
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:property:: service_configs
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ResourceLevelServiceConfig]



   .. py:property:: attributes
      :type: google.protobuf.struct_pb2.Struct



   .. py:property:: log_configuration
      :type: global___LogConfiguration



   .. py:method:: HasField(field_name: Literal['attributes', b'attributes', 'frame', b'frame', 'log_configuration', b'log_configuration']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: AddResourceRequest(*, config: viam.gen.app.v1.robot_pb2.ComponentConfig | None = ..., dependencies: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: config
      :type: viam.gen.app.v1.robot_pb2.ComponentConfig



   .. py:property:: dependencies
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:method:: HasField(field_name: Literal['config', b'config']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: HandlerDefinition(*, subtype: viam.gen.robot.v1.robot_pb2.ResourceRPCSubtype | None = ..., models: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: subtype
      :type: viam.gen.robot.v1.robot_pb2.ResourceRPCSubtype



   .. py:property:: models
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:method:: HasField(field_name: Literal['subtype', b'subtype']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: HandlerMap(*, handlers: collections.abc.Iterable[global___HandlerDefinition] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: handlers
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___HandlerDefinition]



.. py:class:: ReadyRequest(*, parent_address: str = ..., webrtc_offer: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: parent_address
      :type:  str


   .. py:attribute:: webrtc_offer
      :type:  str


.. py:class:: ReadyResponse(*, ready: bool = ..., handlermap: global___HandlerMap | None = ..., webrtc_answer: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: ready
      :type:  bool


   .. py:attribute:: webrtc_answer
      :type:  str


   .. py:property:: handlermap
      :type: global___HandlerMap



   .. py:method:: HasField(field_name: Literal['handlermap', b'handlermap']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ReconfigureResourceRequest(*, config: viam.gen.app.v1.robot_pb2.ComponentConfig | None = ..., dependencies: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: config
      :type: viam.gen.app.v1.robot_pb2.ComponentConfig



   .. py:property:: dependencies
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:method:: HasField(field_name: Literal['config', b'config']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RemoveResourceRequest(*, name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


.. py:class:: ValidateConfigRequest(*, config: viam.gen.app.v1.robot_pb2.ComponentConfig | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: config
      :type: viam.gen.app.v1.robot_pb2.ComponentConfig



   .. py:method:: HasField(field_name: Literal['config', b'config']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ValidateConfigResponse(*, dependencies: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: dependencies
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



.. py:class:: ResourceRPCSubtype(*, subtype: viam.gen.common.v1.common_pb2.ResourceName | None = ..., proto_service: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: proto_service
      :type:  str


   .. py:property:: subtype
      :type: viam.gen.common.v1.common_pb2.ResourceName



   .. py:method:: HasField(field_name: Literal['subtype', b'subtype']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ResourceBase

   Bases: :py:obj:`Protocol`


   The base requirements for a Resource.


   .. py:attribute:: SUBTYPE
      :type:  ClassVar[viam.resource.types.Subtype]

      The Subtype of the Resource


   .. py:attribute:: name
      :type:  str

      The name of the Resource


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      :abstractmethod:


      Get the Resource named ``name`` from the provided robot.

      ::

          # Can be used with any resource, using an arm as an example
          my_arm = Arm.from_robot(robot, "my_arm")

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the Resource
      :type name: str

      :returns: The Resource, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: Registry

   The global registry of robotic parts.

   **NB** The Registry should almost never be used directly

   The Registry keeps track of the types of Resources that are available on robots using this SDK. All the base resource types are
   pre-registered (for example Arm, Motor).

   If you create a new resource type that is not an extension of any of the existing base resource types, then you must register said
   resource using ``Registry.register(...)``.


   .. py:method:: register_subtype(registration: ResourceRegistration[Resource])
      :classmethod:


      Register a Subtype with the Registry

      :param registration: Object containing registration data for the subtype
      :type registration: ResourceRegistration

      :raises DuplicateResourceError: Raised if the Subtype to register is already in the registry
      :raises ValidationError: Raised if registration is missing any necessary parameters



   .. py:method:: register_resource_creator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model, registration: ResourceCreatorRegistration)
      :classmethod:


      Register a specific ``Model`` and validator function for the specific resource ``Subtype`` with the Registry

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model
      :param registration: The registration functions of the model
      :type registration: ResourceCreatorRegistration

      :raises DuplicateResourceError: Raised if the Subtype and Model pairing is already registered
      :raises ValidationError: Raised if registration does not have creator



   .. py:method:: lookup_subtype(subtype: viam.resource.types.Subtype) -> ResourceRegistration
      :classmethod:


      Lookup and retrieve a registered Subtype by its name

      :param subtype: The subtype of the resource
      :type subtype: str

      :raises ResourceNotFoundError: Raised if the Subtype is not registered

      :returns: The registration object of the resource
      :rtype: ResourceRegistration



   .. py:method:: lookup_resource_creator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model) -> viam.resource.types.ResourceCreator
      :classmethod:


      Lookup and retrieve a registered resource creator by its subtype and model

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model

      :raises ResourceNotFoundError: Raised if the Subtype Model pairing is not registered

      :returns: The function to create the resource
      :rtype: ResourceCreator



   .. py:method:: lookup_validator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model) -> viam.resource.types.Validator
      :classmethod:


      Lookup and retrieve a registered validator function by its subtype and model. If there is none, return None

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model

      :returns: The function to validate the resource
      :rtype: Validator



   .. py:method:: REGISTERED_SUBTYPES() -> Mapping[viam.resource.types.Subtype, ResourceRegistration]
      :classmethod:


      The dictionary of all registered resources
      - Key: Subtype of the resource
      - Value: The registration object for the resource

      :returns: All registered resources
      :rtype: Mapping[Subtype, ResourceRegistration]



   .. py:method:: REGISTERED_RESOURCE_CREATORS() -> Mapping[str, ResourceCreatorRegistration]
      :classmethod:


      The dictionary of all registered resources
      - Key: subtype/model
      - Value: The ResourceCreatorRegistration for the resource

      :returns: All registered resources
      :rtype: Mapping[str, ResourceCreatorRegistration]



.. py:data:: RESOURCE_TYPE_COMPONENT
   :value: 'component'


.. py:data:: RESOURCE_TYPE_SERVICE
   :value: 'service'


.. py:class:: Model(model_family: ModelFamily, name: str)

   Represents a specific model within a family of models


   .. py:attribute:: model_family
      :type:  ModelFamily

      The family to which this model belongs


   .. py:attribute:: name
      :type:  str

      The name of the model


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __hash__() -> int

      Return hash(self).



   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: from_string(model: str, *, ignore_errors=False) -> typing_extensions.Self
      :classmethod:


      Create a ```Model``` from its string representation (namespace:family:name).

      :param model: The Model as a string
      :type model: str
      :param ignore_errors: If namespace or family are not found in the string, default to empty string
                            rather than raise an exception. Defaults to False.
      :type ignore_errors: bool, optional

      :raises ValueError: Raised if the provided string is not a valid Model

      :returns: The Model
      :rtype: Self



.. py:class:: ResourceName(*, namespace: str = ..., type: str = ..., subtype: str = ..., name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: namespace
      :type:  str


   .. py:attribute:: type
      :type:  str


   .. py:attribute:: subtype
      :type:  str


   .. py:attribute:: name
      :type:  str


.. py:class:: Subtype(namespace: str, resource_type: str, resource_subtype: str)

   Represents a known component/service (resource) API


   .. py:attribute:: namespace
      :type:  str

      The namespace of the resource


   .. py:attribute:: resource_type
      :type:  str

      The type of the resource, for example `component` or `service`


   .. py:attribute:: resource_subtype
      :type:  str

      The subtype of the resource for example `servo`, `arm`, `vision`


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __hash__() -> int

      Return hash(self).



   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: from_resource_name(resource_name: viam.proto.common.ResourceName) -> typing_extensions.Self
      :classmethod:


      Convert a ```ResourceName``` into a ```Subtype```

      :param resource_name: The ResourceName to convert
      :type resource_name: viam.proto.common.ResourceName

      :returns: A new Subtype
      :rtype: Self



   .. py:method:: from_string(string: str) -> typing_extensions.Self
      :classmethod:


      Create a ```Subtype``` from its string representation (namespace:resource_type:resource_subtype)

      :param string: The Subtype as a string
      :type string: str

      :raises ValueError: Raised if the string does not represent a valid Subtype

      :returns: A new Subtype
      :rtype: Self



.. py:function:: resource_name_from_string(string: str) -> viam.proto.common.ResourceName

   Create a ResourceName from its string representation (namespace:resource_type:resource_subtype/<optional_remote:>name)

   :param string: The ResourceName as a string
   :type string: str

   :raises ValueError: Raised if the provided string is not a valid ResourceName

   :returns: The new ResourceName
   :rtype: viam.proto.common.ResourceName


.. py:class:: RobotClient

   gRPC client for a Robot. This class should be used for all interactions with a robot.

   There are 2 ways to instantiate a robot client::

       RobotClient.at_address(...)
       RobotClient.with_channel(...)

   You can use the client standalone or within a context::

       robot = await RobotClient.at_address(...)
       async with await RobotClient.with_channel(...) as robot: ...

   You must ``close()`` the robot to release resources.

   Note: Robots used within a context are automatically closed UNLESS created with a channel. Robots created using ``with_channel`` are
   not automatically closed.

   Establish a Connection::

       import asyncio

       from viam.rpc.dial import DialOptions, Credentials
       from viam.robot.client import RobotClient


       async def connect():
           opts = RobotClient.Options.with_api_key(
               # Replace "<API-KEY>" (including brackets) with your machine's API key
               api_key='<API-KEY>',
               # Replace "<API-KEY-ID>" (including brackets) with your machine's API key ID
               api_key_id='<API-KEY-ID>'
           )
           return await RobotClient.at_address('<ADDRESS-FROM-THE-VIAM-APP>', opts)


       async def main():
           # Make a RobotClient
           robot = await connect()
           print('Resources:')
           print(robot.resource_names)
           await robot.close()

       if __name__ == '__main__':
           asyncio.run(main())


   .. py:class:: Options

      .. py:attribute:: refresh_interval
         :type:  int
         :value: 0


         How often to refresh the status/parts of the robot in seconds.
         If not set, the robot will not be refreshed automatically


      .. py:attribute:: dial_options
         :type:  Optional[viam.rpc.dial.DialOptions]
         :value: None


         Options used to connect clients to gRPC servers


      .. py:attribute:: log_level
         :type:  int

         The log level to output


      .. py:attribute:: check_connection_interval
         :type:  int
         :value: 10


         The frequency (in seconds) at which to check if the robot is still connected. 0 (zero) signifies no connection checks


      .. py:attribute:: attempt_reconnect_interval
         :type:  int
         :value: 1


         The frequency (in seconds) at which to attempt to reconnect a disconnected robot. 0 (zero) signifies no reconnection attempts


      .. py:attribute:: disable_sessions
         :type:  bool
         :value: False


         Whether sessions are disabled


      .. py:method:: with_api_key(api_key: str, api_key_id: str, **kwargs) -> typing_extensions.Self
         :classmethod:


         Create RobotClient.Options with an API key for credentials and default values for other arguments.

         ::

             # Replace "<API-KEY>" (including brackets) with your machine's API key
             api_key = '<API-KEY>'
             # Replace "<API-KEY-ID>" (including brackets) with your machine's API key ID
             api_key_id = '<API-KEY-ID>'

             opts = RobotClient.Options.with_api_key(api_key, api_key_id)

             robot = await RobotClient.at_address('<ADDRESS-FROM-THE-VIAM-APP>', opts)

         :param api_key: your API key
         :type api_key: str
         :param api_key_id: your API key ID. Must be a valid UUID
         :type api_key_id: str

         :raises ValueError: Raised if the api_key_id is not a valid UUID

         :returns: the RobotClient.Options
         :rtype: Self




   .. py:method:: at_address(address: str, options: Options) -> typing_extensions.Self
      :classmethod:

      :async:


      Create a robot client that is connected to the robot at the provided address.

      ::

          async def connect():

              opts = RobotClient.Options.with_api_key(
                  # Replace "<API-KEY>" (including brackets) with your machine's API key
                  api_key='<API-KEY>',
                  # Replace "<API-KEY-ID>" (including brackets) with your machine's API key ID
                  api_key_id='<API-KEY-ID>'
              )
              return await RobotClient.at_address('ADDRESS FROM THE VIAM APP', opts)


          async def main():
              # Make a RobotClient
              robot = await connect()

      :param address: Address of the robot (IP address, URL, etc.)
      :type address: str
      :param options: Options for connecting and refreshing
      :type options: Options

      :returns: the RobotClient
      :rtype: Self



   .. py:method:: with_channel(channel: Union[grpclib.client.Channel, viam.rpc.dial.ViamChannel], options: Options) -> typing_extensions.Self
      :classmethod:

      :async:


      Create a robot that is connected to a robot over the given channel.

      Any robots created using this method will *NOT* automatically close the channel upon exit.

      ::

          from viam.robot.client import RobotClient
          from viam.rpc.dial import DialOptions, dial


          async def connect_with_channel() -> RobotClient:
              async with await dial('ADDRESS', DialOptions()) as channel:
                  return await RobotClient.with_channel(channel, RobotClient.Options())

          robot = await connect_with_channel()

      :param channel: The channel that is connected to a robot, obtained by ``viam.rpc.dial``
      :type channel: ViamChannel
      :param options: Options for refreshing. Any connection options will be ignored.
      :type options: Options

      :returns: the RobotClient
      :rtype: Self



   .. py:method:: refresh()
      :async:


      Manually refresh the underlying parts of this robot

      ::

          await robot.refresh()



   .. py:method:: get_component(name: viam.proto.common.ResourceName) -> viam.components.component_base.ComponentBase

      Get a component using its ResourceName.

      This function should not be called directly except in specific cases. The method ``Component.from_robot(...)`` is the preferred
      method for obtaining components.
      ::

          arm = Arm.from_robot(robot=robot, name="my_arm")

      Because this function returns a generic ``ComponentBase`` rather than the specific
      component type, it will be necessary to cast the returned component to the desired component. This can be done using a few
      different methods:

      - Assertion::

          arm = robot.get_component(Arm.get_resource_name("my_arm"))
          assert isinstance(arm, Arm)
          end_pos = await arm.get_end_position()

      - Explicit cast::

          from typing import cast
          arm = robot.get_component(Arm.get_resource_name("my_arm"))
          arm = cast(Arm, arm)
          end_pos = await arm.get_end_position()

      - Declare type on variable assignment.

          - Note: If using an IDE, a type error may be shown which can be ignored.
          ::

              arm: Arm = robot.get_component(Arm.get_resource_name("my_arm"))  # type: ignore
              end_pos = await arm.get_end_position()

      :param name: The component's ResourceName
      :type name: viam.proto.common.ResourceName

      :raises ValueError: Raised if the requested resource is not a component
      :raises ComponentNotFoundError: Error if component with the given type and name does not exist in the registry

      :returns: The component
      :rtype: ComponentBase



   .. py:method:: get_service(name: viam.proto.common.ResourceName) -> viam.services.service_base.ServiceBase

      Get a service using its ResourceName

      This function should not be called directly except in specific cases. The method ``Service.from_robot(...)`` is the preferred
      method for obtaining services.
      ::

          service = MyService.from_robot(robot=robot, name="my_service")

      Because this function returns a generic ``ServiceBase`` rather than a specific service type, it will be necessary to cast the
      returned service to the desired service. This can be done using a few methods:

      - Assertion::

          service = robot.get_service(MyService.get_resource_name("my_service"))
          assert isinstance(service, MyService)

      - Explicit cast::

          from typing import cast
          service = robot.get_service(MyService.get_resource_name("my_service"))
          service = cast(MyService, my_service)

      - Declare type on variable assignment

          - Note: If using an IDE, a type error may be shown which can be ignored.
          ::

              service: MyService = robot.get_service(MyService.get_resource_name("my_service"))  # type: ignore

      :param name: The service's ResourceName
      :type name: viam.proto.common.ResourceName

      :raises ValueError: Raised if the requested resource is not a component
      :raises ComponentNotFoundError: Error if component with the given type and name does not exist in the registry

      :returns: The service
      :rtype: ServiceBase



   .. py:property:: resource_names
      :type: List[viam.proto.common.ResourceName]

      Get a list of all resource names

      ::

          resource_names = robot.resource_names

      :returns: The list of resource names
      :rtype: List[viam.proto.common.ResourceName]


   .. py:method:: close()
      :async:


      Cleanly close the underlying connections and stop any periodic tasks.

      ::

          await robot.close()



   .. py:method:: __aenter__()
      :async:



   .. py:method:: __aexit__(exc_type, exc_value, traceback)
      :async:



   .. py:method:: get_status(components: Optional[List[viam.proto.common.ResourceName]] = None)
      :async:


      Get the status of the robot's components. You can optionally
      provide a list of ``ResourceName`` for which you want statuses.

      ::

          # Get the status of the resources on the machine.
          statuses = await robot.get_status()

      :param components: Optional list of
                         ``ResourceName`` for components you want statuses.
      :type components: Optional[List[viam.proto.common.ResourceName]]



   .. py:method:: get_operations() -> List[viam.proto.robot.Operation]
      :async:


      Get the list of operations currently running on the robot.

      ::

          operations = await robot.get_operations()

      :returns: The list of operations currently running on a given robot.
      :rtype: List[viam.proto.robot.Operation]



   .. py:method:: cancel_operation(id: str)
      :async:


      Cancels the specified operation on the robot.

      ::

          await robot.cancel_operation("INSERT OPERATION ID")

      :param id: ID of operation to cancel.
      :type id: str



   .. py:method:: block_for_operation(id: str)
      :async:


      Blocks on the specified operation on the robot. This function will only return when the specific operation
      has finished or has been cancelled.

      ::

          await robot.block_for_operation("INSERT OPERATION ID")

      :param id: ID of operation to block on.
      :type id: str



   .. py:method:: get_frame_system_config(additional_transforms: Optional[List[viam.proto.common.Transform]] = None) -> List[viam.proto.robot.FrameSystemConfig]
      :async:


      Get the configuration of the frame system of a given robot.

      ::

          # Get a list of each of the reference frames configured on the machine.
          frame_system = await robot.get_frame_system_config()
          print(f"frame system configuration: {frame_system}")

      :returns: The configuration of a given robot's frame system.
      :rtype: List[viam.proto.robot.FrameSystemConfig]



   .. py:method:: transform_pose(query: viam.proto.common.PoseInFrame, destination: str, additional_transforms: Optional[List[viam.proto.common.Transform]] = None) -> viam.proto.common.PoseInFrame
      :async:


      Transform a given source Pose from the reference frame to a new specified destination which is a reference frame.

      ::

          pose = await robot.transform_pose(PoseInFrame(), "origin")

      :param query: The pose that should be transformed.
      :type query: viam.proto.common.PoseInFrame
      :param destination: The name of the reference frame to transform the given pose to.
      :type destination: str

      :returns: The pose and the reference frame for the new destination.
      :rtype: PoseInFrame



   .. py:method:: transform_point_cloud()
      :abstractmethod:

      :async:



   .. py:method:: discover_components(queries: List[viam.proto.robot.DiscoveryQuery]) -> List[viam.proto.robot.Discovery]
      :async:


      Get the list of discovered component configurations.

      ::

          # Define a new discovery query.
          q = robot.DiscoveryQuery(subtype=acme.API, model="some model")

          # Define a list of discovery queries.
          qs = [q]

          # Get component configurations with these queries.
          component_configs = await robot.discover_components(qs)

      :param queries: The list of component models to lookup configurations for.
      :type queries: List[viam.proto.robot.DiscoveryQuery]

      :returns: A list of discovered component configurations.
      :rtype: List[Discovery]



   .. py:method:: stop_all(extra: Dict[viam.proto.common.ResourceName, Dict[str, Any]] = {})
      :async:


      Cancel all current and outstanding operations for the robot and stop all actuators and movement.

      ::

          # Cancel all current and outstanding operations for the robot and stop all actuators and movement.
          await robot.stop_all()

      ::

          await robot.stop_all()

      :param extra: Any extra parameters to pass to the resources' ``stop`` methods,
                    keyed on the resource's ``ResourceName``
      :type extra: Dict[viam.proto.common.ResourceName, Dict[str, Any]]



   .. py:method:: log(name: str, level: str, time: datetime.datetime, log: str, stack: str)
      :async:


      Send log from Python module over gRPC.

      Create a LogEntry object from the log to send to RDK.

      :param name: The logger's name.
      :type name: str
      :param level: The level of the log.
      :type level: str
      :param time: The log creation time.
      :type time: datetime
      :param log: The log message.
      :type log: str
      :param stack: The stack information of the log.
      :type stack: str



   .. py:method:: get_cloud_metadata() -> viam.proto.robot.GetCloudMetadataResponse
      :async:


      Get app-related information about the robot.

      ::

          metadata = machine.get_cloud_metadata()
          print(metadata.machine_id)
          print(metadata.machine_part_id)
          print(metadata.primary_org_id)
          print(metadata.location_id)

      :returns: App-related metadata.
      :rtype: viam.proto.robot.GetCloudMetadataResponse



   .. py:method:: shutdown()
      :async:


      Shutdown shuts down the robot.

      :raises GRPCError: Raised with DeadlineExceeded status if shutdown request times out, or if
          robot server shuts down before having a chance to send a response. Raised with
          status Unavailable if server is unavailable, or if robot server is in the process of
          shutting down when response is ready.



.. py:class:: DialOptions(*, disable_webrtc: bool = False, auth_entity: Optional[str] = None, credentials: Optional[Credentials] = None, insecure: bool = False, allow_insecure_downgrade: bool = False, allow_insecure_with_creds_downgrade: bool = False, max_reconnect_attempts: int = 3, timeout: float = 20)

   .. py:attribute:: disable_webrtc
      :type:  bool

      Bypass Web RTC and connect directly to the robot.


   .. py:attribute:: auth_entity
      :type:  Optional[str]

      The URL to authenticate against. Should be used if the address passed in and FQDN of the server do not match.


   .. py:attribute:: credentials
      :type:  Optional[Credentials]

      Credentials for connecting to the robot


   .. py:attribute:: insecure
      :type:  bool
      :value: False


      Determine if the RPC connection is TLS based. Must be provided to
      establish an insecure connection. Otherwise, a TLS based connection
      will be assumed.


   .. py:attribute:: allow_insecure_downgrade
      :type:  bool
      :value: False


      Allow the RPC connection to be downgraded to an insecure connection
      if detected. This is only used when credentials are not present.


   .. py:attribute:: allow_insecure_with_creds_downgrade
      :type:  bool
      :value: False


      Allow the RPC connection to be downgraded to an insecure connection
      if detected, even with credentials present. This is generally
      unsafe to use, but can be requested.


   .. py:attribute:: max_reconnect_attempts
      :type:  int
      :value: 3


      Max number of times the client attempts to reconnect when connection is lost


   .. py:attribute:: timeout
      :type:  float
      :value: 20


      Number of seconds before the dial connection times out
      Set to 20sec to match _defaultOfferDeadline in goutils/rpc/wrtc_call_queue.go


   .. py:method:: with_api_key(api_key: str, api_key_id: str) -> typing_extensions.Self
      :classmethod:


      Create DialOptions with an API key for credentials and default values for other arguments.

      :param api_key: your API key
      :type api_key: str
      :param api_key_id: your API key ID. Must be a valid UUID
      :type api_key_id: str

      :raises ValueError: Raised if the api_key_id is not a valid UUID

      :returns: the DialOptions
      :rtype: Self



.. py:class:: Server(resources: List[viam.resource.base.ResourceBase], *, module_service: Optional[viam.module.service.ModuleRPCService] = None)

   Bases: :py:obj:`viam.resource.manager.ResourceManager`


   gRPC Server


   .. py:method:: serve(host: Optional[str] = 'localhost', port: Optional[int] = 9090, log_level: Optional[int] = logging.INFO, *, path: Optional[str] = None)
      :async:


      Server the gRPC server on the provided host and port

      :param host: Desired hostname of the server. Defaults to "localhost".
      :type host: Optional[str], optional
      :param port: Desired port of the server. Defaults to 9090.
      :type port: Optional[int], optional
      :param log_level: The minimum log level. To not receive any logs, set to None. Defaults to logging.INFO.
      :type log_level: Optional[int], optional
      :param path: UNIX socket path. Takes precedence over `host` and `port` if set. Defaults to None.
      :type path: Optional[str], optional



   .. py:method:: create_and_serve(components: List[viam.resource.base.ResourceBase], host: Optional[str] = 'localhost', port: Optional[int] = 9090, log_level: int = logging.INFO, *, path: Optional[str] = None)
      :classmethod:

      :async:


      Convenience method to create and start the server.

      :param components: List of components to manage
      :type components: List[ComponentBase]
      :param host: Desired hostname. Defaults to "localhost".
      :type host: str, optional
      :param port: Desired port. Defaults to 9090.
      :type port: int, optional
      :param log_level: The minimum log level.
                        To not receive any logs, set to None.
                        Defaults to logging.INFO
      :type log_level: int, optional
      :param path: UNIX socket path. Takes precedence over `host` and `port` if set. Defaults to None.
      :type path: Optional[str], optional



   .. py:method:: close()
      :async:


      Close the resourcce manager by removing all resources.
      Please note that any errors will not raise an exception. Errors will still be logged.



.. py:class:: ModuleRPCService(module: viam.module.module.Module)

   Bases: :py:obj:`viam.proto.module.ModuleServiceBase`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:method:: AddResource(stream: grpclib.server.Stream[viam.proto.module.AddResourceRequest, viam.proto.module.AddResourceResponse]) -> None
      :async:



   .. py:method:: ReconfigureResource(stream: grpclib.server.Stream[viam.proto.module.ReconfigureResourceRequest, viam.proto.module.ReconfigureResourceResponse]) -> None
      :async:



   .. py:method:: RemoveResource(stream: grpclib.server.Stream[viam.proto.module.RemoveResourceRequest, viam.proto.module.RemoveResourceResponse]) -> None
      :async:



   .. py:method:: Ready(stream: grpclib.server.Stream[viam.proto.module.ReadyRequest, viam.proto.module.ReadyResponse]) -> None
      :async:



   .. py:method:: ValidateConfig(stream: grpclib.server.Stream[viam.proto.module.ValidateConfigRequest, viam.proto.module.ValidateConfigResponse]) -> None
      :async:



.. py:class:: Reconfigurable

   Bases: :py:obj:`Protocol`


   The Reconfigurable protocol defines the requirements for making a resource Reconfigurable


   .. py:method:: reconfigure(config: viam.proto.app.robot.ComponentConfig, dependencies: Mapping[viam.proto.common.ResourceName, viam.resource.base.ResourceBase])


.. py:class:: Stoppable

   Bases: :py:obj:`Protocol`


   The Stoppable protocol defines the requirements for making a resource Stoppable.

   All resources that physically move should be Stoppable.


   .. py:method:: stop(*, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None, **kwargs)


.. py:data:: LOGGER

.. py:class:: Module(address: str, *, log_level: int = logging.INFO)

   .. py:attribute:: parent
      :type:  Optional[viam.robot.client.RobotClient]
      :value: None



   .. py:attribute:: server
      :type:  viam.rpc.server.Server


   .. py:method:: from_args() -> typing_extensions.Self
      :classmethod:


      Create a new Module with the args provided in the command line. The first argument after the command must be
      the socket path. If the second argument after the command is "--log-level=debug", the Module's logger will be
      DEBUG level. Otherwise, it will be INFO level. See LogLevel documentation in the RDK for more information on how
      to start modules with a "log-level" commandline argument.

      :raises Exception: If there is no socket path provided in the command line argument

      :returns: a new Module instance
      :rtype: Module



   .. py:method:: run_with_models(*models: viam.resource.base.ResourceBase)
      :classmethod:

      :async:


      Module entrypoint that takes a list of ResourceBase implementations.
      In most cases you'll want to use run_from_registry instead (see below).



   .. py:method:: run_from_registry()
      :classmethod:

      :async:


      Module entrypoint that automatically includes all the resources you've created in your program.

      Example:

      if __name__ == '__main__':
          asyncio.run(Module.run_from_registry())

      Full example at examples/easy_resource/main.py.



   .. py:method:: start()
      :async:


      Start the module service and gRPC server



   .. py:method:: stop()
      :async:


      Stop the module service and gRPC server



   .. py:method:: set_ready(ready: bool)

      Set the module's ready state. The module automatically sets to READY on load. Setting to False can be useful
      in instances where the module is not instantly ready (for example waiting on hardware)

      :param ready: Whether the module is ready
      :type ready: bool



   .. py:method:: add_resource(request: viam.proto.module.AddResourceRequest)
      :async:



   .. py:method:: reconfigure_resource(request: viam.proto.module.ReconfigureResourceRequest)
      :async:



   .. py:method:: remove_resource(request: viam.proto.module.RemoveResourceRequest)
      :async:



   .. py:method:: ready(request: viam.proto.module.ReadyRequest) -> viam.proto.module.ReadyResponse
      :async:



   .. py:method:: add_model_from_registry(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model)

      Add a pre-registered model to this Module



   .. py:method:: validate_config(request: viam.proto.module.ValidateConfigRequest) -> viam.proto.module.ValidateConfigResponse
      :async:



