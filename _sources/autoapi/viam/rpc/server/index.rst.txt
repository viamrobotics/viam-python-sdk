viam.rpc.server
===============

.. py:module:: viam.rpc.server


Attributes
----------

.. autoapisummary::

   viam.rpc.server.LOGGER


Exceptions
----------

.. autoapisummary::

   viam.rpc.server.ViamGRPCError


Classes
-------

.. autoapisummary::

   viam.rpc.server.ResourceBase
   viam.rpc.server.ResourceManager
   viam.rpc.server.Registry
   viam.rpc.server.ResourceRPCServiceBase
   viam.rpc.server.RobotService
   viam.rpc.server.SignalingService
   viam.rpc.server.Server


Module Contents
---------------

.. py:exception:: ViamGRPCError(message: str = '', grpc_code: grpclib.Status = Status.INTERNAL)

   Bases: :py:obj:`ViamError`


   Exception raised if it could happen as a part of GRPC calls.


   .. py:property:: grpc_error
      :type: grpclib.GRPCError



.. py:class:: ResourceBase

   Bases: :py:obj:`Protocol`


   The base requirements for a Resource.


   .. py:attribute:: SUBTYPE
      :type:  ClassVar[viam.resource.types.Subtype]

      The Subtype of the Resource


   .. py:attribute:: name
      :type:  str

      The name of the Resource


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      :abstractmethod:


      Get the Resource named ``name`` from the provided robot.

      ::

          # Can be used with any resource, using an arm as an example
          my_arm = Arm.from_robot(robot, "my_arm")

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the Resource
      :type name: str

      :returns: The Resource, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: ResourceManager(components: List[viam.resource.base.ResourceBase] = [])

   Registry containing all components registered to this server.


   .. py:attribute:: resources
      :type:  Dict[viam.proto.common.ResourceName, viam.resource.base.ResourceBase]


   .. py:method:: register(resource: viam.resource.base.ResourceBase)

      Register a new resource with the registry.
      Resources may not have the same name.
      If a resource is remote and the short name is unique, save a short name version.

      :raises DuplicateResourceError: Error if attempting to register resource
          with the name of an existing resource
      :raises ResourceNotFoundError: Raised if the subtype of the resource is not registered

      :param resource: The resource to register
      :type resource: ResourceBase



   .. py:method:: get_resource(of_type: Type[ResourceType], name: viam.proto.common.ResourceName) -> ResourceType

      Return a resource from the registry.
      If a unique short name version is given, return a remote resource with the name.

      :param of_type: The type of the resource
      :type of_type: Type[ResourceType]
      :param name: The name of the resource
      :type name: viam.proto.common.ResourceName

      :raises ResourceNotFoundError: Error if resource with the given type
          and name does not exist in the registry

      :returns: The resource
      :rtype: ResourceType



   .. py:method:: remove_resource(name: viam.proto.common.ResourceName)
      :async:


      Remove the resource with the specified ```ResourceName```.

      :param name: The ResourceName of the resource
      :type name: viam.proto.common.ResourceName



   .. py:method:: close()
      :async:


      Close the resourcce manager by removing all resources.
      Please note that any errors will not raise an exception. Errors will still be logged.



.. py:class:: Registry

   The global registry of robotic parts.

   **NB** The Registry should almost never be used directly

   The Registry keeps track of the types of Resources that are available on robots using this SDK. All the base resource types are
   pre-registered (for example Arm, Motor).

   If you create a new resource type that is not an extension of any of the existing base resource types, then you must register said
   resource using ``Registry.register(...)``.


   .. py:method:: register_subtype(registration: ResourceRegistration[Resource])
      :classmethod:


      Register a Subtype with the Registry

      :param registration: Object containing registration data for the subtype
      :type registration: ResourceRegistration

      :raises DuplicateResourceError: Raised if the Subtype to register is already in the registry
      :raises ValidationError: Raised if registration is missing any necessary parameters



   .. py:method:: register_resource_creator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model, registration: ResourceCreatorRegistration)
      :classmethod:


      Register a specific ``Model`` and validator function for the specific resource ``Subtype`` with the Registry

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model
      :param registration: The registration functions of the model
      :type registration: ResourceCreatorRegistration

      :raises DuplicateResourceError: Raised if the Subtype and Model pairing is already registered
      :raises ValidationError: Raised if registration does not have creator



   .. py:method:: lookup_subtype(subtype: viam.resource.types.Subtype) -> ResourceRegistration
      :classmethod:


      Lookup and retrieve a registered Subtype by its name

      :param subtype: The subtype of the resource
      :type subtype: str

      :raises ResourceNotFoundError: Raised if the Subtype is not registered

      :returns: The registration object of the resource
      :rtype: ResourceRegistration



   .. py:method:: lookup_resource_creator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model) -> viam.resource.types.ResourceCreator
      :classmethod:


      Lookup and retrieve a registered resource creator by its subtype and model

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model

      :raises ResourceNotFoundError: Raised if the Subtype Model pairing is not registered

      :returns: The function to create the resource
      :rtype: ResourceCreator



   .. py:method:: lookup_validator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model) -> viam.resource.types.Validator
      :classmethod:


      Lookup and retrieve a registered validator function by its subtype and model. If there is none, return None

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model

      :returns: The function to validate the resource
      :rtype: Validator



   .. py:method:: REGISTERED_SUBTYPES() -> Mapping[viam.resource.types.Subtype, ResourceRegistration]
      :classmethod:


      The dictionary of all registered resources
      - Key: Subtype of the resource
      - Value: The registration object for the resource

      :returns: All registered resources
      :rtype: Mapping[Subtype, ResourceRegistration]



   .. py:method:: REGISTERED_RESOURCE_CREATORS() -> Mapping[str, ResourceCreatorRegistration]
      :classmethod:


      The dictionary of all registered resources
      - Key: subtype/model
      - Value: The ResourceCreatorRegistration for the resource

      :returns: All registered resources
      :rtype: Mapping[str, ResourceCreatorRegistration]



.. py:class:: ResourceRPCServiceBase(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`abc.ABC`, :py:obj:`viam.rpc.types.RPCServiceBase`, :py:obj:`Generic`\ [\ :py:obj:`viam.resource.manager.ResourceType`\ ]


   Base RPC service for a resource.
   All resource RPC services must inherit from this class.


   .. py:attribute:: RESOURCE_TYPE


   .. py:attribute:: manager
      :type:  viam.resource.manager.ResourceManager


   .. py:method:: get_resource(name: str) -> viam.resource.manager.ResourceType

      Return the resource with the given name if it exists in the registry.
      If the resource does not exist in the registry,
      this function will raise an error

      :param name: Name of the resource
      :type name: str

      :raises GRPCError with the status code Status.NOT_FOUND:

      :returns: The resource
      :rtype: ResourceType



.. py:class:: RobotService(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`viam.proto.robot.UnimplementedRobotServiceBase`, :py:obj:`viam.resource.rpc_service_base.ResourceRPCServiceBase`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:method:: ResourceNames(stream: grpclib.server.Stream[viam.proto.robot.ResourceNamesRequest, viam.proto.robot.ResourceNamesResponse]) -> None
      :async:



   .. py:method:: GetStatus(stream: grpclib.server.Stream[viam.proto.robot.GetStatusRequest, viam.proto.robot.GetStatusResponse]) -> None
      :async:



   .. py:method:: StreamStatus(stream: grpclib.server.Stream[viam.proto.robot.StreamStatusRequest, viam.proto.robot.StreamStatusResponse]) -> None
      :async:



   .. py:method:: StopAll(stream: grpclib.server.Stream[viam.proto.robot.StopAllRequest, viam.proto.robot.StopAllResponse]) -> None
      :async:



.. py:class:: SignalingService

   Bases: :py:obj:`viam.proto.rpc.webrtc.signaling.SignalingServiceBase`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:method:: Call(stream: grpclib.server.Stream[viam.proto.rpc.webrtc.signaling.CallRequest, viam.proto.rpc.webrtc.signaling.CallResponse]) -> None
      :async:



   .. py:method:: CallUpdate(stream: grpclib.server.Stream[viam.proto.rpc.webrtc.signaling.CallUpdateRequest, viam.proto.rpc.webrtc.signaling.CallUpdateResponse]) -> None
      :async:



   .. py:method:: Answer(stream: grpclib.server.Stream[viam.proto.rpc.webrtc.signaling.AnswerResponse, viam.proto.rpc.webrtc.signaling.AnswerRequest]) -> None
      :async:



   .. py:method:: OptionalWebRTCConfig(stream: grpclib.server.Stream[viam.proto.rpc.webrtc.signaling.OptionalWebRTCConfigRequest, viam.proto.rpc.webrtc.signaling.OptionalWebRTCConfigResponse]) -> None
      :async:



.. py:data:: LOGGER

.. py:class:: Server(resources: List[viam.resource.base.ResourceBase], *, module_service: Optional[viam.module.service.ModuleRPCService] = None)

   Bases: :py:obj:`viam.resource.manager.ResourceManager`


   gRPC Server


   .. py:method:: serve(host: Optional[str] = 'localhost', port: Optional[int] = 9090, log_level: Optional[int] = logging.INFO, *, path: Optional[str] = None)
      :async:


      Server the gRPC server on the provided host and port

      :param host: Desired hostname of the server. Defaults to "localhost".
      :type host: Optional[str], optional
      :param port: Desired port of the server. Defaults to 9090.
      :type port: Optional[int], optional
      :param log_level: The minimum log level. To not receive any logs, set to None. Defaults to logging.INFO.
      :type log_level: Optional[int], optional
      :param path: UNIX socket path. Takes precedence over `host` and `port` if set. Defaults to None.
      :type path: Optional[str], optional



   .. py:method:: create_and_serve(components: List[viam.resource.base.ResourceBase], host: Optional[str] = 'localhost', port: Optional[int] = 9090, log_level: int = logging.INFO, *, path: Optional[str] = None)
      :classmethod:

      :async:


      Convenience method to create and start the server.

      :param components: List of components to manage
      :type components: List[ComponentBase]
      :param host: Desired hostname. Defaults to "localhost".
      :type host: str, optional
      :param port: Desired port. Defaults to 9090.
      :type port: int, optional
      :param log_level: The minimum log level.
                        To not receive any logs, set to None.
                        Defaults to logging.INFO
      :type log_level: int, optional
      :param path: UNIX socket path. Takes precedence over `host` and `port` if set. Defaults to None.
      :type path: Optional[str], optional



   .. py:method:: close()
      :async:


      Close the resourcce manager by removing all resources.
      Please note that any errors will not raise an exception. Errors will still be logged.



