viam.components.generic.client
==============================

.. py:module:: viam.components.generic.client


Attributes
----------

.. autoapisummary::

   viam.components.generic.client.ValueTypes


Classes
-------

.. autoapisummary::

   viam.components.generic.client.DoCommandRequest
   viam.components.generic.client.DoCommandResponse
   viam.components.generic.client.Geometry
   viam.components.generic.client.GenericServiceStub
   viam.components.generic.client.ReconfigurableResourceRPCClientBase
   viam.components.generic.client.Generic
   viam.components.generic.client.GenericClient


Functions
---------

.. autoapisummary::

   viam.components.generic.client.dict_to_struct
   viam.components.generic.client.get_geometries
   viam.components.generic.client.struct_to_dict
   viam.components.generic.client.do_command


Module Contents
---------------

.. py:class:: DoCommandRequest(*, name: str = ..., command: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandRequest represents a generic DoCommand input


   .. py:attribute:: name
      :type:  str


   .. py:property:: command
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['command', b'command']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DoCommandResponse(*, result: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandResponse represents a generic DoCommand output


   .. py:property:: result
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['result', b'result']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: Geometry(*, center: global___Pose | None = ..., sphere: global___Sphere | None = ..., box: global___RectangularPrism | None = ..., capsule: global___Capsule | None = ..., label: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Geometry contains the dimensions of a given geometry and the pose of its center. The geometry is one of either a sphere or a box.


   .. py:attribute:: label
      :type:  str

      Label of the geometry. If none supplied, will be an empty string.


   .. py:property:: center
      :type: global___Pose

      Pose of a geometries center point


   .. py:property:: sphere
      :type: global___Sphere



   .. py:property:: box
      :type: global___RectangularPrism



   .. py:property:: capsule
      :type: global___Capsule



   .. py:method:: HasField(field_name: Literal['box', b'box', 'capsule', b'capsule', 'center', b'center', 'geometry_type', b'geometry_type', 'sphere', b'sphere']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['geometry_type', b'geometry_type']) -> Literal['sphere', 'box', 'capsule'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: GenericServiceStub(channel: grpclib.client.Channel)

.. py:class:: ReconfigurableResourceRPCClientBase

   Bases: :py:obj:`ResourceRPCClientBase`


   A base RPC client that can reset its channel.

   Useful if connection is lost and then regained.


   .. py:method:: reset_channel(channel: grpclib.client.Channel)

      Called when the RPC channel was reset. Passes in the new channel.

      :param channel: The new RPC Channel
      :type channel: Channel



.. py:data:: ValueTypes

   Types that can be encoded into a protobuf `Value`

.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: get_geometries(client: viam.resource.types.SupportsGetGeometries, name: str, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
   :async:


.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:class:: Generic(name: str)

   Bases: :py:obj:`viam.components.component_base.ComponentBase`


   Generic component, which represents any type of component that can executes arbitrary commands

   This acts as an abstract base class for any drivers representing generic components.
   This cannot be used on its own. If the ``__init__()`` function is overridden, it must call the ``super().__init__()`` function.

   To create a Generic component (an arbitrary component that can process commands), this ``Generic`` component should be subclassed
   and the ``do_command`` function implemented.

   ::

       from viam.components.generic import Generic

   Example::

       class ComplexComponent(Generic):

           async def do_command(
               self,
               command: Mapping[str, ValueTypes],
               *,
               timeout: Optional[float] = None,
               **kwargs
           ) -> Mapping[str, ValueTypes]:
               result = {key: False for key in command.keys()}
               for (name, args) in command.items():
                   if name == 'on':
                       self.on(*args)
                       result[name] = True
                   if name == 'set_frequency':
                       self.set_frequency(*args)
                       result[name] = True
                   if name == 'get_frequency':
                       result[name] = self.frequency
                   if name == 'complex_command':
                       self.complex_command(*args)
                       result[name] = True
               return result

           def set_frequency(self, frequency: int):
               self.frequency = frequency

           def on(self, frequency: int, duration: int):
               self.frequency = frequency
               self.power = 1
               task = threading.Timer(duration, self.off)
               task.start()

           def off(self):
               self.power = 0

           def complex_command(self, arg1, arg2, arg3):
               ...

   To execute commands, simply call the ``do_command`` function with the appropriate parameters.
   ::

       await component.do_command({'on': [300, 10]})
       component.power  # 1
       await asyncio.sleep(10)
       component.power  # 0


   .. py:attribute:: SUBTYPE
      :type:  Final


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/services/frame-system/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: GenericClient(name: str, channel: grpclib.client.Channel)

   Bases: :py:obj:`viam.components.generic.generic.Generic`, :py:obj:`viam.resource.rpc_client_base.ReconfigurableResourceRPCClientBase`


   gRPC client for the Generic component.


   .. py:method:: do_command(command: Mapping[str, Any], *, timeout: Optional[float] = None, **__) -> Mapping[str, Any]
      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/services/frame-system/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:function:: do_command(channel: grpclib.client.Channel, name: str, command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None) -> Mapping[str, viam.utils.ValueTypes]
   :async:


   Convenience method to allow component clients to execute ``do_command`` functions

   :param channel: A gRPC channel
   :type channel: Channel
   :param name: The name of the component
   :type name: str
   :param command: The command to execute
   :type command: Dict[str, Any]

   :returns: The result of the executed command
   :rtype: Dict[str, Any]


