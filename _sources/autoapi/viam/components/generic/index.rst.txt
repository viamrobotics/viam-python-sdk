:py:mod:`viam.components.generic`
=================================

.. py:module:: viam.components.generic


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   client/index.rst
   generic/index.rst
   service/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   viam.components.generic.Generic




.. py:class:: Generic(name: str)


   Bases: :py:obj:`viam.components.component_base.ComponentBase`

   Generic component, which represents any type of component that can executes arbitrary commands

   This acts as an abstract base class for any drivers representing generic components.
   This cannot be used on its own. If the ``__init__()`` function is overridden, it must call the ``super().__init__()`` function.

   To create a Generic component (an arbitrary component that can process commands), this ``Generic`` component should be subclassed
   and the ``do_command`` function implemented.

   ::

       from viam.components.generic import Generic

   Example::

       class ComplexComponent(Generic):

           async def do_command(
               self,
               command: Mapping[str, ValueTypes],
               *,
               timeout: Optional[float] = None,
               **kwargs
           ) -> Mapping[str, ValueTypes]:
               result = {key: False for key in command.keys()}
               for (name, args) in command.items():
                   if name == 'on':
                       self.on(*args)
                       result[name] = True
                   if name == 'set_frequency':
                       self.set_frequency(*args)
                       result[name] = True
                   if name == 'get_frequency':
                       result[name] = self.frequency
                   if name == 'complex_command':
                       self.complex_command(*args)
                       result[name] = True
               return result

           def set_frequency(self, frequency: int):
               self.frequency = frequency

           def on(self, frequency: int, duration: int):
               self.frequency = frequency
               self.power = 1
               task = threading.Timer(duration, self.off)
               task.start()

           def off(self):
               self.power = 0

           def complex_command(self, arg1, arg2, arg3):
               ...

   To execute commands, simply call the ``do_command`` function with the appropriate parameters.
   ::

       await component.do_command({'on': [300, 10]})
       component.power  # 1
       await asyncio.sleep(10)
       component.power  # 0

   .. py:attribute:: SUBTYPE
      :type: Final

      

   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self


   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:
      :async:

      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]


   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:

      Get all geometries associated with the Component, in their current configuration, in the frame of the Component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:

      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str


   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation


   .. py:method:: close()
      :async:

      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to retun errors when future
      non-Close methods are called.

      ::

          await component.close()




