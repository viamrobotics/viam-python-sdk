viam.components.camera.service
==============================

.. py:module:: viam.components.camera.service


Classes
-------

.. autoapisummary::

   viam.components.camera.service.DoCommandRequest
   viam.components.camera.service.DoCommandResponse
   viam.components.camera.service.GetGeometriesRequest
   viam.components.camera.service.GetGeometriesResponse
   viam.components.camera.service.CameraServiceBase
   viam.components.camera.service.GetImageRequest
   viam.components.camera.service.GetImageResponse
   viam.components.camera.service.GetImagesRequest
   viam.components.camera.service.GetImagesResponse
   viam.components.camera.service.GetPointCloudRequest
   viam.components.camera.service.GetPointCloudResponse
   viam.components.camera.service.GetPropertiesRequest
   viam.components.camera.service.GetPropertiesResponse
   viam.components.camera.service.Image
   viam.components.camera.service.RenderFrameRequest
   viam.components.camera.service.ResourceRPCServiceBase
   viam.components.camera.service.Camera
   viam.components.camera.service.CameraRPCService


Functions
---------

.. autoapisummary::

   viam.components.camera.service.dict_to_struct
   viam.components.camera.service.struct_to_dict


Module Contents
---------------

.. py:class:: DoCommandRequest(*, name: str = ..., command: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandRequest represents a generic DoCommand input


   .. py:attribute:: name
      :type:  str


   .. py:property:: command
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['command', b'command']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DoCommandResponse(*, result: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandResponse represents a generic DoCommand output


   .. py:property:: result
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['result', b'result']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetGeometriesRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      The component name


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetGeometriesResponse(*, geometries: collections.abc.Iterable[global___Geometry] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: geometries
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Geometry]

      All geometries associated with the component, in their current configuration, in the frame of that component.


.. py:class:: CameraServiceBase

   Bases: :py:obj:`abc.ABC`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:method:: GetImage(stream: grpclib.server.Stream[component.camera.v1.camera_pb2.GetImageRequest, component.camera.v1.camera_pb2.GetImageResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetImages(stream: grpclib.server.Stream[component.camera.v1.camera_pb2.GetImagesRequest, component.camera.v1.camera_pb2.GetImagesResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: RenderFrame(stream: grpclib.server.Stream[component.camera.v1.camera_pb2.RenderFrameRequest, google.api.httpbody_pb2.HttpBody]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetPointCloud(stream: grpclib.server.Stream[component.camera.v1.camera_pb2.GetPointCloudRequest, component.camera.v1.camera_pb2.GetPointCloudResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetProperties(stream: grpclib.server.Stream[component.camera.v1.camera_pb2.GetPropertiesRequest, component.camera.v1.camera_pb2.GetPropertiesResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: DoCommand(stream: grpclib.server.Stream[common.v1.common_pb2.DoCommandRequest, common.v1.common_pb2.DoCommandResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetGeometries(stream: grpclib.server.Stream[common.v1.common_pb2.GetGeometriesRequest, common.v1.common_pb2.GetGeometriesResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: __mapping__() -> Dict[str, grpclib.const.Handler]


.. py:class:: GetImageRequest(*, name: str = ..., mime_type: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a camera


   .. py:attribute:: mime_type
      :type:  str

      Requested MIME type of response


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetImageResponse(*, mime_type: str = ..., image: bytes = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: mime_type
      :type:  str

      Actual MIME type of response


   .. py:attribute:: image
      :type:  bytes

      Frame in bytes


.. py:class:: GetImagesRequest(*, name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a camera


.. py:class:: GetImagesResponse(*, images: collections.abc.Iterable[global___Image] | None = ..., response_metadata: viam.gen.common.v1.common_pb2.ResponseMetadata | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: images
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Image]

      list of images returned from the camera system


   .. py:property:: response_metadata
      :type: viam.gen.common.v1.common_pb2.ResponseMetadata

      contains timestamp data


   .. py:method:: HasField(field_name: Literal['response_metadata', b'response_metadata']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetPointCloudRequest(*, name: str = ..., mime_type: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a camera


   .. py:attribute:: mime_type
      :type:  str

      Requested MIME type of response


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetPointCloudResponse(*, mime_type: str = ..., point_cloud: bytes = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: mime_type
      :type:  str

      Actual MIME type of response


   .. py:attribute:: point_cloud
      :type:  bytes

      Frame in bytes


.. py:class:: GetPropertiesRequest(*, name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a camera


.. py:class:: GetPropertiesResponse(*, supports_pcd: bool = ..., intrinsic_parameters: global___IntrinsicParameters | None = ..., distortion_parameters: global___DistortionParameters | None = ..., mime_types: collections.abc.Iterable[str] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: supports_pcd
      :type:  bool

      A boolean property determining whether the camera supports the return of pointcloud data


   .. py:property:: intrinsic_parameters
      :type: global___IntrinsicParameters

      Parameters for doing a perspective of a 3D scene to a 2D plane
      If camera does not provide intrinsic parameters, leave the field empty
      Initializing the parameters with 0-values is considered an error


   .. py:property:: distortion_parameters
      :type: global___DistortionParameters

      Parameters for modeling lens distortion in cameras
      If camera does not provide distortion parameters, leave the field empty
      Initializing the parameters with 0-values is considered an error


   .. py:property:: mime_types
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]

      Supported MIME types by the camera


   .. py:method:: HasField(field_name: Literal['distortion_parameters', b'distortion_parameters', 'intrinsic_parameters', b'intrinsic_parameters']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: Image(*, source_name: str = ..., format: global___Format = ..., image: bytes = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: source_name
      :type:  str

      the name of the sensor where the image came from


   .. py:attribute:: format
      :type:  global___Format

      format of the response image bytes


   .. py:attribute:: image
      :type:  bytes

      image in bytes


.. py:class:: RenderFrameRequest(*, name: str = ..., mime_type: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a camera


   .. py:attribute:: mime_type
      :type:  str

      Requested MIME type of response


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ResourceRPCServiceBase(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`abc.ABC`, :py:obj:`viam.rpc.types.RPCServiceBase`, :py:obj:`Generic`\ [\ :py:obj:`viam.resource.manager.ResourceType`\ ]


   Base RPC service for a resource.
   All resource RPC services must inherit from this class.


   .. py:attribute:: RESOURCE_TYPE


   .. py:attribute:: manager
      :type:  viam.resource.manager.ResourceManager


   .. py:method:: get_resource(name: str) -> viam.resource.manager.ResourceType

      Return the resource with the given name if it exists in the registry.
      If the resource does not exist in the registry,
      this function will raise an error

      :param name: Name of the resource
      :type name: str

      :raises GRPCError with the status code Status.NOT_FOUND:

      :returns: The resource
      :rtype: ResourceType



.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:class:: Camera(name: str)

   Bases: :py:obj:`viam.components.component_base.ComponentBase`


   Camera represents any physical hardware that can capture frames.

   This acts as an abstract base class for any drivers representing specific
   camera implementations. This cannot be used on its own. If the ``__init__()`` function is
   overridden, it must call the ``super().__init__()`` function.

   ::

       from viam.components.camera import Camera


   .. py:attribute:: SUBTYPE
      :type:  Final


   .. py:attribute:: Properties
      :type:  TypeAlias
      :value: GetPropertiesResponse



   .. py:method:: get_image(mime_type: str = '', *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> viam.media.video.ViamImage
      :abstractmethod:

      :async:


      Get the next image from the camera as a ViamImage.
      Be sure to close the image when finished.

      NOTE: If the mime type is ``image/vnd.viam.dep`` you can use :func:`viam.media.video.ViamImage.bytes_to_depth_array`
      to convert the data to a standard representation.

      ::

          my_camera = Camera.from_robot(robot=robot, name="my_camera")

          # Assume "frame" has a mime_type of "image/vnd.viam.dep"
          frame = await my_camera.get_image(mime_type = CameraMimeType.VIAM_RAW_DEPTH)

          # Convert "frame" to a standard 2D image representation.
          # Remove the 1st 3x8 bytes and reshape the raw bytes to List[List[Int]].
          standard_frame = frame.bytes_to_depth_array()

      :param mime_type: The desired mime type of the image. This does not guarantee output type
      :type mime_type: str

      :returns: The frame.
      :rtype: ViamImage



   .. py:method:: get_images(*, timeout: Optional[float] = None, **kwargs) -> Tuple[List[viam.media.video.NamedImage], viam.proto.common.ResponseMetadata]
      :abstractmethod:

      :async:


      Get simultaneous images from different imagers, along with associated metadata.
      This should not be used for getting a time series of images from the same imager.

      ::

          my_camera = Camera.from_robot(robot=robot, name="my_camera")

          images, metadata = await my_camera.get_images()
          img0 = images[0].image
          timestamp = metadata.captured_at

      :returns: A tuple containing two values; the first [0] a list of images
                returned from the camera system, and the second [1] the metadata associated with this response.
      :rtype: Tuple[List[NamedImage], ResponseMetadata]



   .. py:method:: get_point_cloud(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Tuple[bytes, str]
      :abstractmethod:

      :async:


      Get the next point cloud from the camera. This will be
      returned as bytes with a mimetype describing
      the structure of the data. The consumer of this call
      should encode the bytes into the formatted suggested
      by the mimetype.

      To deserialize the returned information into a numpy array, use the Open3D library.
      ::

          import numpy as np
          import open3d as o3d

          data, _ = await camera.get_point_cloud()

          # write the point cloud into a temporary file
          with open("/tmp/pointcloud_data.pcd", "wb") as f:
              f.write(data)
          pcd = o3d.io.read_point_cloud("/tmp/pointcloud_data.pcd")
          points = np.asarray(pcd.points)

      :returns: A tuple containing two values; the first [0] the pointcloud data,
                and the second [1] the mimetype of the pointcloud (for example, PCD).
      :rtype: Tuple[bytes, str]



   .. py:method:: get_properties(*, timeout: Optional[float] = None, **kwargs) -> Properties
      :abstractmethod:

      :async:


      Get the camera intrinsic parameters and camera distortion parameters

      ::

          my_camera = Camera.from_robot(robot=robot, name="my_camera")

          properties = await my_camera.get_properties()

      :returns: The properties of the camera.
      :rtype: Properties



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/services/frame-system/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: CameraRPCService(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`viam.proto.component.camera.CameraServiceBase`, :py:obj:`viam.resource.rpc_service_base.ResourceRPCServiceBase`\ [\ :py:obj:`viam.components.camera.Camera`\ ]


   gRPC Service for a generic Camera


   .. py:attribute:: RESOURCE_TYPE


   .. py:method:: GetImage(stream: grpclib.server.Stream[viam.proto.component.camera.GetImageRequest, viam.proto.component.camera.GetImageResponse]) -> None
      :async:



   .. py:method:: GetImages(stream: grpclib.server.Stream[viam.proto.component.camera.GetImagesRequest, viam.proto.component.camera.GetImagesResponse]) -> None
      :async:



   .. py:method:: RenderFrame(stream: grpclib.server.Stream[viam.proto.component.camera.RenderFrameRequest, google.api.httpbody_pb2.HttpBody]) -> None
      :async:



   .. py:method:: GetPointCloud(stream: grpclib.server.Stream[viam.proto.component.camera.GetPointCloudRequest, viam.proto.component.camera.GetPointCloudResponse]) -> None
      :async:



   .. py:method:: GetProperties(stream: grpclib.server.Stream[viam.proto.component.camera.GetPropertiesRequest, viam.proto.component.camera.GetPropertiesResponse]) -> None
      :async:



   .. py:method:: DoCommand(stream: grpclib.server.Stream[viam.proto.common.DoCommandRequest, viam.proto.common.DoCommandResponse]) -> None
      :async:



   .. py:method:: GetGeometries(stream: grpclib.server.Stream[viam.proto.common.GetGeometriesRequest, viam.proto.common.GetGeometriesResponse]) -> None
      :async:



