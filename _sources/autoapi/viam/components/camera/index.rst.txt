viam.components.camera
======================

.. py:module:: viam.components.camera


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/viam/components/camera/camera/index
   /autoapi/viam/components/camera/client/index
   /autoapi/viam/components/camera/service/index


Classes
-------

.. autoapisummary::

   viam.components.camera.ViamImage
   viam.components.camera.DistortionParameters
   viam.components.camera.IntrinsicParameters
   viam.components.camera.Camera


Package Contents
----------------

.. py:class:: ViamImage(data: bytes, mime_type: CameraMimeType)

   A native implementation of an image.

   Provides the raw data and the mime type.


   .. py:property:: data
      :type: bytes

      The raw bytes of the image


   .. py:property:: mime_type
      :type: CameraMimeType

      The mime type of the image


   .. py:property:: width
      :type: Optional[int]

      The width of the image


   .. py:property:: height
      :type: Optional[int]

      The height of the image


   .. py:method:: bytes_to_depth_array() -> List[List[int]]

      Decode the data of an image that has the custom depth MIME type ``image/vnd.viam.dep`` into a standard representation.

      :raises NotSupportedError: Raised if the image is not of MIME type `image/vnd.viam.dep`.

      :returns: The standard representation of the image.
      :rtype: List[List[int]]



.. py:class:: DistortionParameters(*, model: str = ..., parameters: collections.abc.Iterable[float] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: model
      :type:  str


   .. py:property:: parameters
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[float]



.. py:class:: IntrinsicParameters(*, width_px: int = ..., height_px: int = ..., focal_x_px: float = ..., focal_y_px: float = ..., center_x_px: float = ..., center_y_px: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: width_px
      :type:  int


   .. py:attribute:: height_px
      :type:  int


   .. py:attribute:: focal_x_px
      :type:  float


   .. py:attribute:: focal_y_px
      :type:  float


   .. py:attribute:: center_x_px
      :type:  float


   .. py:attribute:: center_y_px
      :type:  float


.. py:class:: Camera(name: str, *, logger: Optional[logging.Logger] = None)

   Bases: :py:obj:`viam.components.component_base.ComponentBase`


   Camera represents any physical hardware that can capture frames.

   This acts as an abstract base class for any drivers representing specific
   camera implementations. This cannot be used on its own. If the ``__init__()`` function is
   overridden, it must call the ``super().__init__()`` function.

   ::

       from viam.components.camera import Camera

   For more information, see `Camera component <https://docs.viam.com/dev/reference/apis/components/camera/>`_.


   .. py:attribute:: API
      :type:  Final

      The API of the Resource


   .. py:attribute:: Properties
      :type:  TypeAlias
      :value: GetPropertiesResponse



   .. py:method:: get_image(mime_type: str = '', *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> viam.media.video.ViamImage
      :abstractmethod:

      :async:


      Get the next image from the camera as a ViamImage.
      Be sure to close the image when finished.

      NOTE: If the mime type is ``image/vnd.viam.dep`` you can use :func:`viam.media.video.ViamImage.bytes_to_depth_array`
      to convert the data to a standard representation.

      ::

          my_camera = Camera.from_robot(machine, "my_camera")
          frame = await my_camera.get_image()
          print(f"Frame: {frame}")

      :param mime_type: The desired mime type of the image. This does not guarantee output type
      :type mime_type: str

      :returns: The frame.
      :rtype: ViamImage

      For more information, see `Camera component <https://docs.viam.com/dev/reference/apis/components/camera/#getimage>`_.



   .. py:method:: get_images(*, filter_source_names: Optional[Sequence[str]] = None, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Tuple[Sequence[viam.media.video.NamedImage], viam.proto.common.ResponseMetadata]
      :abstractmethod:

      :async:


      Get simultaneous images from different imagers, along with associated metadata.
      This should not be used for getting a time series of images from the same imager.

      ::

          my_camera = Camera.from_robot(robot=machine, name="my_camera")

          images, metadata = await my_camera.get_images()
          first_image = images[0]
          timestamp = metadata.captured_at

      :param filter_source_names: The filter_source_names parameter can be used to filter only the images from the specified
                                  source names. When unspecified, all images are returned.
      :type filter_source_names: Sequence[str]

      :returns:

                A tuple containing two values; the first [0] a list of images
                    returned from the camera system, and the second [1] the metadata associated with this response.
      :rtype: Tuple[Sequence[NamedImage], ResponseMetadata]

      For more information, see `Camera component <https://docs.viam.com/dev/reference/apis/components/camera/#getimages>`_.



   .. py:method:: get_point_cloud(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Tuple[bytes, str]
      :abstractmethod:

      :async:


      Get the next point cloud from the camera. This will be
      returned as bytes with a mimetype describing
      the structure of the data. The consumer of this call
      should encode the bytes into the formatted suggested
      by the mimetype.

      To deserialize the returned information into a numpy array, use the Open3D library.

      ::

          import numpy as np
          import open3d as o3d

          my_camera = Camera.from_robot(robot=machine, name="my_camera")

          data, _ = await my_camera.get_point_cloud()

          # write the point cloud into a temporary file
          with open("/tmp/pointcloud_data.pcd", "wb") as f:
              f.write(data)
          pcd = o3d.io.read_point_cloud("/tmp/pointcloud_data.pcd")
          points = np.asarray(pcd.points)

      :returns: A tuple containing two values; the first [0] the pointcloud data,
                and the second [1] the mimetype of the pointcloud (for example, PCD).
      :rtype: Tuple[bytes, str]

      For more information, see `Camera component <https://docs.viam.com/dev/reference/apis/components/camera/#getpointcloud>`_.



   .. py:method:: get_properties(*, timeout: Optional[float] = None, **kwargs) -> Properties
      :abstractmethod:

      :async:


      Get the camera intrinsic parameters and camera distortion parameters

      ::

          my_camera = Camera.from_robot(robot=machine, name="my_camera")

          properties = await my_camera.get_properties()

      :returns: The properties of the camera.
      :rtype: Properties

      For more information, see `Camera component <https://docs.viam.com/dev/reference/apis/components/camera/#getproperties>`_.



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = await component.do_command(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> Sequence[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/operate/mobility/define-geometry/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = Arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




