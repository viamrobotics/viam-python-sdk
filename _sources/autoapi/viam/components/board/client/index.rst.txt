viam.components.board.client
============================

.. py:module:: viam.components.board.client


Attributes
----------

.. autoapisummary::

   viam.components.board.client.ValueTypes
   viam.components.board.client.TickStream
   viam.components.board.client.LOGGER


Classes
-------

.. autoapisummary::

   viam.components.board.client.DoCommandRequest
   viam.components.board.client.DoCommandResponse
   viam.components.board.client.Geometry
   viam.components.board.client.BoardServiceStub
   viam.components.board.client.GetDigitalInterruptValueRequest
   viam.components.board.client.GetDigitalInterruptValueResponse
   viam.components.board.client.GetGPIORequest
   viam.components.board.client.GetGPIOResponse
   viam.components.board.client.PowerMode
   viam.components.board.client.PWMFrequencyRequest
   viam.components.board.client.PWMFrequencyResponse
   viam.components.board.client.PWMRequest
   viam.components.board.client.PWMResponse
   viam.components.board.client.ReadAnalogReaderRequest
   viam.components.board.client.SetGPIORequest
   viam.components.board.client.SetPowerModeRequest
   viam.components.board.client.SetPWMFrequencyRequest
   viam.components.board.client.SetPWMRequest
   viam.components.board.client.StreamTicksRequest
   viam.components.board.client.StreamTicksResponse
   viam.components.board.client.WriteAnalogRequest
   viam.components.board.client.ReconfigurableResourceRPCClientBase
   viam.components.board.client.StreamWithIterator
   viam.components.board.client.Board
   viam.components.board.client.AnalogClient
   viam.components.board.client.DigitalInterruptClient
   viam.components.board.client.GPIOPinClient
   viam.components.board.client.BoardClient


Functions
---------

.. autoapisummary::

   viam.components.board.client.getLogger
   viam.components.board.client.dict_to_struct
   viam.components.board.client.get_geometries
   viam.components.board.client.struct_to_dict


Module Contents
---------------

.. py:function:: getLogger(name: str) -> logging.Logger

.. py:class:: DoCommandRequest(*, name: str = ..., command: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandRequest represents a generic DoCommand input


   .. py:attribute:: name
      :type:  str


   .. py:property:: command
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['command', b'command']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DoCommandResponse(*, result: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandResponse represents a generic DoCommand output


   .. py:property:: result
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['result', b'result']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: Geometry(*, center: global___Pose | None = ..., sphere: global___Sphere | None = ..., box: global___RectangularPrism | None = ..., capsule: global___Capsule | None = ..., label: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Geometry contains the dimensions of a given geometry and the pose of its center. The geometry is one of either a sphere or a box.


   .. py:attribute:: label
      :type:  str

      Label of the geometry. If none supplied, will be an empty string.


   .. py:property:: center
      :type: global___Pose

      Pose of a geometries center point


   .. py:property:: sphere
      :type: global___Sphere



   .. py:property:: box
      :type: global___RectangularPrism



   .. py:property:: capsule
      :type: global___Capsule



   .. py:method:: HasField(field_name: Literal['box', b'box', 'capsule', b'capsule', 'center', b'center', 'geometry_type', b'geometry_type', 'sphere', b'sphere']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['geometry_type', b'geometry_type']) -> Literal['sphere', 'box', 'capsule'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: BoardServiceStub(channel: grpclib.client.Channel)

.. py:class:: GetDigitalInterruptValueRequest(*, board_name: str = ..., digital_interrupt_name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Digital Interrupt


   .. py:attribute:: board_name
      :type:  str


   .. py:attribute:: digital_interrupt_name
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetDigitalInterruptValueResponse(*, value: int = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: value
      :type:  int


.. py:class:: GetGPIORequest(*, name: str = ..., pin: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: pin
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetGPIOResponse(*, high: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: high
      :type:  bool


.. py:class:: PowerMode

   Bases: :py:obj:`_PowerMode`


   Power Management API


.. py:class:: PWMFrequencyRequest(*, name: str = ..., pin: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: pin
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: PWMFrequencyResponse(*, frequency_hz: int = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: frequency_hz
      :type:  int


.. py:class:: PWMRequest(*, name: str = ..., pin: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: pin
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: PWMResponse(*, duty_cycle_pct: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: duty_cycle_pct
      :type:  float

      0-1


.. py:class:: ReadAnalogReaderRequest(*, board_name: str = ..., analog_reader_name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Analog Reader


   .. py:attribute:: board_name
      :type:  str


   .. py:attribute:: analog_reader_name
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: SetGPIORequest(*, name: str = ..., pin: str = ..., high: bool = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: pin
      :type:  str


   .. py:attribute:: high
      :type:  bool


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: SetPowerModeRequest(*, name: str = ..., power_mode: global___PowerMode = ..., duration: google.protobuf.duration_pb2.Duration | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      name of board


   .. py:attribute:: power_mode
      :type:  global___PowerMode

      Requested power mode


   .. py:property:: duration
      :type: google.protobuf.duration_pb2.Duration

      Requested duration to stay in `power_mode`


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['_duration', b'_duration', 'duration', b'duration', 'extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_duration', b'_duration']) -> Literal['duration'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: SetPWMFrequencyRequest(*, name: str = ..., pin: str = ..., frequency_hz: int = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: pin
      :type:  str


   .. py:attribute:: frequency_hz
      :type:  int


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: SetPWMRequest(*, name: str = ..., pin: str = ..., duty_cycle_pct: float = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: pin
      :type:  str


   .. py:attribute:: duty_cycle_pct
      :type:  float

      0-1


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: StreamTicksRequest(*, name: str = ..., pin_names: collections.abc.Iterable[str] | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Board name


   .. py:property:: pin_names
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]

      Name of digital interrupts to recieve ticks from


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: StreamTicksResponse(*, pin_name: str = ..., time: int = ..., high: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: pin_name
      :type:  str

      name of interrupt


   .. py:attribute:: time
      :type:  int

      Time in nanoseconds of a tick


   .. py:attribute:: high
      :type:  bool

      Value high or low of the tick


.. py:class:: WriteAnalogRequest(*, name: str = ..., pin: str = ..., value: int = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Analog Writer


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: pin
      :type:  str


   .. py:attribute:: value
      :type:  int


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ReconfigurableResourceRPCClientBase

   Bases: :py:obj:`ResourceRPCClientBase`


   A base RPC client that can reset its channel.

   Useful if connection is lost and then regained.


   .. py:method:: reset_channel(channel: grpclib.client.Channel)

      Called when the RPC channel was reset. Passes in the new channel.

      :param channel: The new RPC Channel
      :type channel: Channel



.. py:class:: StreamWithIterator(stream: collections.abc.AsyncIterator[StreamType])

   Bases: :py:obj:`Stream`\ [\ :py:obj:`StreamType`\ ]


   .. py:method:: next() -> StreamType
      :async:



   .. py:method:: __aiter__()


   .. py:method:: __anext__() -> StreamType
      :async:



.. py:data:: ValueTypes

   Types that can be encoded into a protobuf `Value`

.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: get_geometries(client: viam.resource.types.SupportsGetGeometries, name: str, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
   :async:


.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:class:: Board(name: str)

   Bases: :py:obj:`viam.components.component_base.ComponentBase`


   Board represents a physical general purpose compute board that contains various
   components such as analog readers/writers, and digital interrupts.

   This acts as an abstract base class for any drivers representing specific
   board implementations. This cannot be used on its own. If the ``__init__()`` function is
   overridden, it must call the ``super().__init__()`` function.

   ::

       from viam.components.board import Board

   For more information, see `Board component <https://docs.viam.com/components/board/>`_.


   .. py:attribute:: SUBTYPE
      :type:  Final


   .. py:class:: Analog(name: str)

      Analog represents an analog pin reader or writer that resides on a Board.


      .. py:attribute:: name
         :type:  str

         The name of the analog pin


      .. py:attribute:: Value
         :type:  TypeAlias
         :value: ReadAnalogReaderResponse


         Value contains the result of reading an analog reader. It contains the raw data read,
         the reader's minimum and maximum possible values, and its step size (the minimum possible
         change between values it can read).

         For more information, see `analogs <https://docs.viam.com/components/board/#analogs>`_.


      .. py:method:: read(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Value
         :abstractmethod:

         :async:


         Read the current value from the reader.

         ::

             my_board = Board.from_robot(robot=robot, name="my_board")

             # Get the Analog "my_example_analog_reader".
             reader = await my_board.analog_reader_by_name(
                 name="my_example_analog_reader")

             # Get the value of the digital signal "my_example_analog_reader" has most
             # recently measured.
             reading = await reader.read()

         :returns: The current value, including the min, max, and step_size of the reader.
         :rtype: Value

         For more information, see `Board component Analog API <https://docs.viam.com/components/board/#analog-api>`_.



      .. py:method:: write(value: int, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
         :abstractmethod:

         :async:


         Write a value to the Analog writer.

         ::

             my_board = Board.from_robot(robot=robot, name="my_board")

             # Get the Analog "my_example_analog_writer".
             writer = await my_board.analog_by_name(
                 name="my_example_analog_writer")

             await writer.write(42)

         :param value: Value to write to the analog writer.
         :type value: int

         For more information, see `Board component Analog API <https://docs.viam.com/components/board/#analog-api>`_.




   .. py:class:: DigitalInterrupt(name: str)

      DigitalInterrupt represents a configured interrupt on the Board that
      when interrupted, calls the added callbacks. Post processors can
      be added to modify what Value it ultimately returns.

      For more information, see `digital_interrupts <https://docs.viam.com/components/board/#digital_interrupts>`_.


      .. py:attribute:: name
         :type:  str

         The name of the digital interrupt.


      .. py:method:: value(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> int
         :abstractmethod:

         :async:


         Get the current value of the interrupt,
         which is based on the type of interrupt.

         ::

             my_board = Board.from_robot(robot=robot, name="my_board")

             # Get the DigitalInterrupt "my_example_digital_interrupt".
             interrupt = await my_board.digital_interrupt_by_name(
                 name="my_example_digital_interrupt")

             # Get the amount of times this DigitalInterrupt has been interrupted with a
             # tick.
             count = await interrupt.value()

         :returns: The current value.
         :rtype: int

         For more information, see
         `Board component DigitalInterrupt API <https://docs.viam.com/components/board/#digitalinterrupt-api>`_.




   .. py:class:: GPIOPin(name: str)

      Abstract representation of an individual GPIO pin on a board.


      .. py:attribute:: name
         :type:  str

         The name of the GPIO pin.


      .. py:method:: set(high: bool, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
         :abstractmethod:

         :async:


         Set the pin to either low or high.

         ::

             my_board = Board.from_robot(robot=robot, name="my_board")

             # Get the GPIOPin with pin number 15.
             pin = await my_board.gpio_pin_by_name(name="15")

             # Set the pin to high.
             await pin.set(high="true")

         :param high: When true, sets the pin to high. When false, sets the pin to low.
         :type high: bool

         For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.



      .. py:method:: get(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> bool
         :abstractmethod:

         :async:


         Get the high/low state of the pin.

         ::

             my_board = Board.from_robot(robot=robot, name="my_board")

             # Get the GPIOPin with pin number 15.
             pin = await my_board.gpio_pin_by_name(name="15")

             # Get if it is true or false that the state of the pin is high.
             high = await pin.get()

         :returns: Indicates if the state of the pin is high.
         :rtype: bool

         For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.



      .. py:method:: get_pwm(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> float
         :abstractmethod:

         :async:


         Get the pin's given duty cycle.

         ::

             my_board = Board.from_robot(robot=robot, name="my_board")

             # Get the GPIOPin with pin number 15.
             pin = await my_board.gpio_pin_by_name(name="15")

             # Get if it is true or false that the state of the pin is high.
             duty_cycle = await pin.get_pwm()

         :returns: The duty cycle.
         :rtype: float

         For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.



      .. py:method:: set_pwm(duty_cycle: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
         :abstractmethod:

         :async:


         Set the pin to the given ``duty_cycle``.

         ::

             my_board = Board.from_robot(robot=robot, name="my_board")

             # Get the GPIOPin with pin number 15.
             pin = await my_board.gpio_pin_by_name(name="15")

             # Set the duty cycle to .6, meaning that this pin will be in the high state for
             # 60% of the duration of the PWM interval period.
             await pin.set_pwm(cycle=.6)

         :param duty_cycle: The duty cycle.
         :type duty_cycle: float

         For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.



      .. py:method:: get_pwm_frequency(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> int
         :abstractmethod:

         :async:


         Get the PWM frequency of the pin.

         ::

             my_board = Board.from_robot(robot=robot, name="my_board")

             # Get the GPIOPin with pin number 15.
             pin = await my_board.gpio_pin_by_name(name="15")

             # Get the PWM frequency of this pin.
             freq = await pin.get_pwm_frequency()

         :returns: The PWM frequency.
         :rtype: int

         For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.



      .. py:method:: set_pwm_frequency(frequency: int, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
         :abstractmethod:

         :async:


         Set the pin to the given PWM ``frequency`` (in Hz).
         When ``frequency`` is 0, it will use the board's default PWM frequency.

         ::

             my_board = Board.from_robot(robot=robot, name="my_board")

             # Get the GPIOPin with pin number 15.
             pin = await my_board.gpio_pin_by_name(name="15")

             # Set the PWM frequency of this pin to 1600 Hz.
             high = await pin.set_pwm_frequency(frequency=1600)

         :param frequency: The frequency, in Hz.
         :type frequency: int

         For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.




   .. py:method:: analog_by_name(name: str) -> Analog
      :abstractmethod:

      :async:


      Get an Analog (reader or writer) by ``name``.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the Analog "my_example_analog_reader".
          reader = await my_board.analog_by_name(name="my_example_analog_reader")

      :param name: Name of the analog reader to be retrieved.
      :type name: str

      :returns: The analog reader or writer.
      :rtype: Analog

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: digital_interrupt_by_name(name: str) -> DigitalInterrupt
      :abstractmethod:

      :async:


      Get a DigitalInterrupt by ``name``.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the DigitalInterrupt "my_example_digital_interrupt".
          interrupt = await my_board.digital_interrupt_by_name(
              name="my_example_digital_interrupt")

      :param name: Name of the digital interrupt.
      :type name: str

      :returns: The digital interrupt.
      :rtype: DigitalInterrupt

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: gpio_pin_by_name(name: str) -> GPIOPin
      :abstractmethod:

      :async:


      Get a GPIO Pin by ``name``.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

      :param name: Name of the GPIO pin.
      :type name: str

      :returns: The pin.
      :rtype: GPIOPin

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: analog_names() -> List[str]
      :abstractmethod:

      :async:


      Get the names of all known analog readers and/or writers.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the name of every Analog configured on the board.
          names = await my_board.analog_names()

      :returns: The list of names of all known analog readers/writers.
      :rtype: List[str]

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: digital_interrupt_names() -> List[str]
      :abstractmethod:

      :async:


      Get the names of all known digital interrupts.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the name of every DigitalInterrupt configured on the board.
          names = await my_board.digital_interrupt_names()

      :returns: The names of the digital interrupts.
      :rtype: List[str]

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: set_power_mode(mode: viam.proto.component.board.PowerMode.ValueType, duration: Optional[datetime.timedelta] = None, *, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Set the board to the indicated power mode.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Set the power mode of the board to OFFLINE_DEEP.
          status = await my_board.set_power_mode(mode=PowerMode.POWER_MODE_OFFLINE_DEEP)

      :param mode: The desired power mode.
      :type mode: PowerMode
      :param duration: Requested duration to stay in power mode.
      :type duration: Optional[timedelta]

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: stream_ticks(interrupts: List[DigitalInterrupt], *, timeout: Optional[float] = None, **kwargs) -> TickStream
      :abstractmethod:

      :async:


      Stream digital interrupt ticks.

      ::


          my_board = Board.from_robot(robot=robot, name="my_board")
          di8 = await my_board.digital_interrupt_by_name(name="8"))
          di11 = await my_board.digital_interrupt_by_name(name="11"))

          # Iterate over stream of ticks from pins 8 and 11.
          async for tick in my_board.stream_ticks([di8, di11]):
              print(f"Pin {tick.pin_name} changed to {'high' if tick.high else 'low'} at {tick.time}")


      :param interrupts: list of digital interrupts to receive ticks from.
      :type interrupts: List[DigitalInterrupt]

      :returns: stream of ticks.
      :rtype: TickStream

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/services/frame-system/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:data:: TickStream

.. py:data:: LOGGER

.. py:class:: AnalogClient(name: str, board: BoardClient)

   Bases: :py:obj:`viam.components.board.board.Board.Analog`


   Analog represents an analog pin reader or writer that resides on a Board.


   .. py:method:: read(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> viam.components.board.board.Board.Analog.Value
      :async:


      Read the current value from the reader.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the Analog "my_example_analog_reader".
          reader = await my_board.analog_reader_by_name(
              name="my_example_analog_reader")

          # Get the value of the digital signal "my_example_analog_reader" has most
          # recently measured.
          reading = await reader.read()

      :returns: The current value, including the min, max, and step_size of the reader.
      :rtype: Value

      For more information, see `Board component Analog API <https://docs.viam.com/components/board/#analog-api>`_.



   .. py:method:: write(value: int, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :async:


      Write a value to the Analog writer.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the Analog "my_example_analog_writer".
          writer = await my_board.analog_by_name(
              name="my_example_analog_writer")

          await writer.write(42)

      :param value: Value to write to the analog writer.
      :type value: int

      For more information, see `Board component Analog API <https://docs.viam.com/components/board/#analog-api>`_.



.. py:class:: DigitalInterruptClient(name: str, board: BoardClient)

   Bases: :py:obj:`viam.components.board.board.Board.DigitalInterrupt`


   DigitalInterrupt represents a configured interrupt on the Board that
   when interrupted, calls the added callbacks. Post processors can
   be added to modify what Value it ultimately returns.

   For more information, see `digital_interrupts <https://docs.viam.com/components/board/#digital_interrupts>`_.


   .. py:method:: value(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> int
      :async:


      Get the current value of the interrupt,
      which is based on the type of interrupt.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the DigitalInterrupt "my_example_digital_interrupt".
          interrupt = await my_board.digital_interrupt_by_name(
              name="my_example_digital_interrupt")

          # Get the amount of times this DigitalInterrupt has been interrupted with a
          # tick.
          count = await interrupt.value()

      :returns: The current value.
      :rtype: int

      For more information, see
      `Board component DigitalInterrupt API <https://docs.viam.com/components/board/#digitalinterrupt-api>`_.



.. py:class:: GPIOPinClient(name: str, board: BoardClient)

   Bases: :py:obj:`viam.components.board.board.Board.GPIOPin`


   Abstract representation of an individual GPIO pin on a board.


   .. py:method:: get(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> bool
      :async:


      Get the high/low state of the pin.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Get if it is true or false that the state of the pin is high.
          high = await pin.get()

      :returns: Indicates if the state of the pin is high.
      :rtype: bool

      For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.



   .. py:method:: set(high: bool, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:


      Set the pin to either low or high.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Set the pin to high.
          await pin.set(high="true")

      :param high: When true, sets the pin to high. When false, sets the pin to low.
      :type high: bool

      For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.



   .. py:method:: get_pwm(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> float
      :async:


      Get the pin's given duty cycle.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Get if it is true or false that the state of the pin is high.
          duty_cycle = await pin.get_pwm()

      :returns: The duty cycle.
      :rtype: float

      For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.



   .. py:method:: set_pwm(duty_cycle: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:


      Set the pin to the given ``duty_cycle``.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Set the duty cycle to .6, meaning that this pin will be in the high state for
          # 60% of the duration of the PWM interval period.
          await pin.set_pwm(cycle=.6)

      :param duty_cycle: The duty cycle.
      :type duty_cycle: float

      For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.



   .. py:method:: get_pwm_frequency(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> int
      :async:


      Get the PWM frequency of the pin.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Get the PWM frequency of this pin.
          freq = await pin.get_pwm_frequency()

      :returns: The PWM frequency.
      :rtype: int

      For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.



   .. py:method:: set_pwm_frequency(frequency: int, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:


      Set the pin to the given PWM ``frequency`` (in Hz).
      When ``frequency`` is 0, it will use the board's default PWM frequency.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Set the PWM frequency of this pin to 1600 Hz.
          high = await pin.set_pwm_frequency(frequency=1600)

      :param frequency: The frequency, in Hz.
      :type frequency: int

      For more information, see `GPIOPin API <https://docs.viam.com/components/board/#gpiopin-api>`_.



.. py:class:: BoardClient(name: str, channel: grpclib.client.Channel)

   Bases: :py:obj:`viam.components.board.board.Board`, :py:obj:`viam.resource.rpc_client_base.ReconfigurableResourceRPCClientBase`


   gRPC client for the Board component.


   .. py:method:: analog_by_name(name: str) -> viam.components.board.board.Board.Analog
      :async:


      Get an Analog (reader or writer) by ``name``.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the Analog "my_example_analog_reader".
          reader = await my_board.analog_by_name(name="my_example_analog_reader")

      :param name: Name of the analog reader to be retrieved.
      :type name: str

      :returns: The analog reader or writer.
      :rtype: Analog

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: digital_interrupt_by_name(name: str) -> viam.components.board.board.Board.DigitalInterrupt
      :async:


      Get a DigitalInterrupt by ``name``.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the DigitalInterrupt "my_example_digital_interrupt".
          interrupt = await my_board.digital_interrupt_by_name(
              name="my_example_digital_interrupt")

      :param name: Name of the digital interrupt.
      :type name: str

      :returns: The digital interrupt.
      :rtype: DigitalInterrupt

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: gpio_pin_by_name(name: str) -> viam.components.board.board.Board.GPIOPin
      :async:


      Get a GPIO Pin by ``name``.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

      :param name: Name of the GPIO pin.
      :type name: str

      :returns: The pin.
      :rtype: GPIOPin

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: analog_names() -> List[str]
      :async:


      Get the names of all known analog readers and/or writers.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the name of every Analog configured on the board.
          names = await my_board.analog_names()

      :returns: The list of names of all known analog readers/writers.
      :rtype: List[str]

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: digital_interrupt_names() -> List[str]
      :async:


      Get the names of all known digital interrupts.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the name of every DigitalInterrupt configured on the board.
          names = await my_board.digital_interrupt_names()

      :returns: The names of the digital interrupts.
      :rtype: List[str]

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **__) -> Mapping[str, viam.utils.ValueTypes]
      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: set_power_mode(mode: viam.proto.component.board.PowerMode.ValueType, duration: Optional[datetime.timedelta] = None, *, timeout: Optional[float] = None, **__)
      :async:


      Set the board to the indicated power mode.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Set the power mode of the board to OFFLINE_DEEP.
          status = await my_board.set_power_mode(mode=PowerMode.POWER_MODE_OFFLINE_DEEP)

      :param mode: The desired power mode.
      :type mode: PowerMode
      :param duration: Requested duration to stay in power mode.
      :type duration: Optional[timedelta]

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/services/frame-system/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: write_analog(pin: str, value: int, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:



   .. py:method:: stream_ticks(interrupts: List[viam.components.board.board.Board.DigitalInterrupt], *, extra: Optional[Dict[str, Any]] = None, **__) -> viam.components.board.board.TickStream
      :async:


      Stream digital interrupt ticks.

      ::


          my_board = Board.from_robot(robot=robot, name="my_board")
          di8 = await my_board.digital_interrupt_by_name(name="8"))
          di11 = await my_board.digital_interrupt_by_name(name="11"))

          # Iterate over stream of ticks from pins 8 and 11.
          async for tick in my_board.stream_ticks([di8, di11]):
              print(f"Pin {tick.pin_name} changed to {'high' if tick.high else 'low'} at {tick.time}")


      :param interrupts: list of digital interrupts to receive ticks from.
      :type interrupts: List[DigitalInterrupt]

      :returns: stream of ticks.
      :rtype: TickStream

      For more information, see `Board component <https://docs.viam.com/components/board/>`_.



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




