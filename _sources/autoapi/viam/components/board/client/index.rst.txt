:py:mod:`viam.components.board.client`
======================================

.. py:module:: viam.components.board.client


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   viam.components.board.client.AnalogReaderClient
   viam.components.board.client.DigitalInterruptClient
   viam.components.board.client.GPIOPinClient
   viam.components.board.client.BoardClient




.. py:class:: AnalogReaderClient(name: str, board: BoardClient)


   Bases: :py:obj:`viam.components.board.Board.AnalogReader`

   AnalogReader represents an analog pin reader that resides on a Board.

   .. py:method:: read(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> int
      :async:

      Read the current value.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Get if it is true or false that the pin is set to high.
          duty_cycle = await pin.get_pwm()

          # Get the AnalogReader "my_example_analog_reader".
          reader = await my_board.analog_reader_by_name(
              name="my_example_analog_reader")

          # Get the value of the digital signal "my_example_analog_reader" has most
          # recently measured.
          reading = reader.read()

      :returns: The current value.
      :rtype: int



.. py:class:: DigitalInterruptClient(name: str, board: BoardClient)


   Bases: :py:obj:`viam.components.board.Board.DigitalInterrupt`

   DigitalInterrupt represents a configured interrupt on the Board that
   when interrupted, calls the added callbacks. Post processors can
   be added to modify what Value it ultimately returns.

   .. py:method:: value(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> int
      :async:

      Get the current value of the interrupt,
      which is based on the type of interrupt.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the DigitalInterrupt "my_example_digital_interrupt".
          interrupt = await my_board.digital_interrupt_by_name(
              name="my_example_digital_interrupt")

          # Get the amount of times this DigitalInterrupt has been interrupted with a
          # tick.
          count = await interrupt.value()

      :returns: The current value.
      :rtype: int



.. py:class:: GPIOPinClient(name: str, board: BoardClient)


   Bases: :py:obj:`viam.components.board.Board.GPIOPin`

   Abstract representation of an individual GPIO pin on a board

   .. py:method:: get(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> bool
      :async:

      Get the high/low state of the pin.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Get if it is true or false that the state of the pin is high.
          high = await pin.get()

      :returns: Indicates if the state of the pin is high.
      :rtype: bool


   .. py:method:: set(high: bool, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:

      Set the pin to either low or high.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Set the pin to high.
          await pin.set(high="true")

      :param high: When true, sets the pin to high. When false, sets the pin to low.
      :type high: bool


   .. py:method:: get_pwm(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> float
      :async:

      Get the pin's given duty cycle.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Get if it is true or false that the state of the pin is high.
          duty_cycle = await pin.get_pwm()

      :returns: The duty cycle.
      :rtype: float


   .. py:method:: set_pwm(duty_cycle: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:

      Set the pin to the given ``duty_cycle``.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Set the duty cycle to .6, meaning that this pin will be in the high state for
          # 60% of the duration of the PWM interval period.
          await pin.set_pwm(cycle=.6)

      :param duty_cycle: The duty cycle.
      :type duty_cycle: float


   .. py:method:: get_pwm_frequency(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> int
      :async:

      Get the PWM frequency of the pin.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Get the PWM frequency of this pin.
          freq = await pin.get_pwm_frequency()

      :returns: The PWM frequency.
      :rtype: int


   .. py:method:: set_pwm_frequency(frequency: int, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:

      Set the pin to the given PWM ``frequency`` (in Hz).
      When ``frequency`` is 0, it will use the board's default PWM frequency.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

          # Set the PWM frequency of this pin to 1600 Hz.
          high = await pin.set_pwm_frequency(frequency=1600)

      :param frequency: The frequency, in Hz.
      :type frequency: int



.. py:class:: BoardClient(name: str, channel: grpclib.client.Channel)


   Bases: :py:obj:`viam.components.board.Board`, :py:obj:`viam.resource.rpc_client_base.ReconfigurableResourceRPCClientBase`

   gRPC client for the Board component.

   .. py:method:: analog_reader_by_name(name: str) -> viam.components.board.Board.AnalogReader
      :async:

      Get an AnalogReader by ``name``.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the AnalogReader "my_example_analog_reader".
          reader = await my_board.analog_reader_by_name(name="my_example_analog_reader")

      :param name: Name of the analog reader to be retrieved.
      :type name: str

      :returns: The analog reader.
      :rtype: AnalogReader


   .. py:method:: digital_interrupt_by_name(name: str) -> viam.components.board.Board.DigitalInterrupt
      :async:

      Get a DigitalInterrupt by ``name``.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the DigitalInterrupt "my_example_digital_interrupt".
          interrupt = await my_board.digital_interrupt_by_name(
              name="my_example_digital_interrupt")

      :param name: Name of the digital interrupt.
      :type name: str

      :returns: the digital interrupt.
      :rtype: DigitalInterrupt


   .. py:method:: gpio_pin_by_name(name: str) -> viam.components.board.Board.GPIOPin
      :async:

      Get a GPIO Pin by ``name``.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the GPIOPin with pin number 15.
          pin = await my_board.gpio_pin_by_name(name="15")

      :param name: Name of the GPIO pin.
      :type name: str

      :returns: the pin.
      :rtype: GPIOPin


   .. py:method:: analog_reader_names() -> List[str]
      :async:

      Get the names of all known analog readers.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the name of every AnalogReader configured on the board.
          names = await my_board.analog_reader_names()

      :returns: The names of the analog readers..
      :rtype: List[str]


   .. py:method:: digital_interrupt_names() -> List[str]
      :async:

      Get the names of all known digital interrupts.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the name of every DigitalInterrupt configured on the board.
          names = await my_board.digital_interrupt_names()

      :returns: The names of the digital interrupts.
      :rtype: List[str]


   .. py:method:: status(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> viam.proto.common.BoardStatus
      :async:

      Return the current status of the board.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Get the current status of the board.
          status = await my_board.status()

      :returns: the status.
      :rtype: viam.proto.common.BoardStatus


   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **__) -> Mapping[str, viam.utils.ValueTypes]
      :async:

      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]


   .. py:method:: set_power_mode(mode: viam.proto.component.board.PowerMode.ValueType, duration: Optional[datetime.timedelta] = None, *, timeout: Optional[float] = None, **__)
      :async:

      Set the board to the indicated power mode.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Set the power mode of the board to OFFLINE_DEEP.
          status = await my_board.set_power_mode(mode=PowerMode.POWER_MODE_OFFLINE_DEEP)

      :param mode: the desired power mode


   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:

      Get all geometries associated with the Component, in their current configuration, in the frame of the Component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]


   .. py:method:: write_analog(pin: str, value: int, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:

      Write an analog value to a pin on the board.

      ::

          my_board = Board.from_robot(robot=robot, name="my_board")

          # Set pin 11 to value 48.
          await my_board.write_analog(pin="11", value=48)

      :param pin: name of the pin.
      :type pin: str
      :param value: value to write.
      :type value: int


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:

      Get the ResourceName for this Resource with the given name

      :param name: The name of the Resource
      :type name: str


   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation


   .. py:method:: close()
      :async:

      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to retun errors when future
      non-Close methods are called.

      ::

          await component.close()




