viam.components.motor.client
============================

.. py:module:: viam.components.motor.client


Attributes
----------

.. autoapisummary::

   viam.components.motor.client.ValueTypes


Classes
-------

.. autoapisummary::

   viam.components.motor.client.DoCommandRequest
   viam.components.motor.client.DoCommandResponse
   viam.components.motor.client.Geometry
   viam.components.motor.client.GetPositionRequest
   viam.components.motor.client.GetPositionResponse
   viam.components.motor.client.GetPropertiesRequest
   viam.components.motor.client.GetPropertiesResponse
   viam.components.motor.client.GoForRequest
   viam.components.motor.client.GoToRequest
   viam.components.motor.client.IsMovingRequest
   viam.components.motor.client.IsMovingResponse
   viam.components.motor.client.IsPoweredRequest
   viam.components.motor.client.IsPoweredResponse
   viam.components.motor.client.MotorServiceStub
   viam.components.motor.client.ResetZeroPositionRequest
   viam.components.motor.client.SetPowerRequest
   viam.components.motor.client.SetRPMRequest
   viam.components.motor.client.StopRequest
   viam.components.motor.client.ReconfigurableResourceRPCClientBase
   viam.components.motor.client.Motor
   viam.components.motor.client.MotorClient


Functions
---------

.. autoapisummary::

   viam.components.motor.client.dict_to_struct
   viam.components.motor.client.get_geometries
   viam.components.motor.client.struct_to_dict


Module Contents
---------------

.. py:class:: DoCommandRequest(*, name: str = ..., command: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandRequest represents a generic DoCommand input


   .. py:attribute:: name
      :type:  str


   .. py:property:: command
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['command', b'command']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DoCommandResponse(*, result: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandResponse represents a generic DoCommand output


   .. py:property:: result
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['result', b'result']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: Geometry(*, center: global___Pose | None = ..., sphere: global___Sphere | None = ..., box: global___RectangularPrism | None = ..., capsule: global___Capsule | None = ..., label: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Geometry contains the dimensions of a given geometry and the pose of its center. The geometry is one of either a sphere or a box.


   .. py:attribute:: label
      :type:  str

      Label of the geometry. If none supplied, will be an empty string.


   .. py:property:: center
      :type: global___Pose

      Pose of a geometries center point


   .. py:property:: sphere
      :type: global___Sphere



   .. py:property:: box
      :type: global___RectangularPrism



   .. py:property:: capsule
      :type: global___Capsule



   .. py:method:: HasField(field_name: Literal['box', b'box', 'capsule', b'capsule', 'center', b'center', 'geometry_type', b'geometry_type', 'sphere', b'sphere']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['geometry_type', b'geometry_type']) -> Literal['sphere', 'box', 'capsule'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: GetPositionRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a motor


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetPositionResponse(*, position: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: position
      :type:  float

      Current position of the motor relative to its home


.. py:class:: GetPropertiesRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a motor


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetPropertiesResponse(*, position_reporting: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: position_reporting
      :type:  bool

      Returns true if the motor supports reporting its position


.. py:class:: GoForRequest(*, name: str = ..., rpm: float = ..., revolutions: float = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a motor


   .. py:attribute:: rpm
      :type:  float

      Speed of motor travel in rotations per minute


   .. py:attribute:: revolutions
      :type:  float

      Number of revolutions relative to motor's start position


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GoToRequest(*, name: str = ..., rpm: float = ..., position_revolutions: float = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a motor


   .. py:attribute:: rpm
      :type:  float

      Speed of motor travel in rotations per minute


   .. py:attribute:: position_revolutions
      :type:  float

      Number of revolutions relative to motor's home home/zero


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: IsMovingRequest(*, name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


.. py:class:: IsMovingResponse(*, is_moving: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: is_moving
      :type:  bool


.. py:class:: IsPoweredRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a motor


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: IsPoweredResponse(*, is_on: bool = ..., power_pct: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: is_on
      :type:  bool

      Returns true if the motor is on


   .. py:attribute:: power_pct
      :type:  float

      Returns power percent (from 0 to 1, or from -1 to 1 for motors that support negative power),
      based on the last command sent to motor. If the last command was a stop command, this value
      will be 0.


.. py:class:: MotorServiceStub(channel: grpclib.client.Channel)

.. py:class:: ResetZeroPositionRequest(*, name: str = ..., offset: float = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a motor


   .. py:attribute:: offset
      :type:  float

      Motor position


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: SetPowerRequest(*, name: str = ..., power_pct: float = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a motor


   .. py:attribute:: power_pct
      :type:  float

      Percentage of motor's power, between -1 and 1


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: SetRPMRequest(*, name: str = ..., rpm: float = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a motor


   .. py:attribute:: rpm
      :type:  float

      Speed of motor travel in rotations per minute


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: StopRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of a motor


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ReconfigurableResourceRPCClientBase

   Bases: :py:obj:`ResourceRPCClientBase`


   A base RPC client that can reset its channel.

   Useful if connection is lost and then regained.


   .. py:method:: reset_channel(channel: grpclib.client.Channel)

      Called when the RPC channel was reset. Passes in the new channel.

      :param channel: The new RPC Channel
      :type channel: Channel



.. py:data:: ValueTypes

   Types that can be encoded into a protobuf `Value`

.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: get_geometries(client: viam.resource.types.SupportsGetGeometries, name: str, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
   :async:


.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:class:: Motor(name: str)

   Bases: :py:obj:`viam.components.component_base.ComponentBase`


   Motor represents a physical motor.

   This acts as an abstract base class for any drivers representing specific
   motor implementations. This cannot be used on its own. If the ``__init__()`` function is
   overridden, it must call the ``super().__init__()`` function.

   ::

       from viam.components.motor import Motor


   .. py:class:: Properties

      .. py:attribute:: position_reporting
         :type:  bool



   .. py:attribute:: SUBTYPE
      :type:  Final


   .. py:method:: set_power(power: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Sets the "percentage" of power the motor should employ between -1 and 1.
      When ``power`` is negative, the rotation will be in the backward direction.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Set the power to 40% forwards.
          await my_motor.set_power(power=0.4)

      :param power: Power between -1 and 1
                    (negative implies backwards).
      :type power: float



   .. py:method:: go_for(rpm: float, revolutions: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Spin the motor the specified number of ``revolutions`` at specified ``rpm``.
      When ``rpm`` or ``revolutions`` is a negative value, the rotation will be in the backward direction.
      Note: if both ``rpm`` and ``revolutions`` are negative, the motor will spin in the forward direction.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Turn the motor 7.2 revolutions at 60 RPM.
          await my_motor.go_for(rpm=60, revolutions=7.2)

      :param rpm: Speed at which the motor should move in rotations per minute
                  (negative implies backwards).
      :type rpm: float
      :param revolutions: Number of revolutions the motor should run for
                          (negative implies backwards).
      :type revolutions: float



   .. py:method:: go_to(rpm: float, position_revolutions: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Spin the motor to the specified position (provided in revolutions from home/zero),
      at the specified speed, in revolutions per minute.
      Regardless of the directionality of the ``rpm`` this function will move
      the motor towards the specified position.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Turn the motor to 8.3 revolutions from home at 75 RPM.
          await my_motor.go_to(rpm=75, revolutions=8.3)

      :param rpm: Speed at which the motor should rotate (absolute value).
      :type rpm: float
      :param position_revolutions: Target position relative to home/zero, in revolutions.
      :type position_revolutions: float



   .. py:method:: set_rpm(rpm: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Spin the motor indefinitely at the specified speed, in revolutions per minute.
      Positive ``rpm`` will result in forward movement and negative ``rpm`` will result in backwards movement

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Spin the motor at 75 RPM.
          await my_motor.set_rpm(rpm=75)

      :param rpm: Speed at which the motor should rotate.
      :type rpm: float



   .. py:method:: reset_zero_position(offset: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Set the current position (modified by ``offset``) to be the new zero (home) position.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Set the current position as the new home position with no offset.
          await my_motor.reset_zero_position(offset=0.0)

      :param offset: The offset from the current position to new home/zero position.
      :type offset: float



   .. py:method:: get_position(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> float
      :abstractmethod:

      :async:


      Report the position of the motor based on its encoder.
      The value returned is the number of revolutions relative to its zero position.
      This method will raise an exception if position reporting is not supported by the motor.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Get the current position of the motor.
          position = await my_motor.get_position()

      :returns: Number of revolutions the motor is away from zero/home.
      :rtype: float



   .. py:method:: get_properties(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Properties
      :abstractmethod:

      :async:


      Report a dictionary mapping optional properties to
      whether it is supported by this motor.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Report a dictionary mapping optional properties to whether it is supported by
          # this motor.
          properties = await my_motor.get_properties()

          # Print out the properties.
          print(f'Properties: {properties}')

      :returns: Map of feature names to supported status.
      :rtype: Properties



   .. py:method:: stop(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Stop the motor immediately, without any gradual step down.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Stop the motor.
          await my_motor.stop()



   .. py:method:: is_powered(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Tuple[bool, float]
      :abstractmethod:

      :async:


      Returns whether or not the motor is currently running.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Check whether the motor is currently running.
          powered = await my_motor.is_powered()

          print('Powered: ', powered)

      :returns:

                A tuple containing two values; the first [0] value indicates whether the motor is currently powered, and
                    the second [1] value indicates the current power percentage of the motor.
      :rtype: Tuple[bool, float]



   .. py:method:: is_moving() -> bool
      :abstractmethod:

      :async:


      Get if the motor is currently moving.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Check whether the motor is currently moving.
          moving = await my_motor.is_moving()
          print('Moving: ', moving)

      :returns: Whether the motor is moving.
      :rtype: bool



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/services/frame-system/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: MotorClient(name: str, channel: grpclib.client.Channel)

   Bases: :py:obj:`viam.components.motor.motor.Motor`, :py:obj:`viam.resource.rpc_client_base.ReconfigurableResourceRPCClientBase`


   gRPC client for the Motor component.


   .. py:method:: set_power(power: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:


      Sets the "percentage" of power the motor should employ between -1 and 1.
      When ``power`` is negative, the rotation will be in the backward direction.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Set the power to 40% forwards.
          await my_motor.set_power(power=0.4)

      :param power: Power between -1 and 1
                    (negative implies backwards).
      :type power: float



   .. py:method:: go_for(rpm: float, revolutions: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:


      Spin the motor the specified number of ``revolutions`` at specified ``rpm``.
      When ``rpm`` or ``revolutions`` is a negative value, the rotation will be in the backward direction.
      Note: if both ``rpm`` and ``revolutions`` are negative, the motor will spin in the forward direction.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Turn the motor 7.2 revolutions at 60 RPM.
          await my_motor.go_for(rpm=60, revolutions=7.2)

      :param rpm: Speed at which the motor should move in rotations per minute
                  (negative implies backwards).
      :type rpm: float
      :param revolutions: Number of revolutions the motor should run for
                          (negative implies backwards).
      :type revolutions: float



   .. py:method:: go_to(rpm: float, position_revolutions: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:


      Spin the motor to the specified position (provided in revolutions from home/zero),
      at the specified speed, in revolutions per minute.
      Regardless of the directionality of the ``rpm`` this function will move
      the motor towards the specified position.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Turn the motor to 8.3 revolutions from home at 75 RPM.
          await my_motor.go_to(rpm=75, revolutions=8.3)

      :param rpm: Speed at which the motor should rotate (absolute value).
      :type rpm: float
      :param position_revolutions: Target position relative to home/zero, in revolutions.
      :type position_revolutions: float



   .. py:method:: set_rpm(rpm: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:


      Spin the motor indefinitely at the specified speed, in revolutions per minute.
      Positive ``rpm`` will result in forward movement and negative ``rpm`` will result in backwards movement

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Spin the motor at 75 RPM.
          await my_motor.set_rpm(rpm=75)

      :param rpm: Speed at which the motor should rotate.
      :type rpm: float



   .. py:method:: reset_zero_position(offset: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:


      Set the current position (modified by ``offset``) to be the new zero (home) position.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Set the current position as the new home position with no offset.
          await my_motor.reset_zero_position(offset=0.0)

      :param offset: The offset from the current position to new home/zero position.
      :type offset: float



   .. py:method:: get_position(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> float
      :async:


      Report the position of the motor based on its encoder.
      The value returned is the number of revolutions relative to its zero position.
      This method will raise an exception if position reporting is not supported by the motor.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Get the current position of the motor.
          position = await my_motor.get_position()

      :returns: Number of revolutions the motor is away from zero/home.
      :rtype: float



   .. py:method:: get_properties(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> viam.components.motor.motor.Motor.Properties
      :async:


      Report a dictionary mapping optional properties to
      whether it is supported by this motor.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Report a dictionary mapping optional properties to whether it is supported by
          # this motor.
          properties = await my_motor.get_properties()

          # Print out the properties.
          print(f'Properties: {properties}')

      :returns: Map of feature names to supported status.
      :rtype: Properties



   .. py:method:: stop(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:


      Stop the motor immediately, without any gradual step down.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Stop the motor.
          await my_motor.stop()



   .. py:method:: is_powered(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> Tuple[bool, float]
      :async:


      Returns whether or not the motor is currently running.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Check whether the motor is currently running.
          powered = await my_motor.is_powered()

          print('Powered: ', powered)

      :returns:

                A tuple containing two values; the first [0] value indicates whether the motor is currently powered, and
                    the second [1] value indicates the current power percentage of the motor.
      :rtype: Tuple[bool, float]



   .. py:method:: is_moving(*, timeout: Optional[float] = None) -> bool
      :async:


      Get if the motor is currently moving.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Check whether the motor is currently moving.
          moving = await my_motor.is_moving()
          print('Moving: ', moving)

      :returns: Whether the motor is moving.
      :rtype: bool



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **__) -> Mapping[str, viam.utils.ValueTypes]
      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/services/frame-system/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




