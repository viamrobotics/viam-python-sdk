:py:mod:`viam.components.motor.client`
======================================

.. py:module:: viam.components.motor.client


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   viam.components.motor.client.MotorClient




.. py:class:: MotorClient(name: str, channel: grpclib.client.Channel)


   Bases: :py:obj:`viam.components.motor.motor.Motor`, :py:obj:`viam.resource.rpc_client_base.ReconfigurableResourceRPCClientBase`

   gRPC client for the Motor component.

   .. py:method:: set_power(power: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:

      Sets the "percentage" of power the motor should employ between -1 and 1.
      When ``power`` is negative, the rotation will be in the backward direction.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Set the power to 40% forwards.
          await my_motor.set_power(power=0.4)

      :param power: Power between -1 and 1
                    (negative implies backwards).
      :type power: float


   .. py:method:: go_for(rpm: float, revolutions: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:

      Spin the motor the specified number of ``revolutions`` at specified ``rpm``.
      When ``rpm`` or ``revolutions`` is a negative value, the rotation will be in the backward direction.
      Note: if both ``rpm`` and ``revolutions`` are negative, the motor will spin in the forward direction.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Turn the motor 7.2 revolutions at 60 RPM.
          await my_motor.go_for(rpm=60, revolutions=7.2)

      :param rpm: Speed at which the motor should move in rotations per minute
                  (negative implies backwards).
      :type rpm: float
      :param revolutions: Number of revolutions the motor should run for
                          (negative implies backwards).
      :type revolutions: float


   .. py:method:: go_to(rpm: float, position_revolutions: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:

      Spin the motor to the specified position (provided in revolutions from home/zero),
      at the specified speed, in revolutions per minute.
      Regardless of the directionality of the ``rpm`` this function will move
      the motor towards the specified position.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Turn the motor to 8.3 revolutions from home at 75 RPM.
          await my_motor.go_to(rpm=75, revolutions=8.3)

      :param rpm: Speed at which the motor should rotate (absolute value).
      :type rpm: float
      :param position_revolutions: Target position relative to home/zero, in revolutions.
      :type position_revolutions: float


   .. py:method:: reset_zero_position(offset: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:

      Set the current position (modified by ``offset``) to be the new zero (home) position.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Set the current position as the new home position with no offset.
          await my_motor.reset_zero_position(offset=0.0)

      :param offset: The offset from the current position to new home/zero position.
      :type offset: float


   .. py:method:: get_position(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> float
      :async:

      Report the position of the motor based on its encoder.
      The value returned is the number of revolutions relative to its zero position.
      This method will raise an exception if position reporting is not supported by the motor.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Get the current position of the motor.
          position = await my_motor.get_position()

      :returns: Number of revolutions the motor is away from zero/home.
      :rtype: float


   .. py:method:: get_properties(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> viam.components.motor.motor.Motor.Properties
      :async:

      Report a dictionary mapping optional properties to
      whether it is supported by this motor.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Report a dictionary mapping optional properties to whether it is supported by
          # this motor.
          properties = await my_motor.get_properties()

          # Print out the properties.
          print(f'Properties: {properties}')

      :returns: Map of feature names to supported status.
      :rtype: Properties


   .. py:method:: stop(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__)
      :async:

      Stop the motor immediately, without any gradual step down.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Stop the motor.
          await my_motor.stop()


   .. py:method:: is_powered(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **__) -> Tuple[bool, float]
      :async:

      Returns whether or not the motor is currently running.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Check whether the motor is currently running.
          powered = await my_motor.is_powered()

          print('Powered: ', powered)

      :returns: Indicates whether the motor is currently powered.
                float: The current power percentage of the motor
      :rtype: bool


   .. py:method:: is_moving(*, timeout: Optional[float] = None) -> bool
      :async:

      Get if the motor is currently moving.

      ::

          my_motor = Motor.from_robot(robot=robot, name="my_motor")

          # Check whether the motor is currently moving.
          moving = await my_motor.is_moving()
          print('Moving: ', moving)

      :returns: Whether the motor is moving.
      :rtype: bool


   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **__) -> Mapping[str, viam.utils.ValueTypes]
      :async:

      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]


   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:

      Get all geometries associated with the Component, in their current configuration, in the frame of the Component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:

      Get the ResourceName for this Resource with the given name

      :param name: The name of the Resource
      :type name: str


   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation


   .. py:method:: close()
      :async:

      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to retun errors when future
      non-Close methods are called.

      ::

          await component.close()




