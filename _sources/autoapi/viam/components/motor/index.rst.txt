:py:mod:`viam.components.motor`
===============================

.. py:module:: viam.components.motor


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   client/index.rst
   motor/index.rst
   service/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   viam.components.motor.Motor




.. py:class:: Motor(name: str)

   Bases: :py:obj:`viam.components.component_base.ComponentBase`

   Motor represents a physical motor.

   This acts as an abstract base class for any drivers representing specific
   motor implementations. This cannot be used on its own. If the ``__init__()`` function is
   overridden, it must call the ``super().__init__()`` function.

   .. py:class:: Properties

      .. py:attribute:: position_reporting
         :type: bool

         


   .. py:attribute:: SUBTYPE
      :type: Final

      

   .. py:method:: set_power(power: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:
      :async:

      Sets the "percentage" of power the motor should employ between -1 and 1.
      When ``power`` is negative, the rotation will be in the backward direction.

      :param power: Power between -1 and 1
                    (negative implies backwards).
      :type power: float


   .. py:method:: go_for(rpm: float, revolutions: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:
      :async:

      Spin the motor the specified number of ``revolutions`` at specified ``rpm``.
      When ``rpm`` or ``revolutions`` is a negative value, the rotation will be in the backward direction.
      Note: if both ``rpm`` and ``revolutions`` are negative, the motor will spin in the forward direction.

      :param rpm: Speed at which the motor should move in rotations per minute
                  (negative implies backwards).
      :type rpm: float
      :param revolutions: Number of revolutions the motor should run for
                          (negative implies backwards).
      :type revolutions: float


   .. py:method:: go_to(rpm: float, position_revolutions: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:
      :async:

      Spin the motor to the specified position (provided in revolutions from home/zero),
      at the specified speed, in revolutions per minute.
      Regardless of the directionality of the ``rpm`` this function will move
      the motor towards the specified position.

      :param rpm: Speed at which the motor should rotate (absolute value).
      :type rpm: float
      :param position_revolutions: Target position relative to home/zero, in revolutions.
      :type position_revolutions: float


   .. py:method:: reset_zero_position(offset: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:
      :async:

      Set the current position (modified by ``offset``) to be the new zero (home) position.

      :param offset: The offset from the current position to new home/zero position.
      :type offset: float


   .. py:method:: get_position(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> float
      :abstractmethod:
      :async:

      Report the position of the motor based on its encoder.
      The value returned is the number of revolutions relative to its zero position.
      This method will raise an exception if position reporting is not supported by the motor.

      :returns: Number of revolutions the motor is away from zero/home.
      :rtype: float


   .. py:method:: get_properties(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Properties
      :abstractmethod:
      :async:

      Report a dictionary mapping optional properties to
      whether it is supported by this motor.

      :returns: Map of feature names to supported status.
      :rtype: Properties


   .. py:method:: stop(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:
      :async:

      Stop the motor immediately, without any gradual step down.


   .. py:method:: is_powered(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Tuple[bool, float]
      :abstractmethod:
      :async:

      Returns whether or not the motor is currently running.

      :returns: Indicates whether the motor is currently powered.
                float: The current power percentage of the motor
      :rtype: bool


   .. py:method:: is_moving() -> bool
      :abstractmethod:
      :async:

      Get if the motor is currently moving.

      :returns: Whether the motor is moving.
      :rtype: bool


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self


   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:
      :async:

      Send/Receive arbitrary commands to the Resource

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:

      Get the ResourceName for this Resource with the given name

      :param name: The name of the Resource
      :type name: str


   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: Operation



