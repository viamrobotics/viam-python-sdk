viam.components.motor
=====================

.. py:module:: viam.components.motor


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/viam/components/motor/client/index
   /autoapi/viam/components/motor/motor/index
   /autoapi/viam/components/motor/service/index


Classes
-------

.. autoapisummary::

   viam.components.motor.Motor


Package Contents
----------------

.. py:class:: Motor(name: str, *, logger: Optional[logging.Logger] = None)

   Bases: :py:obj:`viam.components.component_base.ComponentBase`


   Motor represents a physical motor.

   This acts as an abstract base class for any drivers representing specific
   motor implementations. This cannot be used on its own. If the ``__init__()`` function is
   overridden, it must call the ``super().__init__()`` function.

   ::

       from viam.components.motor import Motor

   For more information, see `Motor component <https://docs.viam.com/dev/reference/apis/components/motor/>`_.


   .. py:class:: Properties

      .. py:attribute:: position_reporting
         :type:  bool



   .. py:attribute:: API
      :type:  Final

      The API of the Resource


   .. py:method:: set_power(power: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Sets the "percentage" of power the motor should employ between -1 and 1.
      When ``power`` is negative, the rotation will be in the backward direction.

      ::

          my_motor = Motor.from_robot(robot=machine, name="my_motor")

          # Set the power to 40% forwards.
          await my_motor.set_power(power=0.4)

      :param power: Power between -1 and 1
                    (negative implies backwards).
      :type power: float

      For more information, see `Motor component <https://docs.viam.com/dev/reference/apis/components/motor/#setpower>`_.



   .. py:method:: go_for(rpm: float, revolutions: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Spin the motor the specified number of ``revolutions`` at specified ``rpm``.
      When ``rpm`` or ``revolutions`` is a negative value, the rotation will be in the backward direction.
      Note: if both ``rpm`` and ``revolutions`` are negative, the motor will spin in the forward direction.

      ::

          my_motor = Motor.from_robot(robot=machine, name="my_motor")

          # Turn the motor 7.2 revolutions at 60 RPM.
          await my_motor.go_for(rpm=60, revolutions=7.2)

      :param rpm: Speed at which the motor should move in rotations per minute
                  (negative implies backwards).
      :type rpm: float
      :param revolutions: Number of revolutions the motor should run for
                          (negative implies backwards).
      :type revolutions: float

      For more information, see `Motor component <https://docs.viam.com/dev/reference/apis/components/motor/#gofor>`_.



   .. py:method:: go_to(rpm: float, position_revolutions: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Spin the motor to the specified position (provided in revolutions from home/zero),
      at the specified speed, in revolutions per minute.
      Regardless of the directionality of the ``rpm`` this function will move
      the motor towards the specified position.

      ::

          my_motor = Motor.from_robot(robot=machine, name="my_motor")

          # Turn the motor to 8.3 revolutions from home at 75 RPM.
          await my_motor.go_to(rpm=75, revolutions=8.3)

      :param rpm: Speed at which the motor should rotate (absolute value).
      :type rpm: float
      :param position_revolutions: Target position relative to home/zero, in revolutions.
      :type position_revolutions: float

      For more information, see `Motor component <https://docs.viam.com/dev/reference/apis/components/motor/#goto>`_.



   .. py:method:: set_rpm(rpm: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Spin the motor indefinitely at the specified speed, in revolutions per minute.
      Positive ``rpm`` will result in forward movement and negative ``rpm`` will result in backwards movement

      ::

          my_motor = Motor.from_robot(robot=machine, name="my_motor")

          # Spin the motor at 75 RPM.
          await my_motor.set_rpm(rpm=75)

      :param rpm: Speed at which the motor should rotate.
      :type rpm: float

      For more information, see `Motor component <https://docs.viam.com/dev/reference/apis/components/motor/#setrpm>`_.



   .. py:method:: reset_zero_position(offset: float, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Set the current position (modified by ``offset``) to be the new zero (home) position.

      ::

          my_motor = Motor.from_robot(robot=machine, name="my_motor")

          # Set the current position as the new home position with no offset.
          await my_motor.reset_zero_position(offset=0.0)

      :param offset: The offset from the current position to new home/zero position.
      :type offset: float

      For more information, see `Motor component <https://docs.viam.com/dev/reference/apis/components/motor/#resetzeroposition>`_.



   .. py:method:: get_position(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> float
      :abstractmethod:

      :async:


      Report the position of the motor based on its encoder.
      The value returned is the number of revolutions relative to its zero position.
      This method will raise an exception if position reporting is not supported by the motor.

      ::

          my_motor = Motor.from_robot(robot=machine, name="my_motor")

          # Get the current position of the motor.
          position = await my_motor.get_position()

      :returns: Number of revolutions the motor is away from zero/home.
      :rtype: float

      For more information, see `Motor component <https://docs.viam.com/dev/reference/apis/components/motor/#getposition>`_.



   .. py:method:: get_properties(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Properties
      :abstractmethod:

      :async:


      Report a dictionary mapping optional properties to
      whether it is supported by this motor.

      ::

          my_motor = Motor.from_robot(robot=machine, name="my_motor")

          # Report a dictionary mapping optional properties to whether it is supported by
          # this motor.
          properties = await my_motor.get_properties()

          # Print out the properties.
          print(f'Properties: {properties}')

      :returns: Map of feature names to supported status.
      :rtype: Properties

      For more information, see `Motor component <https://docs.viam.com/dev/reference/apis/components/motor/#getproperties>`_.



   .. py:method:: stop(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Stop the motor immediately, without any gradual step down.

      ::

          my_motor = Motor.from_robot(robot=machine, name="my_motor")

          # Stop the motor.
          await my_motor.stop()

      For more information, see `Motor component <https://docs.viam.com/dev/reference/apis/components/motor/#stop>`_.



   .. py:method:: is_powered(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Tuple[bool, float]
      :abstractmethod:

      :async:


      Returns whether or not the motor is currently running.

      ::

          my_motor = Motor.from_robot(robot=machine, name="my_motor")

          # Check whether the motor is currently running.
          powered = await my_motor.is_powered()

          print('Powered: ', powered)

      :returns: A tuple containing two values; the first [0] value indicates whether the motor is currently powered, and
                the second [1] value indicates the current power percentage of the motor.
      :rtype: Tuple[bool, float]

      For more information, see `Motor component <https://docs.viam.com/dev/reference/apis/components/motor/#ispowered>`_.



   .. py:method:: is_moving() -> bool
      :abstractmethod:

      :async:


      Get if the motor is currently moving.

      ::

          my_motor = Motor.from_robot(robot=machine, name="my_motor")

          # Check whether the motor is currently moving.
          moving = await my_motor.is_moving()
          print('Moving: ', moving)

      :returns: Whether the motor is moving.
      :rtype: bool

      For more information, see `Motor component <https://docs.viam.com/dev/reference/apis/components/motor/#ismoving>`_.



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = await component.do_command(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> Sequence[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/operate/mobility/define-geometry/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = Arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




