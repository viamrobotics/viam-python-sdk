:py:mod:`viam.components.movement_sensor`
=========================================

.. py:module:: viam.components.movement_sensor


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   client/index.rst
   movement_sensor/index.rst
   service/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   viam.components.movement_sensor.GeoPoint
   viam.components.movement_sensor.Orientation
   viam.components.movement_sensor.Vector3
   viam.components.movement_sensor.MovementSensor




.. py:class:: GeoPoint(*, latitude: float = ..., longitude: float = ...)


   Bases: :py:obj:`google.protobuf.message.Message`

   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: latitude
      :type: float

      

   .. py:attribute:: longitude
      :type: float

      


.. py:class:: Orientation(*, o_x: float = ..., o_y: float = ..., o_z: float = ..., theta: float = ...)


   Bases: :py:obj:`google.protobuf.message.Message`

   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: o_x
      :type: float

      x component of a vector defining axis of rotation

   .. py:attribute:: o_y
      :type: float

      y component of a vector defining axis of rotation

   .. py:attribute:: o_z
      :type: float

      z component of a vector defining axis of rotation

   .. py:attribute:: theta
      :type: float

      degrees


.. py:class:: Vector3(*, x: float = ..., y: float = ..., z: float = ...)


   Bases: :py:obj:`google.protobuf.message.Message`

   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: x
      :type: float

      

   .. py:attribute:: y
      :type: float

      

   .. py:attribute:: z
      :type: float

      


.. py:class:: MovementSensor(name: str)


   Bases: :py:obj:`viam.components.sensor.Sensor`

   MovementSensor reports information about the robot's direction, position and speed.

   This acts as an abstract base class for any sensors that can provide data regarding the robot's direction, position, and speed.
   This cannot be used on its own. If the ``__init__()`` function is overridden, it must call the ``super().__init__()`` function.

   .. py:class:: Properties


      .. py:property:: proto
         :type: viam.proto.component.movementsensor.GetPropertiesResponse


      .. py:attribute:: linear_acceleration_supported
         :type: bool

         

      .. py:attribute:: angular_velocity_supported
         :type: bool

         

      .. py:attribute:: orientation_supported
         :type: bool

         

      .. py:attribute:: position_supported
         :type: bool

         

      .. py:attribute:: compass_heading_supported
         :type: bool

         

      .. py:attribute:: linear_velocity_supported
         :type: bool

         

      .. py:method:: from_proto(proto: viam.proto.component.movementsensor.GetPropertiesResponse) -> typing_extensions.Self
         :classmethod:



   .. py:attribute:: SUBTYPE
      :type: Final

      

   .. py:method:: get_position(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Tuple[viam.components.movement_sensor.GeoPoint, float]
      :abstractmethod:
      :async:

      Get the current GeoPoint (latitude, longitude) and altitude (m)

      :returns: The current lat/long, along with the altitude in m
      :rtype: Tuple[GeoPoint, float]


   .. py:method:: get_linear_velocity(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> viam.components.movement_sensor.Vector3
      :abstractmethod:
      :async:

      Get the current linear velocity as a ``Vector3`` with x, y, and z axes represented in m/sec

      :returns: The linear velocity in m/sec
      :rtype: Vector3


   .. py:method:: get_angular_velocity(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> viam.components.movement_sensor.Vector3
      :abstractmethod:
      :async:

      Get the current angular velocity as a ``Vector3`` with x, y, and z axes represented in degrees/sec

      :returns: The angular velocity in degrees/sec
      :rtype: Vector3


   .. py:method:: get_linear_acceleration(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> viam.components.movement_sensor.Vector3
      :abstractmethod:
      :async:

      Get the current linear acceleration as a ``Vector3`` with x, y, and z axes represented in m/sec^2

      :returns: The linear acceleration in m/sec^2
      :rtype: Vector3


   .. py:method:: get_compass_heading(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> float
      :abstractmethod:
      :async:

      Get the current compass heading in degrees

      :returns: The compass heading in degrees
      :rtype: float


   .. py:method:: get_orientation(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> viam.components.movement_sensor.Orientation
      :abstractmethod:
      :async:

      Get the current orientation

      :returns: The orientation
      :rtype: Orientation


   .. py:method:: get_properties(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Properties
      :abstractmethod:
      :async:

      Get the supported properties of this sensor

      :returns: The properties
      :rtype: MovementSensor.Properties


   .. py:method:: get_accuracy(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Mapping[str, float]
      :abstractmethod:
      :async:

      Get the accuracy of the various sensors

      :returns: The accuracy
      :rtype: Dict[str, float]


   .. py:method:: get_readings(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Mapping[str, Any]
      :async:

      Obtain the measurements/data specific to this sensor.
      If a sensor is not configured to have a measurement or fails to read a piece of data, it will not appear in the readings dictionary.

      :returns: The readings for the MovementSensor:
                {
                    position: GeoPoint,
                    altitude: float,
                    linear_velocity: Vector3,
                    angular_velocity: Vector3,
                    linear_acceleration: Vector3,
                    compass: float,
                    orientation: Orientation,
                }
      :rtype: Mapping[str, Any]


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self


   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:
      :async:

      Send/Receive arbitrary commands to the Resource

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:

      Get the ResourceName for this Resource with the given name

      :param name: The name of the Resource
      :type name: str


   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



