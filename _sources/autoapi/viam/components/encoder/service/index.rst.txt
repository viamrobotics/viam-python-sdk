viam.components.encoder.service
===============================

.. py:module:: viam.components.encoder.service


Classes
-------

.. autoapisummary::

   viam.components.encoder.service.DoCommandRequest
   viam.components.encoder.service.DoCommandResponse
   viam.components.encoder.service.GetGeometriesRequest
   viam.components.encoder.service.GetGeometriesResponse
   viam.components.encoder.service.EncoderServiceBase
   viam.components.encoder.service.GetPositionRequest
   viam.components.encoder.service.GetPositionResponse
   viam.components.encoder.service.GetPropertiesRequest
   viam.components.encoder.service.GetPropertiesResponse
   viam.components.encoder.service.ResetPositionRequest
   viam.components.encoder.service.ResetPositionResponse
   viam.components.encoder.service.ResourceRPCServiceBase
   viam.components.encoder.service.Encoder
   viam.components.encoder.service.EncoderRPCService


Functions
---------

.. autoapisummary::

   viam.components.encoder.service.dict_to_struct
   viam.components.encoder.service.struct_to_dict


Module Contents
---------------

.. py:class:: DoCommandRequest(*, name: str = ..., command: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandRequest represents a generic DoCommand input


   .. py:attribute:: name
      :type:  str


   .. py:property:: command
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['command', b'command']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DoCommandResponse(*, result: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandResponse represents a generic DoCommand output


   .. py:property:: result
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['result', b'result']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetGeometriesRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      The component name


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetGeometriesResponse(*, geometries: collections.abc.Iterable[global___Geometry] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: geometries
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Geometry]

      All geometries associated with the component, in their current configuration, in the frame of that component.


.. py:class:: EncoderServiceBase

   Bases: :py:obj:`abc.ABC`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:method:: GetPosition(stream: grpclib.server.Stream[component.encoder.v1.encoder_pb2.GetPositionRequest, component.encoder.v1.encoder_pb2.GetPositionResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: ResetPosition(stream: grpclib.server.Stream[component.encoder.v1.encoder_pb2.ResetPositionRequest, component.encoder.v1.encoder_pb2.ResetPositionResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetProperties(stream: grpclib.server.Stream[component.encoder.v1.encoder_pb2.GetPropertiesRequest, component.encoder.v1.encoder_pb2.GetPropertiesResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: DoCommand(stream: grpclib.server.Stream[common.v1.common_pb2.DoCommandRequest, common.v1.common_pb2.DoCommandResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetGeometries(stream: grpclib.server.Stream[common.v1.common_pb2.GetGeometriesRequest, common.v1.common_pb2.GetGeometriesResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: __mapping__() -> Dict[str, grpclib.const.Handler]


.. py:class:: GetPositionRequest(*, name: str = ..., position_type: global___PositionType | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of encoder


   .. py:attribute:: position_type
      :type:  global___PositionType

      If supplied, the response will return the specified
      position type. If the driver does not implement
      the requested type, this call will return an error.
      If position type is not specified, the response
      will return a default according to the driver.


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['_position_type', b'_position_type', 'extra', b'extra', 'position_type', b'position_type']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_position_type', b'_position_type']) -> Literal['position_type'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: GetPositionResponse(*, value: float = ..., position_type: global___PositionType = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: value
      :type:  float


   .. py:attribute:: position_type
      :type:  global___PositionType


.. py:class:: GetPropertiesRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of the encoder


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetPropertiesResponse(*, ticks_count_supported: bool = ..., angle_degrees_supported: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: ticks_count_supported
      :type:  bool


   .. py:attribute:: angle_degrees_supported
      :type:  bool


.. py:class:: ResetPositionRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of an encoder


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ResetPositionResponse

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: ResourceRPCServiceBase(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`abc.ABC`, :py:obj:`viam.rpc.types.RPCServiceBase`, :py:obj:`Generic`\ [\ :py:obj:`viam.resource.manager.ResourceType`\ ]


   Base RPC service for a resource.
   All resource RPC services must inherit from this class.


   .. py:attribute:: RESOURCE_TYPE


   .. py:attribute:: manager
      :type:  viam.resource.manager.ResourceManager


   .. py:method:: get_resource(name: str) -> viam.resource.manager.ResourceType

      Return the resource with the given name if it exists in the registry.
      If the resource does not exist in the registry,
      this function will raise an error

      :param name: Name of the resource
      :type name: str

      :raises GRPCError with the status code Status.NOT_FOUND:

      :returns: The resource
      :rtype: ResourceType



.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:class:: Encoder(name: str)

   Bases: :py:obj:`viam.components.component_base.ComponentBase`


   Base component.
   All components must inherit from this class.


   .. py:class:: Properties

      .. py:attribute:: ticks_count_supported
         :type:  bool


      .. py:attribute:: angle_degrees_supported
         :type:  bool



   .. py:attribute:: SUBTYPE
      :type:  Final


   .. py:method:: reset_position(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Set the current position to be the new zero (home) position.

      ::

          my_encoder = Encoder.from_robot(robot=robot, name='my_encoder')

          # Reset the zero position of the encoder.
          await my_encoder.reset_position()




   .. py:method:: get_position(position_type: Optional[viam.proto.component.encoder.PositionType.ValueType] = None, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Tuple[float, viam.proto.component.encoder.PositionType.ValueType]
      :abstractmethod:

      :async:


      Report the position of the encoder.
      The value returned is the current position in terms of it's ``position_type``.
      The position will be either in relative units (ticks away from a zero position) for
      ``PositionType.TICKS`` or absolute units (degrees along a circle) for ``PositionType.DEGREES``.

      ::

          my_encoder = Encoder.from_robot(robot=robot, name='my_encoder')

          # Get the position of the encoder in ticks
          position = await my_encoder.get_position(encoder.PositionTypeTicks)
          print("The encoder position is currently ", position[0], position[1])

      :param position_type: The desired output type of the position.
      :type position_type: PositionType.ValueType

      :returns: A tuple containing two values; the first [0] the Position of the encoder
                which can either be ticks since last zeroing for a relative encoder or degrees for an absolute encoder,
                and the second [1] the type of position the encoder returns (ticks or degrees).
      :rtype: Tuple[float, PositionType]



   .. py:method:: get_properties(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> Properties
      :abstractmethod:

      :async:


      Return a dictionary of the types of position reporting this encoder supports

      ::

          my_encoder = Encoder.from_robot(robot=robot, name='my_encoder')

          # Get whether the encoder returns position in ticks or degrees.
          properties = await my_encoder.get_properties()

      :returns: Map of position types to supported status.
      :rtype: Encoder.Properties



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/services/frame-system/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: EncoderRPCService(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`viam.proto.component.encoder.EncoderServiceBase`, :py:obj:`viam.resource.rpc_service_base.ResourceRPCServiceBase`\ [\ :py:obj:`viam.components.encoder.encoder.Encoder`\ ]


   gRPC Service for an Encoder


   .. py:attribute:: RESOURCE_TYPE


   .. py:method:: ResetPosition(stream: grpclib.server.Stream[viam.proto.component.encoder.ResetPositionRequest, viam.proto.component.encoder.ResetPositionResponse]) -> None
      :async:



   .. py:method:: GetPosition(stream: grpclib.server.Stream[viam.proto.component.encoder.GetPositionRequest, viam.proto.component.encoder.GetPositionResponse]) -> None
      :async:



   .. py:method:: GetProperties(stream: grpclib.server.Stream[viam.proto.component.encoder.GetPropertiesRequest, viam.proto.component.encoder.GetPropertiesResponse]) -> None
      :async:



   .. py:method:: DoCommand(stream: grpclib.server.Stream[viam.proto.common.DoCommandRequest, viam.proto.common.DoCommandResponse]) -> None
      :async:



   .. py:method:: GetGeometries(stream: grpclib.server.Stream[viam.proto.common.GetGeometriesRequest, viam.proto.common.GetGeometriesResponse]) -> None
      :async:



