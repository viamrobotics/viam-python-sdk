viam.components.arm.service
===========================

.. py:module:: viam.components.arm.service


Classes
-------

.. autoapisummary::

   viam.components.arm.service.DoCommandRequest
   viam.components.arm.service.DoCommandResponse
   viam.components.arm.service.GetGeometriesRequest
   viam.components.arm.service.GetGeometriesResponse
   viam.components.arm.service.GetKinematicsRequest
   viam.components.arm.service.GetKinematicsResponse
   viam.components.arm.service.ArmServiceBase
   viam.components.arm.service.GetEndPositionRequest
   viam.components.arm.service.GetEndPositionResponse
   viam.components.arm.service.GetJointPositionsRequest
   viam.components.arm.service.GetJointPositionsResponse
   viam.components.arm.service.IsMovingRequest
   viam.components.arm.service.IsMovingResponse
   viam.components.arm.service.MoveToJointPositionsRequest
   viam.components.arm.service.MoveToJointPositionsResponse
   viam.components.arm.service.MoveToPositionRequest
   viam.components.arm.service.MoveToPositionResponse
   viam.components.arm.service.StopRequest
   viam.components.arm.service.StopResponse
   viam.components.arm.service.ResourceRPCServiceBase
   viam.components.arm.service.Arm
   viam.components.arm.service.ArmRPCService


Functions
---------

.. autoapisummary::

   viam.components.arm.service.dict_to_struct
   viam.components.arm.service.struct_to_dict


Module Contents
---------------

.. py:class:: DoCommandRequest(*, name: str = ..., command: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandRequest represents a generic DoCommand input


   .. py:attribute:: name
      :type:  str


   .. py:property:: command
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['command', b'command']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DoCommandResponse(*, result: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandResponse represents a generic DoCommand output


   .. py:property:: result
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['result', b'result']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetGeometriesRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      The component name


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetGeometriesResponse(*, geometries: collections.abc.Iterable[global___Geometry] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: geometries
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Geometry]

      All geometries associated with the component, in their current configuration, in the frame of that component.


.. py:class:: GetKinematicsRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      The component name


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetKinematicsResponse(*, format: global___KinematicsFileFormat = ..., kinematics_data: bytes = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: format
      :type:  global___KinematicsFileFormat

      The kinematics of the component, in either URDF format or in Viam’s kinematic parameter format (spatial vector algebra)
      https://docs.viam.com/internals/kinematic-chain-config/#kinematic-parameters


   .. py:attribute:: kinematics_data
      :type:  bytes

      The byte contents of the file


.. py:class:: ArmServiceBase

   Bases: :py:obj:`abc.ABC`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:method:: GetEndPosition(stream: grpclib.server.Stream[component.arm.v1.arm_pb2.GetEndPositionRequest, component.arm.v1.arm_pb2.GetEndPositionResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: MoveToPosition(stream: grpclib.server.Stream[component.arm.v1.arm_pb2.MoveToPositionRequest, component.arm.v1.arm_pb2.MoveToPositionResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetJointPositions(stream: grpclib.server.Stream[component.arm.v1.arm_pb2.GetJointPositionsRequest, component.arm.v1.arm_pb2.GetJointPositionsResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: MoveToJointPositions(stream: grpclib.server.Stream[component.arm.v1.arm_pb2.MoveToJointPositionsRequest, component.arm.v1.arm_pb2.MoveToJointPositionsResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: Stop(stream: grpclib.server.Stream[component.arm.v1.arm_pb2.StopRequest, component.arm.v1.arm_pb2.StopResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: IsMoving(stream: grpclib.server.Stream[component.arm.v1.arm_pb2.IsMovingRequest, component.arm.v1.arm_pb2.IsMovingResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: DoCommand(stream: grpclib.server.Stream[common.v1.common_pb2.DoCommandRequest, common.v1.common_pb2.DoCommandResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetKinematics(stream: grpclib.server.Stream[common.v1.common_pb2.GetKinematicsRequest, common.v1.common_pb2.GetKinematicsResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetGeometries(stream: grpclib.server.Stream[common.v1.common_pb2.GetGeometriesRequest, common.v1.common_pb2.GetGeometriesResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: __mapping__() -> Dict[str, grpclib.const.Handler]


.. py:class:: GetEndPositionRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of an arm


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetEndPositionResponse(*, pose: viam.gen.common.v1.common_pb2.Pose | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: pose
      :type: viam.gen.common.v1.common_pb2.Pose

      Returns 6d pose of the end effector relative to the base, represented by X,Y,Z coordinates which express
      millimeters and theta, ox, oy, oz coordinates which express an orientation vector


   .. py:method:: HasField(field_name: Literal['pose', b'pose']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetJointPositionsRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of an arm


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetJointPositionsResponse(*, positions: global___JointPositions | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: positions
      :type: global___JointPositions

      a list JointPositions


   .. py:method:: HasField(field_name: Literal['positions', b'positions']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: IsMovingRequest(*, name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


.. py:class:: IsMovingResponse(*, is_moving: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: is_moving
      :type:  bool


.. py:class:: MoveToJointPositionsRequest(*, name: str = ..., positions: global___JointPositions | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of an arm


   .. py:property:: positions
      :type: global___JointPositions

      A list of joint positions
      There should be 1 entry in the list per joint DOF, ordered spatially from the base toward the end effector


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra', 'positions', b'positions']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: MoveToJointPositionsResponse

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: MoveToPositionRequest(*, name: str = ..., to: viam.gen.common.v1.common_pb2.Pose | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Moves an arm to the specified pose that is within the reference frame of the arm.
   Move request in Motion API has the same behavior except that it performs obstacle avoidance when a world_state
   message is specified.


   .. py:attribute:: name
      :type:  str

      Name of an arm


   .. py:property:: to
      :type: viam.gen.common.v1.common_pb2.Pose

      The destination to move the arm to; this is from the reference frame of the arm.


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra', 'to', b'to']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: MoveToPositionResponse

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: StopRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of an arm


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: StopResponse

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: ResourceRPCServiceBase(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`abc.ABC`, :py:obj:`viam.rpc.types.RPCServiceBase`, :py:obj:`Generic`\ [\ :py:obj:`viam.resource.manager.ResourceType`\ ]


   Base RPC service for a resource.
   All resource RPC services must inherit from this class.


   .. py:attribute:: RESOURCE_TYPE


   .. py:attribute:: manager
      :type:  viam.resource.manager.ResourceManager


   .. py:method:: get_resource(name: str) -> viam.resource.manager.ResourceType

      Return the resource with the given name if it exists in the registry.
      If the resource does not exist in the registry,
      this function will raise an error

      :param name: Name of the resource
      :type name: str

      :raises GRPCError with the status code Status.NOT_FOUND:

      :returns: The resource
      :rtype: ResourceType



.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:class:: Arm(name: str)

   Bases: :py:obj:`viam.components.component_base.ComponentBase`


   Arm represents a physical robot arm that exists in three-dimensional space.

   This acts as an abstract base class for any drivers representing specific
   arm implementations. This cannot be used on its own. If the ``__init__()`` function is
   overridden, it must call the ``super().__init__()`` function.

   ::

       from viam.components.arm import Arm
       # To use move_to_position:
       from viam.proto.common import Pose
       # To use move_to_joint_positions:
       from viam.proto.component.arm import JointPositions

   For more information, see `Arm component <https://docs.viam.com/components/arm/>`_.


   .. py:attribute:: SUBTYPE
      :type:  Final


   .. py:method:: get_end_position(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> viam.components.arm.Pose
      :abstractmethod:

      :async:


      Get the current position of the end of the arm expressed as a ``Pose``.

      ::

          my_arm = Arm.from_robot(robot=robot, name="my_arm")

          # Get the end position of the arm as a Pose.
          pos = await my_arm.get_end_position()

      :returns: A representation of the arm’s current position as a 6 DOF (six degrees of freedom) pose.
                The ``Pose`` is composed of values for location and orientation with respect to the origin.
                Location is expressed as distance, which is represented by x, y, and z coordinate values.
                Orientation is expressed as an orientation vector, which is represented by o_x, o_y, o_z, and theta values.
      :rtype: Pose

      For more information, see `Arm component <https://docs.viam.com/components/arm/>`_.



   .. py:method:: move_to_position(pose: viam.components.arm.Pose, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Move the end of the arm to the Pose specified in ``pose``.

      ::

          my_arm = Arm.from_robot(robot=robot, name="my_arm")

          # Create a Pose for the arm.
          examplePose = Pose(x=5, y=5, z=5, o_x=5, o_y=5, o_z=5, theta=20)

          # Move your arm to the Pose.
          await my_arm.move_to_position(pose=examplePose)

      :param pose: The destination ``Pose`` for the arm. The ``Pose`` is composed of values for location and orientation
                   with respect to the origin.
                   Location is expressed as distance, which is represented by x, y, and z coordinate values.
                   Orientation is expressed as an orientation vector, which is represented by o_x, o_y, o_z, and theta values.
      :type pose: Pose

      For more information, see `Arm component <https://docs.viam.com/components/arm/>`_.



   .. py:method:: move_to_joint_positions(positions: viam.components.arm.JointPositions, *, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Move each joint on the arm to the corresponding angle specified in ``positions``.

      ::

          my_arm = Arm.from_robot(robot=robot, name="my_arm")

          # Declare a list of values with your desired rotational value for each joint on
          # the arm.
          degrees = [0.0, 45.0, 0.0, 0.0, 0.0]

          # Declare a new JointPositions with these values.
          jointPos = arm.move_to_joint_positions(
              JointPositions(values=[0.0, 45.0, 0.0, 0.0, 0.0]))

          # Move each joint of the arm to the position these values specify.
          await my_arm.move_to_joint_positions(positions=jointPos)

      :param positions: The destination ``JointPositions`` for the arm.
      :type positions: JointPositions

      For more information, see `Arm component <https://docs.viam.com/components/arm/>`_.



   .. py:method:: get_joint_positions(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs) -> viam.components.arm.JointPositions
      :abstractmethod:

      :async:


      Get the JointPositions representing the current position of the arm.

      ::

          my_arm = Arm.from_robot(robot=robot, name="my_arm")

          # Get the current position of each joint on the arm as JointPositions.
          pos = await my_arm.get_joint_positions()

      :returns: The current ``JointPositions`` for the arm.
                ``JointPositions`` can have one attribute, ``values``, a list of joint positions with rotational values (degrees)
                and translational values (mm).
      :rtype: JointPositions

      For more information, see `Arm component <https://docs.viam.com/components/arm/>`_.



   .. py:method:: stop(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None, **kwargs)
      :abstractmethod:

      :async:


      Stop all motion of the arm. It is assumed that the arm stops immediately.

      ::

          my_arm = Arm.from_robot(robot=robot, name="my_arm")

          # Stop all motion of the arm. It is assumed that the arm stops immediately.
          await my_arm.stop()

      For more information, see `Arm component <https://docs.viam.com/components/arm/>`_.



   .. py:method:: is_moving() -> bool
      :abstractmethod:

      :async:


      Get if the arm is currently moving.

      ::

          my_arm = Arm.from_robot(robot=robot, name="my_arm")

          # Stop all motion of the arm. It is assumed that the arm stops immediately.
          await my_arm.stop()

          # Print if the arm is currently moving.
          print(my_arm.is_moving())

      :returns: Whether the arm is moving.
      :rtype: bool

      For more information, see `Arm component <https://docs.viam.com/components/arm/>`_.



   .. py:method:: get_kinematics(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> Tuple[viam.components.arm.KinematicsFileFormat.ValueType, bytes]
      :abstractmethod:

      :async:


      Get the kinematics information associated with the arm.

      ::

          my_arm = Arm.from_robot(robot=robot, name="my_arm")

          # Get the kinematics information associated with the arm.
          kinematics = await my_arm.get_kinematics()

          # Get the format of the kinematics file.
          k_file = kinematics[0]

          # Get the byte contents of the file.
          k_bytes = kinematics[1]

      :returns: A tuple containing two values; the first [0] value represents the format of the
                file, either in URDF format or Viam's kinematic parameter format (spatial vector algebra), and the second [1] value
                represents the byte contents of the file.
      :rtype: Tuple[KinematicsFileFormat.ValueType, bytes]

      For more information, see `Arm component <https://docs.viam.com/components/arm/>`_.



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the component named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the component
      :type name: str

      :returns: The component, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_geometries(*, extra: Optional[Dict[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.Geometry]
      :async:


      Get all geometries associated with the component, in their current configuration, in the
      `frame <https://docs.viam.com/services/frame-system/>`__ of the component.

      ::

          geometries = await component.get_geometries()

          if geometries:
              # Get the center of the first geometry
              print(f"Pose of the first geometry's centerpoint: {geometries[0].center}")

      :returns: The geometries associated with the Component.
      :rtype: List[Geometry]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: ArmRPCService(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`viam.proto.component.arm.ArmServiceBase`, :py:obj:`viam.resource.rpc_service_base.ResourceRPCServiceBase`\ [\ :py:obj:`viam.components.arm.arm.Arm`\ ]


   gRPC Service for an Arm


   .. py:attribute:: RESOURCE_TYPE


   .. py:method:: GetEndPosition(stream: grpclib.server.Stream[viam.proto.component.arm.GetEndPositionRequest, viam.proto.component.arm.GetEndPositionResponse]) -> None
      :async:



   .. py:method:: MoveToPosition(stream: grpclib.server.Stream[viam.proto.component.arm.MoveToPositionRequest, viam.proto.component.arm.MoveToPositionResponse]) -> None
      :async:



   .. py:method:: GetJointPositions(stream: grpclib.server.Stream[viam.proto.component.arm.GetJointPositionsRequest, viam.proto.component.arm.GetJointPositionsResponse]) -> None
      :async:



   .. py:method:: MoveToJointPositions(stream: grpclib.server.Stream[viam.proto.component.arm.MoveToJointPositionsRequest, viam.proto.component.arm.MoveToJointPositionsResponse]) -> None
      :async:



   .. py:method:: Stop(stream: grpclib.server.Stream[viam.proto.component.arm.StopRequest, viam.proto.component.arm.StopResponse]) -> None
      :async:



   .. py:method:: IsMoving(stream: grpclib.server.Stream[viam.proto.component.arm.IsMovingRequest, viam.proto.component.arm.IsMovingResponse]) -> None
      :async:



   .. py:method:: DoCommand(stream: grpclib.server.Stream[viam.proto.common.DoCommandRequest, viam.proto.common.DoCommandResponse]) -> None
      :async:



   .. py:method:: GetKinematics(stream: grpclib.server.Stream[viam.proto.common.GetKinematicsRequest, viam.proto.common.GetKinematicsResponse]) -> None
      :async:



   .. py:method:: GetGeometries(stream: grpclib.server.Stream[viam.proto.common.GetGeometriesRequest, viam.proto.common.GetGeometriesResponse]) -> None
      :async:



