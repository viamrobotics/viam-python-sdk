viam.resource.easy_resource
===========================

.. py:module:: viam.resource.easy_resource


Attributes
----------

.. autoapisummary::

   viam.resource.easy_resource.modelRegex
   viam.resource.easy_resource.logger


Classes
-------

.. autoapisummary::

   viam.resource.easy_resource.EasyResource


Functions
---------

.. autoapisummary::

   viam.resource.easy_resource.stub_model


Module Contents
---------------

.. py:data:: modelRegex

.. py:data:: logger

.. py:function:: stub_model(cls: abc.ABCMeta) -> abc.ABCMeta

   Class decorator which adds error implementations of abstract functions. This means they will fail
   when called, rather than the default where they fail when instantiated. This is intended for developers
   who want to build and test incrementally, not for production use.

   .. rubric:: Example

   @stub_model
   class MyMotor(Motor, EasyResource):
       MODEL = 'viam:motor:easy-resource-example'

   Normally this class would fail to instantiate. With the decorator, it will succeed but the unimplemented
   methods will throw errors at runtime.


.. py:class:: EasyResource(name: str)

   EasyResource is a mixin that simplifies the process of creating Viam modules (extension programs)
   and resources (the resource classes provided by those extension programs).

   Basic usage:

   ::

       class MyModel(Sensor, EasyResource):
           MODEL = "my-org:sensor:my-sensor"

           async def get_readings(self, **kwargs):
               return {"ok": True}

   See examples/easy_resource/main.py for extended usage.


   .. py:attribute:: API
      :type:  ClassVar[EasyResource.API]


   .. py:attribute:: MODEL
      :type:  ClassVar[viam.resource.types.Model]


   .. py:method:: __init_subclass__(register=True, **kwargs)
      :classmethod:


      When you subclass this mixin, it parses cls.MODEL and registers cls in global registry.



   .. py:attribute:: name


   .. py:method:: new(config: viam.proto.app.robot.ComponentConfig, dependencies: Mapping[viam.proto.common.ResourceName, viam.resource.base.ResourceBase])
      :classmethod:


      This is passed to register_resource_creator; the default implementation calls reconfigure()
      when an instance of your model is instantiated. You can override this in your subclass.



   .. py:method:: validate_config(config: viam.proto.app.robot.ComponentConfig) -> Sequence[str]
      :classmethod:


      This method allows you to validate the configuration object received from the machine,
      as well as to return any implicit dependencies based on that `config`.

      :param config: The configuration for this resource
      :type config: ComponentConfig

      :returns: A list of implicit dependencies
      :rtype: Sequence[str]



   .. py:method:: register()
      :classmethod:


      This adds the model to the global registry. It is called by __init_subclass__ and you typically
      won't call it directly.



   .. py:method:: reconfigure(config: viam.proto.app.robot.ComponentConfig, dependencies: Mapping[viam.proto.common.ResourceName, viam.resource.base.ResourceBase])


