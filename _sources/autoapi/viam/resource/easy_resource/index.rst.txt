viam.resource.easy_resource
===========================

.. py:module:: viam.resource.easy_resource


Attributes
----------

.. autoapisummary::

   viam.resource.easy_resource.modelRegex
   viam.resource.easy_resource.logger


Exceptions
----------

.. autoapisummary::

   viam.resource.easy_resource.MethodNotImplementedError


Classes
-------

.. autoapisummary::

   viam.resource.easy_resource.ComponentConfig
   viam.resource.easy_resource.ResourceName
   viam.resource.easy_resource.ResourceBase
   viam.resource.easy_resource.Registry
   viam.resource.easy_resource.ResourceCreatorRegistration
   viam.resource.easy_resource.Model
   viam.resource.easy_resource.ModelFamily
   viam.resource.easy_resource.Subtype
   viam.resource.easy_resource.EasyResource


Functions
---------

.. autoapisummary::

   viam.resource.easy_resource.stub_model


Module Contents
---------------

.. py:class:: ComponentConfig(*, name: str = ..., namespace: str = ..., type: str = ..., model: str = ..., frame: global___Frame | None = ..., depends_on: collections.abc.Iterable[str] | None = ..., service_configs: collections.abc.Iterable[global___ResourceLevelServiceConfig] | None = ..., attributes: google.protobuf.struct_pb2.Struct | None = ..., api: str = ..., log_configuration: global___LogConfiguration | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: namespace
      :type:  str

      deprecated; use api


   .. py:attribute:: type
      :type:  str

      deprecated; use api


   .. py:attribute:: model
      :type:  str


   .. py:attribute:: api
      :type:  str


   .. py:property:: frame
      :type: global___Frame



   .. py:property:: depends_on
      :type: google.protobuf.internal.containers.RepeatedScalarFieldContainer[str]



   .. py:property:: service_configs
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ResourceLevelServiceConfig]



   .. py:property:: attributes
      :type: google.protobuf.struct_pb2.Struct



   .. py:property:: log_configuration
      :type: global___LogConfiguration



   .. py:method:: HasField(field_name: Literal['attributes', b'attributes', 'frame', b'frame', 'log_configuration', b'log_configuration']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ResourceName(*, namespace: str = ..., type: str = ..., subtype: str = ..., name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: namespace
      :type:  str


   .. py:attribute:: type
      :type:  str


   .. py:attribute:: subtype
      :type:  str


   .. py:attribute:: name
      :type:  str


.. py:exception:: MethodNotImplementedError(method_name: str)

   Bases: :py:obj:`ViamGRPCError`


   Exception raised when specific methods are unimplemented.


.. py:class:: ResourceBase

   Bases: :py:obj:`Protocol`


   The base requirements for a Resource.


   .. py:attribute:: SUBTYPE
      :type:  ClassVar[viam.resource.types.Subtype]

      The Subtype of the Resource


   .. py:attribute:: name
      :type:  str

      The name of the Resource


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      :abstractmethod:


      Get the Resource named ``name`` from the provided robot.

      ::

          # Can be used with any resource, using an arm as an example
          my_arm = Arm.from_robot(robot, "my_arm")

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the Resource
      :type name: str

      :returns: The Resource, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: Registry

   The global registry of robotic parts.

   **NB** The Registry should almost never be used directly

   The Registry keeps track of the types of Resources that are available on robots using this SDK. All the base resource types are
   pre-registered (for example Arm, Motor).

   If you create a new resource type that is not an extension of any of the existing base resource types, then you must register said
   resource using ``Registry.register(...)``.


   .. py:method:: register_subtype(registration: ResourceRegistration[Resource])
      :classmethod:


      Register a Subtype with the Registry

      :param registration: Object containing registration data for the subtype
      :type registration: ResourceRegistration

      :raises DuplicateResourceError: Raised if the Subtype to register is already in the registry
      :raises ValidationError: Raised if registration is missing any necessary parameters



   .. py:method:: register_resource_creator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model, registration: ResourceCreatorRegistration)
      :classmethod:


      Register a specific ``Model`` and validator function for the specific resource ``Subtype`` with the Registry

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model
      :param registration: The registration functions of the model
      :type registration: ResourceCreatorRegistration

      :raises DuplicateResourceError: Raised if the Subtype and Model pairing is already registered
      :raises ValidationError: Raised if registration does not have creator



   .. py:method:: lookup_subtype(subtype: viam.resource.types.Subtype) -> ResourceRegistration
      :classmethod:


      Lookup and retrieve a registered Subtype by its name

      :param subtype: The subtype of the resource
      :type subtype: str

      :raises ResourceNotFoundError: Raised if the Subtype is not registered

      :returns: The registration object of the resource
      :rtype: ResourceRegistration



   .. py:method:: lookup_resource_creator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model) -> viam.resource.types.ResourceCreator
      :classmethod:


      Lookup and retrieve a registered resource creator by its subtype and model

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model

      :raises ResourceNotFoundError: Raised if the Subtype Model pairing is not registered

      :returns: The function to create the resource
      :rtype: ResourceCreator



   .. py:method:: lookup_validator(subtype: viam.resource.types.Subtype, model: viam.resource.types.Model) -> viam.resource.types.Validator
      :classmethod:


      Lookup and retrieve a registered validator function by its subtype and model. If there is none, return None

      :param subtype: The Subtype of the resource
      :type subtype: Subtype
      :param model: The Model of the resource
      :type model: Model

      :returns: The function to validate the resource
      :rtype: Validator



   .. py:method:: REGISTERED_SUBTYPES() -> Mapping[viam.resource.types.Subtype, ResourceRegistration]
      :classmethod:


      The dictionary of all registered resources
      - Key: Subtype of the resource
      - Value: The registration object for the resource

      :returns: All registered resources
      :rtype: Mapping[Subtype, ResourceRegistration]



   .. py:method:: REGISTERED_RESOURCE_CREATORS() -> Mapping[str, ResourceCreatorRegistration]
      :classmethod:


      The dictionary of all registered resources
      - Key: subtype/model
      - Value: The ResourceCreatorRegistration for the resource

      :returns: All registered resources
      :rtype: Mapping[str, ResourceCreatorRegistration]



.. py:class:: ResourceCreatorRegistration

   An object representing a resource creator to be registered.

   If creating a custom Resource creator, you should register the creator by creating a ``ResourceCreatorRegistration`` object and
   registering it to the ``Registry``.


   .. py:attribute:: creator
      :type:  viam.resource.types.ResourceCreator

      A function that can create a resource given a mapping of dependencies (``ResourceName`` to ``ResourceBase``


   .. py:attribute:: validator
      :type:  viam.resource.types.Validator

      A function that can validate a resource and return implicit dependencies.

      If called without a validator function, default to a function returning an empty Sequence


.. py:class:: Model(model_family: ModelFamily, name: str)

   Represents a specific model within a family of models


   .. py:attribute:: model_family
      :type:  ModelFamily

      The family to which this model belongs


   .. py:attribute:: name
      :type:  str

      The name of the model


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __hash__() -> int

      Return hash(self).



   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: from_string(model: str, *, ignore_errors=False) -> typing_extensions.Self
      :classmethod:


      Create a ```Model``` from its string representation (namespace:family:name).

      :param model: The Model as a string
      :type model: str
      :param ignore_errors: If namespace or family are not found in the string, default to empty string
                            rather than raise an exception. Defaults to False.
      :type ignore_errors: bool, optional

      :raises ValueError: Raised if the provided string is not a valid Model

      :returns: The Model
      :rtype: Self



.. py:class:: ModelFamily(namespace: str, family: str)

   Represents a family of related models


   .. py:attribute:: namespace
      :type:  str

      The namespace of the model family


   .. py:attribute:: family
      :type:  str

      The family name


   .. py:attribute:: DEFAULT_FAMILY_NAME
      :type:  ClassVar[str]
      :value: 'builtin'



   .. py:attribute:: DEFAULT
      :type:  ClassVar[ModelFamily]


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __hash__() -> int

      Return hash(self).



   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



.. py:class:: Subtype(namespace: str, resource_type: str, resource_subtype: str)

   Represents a known component/service (resource) API


   .. py:attribute:: namespace
      :type:  str

      The namespace of the resource


   .. py:attribute:: resource_type
      :type:  str

      The type of the resource, for example `component` or `service`


   .. py:attribute:: resource_subtype
      :type:  str

      The subtype of the resource for example `servo`, `arm`, `vision`


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __hash__() -> int

      Return hash(self).



   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: from_resource_name(resource_name: viam.proto.common.ResourceName) -> typing_extensions.Self
      :classmethod:


      Convert a ```ResourceName``` into a ```Subtype```

      :param resource_name: The ResourceName to convert
      :type resource_name: viam.proto.common.ResourceName

      :returns: A new Subtype
      :rtype: Self



   .. py:method:: from_string(string: str) -> typing_extensions.Self
      :classmethod:


      Create a ```Subtype``` from its string representation (namespace:resource_type:resource_subtype)

      :param string: The Subtype as a string
      :type string: str

      :raises ValueError: Raised if the string does not represent a valid Subtype

      :returns: A new Subtype
      :rtype: Self



.. py:data:: modelRegex

.. py:data:: logger

.. py:function:: stub_model(cls: abc.ABCMeta) -> abc.ABCMeta

   Class decorator which adds error implementations of abstract functions. This means they will fail
   when called, rather than the default where they fail when instantiated. This is intended for developers
   who want to build and test incrementally, not for production use.

   .. rubric:: Example

   @stub_model
   class MyMotor(Motor, EasyResource):
       MODEL = 'viam:motor:easy-resource-example'

   Normally this class would fail to instantiate. With the decorator, it will succeed but the unimplemented
   methods will throw errors at runtime.


.. py:class:: EasyResource(name: str)

   EasyResource is a mixin that simplifies the process of creating Viam modules (extension programs)
   and resources (the resource classes provided by those extension programs).

   Basic usage:

   ::

       class MyModel(Sensor, EasyResource):
           MODEL = "my-org:sensor:my-sensor"

           async def get_readings(self, **kwargs):
               return {"ok": True}

   See examples/easy_resource/main.py for extended usage.


   .. py:attribute:: SUBTYPE
      :type:  viam.resource.types.Subtype


   .. py:attribute:: MODEL
      :type:  viam.resource.types.Model


   .. py:method:: __init_subclass__(register=True, **kwargs)
      :classmethod:


      When you subclass this mixin, it parses cls.MODEL and registers cls in global registry.



   .. py:method:: new(config: viam.proto.app.robot.ComponentConfig, dependencies: Mapping[viam.proto.common.ResourceName, viam.resource.base.ResourceBase])
      :classmethod:


      This is passed to register_resource_creator; the default implementation calls reconfigure()
      when an instance of your model is instantiated. You can override this in your subclass.



   .. py:method:: register()
      :classmethod:


      This adds the model to the global registry. It is called by __init_subclass__ and you typically
      won't call it directly.



   .. py:method:: reconfigure(config: viam.proto.app.robot.ComponentConfig, dependencies: Mapping[viam.proto.common.ResourceName, viam.resource.base.ResourceBase])


