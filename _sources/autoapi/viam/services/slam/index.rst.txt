:py:mod:`viam.services.slam`
============================

.. py:module:: viam.services.slam


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   client/index.rst
   service/index.rst
   slam/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   viam.services.slam.Pose
   viam.services.slam.SLAMClient




.. py:class:: Pose(*, x: float = ..., y: float = ..., z: float = ..., o_x: float = ..., o_y: float = ..., o_z: float = ..., theta: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`

   Pose is a combination of location and orientation.
   Location is expressed as distance which is represented by x , y, z coordinates. Orientation is expressed as an orientation vector which
   is represented by o_x, o_y, o_z and theta. The o_x, o_y, o_z coordinates represent the point on the cartesian unit sphere that the end of
   the arm is pointing to (with the origin as reference). That unit vector forms an axis around which theta rotates. This means that
   incrementing / decrementing theta will perform an inline rotation of the end effector.
   Theta is defined as rotation between two planes: the first being defined by the origin, the point (0,0,1), and the rx, ry, rz point, and the
   second being defined by the origin, the rx, ry, rz point and the local Z axis. Therefore, if theta is kept at zero as the north/south pole
   is circled, the Roll will correct itself to remain in-line.

   .. py:attribute:: x
      :type: float

      millimeters from the origin

   .. py:attribute:: y
      :type: float

      millimeters from the origin

   .. py:attribute:: z
      :type: float

      millimeters from the origin

   .. py:attribute:: o_x
      :type: float

      z component of a vector defining axis of rotation

   .. py:attribute:: o_y
      :type: float

      x component of a vector defining axis of rotation

   .. py:attribute:: o_z
      :type: float

      y component of a vector defining axis of rotation

   .. py:attribute:: theta
      :type: float

      degrees


.. py:class:: SLAMClient(name: str, channel: grpclib.client.Channel)

   Bases: :py:obj:`viam.services.slam.slam.SLAM`, :py:obj:`viam.resource.rpc_client_base.ReconfigurableResourceRPCClientBase`

   Connect to the SLAMService, which allows the robot to create a map of its surroundings and find its location in that map.

   .. py:method:: get_position(*, timeout: Optional[float] = None) -> viam.services.slam.Pose
      :async:

      Get current position of the specified component in the SLAM Map.

      :returns: The current position of the specified component
      :rtype: Pose


   .. py:method:: get_point_cloud_map(*, timeout: Optional[float] = None) -> List[viam.proto.service.slam.GetPointCloudMapResponse]
      :async:

      Get the point cloud map.

      :returns:

                Complete pointcloud in standard PCD format. Chunks of the PointCloud, concatenating all
                    GetPointCloudMapResponse.point_cloud_pcd_chunk values
      :rtype: List[GetPointCloudMapResponse]


   .. py:method:: get_internal_state(*, timeout: Optional[float] = None) -> List[viam.proto.service.slam.GetInternalStateResponse]
      :async:

      Get the internal state of the SLAM algorithm required to continue mapping/localization.

      :returns: Chunks of the internal state of the SLAM algorithm
      :rtype: List[GetInternalStateResponse]


   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None) -> Mapping[str, viam.utils.ValueTypes]
      :async:

      Send/Receive arbitrary commands to the Resource

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      Get the service named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service
      :type name: str

      :returns: The service, if it exists on the robot
      :rtype: Self


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:

      Get the ResourceName for this Resource with the given name

      :param name: The name of the Resource
      :type name: str


   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



