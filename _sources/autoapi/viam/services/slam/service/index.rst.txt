viam.services.slam.service
==========================

.. py:module:: viam.services.slam.service


Classes
-------

.. autoapisummary::

   viam.services.slam.service.DoCommandRequest
   viam.services.slam.service.DoCommandResponse
   viam.services.slam.service.GetInternalStateRequest
   viam.services.slam.service.GetInternalStateResponse
   viam.services.slam.service.GetPointCloudMapRequest
   viam.services.slam.service.GetPointCloudMapResponse
   viam.services.slam.service.GetPositionRequest
   viam.services.slam.service.GetPositionResponse
   viam.services.slam.service.GetPropertiesRequest
   viam.services.slam.service.GetPropertiesResponse
   viam.services.slam.service.SLAMServiceBase
   viam.services.slam.service.ResourceRPCServiceBase
   viam.services.slam.service.SLAM
   viam.services.slam.service.SLAMRPCService


Functions
---------

.. autoapisummary::

   viam.services.slam.service.dict_to_struct
   viam.services.slam.service.struct_to_dict


Module Contents
---------------

.. py:class:: DoCommandRequest(*, name: str = ..., command: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandRequest represents a generic DoCommand input


   .. py:attribute:: name
      :type:  str


   .. py:property:: command
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['command', b'command']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DoCommandResponse(*, result: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandResponse represents a generic DoCommand output


   .. py:property:: result
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['result', b'result']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetInternalStateRequest(*, name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of slam service


.. py:class:: GetInternalStateResponse(*, internal_state_chunk: bytes = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: internal_state_chunk
      :type:  bytes

      Chunk of the internal state of the SLAM algorithm required to continue
      mapping/localization


.. py:class:: GetPointCloudMapRequest(*, name: str = ..., return_edited_map: bool | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of slam service


   .. py:attribute:: return_edited_map
      :type:  bool

      For SLAM services that implement handling an edited map, this boolean
      should indicate whether to return that edited map. If the SLAM service
      does not handle edited maps, the unedited map will be returned instead.


   .. py:method:: HasField(field_name: Literal['_return_edited_map', b'_return_edited_map', 'return_edited_map', b'return_edited_map']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_return_edited_map', b'_return_edited_map']) -> Literal['return_edited_map'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: GetPointCloudMapResponse(*, point_cloud_pcd_chunk: bytes = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: point_cloud_pcd_chunk
      :type:  bytes

      One chunk of the PointCloud.
      For a given GetPointCloudMap request, concatenating all
      GetPointCloudMapResponse.point_cloud_pcd_chunk values in the
      order received result in the complete pointcloud in standard PCD
      format where XY is the ground plane and positive Z is up, following
      the Right Hand Rule.

      Read more about the pointcloud format here:
      https://pointclouds.org/documentation/tutorials/pcd_file_format.html

      Viam expects pointcloud data with fields "x y z" or "x y z rgb", and for
      this to be specified in the pointcloud header in the FIELDS entry. If color
      data is included in the pointcloud, Viam's services assume that the color
      value encodes a confidence score for that data point. Viam expects the
      confidence score to be encoded in the blue parameter of the RGB value, on a
      scale from 1-100.

      Pointclouds are little endian encoded.


.. py:class:: GetPositionRequest(*, name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of slam service


.. py:class:: GetPositionResponse(*, pose: viam.gen.common.v1.common_pb2.Pose | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: pose
      :type: viam.gen.common.v1.common_pb2.Pose

      Current position of the specified component in the SLAM Map


   .. py:method:: HasField(field_name: Literal['pose', b'pose']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetPropertiesRequest(*, name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of the slam service


.. py:class:: GetPropertiesResponse(*, cloud_slam: bool = ..., mapping_mode: global___MappingMode = ..., internal_state_file_type: str | None = ..., sensor_info: collections.abc.Iterable[global___SensorInfo] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Returns properties information for the named slam service


   .. py:attribute:: cloud_slam
      :type:  bool


   .. py:attribute:: mapping_mode
      :type:  global___MappingMode


   .. py:attribute:: internal_state_file_type
      :type:  str


   .. py:property:: sensor_info
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SensorInfo]



   .. py:method:: HasField(field_name: Literal['_internal_state_file_type', b'_internal_state_file_type', 'internal_state_file_type', b'internal_state_file_type']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_internal_state_file_type', b'_internal_state_file_type']) -> Literal['internal_state_file_type'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: SLAMServiceBase

   Bases: :py:obj:`abc.ABC`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:method:: GetPosition(stream: grpclib.server.Stream[service.slam.v1.slam_pb2.GetPositionRequest, service.slam.v1.slam_pb2.GetPositionResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetPointCloudMap(stream: grpclib.server.Stream[service.slam.v1.slam_pb2.GetPointCloudMapRequest, service.slam.v1.slam_pb2.GetPointCloudMapResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetInternalState(stream: grpclib.server.Stream[service.slam.v1.slam_pb2.GetInternalStateRequest, service.slam.v1.slam_pb2.GetInternalStateResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetProperties(stream: grpclib.server.Stream[service.slam.v1.slam_pb2.GetPropertiesRequest, service.slam.v1.slam_pb2.GetPropertiesResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: DoCommand(stream: grpclib.server.Stream[common.v1.common_pb2.DoCommandRequest, common.v1.common_pb2.DoCommandResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: __mapping__() -> Dict[str, grpclib.const.Handler]


.. py:class:: ResourceRPCServiceBase(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`abc.ABC`, :py:obj:`viam.rpc.types.RPCServiceBase`, :py:obj:`Generic`\ [\ :py:obj:`viam.resource.manager.ResourceType`\ ]


   Base RPC service for a resource.
   All resource RPC services must inherit from this class.


   .. py:attribute:: RESOURCE_TYPE


   .. py:attribute:: manager
      :type:  viam.resource.manager.ResourceManager


   .. py:method:: get_resource(name: str) -> viam.resource.manager.ResourceType

      Return the resource with the given name if it exists in the registry.
      If the resource does not exist in the registry,
      this function will raise an error

      :param name: Name of the resource
      :type name: str

      :raises GRPCError with the status code Status.NOT_FOUND:

      :returns: The resource
      :rtype: ResourceType



.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:class:: SLAM(name: str)

   Bases: :py:obj:`viam.services.service_base.ServiceBase`


   SLAM represents a SLAM service.

   This acts as an abstract base class for any drivers representing specific
   arm implementations. This cannot be used on its own. If the ``__init__()`` function is
   overridden, it must call the ``super().__init__()`` function.


   .. py:attribute:: SUBTYPE
      :type:  Final


   .. py:attribute:: Properties
      :type:  TypeAlias
      :value: GetPropertiesResponse



   .. py:method:: get_internal_state(*, timeout: Optional[float]) -> List[bytes]
      :abstractmethod:

      :async:


      Get the internal state of the SLAM algorithm required to continue mapping/localization.

      ::

          slam = SLAMClient.from_robot(robot=robot, name="my_slam_service")

          # Get the internal state of the SLAM algorithm required to continue mapping/localization.
          internal_state = await slam.get_internal_state()

      :returns: Chunks of the internal state of the SLAM algorithm
      :rtype: List[GetInternalStateResponse]



   .. py:method:: get_point_cloud_map(return_edited_map: bool = False, *, timeout: Optional[float]) -> List[bytes]
      :abstractmethod:

      :async:


      Get the point cloud map.

      ::

          slam_svc = SLAMClient.from_robot(robot=robot, name="my_slam_service")

          # Get the point cloud map in standard PCD format.
          pcd_map = await slam_svc.get_point_cloud_map()

      :param return_edited_map: signal to the SLAM service to return an edited map, if the map package contains one and if
                                the SLAM service supports the feature
      :type return_edited_map: bool

      :returns: Complete pointcloud in standard PCD format. Chunks of the PointCloud, concatenating all
                GetPointCloudMapResponse.point_cloud_pcd_chunk values.
      :rtype: List[GetPointCloudMapResponse]



   .. py:method:: get_position(*, timeout: Optional[float]) -> viam.services.slam.Pose
      :abstractmethod:

      :async:


      Get current position of the specified component in the SLAM Map.

      ::

          slam_svc = SLAMClient.from_robot(robot=robot, name="my_slam_service")

          # Get the current position of the specified source component in the SLAM map as a Pose.
          pose = await slam.get_position()

      :returns: The current position of the specified component
      :rtype: Pose



   .. py:method:: get_properties(*, timeout: Optional[float]) -> Properties
      :abstractmethod:

      :async:


      Get information regarding the current SLAM session.

      ::

          slam_svc = SLAMClient.from_robot(robot=robot, name="my_slam_service")

          # Get the properties of your current SLAM session.
          slam_properties = await slam_svc.get_properties()

      :returns: The properties of SLAM
      :rtype: Properties



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the service named ``name`` from the provided robot.

      ::

          async def connect() -> ViamClient:
              # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
              dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
              return await ViamClient.create_from_dial_options(dial_options)

          async def main():
              robot = await connect()

              # Can be used with any resource, using the motion service as an example
              motion = MotionClient.from_robot(robot=robot, name="builtin")

              robot.close()

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service
      :type name: str

      :returns: The service, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:

      :async:


      Send/receive arbitrary commands.

      ::

          motion = MotionClient.from_robot(robot, "builtin")

          my_command = {
            "cmnd": "dosomething",
            "someparameter": 52
          }

          # Can be used with any resource, using the motion service as an example
          await motion.do_command(command=my_command)

      :param command: The command to execute
      :type command: Dict[str, ValueTypes]

      :returns: Result of the executed command
      :rtype: Dict[str, ValueTypes]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: SLAMRPCService(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`viam.proto.service.slam.SLAMServiceBase`, :py:obj:`viam.resource.rpc_service_base.ResourceRPCServiceBase`


   gRPC Service for a SLAM service


   .. py:attribute:: RESOURCE_TYPE


   .. py:method:: GetInternalState(stream: grpclib.server.Stream[viam.proto.service.slam.GetInternalStateRequest, viam.proto.service.slam.GetInternalStateResponse]) -> None
      :async:



   .. py:method:: GetPointCloudMap(stream: grpclib.server.Stream[viam.proto.service.slam.GetPointCloudMapRequest, viam.proto.service.slam.GetPointCloudMapResponse]) -> None
      :async:



   .. py:method:: GetPosition(stream: grpclib.server.Stream[viam.proto.service.slam.GetPositionRequest, viam.proto.service.slam.GetPositionResponse]) -> None
      :async:



   .. py:method:: GetProperties(stream: grpclib.server.Stream[viam.proto.service.slam.GetPropertiesRequest, viam.proto.service.slam.GetPropertiesResponse]) -> None
      :async:



   .. py:method:: DoCommand(stream: grpclib.server.Stream[viam.proto.common.DoCommandRequest, viam.proto.common.DoCommandResponse]) -> None
      :async:



