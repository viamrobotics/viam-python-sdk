:py:mod:`viam.services.motion`
==============================

.. py:module:: viam.services.motion


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   client/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   viam.services.motion.MotionConfiguration
   viam.services.motion.MotionClient




.. py:class:: MotionConfiguration(*, vision_services: collections.abc.Iterable[viam.gen.common.v1.common_pb2.ResourceName] | None = ..., position_polling_frequency_hz: float | None = ..., obstacle_polling_frequency_hz: float | None = ..., plan_deviation_m: float | None = ..., linear_m_per_sec: float | None = ..., angular_degs_per_sec: float | None = ...)


   Bases: :py:obj:`google.protobuf.message.Message`

   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:property:: vision_services
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.ResourceName]

      The name of the vision service(s) that will be used to detect obstacles

   .. py:attribute:: position_polling_frequency_hz
      :type: float

      Sets the frequency to poll for the position of the robot

   .. py:attribute:: obstacle_polling_frequency_hz
      :type: float

      Sets the frequency to poll the vision service(s) for new obstacles

   .. py:attribute:: plan_deviation_m
      :type: float

      Sets the distance in meters that a robot is allowed to deviate from the motion plan

   .. py:attribute:: linear_m_per_sec
      :type: float

      Optional linear velocity to target when moving

   .. py:attribute:: angular_degs_per_sec
      :type: float

      Optional angular velocity to target when turning

   .. py:method:: HasField(field_name: Literal[_angular_degs_per_sec, b'_angular_degs_per_sec', _linear_m_per_sec, b'_linear_m_per_sec', _obstacle_polling_frequency_hz, b'_obstacle_polling_frequency_hz', _plan_deviation_m, b'_plan_deviation_m', _position_polling_frequency_hz, b'_position_polling_frequency_hz', angular_degs_per_sec, b'angular_degs_per_sec', linear_m_per_sec, b'linear_m_per_sec', obstacle_polling_frequency_hz, b'obstacle_polling_frequency_hz', plan_deviation_m, b'plan_deviation_m', position_polling_frequency_hz, b'position_polling_frequency_hz']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.


   .. py:method:: WhichOneof(oneof_group: Literal[_angular_degs_per_sec, b'_angular_degs_per_sec']) -> Literal[angular_degs_per_sec] | None
                  WhichOneof(oneof_group: Literal[_linear_m_per_sec, b'_linear_m_per_sec']) -> Literal[linear_m_per_sec] | None
                  WhichOneof(oneof_group: Literal[_obstacle_polling_frequency_hz, b'_obstacle_polling_frequency_hz']) -> Literal[obstacle_polling_frequency_hz] | None
                  WhichOneof(oneof_group: Literal[_plan_deviation_m, b'_plan_deviation_m']) -> Literal[plan_deviation_m] | None
                  WhichOneof(oneof_group: Literal[_position_polling_frequency_hz, b'_position_polling_frequency_hz']) -> Literal[position_polling_frequency_hz] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: MotionClient(name: str, channel: grpclib.client.Channel)


   Bases: :py:obj:`viam.services.service_client_base.ServiceClientBase`, :py:obj:`viam.resource.rpc_client_base.ReconfigurableResourceRPCClientBase`

   Motion is a Viam service that coordinates motion planning across all of the components in a given robot.

   The motion planning service calculates a valid path that avoids self collision by default. If additional constraints are supplied in the
   ``world_state`` message, the motion planning service will also account for those.

   .. py:attribute:: SUBTYPE
      :type: Final

      

   .. py:attribute:: client
      :type: viam.proto.service.motion.MotionServiceStub

      

   .. py:method:: move(component_name: viam.proto.common.ResourceName, destination: viam.proto.common.PoseInFrame, world_state: Optional[viam.proto.common.WorldState] = None, constraints: Optional[viam.proto.service.motion.Constraints] = None, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> bool
      :async:

      Plan and execute a movement to move the component specified to its goal destination.

      Note: Frames designated with respect to components can also be used as the ``component_name`` when calling for a move. This
      technique allows for planning and moving the frame itself to the ``destination``. To do so, simply create a resource name with
      originating ReferenceFrame's name. Then pass in the resource name into ``component_name``. Ex::

          resource_name = Arm.get_resource_name("externalFrame")
          success = await MotionServiceClient.move(resource_name, ...)

      :param component_name: Name of a component on a given robot.
      :type component_name: viam.proto.common.ResourceName
      :param destination: The destination to move to, expressed as a ``Pose`` and the frame in which it was
                          observed.
      :type destination: viam.proto.common.PoseInFrame
      :param world_state: When supplied, the motion service will create a plan that obeys any contraints
                          expressed in the WorldState message.
      :type world_state: viam.proto.common.WorldState
      :param constraints: When supplied, the motion service will create a plan that obeys any
                          specified constraints
      :type constraints: viam.proto.service.motion.Constraints

      :returns: Whether the move was successful
      :rtype: bool


   .. py:method:: move_on_globe(component_name: viam.proto.common.ResourceName, destination: viam.proto.common.GeoPoint, movement_sensor_name: viam.proto.common.ResourceName, obstacles: Optional[Sequence[viam.proto.common.GeoObstacle]] = None, heading: Optional[float] = None, configuration: Optional[viam.proto.service.motion.MotionConfiguration] = None, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> bool
      :async:

      Move a component to a specific latitude and longitude, using a ``MovementSensor`` to check the location.

      :param component_name: The component to move
      :type component_name: ResourceName
      :param destination: The destination point
      :type destination: GeoPoint
      :param movement_sensor_name: The ``MovementSensor`` which will be used to check robot location
      :type movement_sensor_name: ResourceName
      :param obstacles: Obstacles to be considered for motion planning. Defaults to None.
      :type obstacles: Optional[Sequence[GeoObstacle]], optional
      :param heading: Compass heading to achieve at the destination, in degrees [0-360). Defaults to None.
      :type heading: Optional[float], optional
      :param linear_meters_per_sec: Linear velocity to target when moving. Defaults to None.
      :type linear_meters_per_sec: Optional[float], optional
      :param angular_deg_per_sec: Angular velocity to target when turning. Defaults to None.
      :type angular_deg_per_sec: Optional[float], optional

      :returns: Whether the request was successful
      :rtype: bool


   .. py:method:: move_on_map(component_name: viam.proto.common.ResourceName, destination: viam.proto.common.Pose, slam_service_name: viam.proto.common.ResourceName, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> bool
      :async:

      Move a component to a specific pose, using a ``SlamService`` for the SLAM map

      :param component_name: The component to move
      :type component_name: ResourceName
      :param destination: The destination, which can be any pose with respect to the SLAM map's origin
      :type destination: Pose
      :param slam_service_name: The slam service from which the SLAM map is requested
      :type slam_service_name: ResourceName

      :returns: Whether the request was successful
      :rtype: bool


   .. py:method:: get_pose(component_name: viam.proto.common.ResourceName, destination_frame: str, supplemental_transforms: Optional[List[viam.proto.common.Transform]] = None, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> viam.proto.common.PoseInFrame
      :async:

      Get the Pose and observer frame for any given component on a robot. A ``component_name`` can be created like this::

          component_name = Arm.get_resource_name("arm")

      Note that the example uses the ``Arm`` class, but any component class that inherits from ``ComponentBase`` will work
      (``Base``, ``Gripper``, etc).


      :param component_name: Name of a component on a robot.
      :type component_name: viam.proto.common.ResourceName
      :param destination_frame: Name of the desired reference frame.
      :type destination_frame: str
      :param supplemental_transforms: Transforms used to augment the robot's frame while
                                      calculating pose.
      :type supplemental_transforms: Optional[List[viam.proto.common.Transform]]

      :returns: Pose of the given component and the frame in which it was observed.
      :rtype: ``Pose`` (PoseInFrame)


   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None) -> Mapping[str, viam.utils.ValueTypes]
      :async:

      Send/receive arbitrary commands

      :param command: The command to execute
      :type command: Dict[str, ValueTypes]

      :returns: Result of the executed command
      :rtype: Dict[str, ValueTypes]


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str = 'builtin') -> typing_extensions.Self
      :classmethod:

      Get the service client named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service client
      :type name: str

      :returns: The service client, if it exists on the robot
      :rtype: Self


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:

      Get the ResourceName for this Resource with the given name

      :param name: The name of the Resource
      :type name: str


   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



