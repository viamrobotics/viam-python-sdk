viam.services.motion.motion
===========================

.. py:module:: viam.services.motion.motion


Classes
-------

.. autoapisummary::

   viam.services.motion.motion.Motion


Module Contents
---------------

.. py:class:: Motion(name: str, *, logger: Optional[logging.Logger] = None)

   Bases: :py:obj:`viam.services.service_base.ServiceBase`


   Motion is a Viam service that coordinates motion planning across all of the components in a given robot.

   The motion planning service calculates a valid path that avoids self collision by default. If additional constraints are supplied in the
   ``world_state`` message, the motion planning service will also account for those.

   For more information, see `Motion service <https://docs.viam.com/dev/reference/apis/services/motion/>`_.


   .. py:attribute:: Plan
      :type:  TypeAlias
      :value: GetPlanResponse



   .. py:attribute:: API
      :type:  Final

      The API of the Resource


   .. py:method:: move(component_name: str, destination: viam.proto.common.PoseInFrame, world_state: Optional[viam.proto.common.WorldState] = None, constraints: Optional[viam.proto.service.motion.Constraints] = None, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> bool
      :abstractmethod:

      :async:


      Plan and execute a movement to move the component specified to its goal destination.

      Note: Frames designated with respect to components can also be used as the ``component_name`` when calling for a move. This
      technique allows for planning and moving the frame itself to the ``destination``.
      To do so, simply pass in a string into ``component_name``. Ex::

          success = await MotionServiceClient.move("externalFrame", ...)

      ::

          motion = MotionClient.from_robot(robot=machine, name="builtin")

          # Assumes "my_gripper" on the machine
          gripper_name = "my_gripper"
          my_frame = "my_gripper_offset"

          goal_pose = Pose(x=0, y=0, z=300, o_x=0, o_y=0, o_z=1, theta=0)

          # Move the gripper
          moved = await motion.move(component_name=gripper_name,
                                destination=PoseInFrame(reference_frame="myFrame",
                                                        pose=goal_pose),
                                world_state=worldState,
                                constraints={},
                                extra={})

      :param component_name: Name of a component on a given robot.
      :type component_name: str
      :param destination: The destination to move to, expressed as a ``Pose`` and the frame in which it was
                          observed.
      :type destination: viam.proto.common.PoseInFrame
      :param world_state: When supplied, the motion service will create a plan that obeys any constraints
                          expressed in the WorldState message.
      :type world_state: viam.proto.common.WorldState
      :param constraints: When supplied, the motion service will create a plan that obeys any
                          specified constraints. These can include:
                          - LinearConstraint: Specifies that the component being moved should move linearly relative to its goal.
                          - OrientationConstraint: Specifies that the component being moved will not deviate its orientation beyond some threshold
                            relative to the goal.
                          - CollisionSpecification: Used to selectively apply obstacle avoidance to specific parts of the robot.
                          - PseudolinearConstraint: Specifies that the component being moved should not deviate from the straight-line path to their
                            goal by more than a factor proportional to the distance from start to goal. For example, if a component is moving 100mm,
                            then a LineToleranceFactor of 1.0 means that the component will remain within a 100mm radius of the straight-line
                            start-goal path.
      :type constraints: viam.proto.service.motion.Constraints

      :returns: Whether the move was successful.
      :rtype: bool

      For more information, see `Motion service <https://docs.viam.com/dev/reference/apis/services/motion/#move>`_.



   .. py:method:: move_on_globe(component_name: str, destination: viam.proto.common.GeoPoint, movement_sensor_name: str, obstacles: Optional[Sequence[viam.proto.common.GeoGeometry]] = None, heading: Optional[float] = None, configuration: Optional[viam.proto.service.motion.MotionConfiguration] = None, *, bounding_regions: Optional[Sequence[viam.proto.common.GeoGeometry]] = None, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> str
      :abstractmethod:

      :async:


      Move a component to a specific latitude and longitude, using a ``MovementSensor`` to check the location.

      ``move_on_globe()`` is non blocking, meaning the motion service will move the component to the destination
      GPS point after ``move_on_globe()`` returns.

      Each successful ``move_on_globe()`` call returns a unique ExecutionID which you can use to identify all plans
      generated during the ``move_on_globe()`` call.

      You can monitor the progress of the ``move_on_globe()`` call by querying ``get_plan()`` and ``list_plan_statuses()``.

      ::

          motion = MotionClient.from_robot(robot=machine, name="builtin")

          # Get the names of the base and movement sensor
          my_base_name = "my_base"
          mvmnt_sensor_name = "my_movement_sensor"
          #  Define a destination GeoPoint at the GPS coordinates [0, 0]
          my_destination = movement_sensor.GeoPoint(latitude=0, longitude=0)

          # Move the base component to the designated geographic location, as reported by the movement sensor
          execution_id = await motion.move_on_globe(
              component_name=my_base_name,
              destination=my_destination,
              movement_sensor_name=mvmnt_sensor_name)

      :param component_name: The name of the base to move.
      :type component_name: str
      :param destination: The location of the component's destination, represented in geographic notation as a
                          GeoPoint (lat, lng).
      :type destination: GeoPoint
      :param movement_sensor_name: The name of the movement sensor that you want to use to check
                                   the machine's location.
      :type movement_sensor_name: str
      :param obstacles: Obstacles to consider when planning the motion of the component,
                        with each represented as a GeoGeometry. Default: None
      :type obstacles: Optional[Sequence[GeoGeometry]]
      :param heading: The compass heading, in degrees, that the machine's movement sensor should report
                      at the destination point. Range: [0-360) 0: North, 90: East, 180: South, 270: West. Default: None
      :type heading: Optional[float]
      :param configuration: The configuration you want to set across this machine for this
                            motion service. This parameter and each of its fields are optional.

                            - obstacle_detectors (Sequence[ObstacleDetector]): The names of each vision service and camera resource pair
                            you want to use for transient obstacle avoidance.

                            - position_polling_frequency_hz (float): The frequency in Hz to poll the position of the machine.
                            - obstacle_polling_frequency_hz (float): The frequency in Hz to poll the vision service for new obstacles.
                            - plan_deviation_m (float): The distance in meters that the machine can deviate from the motion plan.
                            - linear_m_per_sec (float): Linear velocity this machine should target when moving.
                            - angular_degs_per_sec (float): Angular velocity this machine should target when turning.
      :type configuration: Optional[MotionConfiguration]
      :param bounding_regions: Set of obstacles which the robot must remain within while navigating
      :type bounding_regions: Optional[Sequence[GeoGeometry]]
      :param extra: Extra options to pass to the underlying RPC call.
      :type extra: Optional[Dict[str, Any]]
      :param timeout: An option to set how long to wait (in seconds) before calling a time-out and closing
                      the underlying RPC call.
      :type timeout: Optional[float]

      :returns: ExecutionID of the ``move_on_globe()`` call, which can be used to track execution progress.
      :rtype: str

      For more information, see `Motion service <https://docs.viam.com/dev/reference/apis/services/motion/#moveonglobe>`_.



   .. py:method:: move_on_map(component_name: str, destination: viam.proto.common.Pose, slam_service_name: str, configuration: Optional[viam.proto.service.motion.MotionConfiguration] = None, obstacles: Optional[Sequence[viam.proto.common.Geometry]] = None, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> str
      :abstractmethod:

      :async:


      Move a component to a specific pose, using a ``SlamService`` for the SLAM map, using a ``SLAM Service`` to check the location.

      ``move_on_map()`` is non blocking, meaning the motion service will move the component to the destination
      Pose point after ``move_on_map()`` returns.

      Each successful ``move_on_map()`` call returns a unique ExecutionID which you can use to identify all plans
      generated during the ``move_on_map()`` call.

      You can monitor the progress of the ``move_on_map()`` call by querying ``get_plan()`` and ``list_plan_statuses()``.

      ::

          motion = MotionClient.from_robot(robot=machine, name="builtin")

          # Get the names of the base component and SLAM service
          my_base_name = "my_base"
          my_slam_service_name = "my_slam_service"

          # Define a destination pose with respect to the origin of the map from the SLAM service "my_slam_service"
          my_pose = Pose(y=10)

          # Move the base component to the destination pose of Y=10, a location of
          # (0, 10, 0) in respect to the origin of the map
          execution_id = await motion.move_on_map(component_name=my_base_name,
                                                  destination=my_pose,
                                                  slam_service_name=my_slam_service_name)

      :param component_name: The name of the base to move.
      :type component_name: str
      :param destination: The destination, which can be any Pose with respect to the SLAM map's origin.
      :type destination: Pose
      :param slam_service_name: The name of the SLAM service from which the SLAM map is requested.
      :type slam_service_name: str
      :param configuration: The configuration you want to set across this machine for this motion service.
                            This parameter and each of its fields are optional.

                            - obstacle_detectors (Sequence[ObstacleDetector]): The names of each vision service and camera resource pair you want to use
                            for transient obstacle avoidance.

                            - position_polling_frequency_hz (float): The frequency in hz to poll the position of the machine.
                            - obstacle_polling_frequency_hz (float): The frequency in hz to poll the vision service for new obstacles.
                            - plan_deviation_m (float): The distance in meters that the machine can deviate from the motion plan.
                            - linear_m_per_sec (float): Linear velocity this machine should target when moving.
                            - angular_degs_per_sec (float): Angular velocity this machine should target when turning.
      :type configuration: Optional[MotionConfiguration]
      :param obstacles: Obstacles to be considered for motion planning.
      :type obstacles: Optional[Sequence[Geometry]]
      :param extra: Extra options to pass to the underlying RPC call.
      :type extra: Optional[Dict[str, Any]]
      :param timeout: An option to set how long to wait (in seconds) before calling a time-out and closing the underlying
                      RPC call.
      :type timeout: Optional[float]

      :returns: ExecutionID of the ``move_on_map()`` call, which can be used to track execution progress.
      :rtype: str

      For more information, see `Motion service <https://docs.viam.com/dev/reference/apis/services/motion/#moveonmap>`_.



   .. py:method:: stop_plan(component_name: str, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None)
      :abstractmethod:

      :async:


      Stop a component being moved by an in progress ``move_on_globe()`` or ``move_on_map()`` call.

      ::

          motion = MotionClient.from_robot(robot=machine, name="builtin")

          # Assuming a `move_on_globe()` started the execution
          # Stop the base component which was instructed to move by `move_on_globe()`
          # or `move_on_map()`
          my_base_name = "my_base"
          await motion.stop_plan(component_name=mvmnt_sensor)

      :param component_name: The component to stop
      :type component_name: str

      For more information, see `Motion service <https://docs.viam.com/dev/reference/apis/services/motion/#stopplan>`_.



   .. py:method:: get_plan(component_name: str, last_plan_only: bool = False, execution_id: Optional[str] = None, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> Plan
      :abstractmethod:

      :async:


      By default: returns the plan history of the most recent ``move_on_globe()`` or ``move_on_map()`` call to move a component.

      The plan history for executions before the most recent can be requested by providing an ExecutionID in the request.

      Returns a result if both of the following conditions are met:

      - the execution (call to ``move_on_globe()`` or ``move_on_map()``) is still executing **or** changed state within the last 24 hours
      - the robot has not reinitialized

      Plans never change.

      Replans always create new plans.

      Replans share the ExecutionID of the previously executing plan.

      All repeated fields are in time ascending order.

      ::

          motion = MotionClient.from_robot(robot=machine, name="builtin")
          my_base_name = "my_base"
          # Get the plan(s) of the base component which was instructed to move by `MoveOnGlobe()` or `MoveOnMap()`
          resp = await motion.get_plan(component_name=my_base_name)

      :param component_name: The component to stop
      :type component_name: str
      :param last_plan_only: If supplied, the response will only return the last plan for the component / execution.
      :type last_plan_only: Optional[bool]
      :param execution_id: If supplied, the response will only return plans with the provided execution_id.
      :type execution_id: Optional[str]

      :returns: The current PlanWithStatus & replan history which matches the request
      :rtype: ``GetPlanResponse`` (GetPlanResponse)

      For more information, see `Motion service <https://docs.viam.com/dev/reference/apis/services/motion/#getplan>`_.



   .. py:method:: list_plan_statuses(only_active_plans: bool = False, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> Sequence[viam.proto.service.motion.PlanStatusWithID]
      :abstractmethod:

      :async:


      Returns the statuses of plans created by `move_on_globe()` or ``move_on_map()`` calls that meet at least one of the following
      conditions since the motion service initialized:

      - the plan's status is in progress
      - the plan's status changed state within the last 24 hours

      All repeated fields are in chronological order.

      ::

          motion = MotionClient.from_robot(robot=machine, name="builtin")
          # List the plan statuses of the motion service within the TTL
          resp = await motion.list_plan_statuses()

      :param only_active_plans: If supplied, the response will filter out any plans that are not executing.
      :type only_active_plans: Optional[bool]

      :returns: List of last known statuses with the
                associated IDs of all plans within the TTL ordered by timestamp in ascending order.
      :rtype: ``ListPlanStatusesResponse`` (ListPlanStatusesResponse)

      For more information, see `Motion service <https://docs.viam.com/dev/reference/apis/services/motion/#listplanstatuses>`_.



   .. py:method:: get_pose(component_name: str, destination_frame: str, supplemental_transforms: Optional[Sequence[viam.proto.common.Transform]] = None, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> viam.proto.common.PoseInFrame
      :abstractmethod:

      :async:


      Get the Pose and observer frame for any given component on a robot.

      ::

          # Note that the example uses the ``Gripper`` class, but any component class that inherits from ``ComponentBase`` will work
          # (``Arm``, ``Base``, etc).

          # Create a `component_name`:
          component_name = "my_gripper"

          from viam.components.gripper import Gripper
          from viam.services.motion import MotionClient

          # Assume that the connect function is written and will return a valid machine.
          robot = await connect()

          motion = MotionClient.from_robot(robot=machine, name="builtin")
          gripperPoseInWorld = await motion.get_pose(component_name="my_gripper",
                                                  destination_frame="world")

      :param component_name: Name of a component on a robot.
      :type component_name: str
      :param destination_frame: Name of the desired reference frame.
      :type destination_frame: str
      :param supplemental_transforms: Transforms used to augment the robot's frame while
                                      calculating pose.
      :type supplemental_transforms: Optional[List[viam.proto.common.Transform]]

      :returns: Pose of the given component and the frame in which it was observed.
      :rtype: ``Pose`` (PoseInFrame)

      For more information, see `Motion service <https://docs.viam.com/dev/reference/apis/services/motion/#getpose>`_.



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the service named ``name`` from the provided robot.

      ::

          async def connect() -> RobotClient:
              # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
              options = RobotClient.Options.with_api_key("<API-KEY>", "<API-KEY-ID>")
              # Replace "<MACHINE-URL>" (included brackets) with your machine's connection URL or FQDN
              return await RobotClient.at_address("<MACHINE-URL>", options)

          async def main():
              robot = await connect()

              # Can be used with any resource, using the motion service as an example
              motion = MotionClient.from_robot(robot=machine, name="builtin")

              robot.close()

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service
      :type name: str

      :returns: The service, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:

      :async:


      Send/receive arbitrary commands.

      ::

          service = SERVICE.from_robot(robot=machine, "builtin")  # replace SERVICE with the appropriate class

          my_command = {
            "cmnd": "dosomething",
            "someparameter": 52
          }

          # Can be used with any resource, using the motion service as an example
          await service.do_command(command=my_command)

      :param command: The command to execute
      :type command: Dict[str, ValueTypes]

      :returns: Result of the executed command
      :rtype: Dict[str, ValueTypes]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = Arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




