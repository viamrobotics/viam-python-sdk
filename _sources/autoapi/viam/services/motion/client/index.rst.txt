viam.services.motion.client
===========================

.. py:module:: viam.services.motion.client


Attributes
----------

.. autoapisummary::

   viam.services.motion.client.RESOURCE_NAMESPACE_RDK
   viam.services.motion.client.RESOURCE_TYPE_SERVICE
   viam.services.motion.client.ValueTypes


Classes
-------

.. autoapisummary::

   viam.services.motion.client.DoCommandRequest
   viam.services.motion.client.DoCommandResponse
   viam.services.motion.client.GeoGeometry
   viam.services.motion.client.Geometry
   viam.services.motion.client.GeoPoint
   viam.services.motion.client.Pose
   viam.services.motion.client.PoseInFrame
   viam.services.motion.client.ResourceName
   viam.services.motion.client.Transform
   viam.services.motion.client.WorldState
   viam.services.motion.client.Constraints
   viam.services.motion.client.GetPlanRequest
   viam.services.motion.client.GetPlanResponse
   viam.services.motion.client.GetPoseRequest
   viam.services.motion.client.GetPoseResponse
   viam.services.motion.client.ListPlanStatusesRequest
   viam.services.motion.client.ListPlanStatusesResponse
   viam.services.motion.client.MotionConfiguration
   viam.services.motion.client.MotionServiceStub
   viam.services.motion.client.MoveOnGlobeRequest
   viam.services.motion.client.MoveOnGlobeResponse
   viam.services.motion.client.MoveOnMapRequest
   viam.services.motion.client.MoveOnMapResponse
   viam.services.motion.client.MoveRequest
   viam.services.motion.client.MoveResponse
   viam.services.motion.client.StopPlanRequest
   viam.services.motion.client.StopPlanResponse
   viam.services.motion.client.ReconfigurableResourceRPCClientBase
   viam.services.motion.client.Subtype
   viam.services.motion.client.ServiceClientBase
   viam.services.motion.client.MotionClient


Functions
---------

.. autoapisummary::

   viam.services.motion.client.dict_to_struct
   viam.services.motion.client.struct_to_dict


Module Contents
---------------

.. py:class:: DoCommandRequest(*, name: str = ..., command: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandRequest represents a generic DoCommand input


   .. py:attribute:: name
      :type:  str


   .. py:property:: command
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['command', b'command']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DoCommandResponse(*, result: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandResponse represents a generic DoCommand output


   .. py:property:: result
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['result', b'result']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GeoGeometry(*, location: global___GeoPoint | None = ..., geometries: collections.abc.Iterable[global___Geometry] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   GeoGeometry contains information describing Geometry(s) that is located at a GeoPoint


   .. py:property:: location
      :type: global___GeoPoint

      Location of the geometry


   .. py:property:: geometries
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Geometry]

      Geometries associated with the location, where embedded Pose data is with respect to the specified location


   .. py:method:: HasField(field_name: Literal['location', b'location']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: Geometry(*, center: global___Pose | None = ..., sphere: global___Sphere | None = ..., box: global___RectangularPrism | None = ..., capsule: global___Capsule | None = ..., label: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Geometry contains the dimensions of a given geometry and the pose of its center. The geometry is one of either a sphere or a box.


   .. py:attribute:: label
      :type:  str

      Label of the geometry. If none supplied, will be an empty string.


   .. py:property:: center
      :type: global___Pose

      Pose of a geometries center point


   .. py:property:: sphere
      :type: global___Sphere



   .. py:property:: box
      :type: global___RectangularPrism



   .. py:property:: capsule
      :type: global___Capsule



   .. py:method:: HasField(field_name: Literal['box', b'box', 'capsule', b'capsule', 'center', b'center', 'geometry_type', b'geometry_type', 'sphere', b'sphere']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['geometry_type', b'geometry_type']) -> Literal['sphere', 'box', 'capsule'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: GeoPoint(*, latitude: float = ..., longitude: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: latitude
      :type:  float


   .. py:attribute:: longitude
      :type:  float


.. py:class:: Pose(*, x: float = ..., y: float = ..., z: float = ..., o_x: float = ..., o_y: float = ..., o_z: float = ..., theta: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Pose is a combination of location and orientation.
   Location is expressed as distance which is represented by x , y, z coordinates. Orientation is expressed as an orientation vector which
   is represented by o_x, o_y, o_z and theta. The o_x, o_y, o_z coordinates represent the point on the cartesian unit sphere that the end of
   the arm is pointing to (with the origin as reference). That unit vector forms an axis around which theta rotates. This means that
   incrementing / decrementing theta will perform an inline rotation of the end effector.
   Theta is defined as rotation between two planes: the first being defined by the origin, the point (0,0,1), and the rx, ry, rz point, and the
   second being defined by the origin, the rx, ry, rz point and the local Z axis. Therefore, if theta is kept at zero as the north/south pole
   is circled, the Roll will correct itself to remain in-line.


   .. py:attribute:: x
      :type:  float

      millimeters from the origin


   .. py:attribute:: y
      :type:  float

      millimeters from the origin


   .. py:attribute:: z
      :type:  float

      millimeters from the origin


   .. py:attribute:: o_x
      :type:  float

      z component of a vector defining axis of rotation


   .. py:attribute:: o_y
      :type:  float

      x component of a vector defining axis of rotation


   .. py:attribute:: o_z
      :type:  float

      y component of a vector defining axis of rotation


   .. py:attribute:: theta
      :type:  float

      degrees


.. py:class:: PoseInFrame(*, reference_frame: str = ..., pose: global___Pose | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   PoseInFrame contains a pose and the and the reference frame in which it was observed


   .. py:attribute:: reference_frame
      :type:  str


   .. py:property:: pose
      :type: global___Pose



   .. py:method:: HasField(field_name: Literal['pose', b'pose']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ResourceName(*, namespace: str = ..., type: str = ..., subtype: str = ..., name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: namespace
      :type:  str


   .. py:attribute:: type
      :type:  str


   .. py:attribute:: subtype
      :type:  str


   .. py:attribute:: name
      :type:  str


.. py:class:: Transform(*, reference_frame: str = ..., pose_in_observer_frame: global___PoseInFrame | None = ..., physical_object: global___Geometry | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Transform contains a pose and two reference frames. The first reference frame is the starting reference frame, and the second reference
   frame is the observer reference frame. The second reference frame has a pose which represents the pose of an object in the first
   reference frame as observed within the second reference frame.


   .. py:attribute:: reference_frame
      :type:  str

      the name of a given reference frame


   .. py:property:: pose_in_observer_frame
      :type: global___PoseInFrame

      the pose of the above reference frame with respect to a different observer reference frame


   .. py:property:: physical_object
      :type: global___Geometry



   .. py:method:: HasField(field_name: Literal['_physical_object', b'_physical_object', 'physical_object', b'physical_object', 'pose_in_observer_frame', b'pose_in_observer_frame']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_physical_object', b'_physical_object']) -> Literal['physical_object'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: WorldState(*, obstacles: collections.abc.Iterable[global___GeometriesInFrame] | None = ..., transforms: collections.abc.Iterable[global___Transform] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   WorldState contains information about the physical environment around a given robot. All of the fields within this message are optional,
   they can include information about the physical dimensions of an obstacle, the freespace of a robot, and any desired transforms between a
   given reference frame and a new target reference frame.


   .. py:property:: obstacles
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___GeometriesInFrame]

      a list of obstacles expressed as a geometry and the reference frame in which it was observed; this field is optional


   .. py:property:: transforms
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Transform]

      a list of Transforms, optionally with geometries. Used as supplemental transforms to transform a pose from one reference frame to
      another, or to attach moving geometries to the frame system. This field is optional


.. py:class:: Constraints(*, linear_constraint: collections.abc.Iterable[global___LinearConstraint] | None = ..., orientation_constraint: collections.abc.Iterable[global___OrientationConstraint] | None = ..., collision_specification: collections.abc.Iterable[global___CollisionSpecification] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Constraints specifies all enumerated constraints to be passed to Viam's motion planning, along with any optional parameters


   .. py:property:: linear_constraint
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LinearConstraint]

      Typed message for a specific constraint


   .. py:property:: orientation_constraint
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OrientationConstraint]



   .. py:property:: collision_specification
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CollisionSpecification]

      Arc constraint, Time constraint, and others will be added here when they are supported


.. py:class:: GetPlanRequest(*, name: str = ..., component_name: viam.gen.common.v1.common_pb2.ResourceName | None = ..., last_plan_only: bool = ..., execution_id: str | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      The name of the motion service


   .. py:attribute:: last_plan_only
      :type:  bool

      If supplied, the response will only return
      the the last plan for the component / execution


   .. py:attribute:: execution_id
      :type:  str

      If you want to know about the plans of a previous execution


   .. py:property:: component_name
      :type: viam.gen.common.v1.common_pb2.ResourceName

      The name of the component which was requested to be moved.


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['_execution_id', b'_execution_id', 'component_name', b'component_name', 'execution_id', b'execution_id', 'extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_execution_id', b'_execution_id']) -> Literal['execution_id'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: GetPlanResponse(*, current_plan_with_status: global___PlanWithStatus | None = ..., replan_history: collections.abc.Iterable[global___PlanWithStatus] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: current_plan_with_status
      :type: global___PlanWithStatus

      The current plan and status that matches the request query


   .. py:property:: replan_history
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PlanWithStatus]

      Returns the history of all previous plans that were
      generated in ascending order.
      This field will be empty if the motion service
      did not need to re-plan.


   .. py:method:: HasField(field_name: Literal['current_plan_with_status', b'current_plan_with_status']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetPoseRequest(*, name: str = ..., component_name: viam.gen.common.v1.common_pb2.ResourceName | None = ..., destination_frame: str = ..., supplemental_transforms: collections.abc.Iterable[viam.gen.common.v1.common_pb2.Transform] | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: destination_frame
      :type:  str

      the reference frame in which the component's pose
      should be provided, if unset this defaults
      to the "world" reference frame


   .. py:property:: component_name
      :type: viam.gen.common.v1.common_pb2.ResourceName

      the component whose pose is being requested


   .. py:property:: supplemental_transforms
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.Transform]

      pose information on any additional reference frames that are needed
      to compute the component's pose


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['component_name', b'component_name', 'extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetPoseResponse(*, pose: viam.gen.common.v1.common_pb2.PoseInFrame | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: pose
      :type: viam.gen.common.v1.common_pb2.PoseInFrame



   .. py:method:: HasField(field_name: Literal['pose', b'pose']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ListPlanStatusesRequest(*, name: str = ..., only_active_plans: bool = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      The name of the motion service


   .. py:attribute:: only_active_plans
      :type:  bool

      If supplied, the response will filter the
      plan results for the supplied state


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ListPlanStatusesResponse(*, plan_statuses_with_ids: collections.abc.Iterable[global___PlanStatusWithID] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Status of all executed / executing plan statuses with associated IDs within the 24 hour TTL


   .. py:property:: plan_statuses_with_ids
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PlanStatusWithID]

      List of last known statuses with the associated IDs of all plans within the TTL
      ordered by timestamp in ascending order


.. py:class:: MotionConfiguration(*, obstacle_detectors: collections.abc.Iterable[global___ObstacleDetector] | None = ..., position_polling_frequency_hz: float | None = ..., obstacle_polling_frequency_hz: float | None = ..., plan_deviation_m: float | None = ..., linear_m_per_sec: float | None = ..., angular_degs_per_sec: float | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: position_polling_frequency_hz
      :type:  float

      Sets the frequency to poll for the position of the robot


   .. py:attribute:: obstacle_polling_frequency_hz
      :type:  float

      Sets the frequency to poll the vision service(s) for new obstacles


   .. py:attribute:: plan_deviation_m
      :type:  float

      Sets the distance in meters that a robot is allowed to deviate from the motion plan


   .. py:attribute:: linear_m_per_sec
      :type:  float

      Optional linear velocity to target when moving


   .. py:attribute:: angular_degs_per_sec
      :type:  float

      Optional angular velocity to target when turning


   .. py:property:: obstacle_detectors
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ObstacleDetector]

      The ObstacleDetectors that will be used for transient obstacle avoidance


   .. py:method:: HasField(field_name: Literal['_angular_degs_per_sec', b'_angular_degs_per_sec', '_linear_m_per_sec', b'_linear_m_per_sec', '_obstacle_polling_frequency_hz', b'_obstacle_polling_frequency_hz', '_plan_deviation_m', b'_plan_deviation_m', '_position_polling_frequency_hz', b'_position_polling_frequency_hz', 'angular_degs_per_sec', b'angular_degs_per_sec', 'linear_m_per_sec', b'linear_m_per_sec', 'obstacle_polling_frequency_hz', b'obstacle_polling_frequency_hz', 'plan_deviation_m', b'plan_deviation_m', 'position_polling_frequency_hz', b'position_polling_frequency_hz']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_angular_degs_per_sec', b'_angular_degs_per_sec']) -> Literal['angular_degs_per_sec'] | None
                  WhichOneof(oneof_group: Literal['_linear_m_per_sec', b'_linear_m_per_sec']) -> Literal['linear_m_per_sec'] | None
                  WhichOneof(oneof_group: Literal['_obstacle_polling_frequency_hz', b'_obstacle_polling_frequency_hz']) -> Literal['obstacle_polling_frequency_hz'] | None
                  WhichOneof(oneof_group: Literal['_plan_deviation_m', b'_plan_deviation_m']) -> Literal['plan_deviation_m'] | None
                  WhichOneof(oneof_group: Literal['_position_polling_frequency_hz', b'_position_polling_frequency_hz']) -> Literal['position_polling_frequency_hz'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: MotionServiceStub(channel: grpclib.client.Channel)

.. py:class:: MoveOnGlobeRequest(*, name: str = ..., destination: viam.gen.common.v1.common_pb2.GeoPoint | None = ..., heading: float | None = ..., component_name: viam.gen.common.v1.common_pb2.ResourceName | None = ..., movement_sensor_name: viam.gen.common.v1.common_pb2.ResourceName | None = ..., obstacles: collections.abc.Iterable[viam.gen.common.v1.common_pb2.GeoGeometry] | None = ..., motion_configuration: global___MotionConfiguration | None = ..., bounding_regions: collections.abc.Iterable[viam.gen.common.v1.common_pb2.GeoGeometry] | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of the motion service


   .. py:attribute:: heading
      :type:  float

      Optional compass heading to achieve at the destination, in degrees [0-360)


   .. py:property:: destination
      :type: viam.gen.common.v1.common_pb2.GeoPoint

      Destination, encoded as a GeoPoint


   .. py:property:: component_name
      :type: viam.gen.common.v1.common_pb2.ResourceName

      Component on the robot to move to the specified destination


   .. py:property:: movement_sensor_name
      :type: viam.gen.common.v1.common_pb2.ResourceName

      Name of the movement sensor which will be used to check robot location


   .. py:property:: obstacles
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.GeoGeometry]

      Obstacles to be considered for motion planning


   .. py:property:: motion_configuration
      :type: global___MotionConfiguration

      Optional set of motion configuration options


   .. py:property:: bounding_regions
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.GeoGeometry]

      Set of obstacles which the robot must remain within while navigating


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['_heading', b'_heading', '_motion_configuration', b'_motion_configuration', 'component_name', b'component_name', 'destination', b'destination', 'extra', b'extra', 'heading', b'heading', 'motion_configuration', b'motion_configuration', 'movement_sensor_name', b'movement_sensor_name']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_heading', b'_heading']) -> Literal['heading'] | None
                  WhichOneof(oneof_group: Literal['_motion_configuration', b'_motion_configuration']) -> Literal['motion_configuration'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: MoveOnGlobeResponse(*, execution_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: execution_id
      :type:  str

      The unique ID which identifies the execution.
      Multiple plans will share the same execution_id if they were
      generated due to replanning.


.. py:class:: MoveOnMapRequest(*, name: str = ..., destination: viam.gen.common.v1.common_pb2.Pose | None = ..., component_name: viam.gen.common.v1.common_pb2.ResourceName | None = ..., slam_service_name: viam.gen.common.v1.common_pb2.ResourceName | None = ..., motion_configuration: global___MotionConfiguration | None = ..., obstacles: collections.abc.Iterable[viam.gen.common.v1.common_pb2.Geometry] | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of the motion service


   .. py:property:: destination
      :type: viam.gen.common.v1.common_pb2.Pose

      Specify a destination to, which can be any pose with respect to the SLAM map's origin


   .. py:property:: component_name
      :type: viam.gen.common.v1.common_pb2.ResourceName

      Component on the robot to move to the specified destination


   .. py:property:: slam_service_name
      :type: viam.gen.common.v1.common_pb2.ResourceName

      Name of the slam service from which the SLAM map is requested


   .. py:property:: motion_configuration
      :type: global___MotionConfiguration

      Optional set of motion configuration options


   .. py:property:: obstacles
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.Geometry]

      Obstacles to be considered for motion planning


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['_motion_configuration', b'_motion_configuration', 'component_name', b'component_name', 'destination', b'destination', 'extra', b'extra', 'motion_configuration', b'motion_configuration', 'slam_service_name', b'slam_service_name']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_motion_configuration', b'_motion_configuration']) -> Literal['motion_configuration'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: MoveOnMapResponse(*, execution_id: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: execution_id
      :type:  str

      The unique ID which identifies the execution.
      Multiple plans will share the same execution_id if they were
      generated due to replanning.


.. py:class:: MoveRequest(*, name: str = ..., destination: viam.gen.common.v1.common_pb2.PoseInFrame | None = ..., component_name: viam.gen.common.v1.common_pb2.ResourceName | None = ..., world_state: viam.gen.common.v1.common_pb2.WorldState | None = ..., constraints: global___Constraints | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Moves any component on the robot to a specified destination which can be from the reference frame of any other component on the robot.


   .. py:attribute:: name
      :type:  str

      Name of the motion service


   .. py:property:: destination
      :type: viam.gen.common.v1.common_pb2.PoseInFrame

      Destination to move to, which can a pose in the reference frame of any frame in the robot's frame system


   .. py:property:: component_name
      :type: viam.gen.common.v1.common_pb2.ResourceName

      Component on the robot to move to the specified destination


   .. py:property:: world_state
      :type: viam.gen.common.v1.common_pb2.WorldState

      Avoid obstacles by specifying their geometries in the world state
      Augment the frame system of the robot by specifying additional transforms to add to it for the duration of the Move


   .. py:property:: constraints
      :type: global___Constraints

      Constrain the way the robot will move


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['_constraints', b'_constraints', '_world_state', b'_world_state', 'component_name', b'component_name', 'constraints', b'constraints', 'destination', b'destination', 'extra', b'extra', 'world_state', b'world_state']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



   .. py:method:: WhichOneof(oneof_group: Literal['_constraints', b'_constraints']) -> Literal['constraints'] | None
                  WhichOneof(oneof_group: Literal['_world_state', b'_world_state']) -> Literal['world_state'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: MoveResponse(*, success: bool = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: success
      :type:  bool


.. py:class:: StopPlanRequest(*, name: str = ..., component_name: viam.gen.common.v1.common_pb2.ResourceName | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      The name of the motion service


   .. py:property:: component_name
      :type: viam.gen.common.v1.common_pb2.ResourceName

      The component of the currently executing plan to stop


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['component_name', b'component_name', 'extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: StopPlanResponse

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: ReconfigurableResourceRPCClientBase

   Bases: :py:obj:`ResourceRPCClientBase`


   A base RPC client that can reset its channel.

   Useful if connection is lost and then regained.


   .. py:method:: reset_channel(channel: grpclib.client.Channel)

      Called when the RPC channel was reset. Passes in the new channel.

      :param channel: The new RPC Channel
      :type channel: Channel



.. py:data:: RESOURCE_NAMESPACE_RDK
   :value: 'rdk'


.. py:data:: RESOURCE_TYPE_SERVICE
   :value: 'service'


.. py:class:: Subtype(namespace: str, resource_type: str, resource_subtype: str)

   Represents a known component/service (resource) API


   .. py:attribute:: namespace
      :type:  str

      The namespace of the resource


   .. py:attribute:: resource_type
      :type:  str

      The type of the resource, for example `component` or `service`


   .. py:attribute:: resource_subtype
      :type:  str

      The subtype of the resource for example `servo`, `arm`, `vision`


   .. py:method:: __str__() -> str

      Return str(self).



   .. py:method:: __repr__() -> str

      Return repr(self).



   .. py:method:: __hash__() -> int

      Return hash(self).



   .. py:method:: __eq__(other: object) -> bool

      Return self==value.



   .. py:method:: from_resource_name(resource_name: viam.proto.common.ResourceName) -> typing_extensions.Self
      :classmethod:


      Convert a ```ResourceName``` into a ```Subtype```

      :param resource_name: The ResourceName to convert
      :type resource_name: viam.proto.common.ResourceName

      :returns: A new Subtype
      :rtype: Self



   .. py:method:: from_string(string: str) -> typing_extensions.Self
      :classmethod:


      Create a ```Subtype``` from its string representation (namespace:resource_type:resource_subtype)

      :param string: The Subtype as a string
      :type string: str

      :raises ValueError: Raised if the string does not represent a valid Subtype

      :returns: A new Subtype
      :rtype: Self



.. py:class:: ServiceClientBase(name: str, channel: grpclib.client.Channel)

   Bases: :py:obj:`abc.ABC`, :py:obj:`viam.resource.base.ResourceBase`


   Base service client.
   All service clients must inherit from this class.


   .. py:attribute:: SUBTYPE
      :type:  ClassVar[viam.resource.base.Subtype]


   .. py:attribute:: channel
      :type:  grpclib.client.Channel


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str = 'builtin') -> typing_extensions.Self
      :classmethod:


      Get the service client named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service client
      :type name: str

      :returns: The service client, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:

      :async:


      Send/Receive arbitrary commands to the Resource

      ::

          command = {"cmd": "test", "data1": 500}
          result = component.do(command)

      :param command: The command to execute
      :type command: Mapping[str, ValueTypes]

      :raises NotImplementedError: Raised if the Resource does not support arbitrary commands

      :returns: Result of the executed command
      :rtype: Mapping[str, ValueTypes]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:data:: ValueTypes

   Types that can be encoded into a protobuf `Value`

.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:class:: MotionClient(name: str, channel: grpclib.client.Channel)

   Bases: :py:obj:`viam.services.service_client_base.ServiceClientBase`, :py:obj:`viam.resource.rpc_client_base.ReconfigurableResourceRPCClientBase`


   Motion is a Viam service that coordinates motion planning across all of the components in a given robot.

   The motion planning service calculates a valid path that avoids self collision by default. If additional constraints are supplied in the
   ``world_state`` message, the motion planning service will also account for those.

   For more information, see `Motion service <https://docs.viam.com/services/motion/>`_.


   .. py:attribute:: SUBTYPE
      :type:  Final


   .. py:attribute:: client
      :type:  viam.proto.service.motion.MotionServiceStub


   .. py:method:: move(component_name: viam.proto.common.ResourceName, destination: viam.proto.common.PoseInFrame, world_state: Optional[viam.proto.common.WorldState] = None, constraints: Optional[viam.proto.service.motion.Constraints] = None, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> bool
      :async:


      Plan and execute a movement to move the component specified to its goal destination.

      Note: Frames designated with respect to components can also be used as the ``component_name`` when calling for a move. This
      technique allows for planning and moving the frame itself to the ``destination``. To do so, simply create a resource name with
      originating ReferenceFrame's name. Then pass in the resource name into ``component_name``. Ex::

          resource_name = Arm.get_resource_name("externalFrame")
          success = await MotionServiceClient.move(resource_name, ...)

      ::

          motion = MotionClient.from_robot(robot=robot, name="builtin")

          # Assumes a gripper configured with name "my_gripper" on the machine
          gripper_name = Gripper.get_resource_name("my_gripper")
          my_frame = "my_gripper_offset"

          goal_pose = Pose(x=0, y=0, z=300, o_x=0, o_y=0, o_z=1, theta=0)

          # Move the gripper
          moved = await motion.move(component_name=gripper_name,
                                destination=PoseInFrame(reference_frame="myFrame",
                                                        pose=goal_pose),
                                world_state=worldState,
                                constraints={},
                                extra={})

      :param component_name: Name of a component on a given robot.
      :type component_name: viam.proto.common.ResourceName
      :param destination: The destination to move to, expressed as a ``Pose`` and the frame in which it was
                          observed.
      :type destination: viam.proto.common.PoseInFrame
      :param world_state: When supplied, the motion service will create a plan that obeys any constraints
                          expressed in the WorldState message.
      :type world_state: viam.proto.common.WorldState
      :param constraints: When supplied, the motion service will create a plan that obeys any
                          specified constraints.
      :type constraints: viam.proto.service.motion.Constraints

      :returns: Whether the move was successful.
      :rtype: bool

      For more information, see `Motion service <https://docs.viam.com/services/motion/>`_.



   .. py:method:: move_on_globe(component_name: viam.proto.common.ResourceName, destination: viam.proto.common.GeoPoint, movement_sensor_name: viam.proto.common.ResourceName, obstacles: Optional[Sequence[viam.proto.common.GeoGeometry]] = None, heading: Optional[float] = None, configuration: Optional[viam.proto.service.motion.MotionConfiguration] = None, *, bounding_regions: Optional[Sequence[viam.proto.common.GeoGeometry]] = None, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> str
      :async:


      Move a component to a specific latitude and longitude, using a ``MovementSensor`` to check the location.

      ``move_on_globe()`` is non blocking, meaning the motion service will move the component to the destination
      GPS point after ``move_on_globe()`` returns.

      Each successful ``move_on_globe()`` call returns a unique ExecutionID which you can use to identify all plans
      generated during the ``move_on_globe()`` call.

      You can monitor the progress of the ``move_on_globe()`` call by querying ``get_plan()`` and ``list_plan_statuses()``.

      ::

          motion = MotionClient.from_robot(robot=robot, name="builtin")

          # Get the ResourceNames of the base and movement sensor
          my_base_resource_name = Base.get_resource_name("my_base")
          mvmnt_sensor_resource_name = MovementSensor.get_resource_name(
              "my_movement_sensor")
          #  Define a destination GeoPoint at the GPS coordinates [0, 0]
          my_destination = movement_sensor.GeoPoint(latitude=0, longitude=0)

          # Move the base component to the designated geographic location, as reported by the movement sensor
          execution_id = await motion.move_on_globe(
              component_name=my_base_resource_name,
              destination=my_destination,
              movement_sensor_name=mvmnt_sensor_resource_name)

      :param component_name: The ResourceName of the base to move.
      :type component_name: ResourceName
      :param destination: The location of the component’s destination, represented in geographic notation as a
                          GeoPoint (lat, lng).
      :type destination: GeoPoint
      :param movement_sensor_name: The ResourceName of the movement sensor that you want to use to check
                                   the machine’s location.
      :type movement_sensor_name: ResourceName
      :param obstacles: Obstacles to consider when planning the motion of the component,
                        with each represented as a GeoGeometry. Default: None
      :type obstacles: Optional[Sequence[GeoGeometry]]
      :param heading: The compass heading, in degrees, that the machine’s movement sensor should report
                      at the destination point. Range: [0-360) 0: North, 90: East, 180: South, 270: West. Default: None
      :type heading: Optional[float]
      :param configuration: The configuration you want to set across this machine for this
                            motion service. This parameter and each of its fields are optional.

                            - obstacle_detectors (Iterable[ObstacleDetector]): The names of each vision service and camera resource pair
                            you want to use for transient obstacle avoidance.

                            - position_polling_frequency_hz (float): The frequency in Hz to poll the position of the machine.
                            - obstacle_polling_frequency_hz (float): The frequency in Hz to poll the vision service for new obstacles.
                            - plan_deviation_m (float): The distance in meters that the machine can deviate from the motion plan.
                            - linear_m_per_sec (float): Linear velocity this machine should target when moving.
                            - angular_degs_per_sec (float): Angular velocity this machine should target when turning.
      :type configuration: Optional[MotionConfiguration]
      :param bounding_regions: Set of obstacles which the robot must remain within while navigating
      :type bounding_regions: Optional[Sequence[GeoGeometry]]
      :param extra: Extra options to pass to the underlying RPC call.
      :type extra: Optional[Dict[str, Any]]
      :param timeout: An option to set how long to wait (in seconds) before calling a time-out and closing
                      the underlying RPC call.
      :type timeout: Optional[float]

      :returns: ExecutionID of the ``move_on_globe()`` call, which can be used to track execution progress.
      :rtype: str

      For more information, see `Motion service <https://docs.viam.com/services/motion/>`_.



   .. py:method:: move_on_map(component_name: viam.proto.common.ResourceName, destination: viam.proto.common.Pose, slam_service_name: viam.proto.common.ResourceName, configuration: Optional[viam.proto.service.motion.MotionConfiguration] = None, obstacles: Optional[Iterable[viam.proto.common.Geometry]] = None, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> str
      :async:


      Move a component to a specific pose, using a ``SlamService`` for the SLAM map, using a ``SLAM Service`` to check the location.

      ``move_on_map()`` is non blocking, meaning the motion service will move the component to the destination
      Pose point after ``move_on_map()`` returns.

      Each successful ``move_on_map()`` call returns a unique ExecutionID which you can use to identify all plans
      generated during the ``move_on_map()`` call.

      You can monitor the progress of the ``move_on_map()`` call by querying ``get_plan()`` and ``list_plan_statuses()``.

      ::

          motion = MotionClient.from_robot(robot=robot, name="builtin")

          # Get the ResourceNames of the base component and SLAM service
          my_base_resource_name = Base.get_resource_name("my_base")
          my_slam_service_name = SLAMClient.get_resource_name("my_slam_service")

          # Define a destination pose with respect to the origin of the map from the SLAM service "my_slam_service"
          my_pose = Pose(y=10)

          # Move the base component to the destination pose of Y=10, a location of
          # (0, 10, 0) in respect to the origin of the map
          execution_id = await motion.move_on_map(component_name=my_base_resource_name,
                                                  destination=my_pose,
                                                  slam_service_name=my_slam_service_name)

      :param component_name: The ResourceName of the base to move.
      :type component_name: ResourceName
      :param destination: The destination, which can be any Pose with respect to the SLAM map’s origin.
      :type destination: Pose
      :param slam_service_name: The ResourceName of the SLAM service from which the SLAM map is requested.
      :type slam_service_name: ResourceName
      :param configuration: The configuration you want to set across this machine for this motion service.
                            This parameter and each of its fields are optional.

                            - obstacle_detectors (Iterable[ObstacleDetector]): The names of each vision service and camera resource pair you want to use
                            for transient obstacle avoidance.

                            - position_polling_frequency_hz (float): The frequency in hz to poll the position of the machine.
                            - obstacle_polling_frequency_hz (float): The frequency in hz to poll the vision service for new obstacles.
                            - plan_deviation_m (float): The distance in meters that the machine can deviate from the motion plan.
                            - linear_m_per_sec (float): Linear velocity this machine should target when moving.
                            - angular_degs_per_sec (float): Angular velocity this machine should target when turning.
      :type configuration: Optional[MotionConfiguration]
      :param obstacles: Obstacles to be considered for motion planning.
      :type obstacles: Optional[Iterable[Geometry]]
      :param extra: Extra options to pass to the underlying RPC call.
      :type extra: Optional[Dict[str, Any]]
      :param timeout: An option to set how long to wait (in seconds) before calling a time-out and closing the underlying
                      RPC call.
      :type timeout: Optional[float]

      :returns: ExecutionID of the ``move_on_map()`` call, which can be used to track execution progress.
      :rtype: str

      For more information, see `Motion service <https://docs.viam.com/services/motion/>`_.



   .. py:method:: stop_plan(component_name: viam.proto.common.ResourceName, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None)
      :async:


      Stop a component being moved by an in progress ``move_on_globe()`` or ``move_on_map()`` call.

      ::

          # Assuming a `move_on_globe()` started the execution
          # Stop the base component which was instructed to move by `move_on_globe()`
          # or `move_on_map()`
          my_base_resource_name = Base.get_resource_name("my_base")
          await motion.stop_plan(component_name=mvmnt_sensor)

      :param component_name: The component to stop
      :type component_name: ResourceName

      For more information, see `Motion service <https://docs.viam.com/services/motion/>`_.



   .. py:method:: get_plan(component_name: viam.proto.common.ResourceName, last_plan_only: bool = False, execution_id: Optional[str] = None, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> viam.proto.service.motion.GetPlanResponse
      :async:


      By default: returns the plan history of the most recent ``move_on_globe()`` or ``move_on_map()`` call to move a component.

      The plan history for executions before the most recent can be requested by providing an ExecutionID in the request.

      Returns a result if both of the following conditions are met:

      - the execution (call to ``move_on_globe()`` or ``move_on_map()``) is still executing **or** changed state within the last 24 hours
      - the robot has not reinitialized

      Plans never change.

      Replans always create new plans.

      Replans share the ExecutionID of the previously executing plan.

      All repeated fields are in time ascending order.

      ::

          motion = MotionClient.from_robot(robot=robot, name="builtin")
          my_base_resource_name = Base.get_resource_name("my_base")
          # Get the plan(s) of the base component which was instructed to move by `MoveOnGlobe()` or `MoveOnMap()`
          resp = await motion.get_plan(component_name=my_base_resource_name)

      :param component_name: The component to stop
      :type component_name: ResourceName
      :param last_plan_only: If supplied, the response will only return the last plan for the component / execution.
      :type last_plan_only: Optional[bool]
      :param execution_id: If supplied, the response will only return plans with the provided execution_id.
      :type execution_id: Optional[str]

      :returns: The current PlanWithStatus & replan history which matches the request
      :rtype: ``GetPlanResponse`` (GetPlanResponse)

      For more information, see `Motion service <https://docs.viam.com/services/motion/>`_.



   .. py:method:: list_plan_statuses(only_active_plans: bool = False, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> viam.proto.service.motion.ListPlanStatusesResponse
      :async:


      Returns the statuses of plans created by `move_on_globe()` or ``move_on_map()`` calls that meet at least one of the following
      conditions since the motion service initialized:

      - the plan's status is in progress
      - the plan's status changed state within the last 24 hours

      All repeated fields are in chronological order.

      ::

          motion = MotionClient.from_robot(robot=robot, name="builtin")
          # List the plan statuses of the motion service within the TTL
          resp = await motion.list_plan_statuses()

      :param only_active_plans: If supplied, the response will filter out any plans that are not executing.
      :type only_active_plans: Optional[bool]

      :returns: List of last known statuses with the
                associated IDs of all plans within the TTL ordered by timestamp in ascending order.
      :rtype: ``ListPlanStatusesResponse`` (ListPlanStatusesResponse)

      For more information, see `Motion service <https://docs.viam.com/services/motion/>`_.



   .. py:method:: get_pose(component_name: viam.proto.common.ResourceName, destination_frame: str, supplemental_transforms: Optional[List[viam.proto.common.Transform]] = None, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> viam.proto.common.PoseInFrame
      :async:


      Get the Pose and observer frame for any given component on a robot. A ``component_name`` can be created like this::

          component_name = Arm.get_resource_name("arm")

      Note that the example uses the ``Arm`` class, but any component class that inherits from ``ComponentBase`` will work
      (``Base``, ``Gripper``, etc).

      ::

          from viam.components.gripper import Gripper
          from viam.services.motion import MotionClient

          # Assume that the connect function is written and will return a valid machine.
          robot = await connect()

          motion = MotionClient.from_robot(robot=robot, name="builtin")
          gripperName = Gripper.get_resource_name("my_gripper")
          gripperPoseInWorld = await motion.get_pose(component_name=gripperName,
                                                  destination_frame="world")

      :param component_name: Name of a component on a robot.
      :type component_name: viam.proto.common.ResourceName
      :param destination_frame: Name of the desired reference frame.
      :type destination_frame: str
      :param supplemental_transforms: Transforms used to augment the robot's frame while
                                      calculating pose.
      :type supplemental_transforms: Optional[List[viam.proto.common.Transform]]

      :returns: Pose of the given component and the frame in which it was observed.
      :rtype: ``Pose`` (PoseInFrame)

      For more information, see `Motion service <https://docs.viam.com/services/motion/>`_.



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **__) -> Mapping[str, viam.utils.ValueTypes]
      :async:


      Send/receive arbitrary commands

      ::

          # Access the motion service
          motion = MotionClient.from_robot(robot=robot, name="builtin")

          my_command = {
            "command": "dosomething",
            "someparameter": 52
          }

          await motion.do_command(my_command)

      :param command: The command to execute.
      :type command: Dict[str, ValueTypes]

      :returns: Result of the executed command.
      :rtype: Dict[str, ValueTypes]

      For more information, see `Motion service <https://docs.viam.com/services/motion/>`_.



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str = 'builtin') -> typing_extensions.Self
      :classmethod:


      Get the service client named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service client
      :type name: str

      :returns: The service client, if it exists on the robot
      :rtype: Self



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




