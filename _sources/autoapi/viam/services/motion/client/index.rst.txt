:py:mod:`viam.services.motion.client`
=====================================

.. py:module:: viam.services.motion.client


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   viam.services.motion.client.MotionClient




.. py:class:: MotionClient(name: str, channel: grpclib.client.Channel)


   Bases: :py:obj:`viam.services.service_client_base.ServiceClientBase`, :py:obj:`viam.resource.rpc_client_base.ReconfigurableResourceRPCClientBase`

   Motion is a Viam service that coordinates motion planning across all of the components in a given robot.

   The motion planning service calculates a valid path that avoids self collision by default. If additional constraints are supplied in the
   ``world_state`` message, the motion planning service will also account for those.

   .. py:attribute:: SUBTYPE
      :type: Final

      

   .. py:attribute:: client
      :type: viam.proto.service.motion.MotionServiceStub

      

   .. py:method:: move(component_name: viam.proto.common.ResourceName, destination: viam.proto.common.PoseInFrame, world_state: Optional[viam.proto.common.WorldState] = None, constraints: Optional[viam.proto.service.motion.Constraints] = None, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> bool
      :async:

      Plan and execute a movement to move the component specified to its goal destination.

      Note: Frames designated with respect to components can also be used as the ``component_name`` when calling for a move. This
      technique allows for planning and moving the frame itself to the ``destination``. To do so, simply create a resource name with
      originating ReferenceFrame's name. Then pass in the resource name into ``component_name``. Ex::

          resource_name = Arm.get_resource_name("externalFrame")
          success = await MotionServiceClient.move(resource_name, ...)

      :param component_name: Name of a component on a given robot.
      :type component_name: viam.proto.common.ResourceName
      :param destination: The destination to move to, expressed as a ``Pose`` and the frame in which it was
                          observed.
      :type destination: viam.proto.common.PoseInFrame
      :param world_state: When supplied, the motion service will create a plan that obeys any contraints
                          expressed in the WorldState message.
      :type world_state: viam.proto.common.WorldState
      :param constraints: When supplied, the motion service will create a plan that obeys any
                          specified constraints
      :type constraints: viam.proto.service.motion.Constraints

      :returns: Whether the move was successful
      :rtype: bool


   .. py:method:: move_single_component(component_name: viam.proto.common.ResourceName, destination: viam.proto.common.PoseInFrame, world_state: Optional[viam.proto.common.WorldState] = None, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> bool
      :async:

      This function will pass through a move command to a component with a ``move_to_position`` method that takes a ``Pose``. ``Arm`` is
      the only component that support this. This method will transform the destination pose, given in an arbitrary frame, into the pose of
      the arm. The arm will then move its most distal link to that pose. If you instead wish to move any other component than the arm end
      to that pose, then you must manually adjust the given destination by the transform from the arm end to the intended component.

      :param component_name: Name of a component on a given robot.
      :type component_name: viam.proto.common.ResourceName
      :param destination: The destination to move to, expressed as a ``Pose`` and the frame in which it was
                          observed.
      :type destination: viam.proto.common.PoseInFrame
      :param world_state: When supplied, the motion service will create a plan that obeys any contraints
                          expressed in the WorldState message.
      :type world_state: viam.proto.common.WorldState

      :returns: Whether the move was successful
      :rtype: bool


   .. py:method:: move_on_globe(component_name: viam.proto.common.ResourceName, destination: viam.proto.common.GeoPoint, movement_sensor_name: viam.proto.common.ResourceName, obstacles: Optional[Sequence[viam.proto.common.GeoObstacle]] = None, heading: Optional[float] = None, linear_meters_per_sec: Optional[float] = None, angular_deg_per_sec: Optional[float] = None, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> bool
      :async:

      Move a component to a specific latitude and longitude, using a ``MovementSensor`` to check the location.

      :param component_name: The component to move
      :type component_name: ResourceName
      :param destination: The destination point
      :type destination: GeoPoint
      :param movement_sensor_name: The ``MovementSensor`` which will be used to check robot location
      :type movement_sensor_name: ResourceName
      :param obstacles: Obstacles to be considered for motion planning. Defaults to None.
      :type obstacles: Optional[Sequence[GeoObstacle]], optional
      :param heading: Compass heading to achieve at the destination, in degrees [0-360). Defaults to None.
      :type heading: Optional[float], optional
      :param linear_meters_per_sec: Linear velocity to target when moving. Defaults to None.
      :type linear_meters_per_sec: Optional[float], optional
      :param angular_deg_per_sec: Angular velocity to target when turning. Defaults to None.
      :type angular_deg_per_sec: Optional[float], optional

      :returns: Whether the request was successful
      :rtype: bool


   .. py:method:: move_on_map(component_name: viam.proto.common.ResourceName, destination: viam.proto.common.Pose, slam_service_name: viam.proto.common.ResourceName, *, extra: Optional[Mapping[str, viam.utils.ValueTypes]] = None, timeout: Optional[float] = None) -> bool
      :async:

      Move a component to a specific pose, using a ``SlamService`` for the SLAM map

      :param component_name: The component to move
      :type component_name: ResourceName
      :param destination: The destination, which can be any pose with respect to the SLAM map's origin
      :type destination: Pose
      :param slam_service_name: The slam service from which the SLAM map is requested
      :type slam_service_name: ResourceName

      :returns: Whether the request was successful
      :rtype: bool


   .. py:method:: get_pose(component_name: viam.proto.common.ResourceName, destination_frame: str, supplemental_transforms: Optional[List[viam.proto.common.Transform]] = None, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> viam.proto.common.PoseInFrame
      :async:

      Get the Pose and observer frame for any given component on a robot. A ``component_name`` can be created like this::

          component_name = Arm.get_resource_name("arm")

      Note that the example uses the ``Arm`` class, but any component class that inherits from ``ComponentBase`` will work
      (``Base``, ``Gripper``, etc).


      :param component_name: Name of a component on a robot.
      :type component_name: viam.proto.common.ResourceName
      :param destination_frame: Name of the desired reference frame.
      :type destination_frame: str
      :param supplemental_transforms: Transforms used to augment the robot's frame while
                                      calculating pose.
      :type supplemental_transforms: Optional[List[viam.proto.common.Transform]]

      :returns: Pose of the given component and the frame in which it was observed.
      :rtype: ``Pose`` (PoseInFrame)


   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None) -> Mapping[str, viam.utils.ValueTypes]
      :async:

      Send/receive arbitrary commands

      :param command: The command to execute
      :type command: Dict[str, ValueTypes]

      :returns: Result of the executed command
      :rtype: Dict[str, ValueTypes]


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str = 'builtin') -> typing_extensions.Self
      :classmethod:

      Get the service client named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service client
      :type name: str

      :returns: The service client, if it exists on the robot
      :rtype: Self


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:

      Get the ResourceName for this Resource with the given name

      :param name: The name of the Resource
      :type name: str


   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



