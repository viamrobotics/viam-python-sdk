viam.services.generic.generic
=============================

.. py:module:: viam.services.generic.generic


Classes
-------

.. autoapisummary::

   viam.services.generic.generic.Generic


Module Contents
---------------

.. py:class:: Generic(name: str, *, logger: Optional[logging.Logger] = None)

   Bases: :py:obj:`viam.services.service_base.ServiceBase`


   Generic service, which represents any type of service that can execute arbitrary commands

   This acts as an abstract base class for any drivers representing generic services.
   This cannot be used on its own. If the ``__init__()`` function is overridden, it must call the ``super().__init__()`` function.

   To create a Generic service (an arbitrary service that can process commands), this ``Generic`` service should be subclassed
   and the ``do_command`` function implemented.

   Example::

       class ComplexService(Generic):

           async def do_command(
               self,
               command: Mapping[str, ValueTypes],
               *,
               timeout: Optional[float] = None,
               **kwargs
           ) -> Mapping[str, ValueTypes]:
               result = {key: False for key in command.keys()}
               for (name, args) in command.items():
                   if name == 'set_val':
                       self.set_val(*args)
                       result[name] = True
                   if name == 'get_val':
                       result[name] = self.val
                   if name == 'complex_command':
                       self.complex_command(*args)
                       result[name] = True
               return result

           def set_val(self, val: int):
               self.val = val

           def complex_command(self, arg1, arg2, arg3):
               ...

   To execute commands, simply call the ``do_command`` function with the appropriate parameters.
   ::

       await service.do_command({'set_val': 10})
       service.val  # 10
       await service.do_command({'set_val': 5})
       service.val  # 5


   .. py:attribute:: API
      :type:  Final

      The API of the Resource


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the service named ``name`` from the provided robot.

      ::

          async def connect() -> RobotClient:
              # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
              options = RobotClient.Options.with_api_key("<API-KEY>", "<API-KEY-ID>")
              # Replace "<MACHINE-URL>" (included brackets) with your machine's connection URL or FQDN
              return await RobotClient.at_address("<MACHINE-URL>", options)

          async def main():
              robot = await connect()

              # Can be used with any resource, using the motion service as an example
              motion = MotionClient.from_robot(robot=machine, name="builtin")

              robot.close()

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service
      :type name: str

      :returns: The service, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:

      :async:


      Send/receive arbitrary commands.

      ::

          service = SERVICE.from_robot(robot=machine, "builtin")  # replace SERVICE with the appropriate class

          my_command = {
            "cmnd": "dosomething",
            "someparameter": 52
          }

          # Can be used with any resource, using the motion service as an example
          await service.do_command(command=my_command)

      :param command: The command to execute
      :type command: Dict[str, ValueTypes]

      :returns: Result of the executed command
      :rtype: Dict[str, ValueTypes]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = Arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




