:py:mod:`viam.services.vision`
==============================

.. py:module:: viam.services.vision


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   client/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   viam.services.vision.Classification
   viam.services.vision.Detection
   viam.services.vision.VisionServiceClient
   viam.services.vision.VisModelConfig
   viam.services.vision.VisModelType




.. py:class:: Classification(*, class_name: str = ..., confidence: float = ...)



   the general form of the output from a classifier

   .. py:attribute:: class_name
      :type: str

      the class name

   .. py:attribute:: confidence
      :type: float

      the confidence score of the classification


.. py:class:: Detection(*, x_min: builtins.int | None = ..., y_min: builtins.int | None = ..., x_max: builtins.int | None = ..., y_max: builtins.int | None = ..., confidence: float = ..., class_name: str = ...)



   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.

   .. py:attribute:: x_min
      :type: int

      the four corners of the box

   .. py:attribute:: y_min
      :type: int

      

   .. py:attribute:: x_max
      :type: int

      

   .. py:attribute:: y_max
      :type: int

      

   .. py:attribute:: confidence
      :type: float

      the confidence of the detection

   .. py:attribute:: class_name
      :type: str

      label associated with the detected object

   .. py:method:: HasField(field_name: Literal[_x_max, b'_x_max', _x_min, b'_x_min', _y_max, b'_y_max', _y_min, b'_y_min', x_max, b'x_max', x_min, b'x_min', y_max, b'y_max', y_min, b'y_min']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.


   .. py:method:: WhichOneof(oneof_group: Literal[_x_max, b'_x_max']) -> typing_extensions.Literal['x_max'] | None
               WhichOneof(oneof_group: Literal[_x_min, b'_x_min']) -> typing_extensions.Literal['x_min'] | None
               WhichOneof(oneof_group: Literal[_y_max, b'_y_max']) -> typing_extensions.Literal['y_max'] | None
               WhichOneof(oneof_group: Literal[_y_min, b'_y_min']) -> typing_extensions.Literal['y_min'] | None

      Returns the name of the field that is set inside a oneof group.

      If no field is set, returns None.

      :param oneof_group: the name of the oneof group to check.
      :type oneof_group: str

      :returns: The name of the group that is set, or None.
      :rtype: str or None

      :raises ValueError: no group with the given name exists



.. py:class:: VisionServiceClient(name: str, channel: grpclib.client.Channel)



   Connect to the Vision service, which allows you to access various computer vision algorithms
   (like detection, segmentation, tracking, etc) that usually only require a camera or image input.

   .. py:attribute:: SUBTYPE
      :type: Final

      

   .. py:method:: get_detector_names(*, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[str]
      :async:

      Get the list of detectors currently registered in the service.

      :returns: The detector names
      :rtype: List[str]


   .. py:method:: add_detector(config: VisModelConfig, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None)
      :async:

      Add a new detector to the service. Returns nothing if successful, and an error if not.
      Registers a new detector just as if you had put it in the original "register_models" field
      in the robot config. Available types and their parameters can be found in the
      vision service documentation.

      :param config: The configuration of the detector to add.
      :type config: VisModelConfig


   .. py:method:: remove_detector(detector_name: str, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None)
      :async:

      Remove the detector with the given name from the service. Returns nothing if successful.

      :param detector_name: The name of the detector to remove
      :type detector_name: str


   .. py:method:: get_detections_from_camera(camera_name: str, detector_name: str, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.service.vision.Detection]
      :async:

      Get a list of detections in the next image given a camera and a detector

      :param camera_name: The name of the camera to use for detection
      :type camera_name: str
      :param detector_name: The name of the detector to use for detection
      :type detector_name: str

      :returns: A list of 2D bounding boxes, their labels, and the
                confidence score of the labels, around the found objects in the next 2D image
                from the given camera, with the given detector applied to it.
      :rtype: List[Detection]


   .. py:method:: get_detections(image: Union[viam.media.viam_rgba_plugin.Image.Image, viam.media.video.RawImage], detector_name: str, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.service.vision.Detection]
      :async:

      Get a list of detections in the given image using the specified detector

      :param image: The image to get detections from
      :type image: Image
      :param detector_name: The name of the detector to use for detection
      :type detector_name: str

      :returns: A list of 2D bounding boxes, their labels, and the
                confidence score of the labels, around the found objects in the next 2D image
                from the given camera, with the given detector applied to it.
      :rtype: List[Detection]


   .. py:method:: get_classifier_names(*, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[str]
      :async:

      Get the list of classifiers currently registered to the service

      :returns: The list of classifier names
      :rtype: List[str]


   .. py:method:: add_classifier(config: VisModelConfig, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None)
      :async:

      Add a classifier to the service.

      :param config: The configuration of the classifier
      :type config: VisModelConfig


   .. py:method:: remove_classifier(classifier_name: str, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None)
      :async:

      Remove the classifier with the given name from the service. Returns nothing if successful.

      :param classifier_name: The name of the classifier to remove
      :type classifier_name: str


   .. py:method:: get_classifications_from_camera(camera_name: str, classifier_name: str, count: int, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.service.vision.Classification]
      :async:

      Get a list of classifications in the next image given a camera and a classifier

      :param camera_name: The name of the camera to use for detection
      :type camera_name: str
      :param classifier_name: The name of the classifier to use for classification
      :type classifier_name: str
      :param count: The number of classifications desired
      :type count: int

      :returns: The list of Classifications
      :rtype: List[Classification]


   .. py:method:: get_classifications(image: Union[viam.media.viam_rgba_plugin.Image.Image, viam.media.video.RawImage], classifier_name: str, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.service.vision.Classification]
      :async:

      Get a list of detections in the given image using the specified detector

      :param image: The image to get detections from
      :type image: Image
      :param classifier_name: The name of the detector to use for detection
      :type classifier_name: str

      :returns: The list of Classifications
      :rtype: List[Classification]


   .. py:method:: get_segmenter_names(*, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[str]
      :async:

      Get the list of segmenters currently registered in the service.

      :returns: The segmenter names
      :rtype: List[str]


   .. py:method:: add_segmenter(config: VisModelConfig, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None)
      :async:

      Add a segmenter to the service

      :param config: The configuration of the segmenter
      :type config: VisModelConfig


   .. py:method:: remove_segmenter(segmenter_name: str, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None)
      :async:

      Remove the segmenter with the given name from the service. Returns nothing if successful.

      :param segmenter_name: The name of the segmenter to remove
      :type segmenter_name: str


   .. py:method:: get_model_parameters_schema(model_type: VisModelType, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> Mapping[str, Union[str, int, float, bool, Sequence, Mapping]]
      :async:

      Get the parameters needed to add a model to the vision registry.

      :param model_type: The name of model
      :type model_type: VisModelType

      :returns: A dictionary representing the parameters as JSONSchema
      :rtype: Mapping[str, str | int | float | bool | Sequence | Mapping]


   .. py:method:: get_object_point_clouds(camera_name: str, segmenter_name: str, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.PointCloudObject]
      :async:

      Returns a list of the 3D point cloud objects and associated metadata in the latest
      picture obtained from the specified 3D camera (using the specified segmenter).

      To deserialize the returned information into a numpy array, use the Open3D library.
      ::

          import numpy as np
          import open3d as o3d

          object_point_clouds = await vision.get_object_point_clouds(camera_name, segmenter_name)

          # write the first object point cloud into a temporary file
          with open("/tmp/pointcloud_data.pcd", "wb") as f:
              f.write(object_point_clouds[0].point_cloud)
          pcd = o3d.io.read_point_cloud("/tmp/pointcloud_data.pcd")
          points = np.asarray(pcd.points)

      :param camera_name: The name of the camera
      :type camera_name: str
      :param segmenter_name: The name of the segmenter
      :type segmenter_name: str

      :returns: The pointcloud objects with metadata
      :rtype: List[PointCloudObject]


   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None) -> Mapping[str, viam.utils.ValueTypes]
      :async:

      Send/receive arbitrary commands

      :param command: The command to execute
      :type command: Dict[str, ValueTypes]

      :returns: Result of the executed command
      :rtype: Dict[str, ValueTypes]



.. py:class:: VisModelConfig

   .. py:attribute:: name
      :type: str

      

   .. py:attribute:: type
      :type: VisModelType

      

   .. py:attribute:: parameters
      :type: Mapping[str, Any]

      


.. py:class:: VisModelType



   str(object='') -> str
   str(bytes_or_buffer[, encoding[, errors]]) -> str

   Create a new string object from the given object. If encoding or
   errors is specified, then the object must expose a data buffer
   that will be decoded using the given encoding and error handler.
   Otherwise, returns the result of object.__str__() (if defined)
   or repr(object).
   encoding defaults to sys.getdefaultencoding().
   errors defaults to 'strict'.

   .. py:attribute:: DETECTOR_TF_LITE
      :value: 'tflite_detector'

      

   .. py:attribute:: DETECTOR_TENSORFLOW
      :value: 'tf_detector'

      

   .. py:attribute:: DETECTOR_COLOR
      :value: 'color_detector'

      

   .. py:attribute:: CLASSIFIER_TFLITE
      :value: 'tflite_classifier'

      

   .. py:attribute:: CLASSIFIER_TENSORFLOW
      :value: 'tf_classifier'

      

   .. py:attribute:: DETECTOR_SEGMENTER
      :value: 'detector_segmenter'

      

   .. py:attribute:: RADIUS_CLUSTERING_SEGMENTER
      :value: 'radius_clustering_segmenter'

      


