:py:mod:`viam.services.vision.vision`
=====================================

.. py:module:: viam.services.vision.vision


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   viam.services.vision.vision.Vision




.. py:class:: Vision(name: str)


   Bases: :py:obj:`viam.services.service_base.ServiceBase`

   Vision represents a Vision service.

   This acts as an abstract base class for any drivers representing specific
   arm implementations. This cannot be used on its own. If the ``__init__()`` function is
   overridden, it must call the ``super().__init__()`` function.

   .. py:attribute:: SUBTYPE
      :type: Final

      

   .. py:method:: get_detections_from_camera(camera_name: str, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.service.vision.Detection]
      :abstractmethod:
      :async:

      Get a list of detections in the next image given a camera and a detector

      :param camera_name: The name of the camera to use for detection
      :type camera_name: str

      :returns: A list of 2D bounding boxes, their labels, and the
                confidence score of the labels, around the found objects in the next 2D image
                from the given camera, with the given detector applied to it.
      :rtype: List[viam.proto.service.vision.Detection]


   .. py:method:: get_detections(image: Union[PIL.Image.Image, viam.media.video.RawImage], *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.service.vision.Detection]
      :abstractmethod:
      :async:

      Get a list of detections in the given image using the specified detector

      :param image: The image to get detections from
      :type image: Image

      :returns: A list of 2D bounding boxes, their labels, and the
                confidence score of the labels, around the found objects in the next 2D image
                from the given camera, with the given detector applied to it.
      :rtype: List[viam.proto.service.vision.Detection]


   .. py:method:: get_classifications_from_camera(camera_name: str, count: int, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.service.vision.Classification]
      :abstractmethod:
      :async:

      Get a list of classifications in the next image given a camera and a classifier

      :param camera_name: The name of the camera to use for detection
      :type camera_name: str
      :param count: The number of classifications desired
      :type count: int

      :returns: The list of Classifications
      :rtype: List[viam.proto.service.vision.Classification]


   .. py:method:: get_classifications(image: Union[PIL.Image.Image, viam.media.video.RawImage], count: int, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.service.vision.Classification]
      :abstractmethod:
      :async:

      Get a list of classifications in the given image using the specified classifier

      :param image: The image to get detections from
      :type image: Image
      :param count: The number of classifications desired
      :type count: int

      :returns: The list of Classifications
      :rtype: List[viam.proto.service.vision.Classification]


   .. py:method:: get_object_point_clouds(camera_name: str, *, extra: Optional[Mapping[str, Any]] = None, timeout: Optional[float] = None) -> List[viam.proto.common.PointCloudObject]
      :abstractmethod:
      :async:

      Returns a list of the 3D point cloud objects and associated metadata in the latest
      picture obtained from the specified 3D camera (using the specified segmenter).

      To deserialize the returned information into a numpy array, use the Open3D library.
      ::

          import numpy as np
          import open3d as o3d

          object_point_clouds = await vision.get_object_point_clouds(camera_name, segmenter_name)

          # write the first object point cloud into a temporary file
          with open("/tmp/pointcloud_data.pcd", "wb") as f:
              f.write(object_point_clouds[0].point_cloud)
          pcd = o3d.io.read_point_cloud("/tmp/pointcloud_data.pcd")
          points = np.asarray(pcd.points)

      :param camera_name: The name of the camera
      :type camera_name: str

      :returns: The pointcloud objects with metadata
      :rtype: List[viam.proto.common.PointCloudObject]


   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:

      Get the service named ``name`` from the provided robot.

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service
      :type name: str

      :returns: The service, if it exists on the robot
      :rtype: Self


   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:
      :async:

      Send/receive arbitrary commands

      :param command: The command to execute
      :type command: Dict[str, ValueTypes]

      :returns: Result of the executed command
      :rtype: Dict[str, ValueTypes]


   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:

      Get the ResourceName for this Resource with the given name

      :param name: The name of the Resource
      :type name: str


   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation


   .. py:method:: close()
      :async:

      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to retun errors when future
      non-Close methods are called.

      ::

          await component.close()




