viam.services.navigation.service
================================

.. py:module:: viam.services.navigation.service


Classes
-------

.. autoapisummary::

   viam.services.navigation.service.DoCommandRequest
   viam.services.navigation.service.DoCommandResponse
   viam.services.navigation.service.AddWaypointRequest
   viam.services.navigation.service.AddWaypointResponse
   viam.services.navigation.service.GetLocationRequest
   viam.services.navigation.service.GetLocationResponse
   viam.services.navigation.service.GetModeRequest
   viam.services.navigation.service.GetModeResponse
   viam.services.navigation.service.GetObstaclesRequest
   viam.services.navigation.service.GetObstaclesResponse
   viam.services.navigation.service.GetPathsRequest
   viam.services.navigation.service.GetPathsResponse
   viam.services.navigation.service.GetPropertiesRequest
   viam.services.navigation.service.GetPropertiesResponse
   viam.services.navigation.service.GetWaypointsRequest
   viam.services.navigation.service.GetWaypointsResponse
   viam.services.navigation.service.NavigationServiceBase
   viam.services.navigation.service.RemoveWaypointRequest
   viam.services.navigation.service.RemoveWaypointResponse
   viam.services.navigation.service.SetModeRequest
   viam.services.navigation.service.SetModeResponse
   viam.services.navigation.service.ResourceRPCServiceBase
   viam.services.navigation.service.Navigation
   viam.services.navigation.service.NavigationRPCService


Functions
---------

.. autoapisummary::

   viam.services.navigation.service.dict_to_struct
   viam.services.navigation.service.struct_to_dict


Module Contents
---------------

.. py:class:: DoCommandRequest(*, name: str = ..., command: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandRequest represents a generic DoCommand input


   .. py:attribute:: name
      :type:  str


   .. py:property:: command
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['command', b'command']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DoCommandResponse(*, result: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandResponse represents a generic DoCommand output


   .. py:property:: result
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['result', b'result']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: AddWaypointRequest(*, name: str = ..., location: viam.gen.common.v1.common_pb2.GeoPoint | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:property:: location
      :type: viam.gen.common.v1.common_pb2.GeoPoint



   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra', 'location', b'location']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: AddWaypointResponse

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: GetLocationRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetLocationResponse(*, location: viam.gen.common.v1.common_pb2.GeoPoint | None = ..., compass_heading: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: compass_heading
      :type:  float

      A number from [0-360) where 0 is north
      90 is east, 180 is south, 270 is west


   .. py:property:: location
      :type: viam.gen.common.v1.common_pb2.GeoPoint



   .. py:method:: HasField(field_name: Literal['location', b'location']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetModeRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetModeResponse(*, mode: global___Mode = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: mode
      :type:  global___Mode


.. py:class:: GetObstaclesRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   GetObstacles will return the geopoint location and geometry of all
   known obstacles on the navigation map. Obstacles that are detected
   through the vision service will only be returned if this endpoint is called
   when the robot is sensing the obstacle


   .. py:attribute:: name
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetObstaclesResponse(*, obstacles: collections.abc.Iterable[viam.gen.common.v1.common_pb2.GeoGeometry] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: obstacles
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.GeoGeometry]

      List of all known geometries


.. py:class:: GetPathsRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Returns all the paths known to the navigation service


   .. py:attribute:: name
      :type:  str

      Name of the navigation service


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetPathsResponse(*, paths: collections.abc.Iterable[global___Path] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: paths
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Path]



.. py:class:: GetPropertiesRequest(*, name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of the navigation service


.. py:class:: GetPropertiesResponse(*, map_type: global___MapType = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Returns properties information for the named navigation service


   .. py:attribute:: map_type
      :type:  global___MapType


.. py:class:: GetWaypointsRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetWaypointsResponse(*, waypoints: collections.abc.Iterable[global___Waypoint] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: waypoints
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Waypoint]



.. py:class:: NavigationServiceBase

   Bases: :py:obj:`abc.ABC`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:method:: GetMode(stream: grpclib.server.Stream[service.navigation.v1.navigation_pb2.GetModeRequest, service.navigation.v1.navigation_pb2.GetModeResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: SetMode(stream: grpclib.server.Stream[service.navigation.v1.navigation_pb2.SetModeRequest, service.navigation.v1.navigation_pb2.SetModeResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetLocation(stream: grpclib.server.Stream[service.navigation.v1.navigation_pb2.GetLocationRequest, service.navigation.v1.navigation_pb2.GetLocationResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetWaypoints(stream: grpclib.server.Stream[service.navigation.v1.navigation_pb2.GetWaypointsRequest, service.navigation.v1.navigation_pb2.GetWaypointsResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: AddWaypoint(stream: grpclib.server.Stream[service.navigation.v1.navigation_pb2.AddWaypointRequest, service.navigation.v1.navigation_pb2.AddWaypointResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: RemoveWaypoint(stream: grpclib.server.Stream[service.navigation.v1.navigation_pb2.RemoveWaypointRequest, service.navigation.v1.navigation_pb2.RemoveWaypointResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetObstacles(stream: grpclib.server.Stream[service.navigation.v1.navigation_pb2.GetObstaclesRequest, service.navigation.v1.navigation_pb2.GetObstaclesResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetPaths(stream: grpclib.server.Stream[service.navigation.v1.navigation_pb2.GetPathsRequest, service.navigation.v1.navigation_pb2.GetPathsResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: GetProperties(stream: grpclib.server.Stream[service.navigation.v1.navigation_pb2.GetPropertiesRequest, service.navigation.v1.navigation_pb2.GetPropertiesResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: DoCommand(stream: grpclib.server.Stream[common.v1.common_pb2.DoCommandRequest, common.v1.common_pb2.DoCommandResponse]) -> None
      :abstractmethod:

      :async:



   .. py:method:: __mapping__() -> Dict[str, grpclib.const.Handler]


.. py:class:: RemoveWaypointRequest(*, name: str = ..., id: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: id
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: RemoveWaypointResponse

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: SetModeRequest(*, name: str = ..., mode: global___Mode = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: mode
      :type:  global___Mode


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: SetModeResponse

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


.. py:class:: ResourceRPCServiceBase(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`abc.ABC`, :py:obj:`viam.rpc.types.RPCServiceBase`, :py:obj:`Generic`\ [\ :py:obj:`viam.resource.manager.ResourceType`\ ]


   Base RPC service for a resource.
   All resource RPC services must inherit from this class.


   .. py:attribute:: RESOURCE_TYPE


   .. py:attribute:: manager
      :type:  viam.resource.manager.ResourceManager


   .. py:method:: get_resource(name: str) -> viam.resource.manager.ResourceType

      Return the resource with the given name if it exists in the registry.
      If the resource does not exist in the registry,
      this function will raise an error

      :param name: Name of the resource
      :type name: str

      :raises GRPCError with the status code Status.NOT_FOUND:

      :returns: The resource
      :rtype: ResourceType



.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:class:: Navigation(name: str)

   Bases: :py:obj:`viam.services.service_base.ServiceBase`


   Navigation represents a Navigation service.

   This acts as an abstract base class for any drivers representing specific
   navigation service implementations. This cannot be used on its own. If the ``__init__()`` function is
   overridden, it must call the ``super().__init__()`` function.


   .. py:attribute:: SUBTYPE
      :type:  Final


   .. py:method:: get_paths(*, timeout: Optional[float]) -> List[viam.services.navigation.Path]
      :abstractmethod:

      :async:


      Get each path, the series of geo points the robot plans to travel through
      to get to a destination waypoint, in the machine’s motion planning.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get a list containing each path stored by the navigation service
          paths = await my_nav.get_paths()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: An array comprised of Paths, where each path is either a user-provided destination or
                a Waypoint, along with the corresponding set of geopoints. This outlines the route the machine is expected to take to
                reach the specified destination or Waypoint.
      :rtype: List[navigation.Path]



   .. py:method:: get_location(*, timeout: Optional[float]) -> viam.services.navigation.GeoPoint
      :abstractmethod:

      :async:


      Get the current location of the robot in the navigation service.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get the current location of the robot in the navigation service
          location = await my_nav.get_location()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: The current location of the robot in the navigation service,
                represented in a GeoPoint with latitude and longitude values.
      :rtype: navigation.GeoPoint



   .. py:method:: get_obstacles(*, timeout: Optional[float]) -> List[viam.services.navigation.GeoGeometry]
      :abstractmethod:

      :async:


      Get an array or list of the obstacles currently in the service’s data storage.
      These are objects designated for the robot to avoid when navigating.
      These include all transient obstacles which are discovered by the vision services configured for the navigation service,
      in addition to the obstacles that are configured as a part of the service.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get a list containing each obstacle stored by the navigation service
          obstacles = await my_nav.get_obstacles()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: A list comprised of each GeoGeometry in the service’s data storage.
                These are objects designated for the robot to avoid when navigating.
      :rtype: List[navigation.GeoGeometry]



   .. py:method:: get_waypoints(*, timeout: Optional[float]) -> List[viam.services.navigation.Waypoint]
      :abstractmethod:

      :async:


      Get an array of waypoints currently in the service’s data storage.
      These are locations designated within a path for the robot to navigate to.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get a list containing each waypoint stored by the navigation service
          waypoints = await my_nav.get_waypoints()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: An array comprised of each Waypoint in the service’s data storage.
                These are locations designated within a path for the robot to navigate to.
      :rtype: List[navigation.Waypoint]



   .. py:method:: add_waypoint(point: viam.services.navigation.GeoPoint, *, timeout: Optional[float])
      :abstractmethod:

      :async:


      Add a waypoint to the service’s data storage.

      ::

         my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Create a new waypoint with latitude and longitude values of 0 degrees
          location = GeoPoint(latitude=0, longitude=0)


          # Add your waypoint to the service's data storage
          await my_nav.add_waypoint(point=location)

      :param point: The current location of the robot in the navigation service,
                    represented in a GeoPoint with latitude and longitude values.
      :type point: navigation.GeoPoint
      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]



   .. py:method:: remove_waypoint(id: str, *, timeout: Optional[float])
      :abstractmethod:

      :async:


      Remove a waypoint from the service’s data storage. If the robot is currently navigating to this waypoint,
      the motion will be canceled, and the robot will proceed to the next waypoint.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Remove the waypoint matching that ObjectID from the service's data storage
          await my_nav.remove_waypoint(waypoint_id)

      :param id: The MongoDB ObjectID of the Waypoint to remove from the service’s data storage.
      :type id: str
      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]



   .. py:method:: get_mode(*, timeout: Optional[float]) -> viam.services.navigation.Mode.ValueType
      :abstractmethod:

      :async:


      Get the Mode the service is operating in.

      There are two options for modes: MODE_MANUAL or MODE_WAYPOINT.

          MODE_WAYPOINT: Start to look for added waypoints and begin autonomous navigation.
          MODE_MANUAL: Stop autonomous navigation between waypoints and allow the base to be controlled manually.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get the Mode the service is operating in
          await my_nav.get_mode()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: The Mode the service is operating in.
      :rtype: navigation.Mode.ValueType



   .. py:method:: set_mode(mode: viam.services.navigation.Mode.ValueType, *, timeout: Optional[float])
      :abstractmethod:

      :async:


      Set the Mode the service is operating in.

      There are two options for modes: MODE_MANUAL or MODE_WAYPOINT.

          MODE_WAYPOINT: Start to look for added waypoints and begin autonomous navigation.
          MODE_MANUAL: Stop autonomous navigation between waypoints and allow the base to be controlled manually.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Set the Mode the service is operating in to MODE_WAYPOINT and begin navigation
          await my_nav.set_mode(Mode.ValueType.MODE_WAYPOINT)

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]
      :param mode: The Mode for the service to operate in.
      :type mode: navigation.Mode.ValueType



   .. py:method:: get_properties(*, timeout: Optional[float]) -> viam.services.navigation.MapType.ValueType
      :abstractmethod:

      :async:


      Get information about the navigation service.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get the properties of the current navigation service.
          nav_properties = await my_nav.get_properties()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: Information about the type of map the service is using.
      :rtype: MapType.ValueType



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the service named ``name`` from the provided robot.

      ::

          async def connect() -> ViamClient:
              # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
              dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
              return await ViamClient.create_from_dial_options(dial_options)

          async def main():
              robot = await connect()

              # Can be used with any resource, using the motion service as an example
              motion = MotionClient.from_robot(robot=robot, name="builtin")

              robot.close()

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service
      :type name: str

      :returns: The service, if it exists on the robot
      :rtype: Self



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **kwargs) -> Mapping[str, viam.utils.ValueTypes]
      :abstractmethod:

      :async:


      Send/receive arbitrary commands.

      ::

          motion = MotionClient.from_robot(robot, "builtin")

          my_command = {
            "cmnd": "dosomething",
            "someparameter": 52
          }

          # Can be used with any resource, using the motion service as an example
          await motion.do_command(command=my_command)

      :param command: The command to execute
      :type command: Dict[str, ValueTypes]

      :returns: Result of the executed command
      :rtype: Dict[str, ValueTypes]



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




.. py:class:: NavigationRPCService(manager: viam.resource.manager.ResourceManager)

   Bases: :py:obj:`viam.proto.service.navigation.NavigationServiceBase`, :py:obj:`viam.resource.rpc_service_base.ResourceRPCServiceBase`


   gRPC Service for a Navigation service


   .. py:attribute:: RESOURCE_TYPE


   .. py:method:: GetPaths(stream: grpclib.server.Stream[viam.proto.service.navigation.GetPathsRequest, viam.proto.service.navigation.GetPathsResponse]) -> None
      :async:



   .. py:method:: GetLocation(stream: grpclib.server.Stream[viam.proto.service.navigation.GetLocationRequest, viam.proto.service.navigation.GetLocationResponse]) -> None
      :async:



   .. py:method:: GetObstacles(stream: grpclib.server.Stream[viam.proto.service.navigation.GetObstaclesRequest, viam.proto.service.navigation.GetObstaclesResponse]) -> None
      :async:



   .. py:method:: GetWaypoints(stream: grpclib.server.Stream[viam.proto.service.navigation.GetWaypointsRequest, viam.proto.service.navigation.GetWaypointsResponse]) -> None
      :async:



   .. py:method:: AddWaypoint(stream: grpclib.server.Stream[viam.proto.service.navigation.AddWaypointRequest, viam.proto.service.navigation.AddWaypointResponse]) -> None
      :async:



   .. py:method:: RemoveWaypoint(stream: grpclib.server.Stream[viam.proto.service.navigation.RemoveWaypointRequest, viam.proto.service.navigation.RemoveWaypointResponse]) -> None
      :async:



   .. py:method:: GetMode(stream: grpclib.server.Stream[viam.proto.service.navigation.GetModeRequest, viam.proto.service.navigation.GetModeResponse]) -> None
      :async:



   .. py:method:: SetMode(stream: grpclib.server.Stream[viam.proto.service.navigation.SetModeRequest, viam.proto.service.navigation.SetModeResponse]) -> None
      :async:



   .. py:method:: GetProperties(stream: grpclib.server.Stream[viam.proto.service.navigation.GetPropertiesRequest, viam.proto.service.navigation.GetPropertiesResponse]) -> None
      :async:



   .. py:method:: DoCommand(stream: grpclib.server.Stream[viam.proto.common.DoCommandRequest, viam.proto.common.DoCommandResponse]) -> None
      :async:



