viam.services.navigation.client
===============================

.. py:module:: viam.services.navigation.client


Attributes
----------

.. autoapisummary::

   viam.services.navigation.client.ValueTypes


Classes
-------

.. autoapisummary::

   viam.services.navigation.client.DoCommandRequest
   viam.services.navigation.client.DoCommandResponse
   viam.services.navigation.client.AddWaypointRequest
   viam.services.navigation.client.GetLocationRequest
   viam.services.navigation.client.GetLocationResponse
   viam.services.navigation.client.GetModeRequest
   viam.services.navigation.client.GetModeResponse
   viam.services.navigation.client.GetObstaclesRequest
   viam.services.navigation.client.GetObstaclesResponse
   viam.services.navigation.client.GetPathsRequest
   viam.services.navigation.client.GetPathsResponse
   viam.services.navigation.client.GetPropertiesRequest
   viam.services.navigation.client.GetPropertiesResponse
   viam.services.navigation.client.GetWaypointsRequest
   viam.services.navigation.client.GetWaypointsResponse
   viam.services.navigation.client.NavigationServiceStub
   viam.services.navigation.client.Path
   viam.services.navigation.client.RemoveWaypointRequest
   viam.services.navigation.client.SetModeRequest
   viam.services.navigation.client.ReconfigurableResourceRPCClientBase
   viam.services.navigation.client.NavigationClient


Functions
---------

.. autoapisummary::

   viam.services.navigation.client.dict_to_struct
   viam.services.navigation.client.struct_to_dict


Module Contents
---------------

.. py:class:: DoCommandRequest(*, name: str = ..., command: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandRequest represents a generic DoCommand input


   .. py:attribute:: name
      :type:  str


   .. py:property:: command
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['command', b'command']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: DoCommandResponse(*, result: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   DoCommandResponse represents a generic DoCommand output


   .. py:property:: result
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['result', b'result']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: AddWaypointRequest(*, name: str = ..., location: viam.gen.common.v1.common_pb2.GeoPoint | None = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:property:: location
      :type: viam.gen.common.v1.common_pb2.GeoPoint



   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra', 'location', b'location']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetLocationRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetLocationResponse(*, location: viam.gen.common.v1.common_pb2.GeoPoint | None = ..., compass_heading: float = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: compass_heading
      :type:  float

      A number from [0-360) where 0 is north
      90 is east, 180 is south, 270 is west


   .. py:property:: location
      :type: viam.gen.common.v1.common_pb2.GeoPoint



   .. py:method:: HasField(field_name: Literal['location', b'location']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetModeRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetModeResponse(*, mode: global___Mode = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: mode
      :type:  global___Mode


.. py:class:: GetObstaclesRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   GetObstacles will return the geopoint location and geometry of all
   known obstacles on the navigation map. Obstacles that are detected
   through the vision service will only be returned if this endpoint is called
   when the robot is sensing the obstacle


   .. py:attribute:: name
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetObstaclesResponse(*, obstacles: collections.abc.Iterable[viam.gen.common.v1.common_pb2.GeoGeometry] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: obstacles
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.GeoGeometry]

      List of all known geometries


.. py:class:: GetPathsRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Returns all the paths known to the navigation service


   .. py:attribute:: name
      :type:  str

      Name of the navigation service


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct



   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetPathsResponse(*, paths: collections.abc.Iterable[global___Path] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: paths
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Path]



.. py:class:: GetPropertiesRequest(*, name: str = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str

      Name of the navigation service


.. py:class:: GetPropertiesResponse(*, map_type: global___MapType = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Returns properties information for the named navigation service


   .. py:attribute:: map_type
      :type:  global___MapType


.. py:class:: GetWaypointsRequest(*, name: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: GetWaypointsResponse(*, waypoints: collections.abc.Iterable[global___Waypoint] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:property:: waypoints
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Waypoint]



.. py:class:: NavigationServiceStub(channel: grpclib.client.Channel)

.. py:class:: Path(*, destination_waypoint_id: str = ..., geopoints: collections.abc.Iterable[viam.gen.common.v1.common_pb2.GeoPoint] | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   A user provided destination and the set of geopoints that
   the robot is expected to take to get there


   .. py:attribute:: destination_waypoint_id
      :type:  str

      The id of the user specified waypoint


   .. py:property:: geopoints
      :type: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[viam.gen.common.v1.common_pb2.GeoPoint]

      List of geopoints that the motion planner output to reach the destination
      The first geopoint is the starting position of the robot for that path


.. py:class:: RemoveWaypointRequest(*, name: str = ..., id: str = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: id
      :type:  str


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: SetModeRequest(*, name: str = ..., mode: global___Mode = ..., extra: google.protobuf.struct_pb2.Struct | None = ...)

   Bases: :py:obj:`google.protobuf.message.Message`


   Abstract base class for protocol messages.

   Protocol message classes are almost always generated by the protocol
   compiler.  These generated types subclass Message and implement the methods
   shown below.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: mode
      :type:  global___Mode


   .. py:property:: extra
      :type: google.protobuf.struct_pb2.Struct

      Additional arguments to the method


   .. py:method:: HasField(field_name: Literal['extra', b'extra']) -> bool

      Checks if a certain field is set for the message.

      For a oneof group, checks if any field inside is set. Note that if the
      field_name is not defined in the message descriptor, :exc:`ValueError` will
      be raised.

      :param field_name: The name of the field to check for presence.
      :type field_name: str

      :returns: Whether a value has been set for the named field.
      :rtype: bool

      :raises ValueError: if the `field_name` is not a member of this message.



.. py:class:: ReconfigurableResourceRPCClientBase

   Bases: :py:obj:`ResourceRPCClientBase`


   A base RPC client that can reset its channel.

   Useful if connection is lost and then regained.


   .. py:method:: reset_channel(channel: grpclib.client.Channel)

      Called when the RPC channel was reset. Passes in the new channel.

      :param channel: The new RPC Channel
      :type channel: Channel



.. py:data:: ValueTypes

   Types that can be encoded into a protobuf `Value`

.. py:function:: dict_to_struct(obj: Mapping[str, ValueTypes]) -> google.protobuf.struct_pb2.Struct

.. py:function:: struct_to_dict(struct: google.protobuf.struct_pb2.Struct) -> Dict[str, ValueTypes]

.. py:class:: NavigationClient(name: str, channel: grpclib.client.Channel)

   Bases: :py:obj:`viam.services.navigation.navigation.Navigation`, :py:obj:`viam.resource.rpc_client_base.ReconfigurableResourceRPCClientBase`


   Connect to the NavigationService, which allows the robot to navigate to specified locations.


   .. py:attribute:: client
      :type:  viam.proto.service.navigation.NavigationServiceStub


   .. py:method:: get_paths(*, timeout: Optional[float] = None) -> List[viam.proto.service.navigation.Path]
      :async:


      Get each path, the series of geo points the robot plans to travel through
      to get to a destination waypoint, in the machine’s motion planning.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get a list containing each path stored by the navigation service
          paths = await my_nav.get_paths()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: An array comprised of Paths, where each path is either a user-provided destination or
                a Waypoint, along with the corresponding set of geopoints. This outlines the route the machine is expected to take to
                reach the specified destination or Waypoint.
      :rtype: List[navigation.Path]

      For more information, see `Navigation service <https://docs.viam.com/services/navigation/>`_.



   .. py:method:: get_location(*, timeout: Optional[float] = None) -> viam.services.navigation.GeoPoint
      :async:


      Get the current location of the robot in the navigation service.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get the current location of the robot in the navigation service
          location = await my_nav.get_location()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: The current location of the robot in the navigation service,
                represented in a GeoPoint with latitude and longitude values.
      :rtype: navigation.GeoPoint

      For more information, see `Navigation service <https://docs.viam.com/services/navigation/>`_.



   .. py:method:: get_obstacles(*, timeout: Optional[float] = None) -> List[viam.services.navigation.GeoGeometry]
      :async:


      Get an array or list of the obstacles currently in the service’s data storage.
      These are objects designated for the robot to avoid when navigating.
      These include all transient obstacles which are discovered by the vision services configured for the navigation service,
      in addition to the obstacles that are configured as a part of the service.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get a list containing each obstacle stored by the navigation service
          obstacles = await my_nav.get_obstacles()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: A list comprised of each GeoGeometry in the service’s data storage.
                These are objects designated for the robot to avoid when navigating.
      :rtype: List[navigation.GeoGeometry]

      For more information, see `Navigation service <https://docs.viam.com/services/navigation/>`_.



   .. py:method:: get_waypoints(*, timeout: Optional[float] = None) -> List[viam.services.navigation.Waypoint]
      :async:


      Get an array of waypoints currently in the service’s data storage.
      These are locations designated within a path for the robot to navigate to.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get a list containing each waypoint stored by the navigation service
          waypoints = await my_nav.get_waypoints()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: An array comprised of each Waypoint in the service’s data storage.
                These are locations designated within a path for the robot to navigate to.
      :rtype: List[navigation.Waypoint]

      For more information, see `Navigation service <https://docs.viam.com/services/navigation/>`_.



   .. py:method:: add_waypoint(point: viam.services.navigation.GeoPoint, *, timeout: Optional[float] = None)
      :async:


      Add a waypoint to the service’s data storage.

      ::

         my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Create a new waypoint with latitude and longitude values of 0 degrees
          location = GeoPoint(latitude=0, longitude=0)


          # Add your waypoint to the service's data storage
          await my_nav.add_waypoint(point=location)

      :param point: The current location of the robot in the navigation service,
                    represented in a GeoPoint with latitude and longitude values.
      :type point: navigation.GeoPoint
      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      For more information, see `Navigation service <https://docs.viam.com/services/navigation/>`_.



   .. py:method:: remove_waypoint(id: str, *, timeout: Optional[float] = None)
      :async:


      Remove a waypoint from the service’s data storage. If the robot is currently navigating to this waypoint,
      the motion will be canceled, and the robot will proceed to the next waypoint.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Remove the waypoint matching that ObjectID from the service's data storage
          await my_nav.remove_waypoint(waypoint_id)

      :param id: The MongoDB ObjectID of the Waypoint to remove from the service’s data storage.
      :type id: str
      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      For more information, see `Navigation service <https://docs.viam.com/services/navigation/>`_.



   .. py:method:: get_mode(*, timeout: Optional[float] = None) -> viam.services.navigation.Mode.ValueType
      :async:


      Get the Mode the service is operating in.

      There are two options for modes: MODE_MANUAL or MODE_WAYPOINT.

          MODE_WAYPOINT: Start to look for added waypoints and begin autonomous navigation.
          MODE_MANUAL: Stop autonomous navigation between waypoints and allow the base to be controlled manually.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get the Mode the service is operating in
          await my_nav.get_mode()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: The Mode the service is operating in.
      :rtype: navigation.Mode.ValueType

      For more information, see `Navigation service <https://docs.viam.com/services/navigation/>`_.



   .. py:method:: set_mode(mode: viam.services.navigation.Mode.ValueType, *, timeout: Optional[float] = None)
      :async:


      Set the Mode the service is operating in.

      There are two options for modes: MODE_MANUAL or MODE_WAYPOINT.

          MODE_WAYPOINT: Start to look for added waypoints and begin autonomous navigation.
          MODE_MANUAL: Stop autonomous navigation between waypoints and allow the base to be controlled manually.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Set the Mode the service is operating in to MODE_WAYPOINT and begin navigation
          await my_nav.set_mode(Mode.ValueType.MODE_WAYPOINT)

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]
      :param mode: The Mode for the service to operate in.
      :type mode: navigation.Mode.ValueType

      For more information, see `Navigation service <https://docs.viam.com/services/navigation/>`_.



   .. py:method:: get_properties(*, timeout: Optional[float] = None) -> viam.services.navigation.MapType.ValueType
      :async:


      Get information about the navigation service.

      ::

          my_nav = NavigationClient.from_robot(robot=robot, name="my_nav_service")

          # Get the properties of the current navigation service.
          nav_properties = await my_nav.get_properties()

      :param timeout: An option to set how long to wait (in seconds)
                      before calling a time-out and closing the underlying RPC call.
      :type timeout: Optional[float]

      :returns: Information about the type of map the service is using.
      :rtype: MapType.ValueType

      For more information, see `Navigation service <https://docs.viam.com/services/navigation/>`_.



   .. py:method:: do_command(command: Mapping[str, viam.utils.ValueTypes], *, timeout: Optional[float] = None, **__) -> Mapping[str, viam.utils.ValueTypes]
      :async:


      Send/receive arbitrary commands.

      ::

          motion = MotionClient.from_robot(robot, "builtin")

          my_command = {
            "cmnd": "dosomething",
            "someparameter": 52
          }

          # Can be used with any resource, using the motion service as an example
          await motion.do_command(command=my_command)

      :param command: The command to execute
      :type command: Dict[str, ValueTypes]

      :returns: Result of the executed command
      :rtype: Dict[str, ValueTypes]



   .. py:method:: from_robot(robot: viam.robot.client.RobotClient, name: str) -> typing_extensions.Self
      :classmethod:


      Get the service named ``name`` from the provided robot.

      ::

          async def connect() -> ViamClient:
              # Replace "<API-KEY>" (including brackets) with your API key and "<API-KEY-ID>" with your API key ID
              dial_options = DialOptions.with_api_key("<API-KEY>", "<API-KEY-ID>")
              return await ViamClient.create_from_dial_options(dial_options)

          async def main():
              robot = await connect()

              # Can be used with any resource, using the motion service as an example
              motion = MotionClient.from_robot(robot=robot, name="builtin")

              robot.close()

      :param robot: The robot
      :type robot: RobotClient
      :param name: The name of the service
      :type name: str

      :returns: The service, if it exists on the robot
      :rtype: Self



   .. py:method:: get_resource_name(name: str) -> viam.proto.common.ResourceName
      :classmethod:


      Get the ResourceName for this Resource with the given name

      ::

          # Can be used with any resource, using an arm as an example
          my_arm_name = my_arm.get_resource_name("my_arm")

      :param name: The name of the Resource
      :type name: str

      :returns: The ResourceName of this Resource
      :rtype: ResourceName



   .. py:method:: get_operation(kwargs: Mapping[str, Any]) -> viam.operations.Operation

      Get the ``Operation`` associated with the currently running function.

      When writing custom resources, you should get the ``Operation`` by calling this function and check to see if it's cancelled.
      If the ``Operation`` is cancelled, then you can perform any necessary (terminating long running tasks, cleaning up connections, etc.
      ).

      :param kwargs: The kwargs object containing the operation
      :type kwargs: Mapping[str, Any]

      :returns: The operation associated with this function
      :rtype: viam.operations.Operation



   .. py:method:: close()
      :async:


      Safely shut down the resource and prevent further use.

      Close must be idempotent. Later configuration may allow a resource to be "open" again.
      If a resource does not want or need a close function, it is assumed that the resource does not need to return errors when future
      non-Close methods are called.

      ::

          await component.close()




