"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.api.distribution_pb2
import google.api.metric_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class LogMetric(google.protobuf.message.Message):
    """Describes a logs-based metric. The value of the metric is the number of log
    entries that match a logs filter in a given time interval.

    Logs-based metrics can also be used to extract values from logs and create a
    distribution of the values. The distribution records the statistics of the
    extracted values along with an optional histogram of the values as specified
    by the bucket options.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _ApiVersion:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ApiVersionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ApiVersion.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        V2: LogMetric.ApiVersion.ValueType = ...  # 0
        """Logging API v2."""

        V1: LogMetric.ApiVersion.ValueType = ...  # 1
        """Logging API v1."""

    class ApiVersion(_ApiVersion, metaclass=_ApiVersionEnumTypeWrapper):
        """Logging API version."""
        pass

    V2: LogMetric.ApiVersion.ValueType = ...  # 0
    """Logging API v2."""

    V1: LogMetric.ApiVersion.ValueType = ...  # 1
    """Logging API v1."""


    class LabelExtractorsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    METRIC_DESCRIPTOR_FIELD_NUMBER: builtins.int
    VALUE_EXTRACTOR_FIELD_NUMBER: builtins.int
    LABEL_EXTRACTORS_FIELD_NUMBER: builtins.int
    BUCKET_OPTIONS_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The client-assigned metric identifier.
    Examples: `"error_count"`, `"nginx/requests"`.

    Metric identifiers are limited to 100 characters and can include only the
    following characters: `A-Z`, `a-z`, `0-9`, and the special characters
    `_-.,+!*',()%/`. The forward-slash character (`/`) denotes a hierarchy of
    name pieces, and it cannot be the first character of the name.

    The metric identifier in this field must not be
    [URL-encoded](https://en.wikipedia.org/wiki/Percent-encoding).
    However, when the metric identifier appears as the `[METRIC_ID]` part of a
    `metric_name` API parameter, then the metric identifier must be
    URL-encoded. Example: `"projects/my-project/metrics/nginx%2Frequests"`.
    """

    description: typing.Text = ...
    """Optional. A description of this metric, which is used in documentation.
    The maximum length of the description is 8000 characters.
    """

    filter: typing.Text = ...
    """Required. An [advanced logs
    filter](https://cloud.google.com/logging/docs/view/advanced_filters) which
    is used to match log entries. Example:

        "resource.type=gae_app AND severity>=ERROR"

    The maximum length of the filter is 20000 characters.
    """

    @property
    def metric_descriptor(self) -> google.api.metric_pb2.MetricDescriptor:
        """Optional. The metric descriptor associated with the logs-based metric.
        If unspecified, it uses a default metric descriptor with a DELTA metric
        kind, INT64 value type, with no labels and a unit of "1". Such a metric
        counts the number of log entries matching the `filter` expression.

        The `name`, `type`, and `description` fields in the `metric_descriptor`
        are output only, and is constructed using the `name` and `description`
        field in the LogMetric.

        To create a logs-based metric that records a distribution of log values, a
        DELTA metric kind with a DISTRIBUTION value type must be used along with
        a `value_extractor` expression in the LogMetric.

        Each label in the metric descriptor must have a matching label
        name as the key and an extractor expression as the value in the
        `label_extractors` map.

        The `metric_kind` and `value_type` fields in the `metric_descriptor` cannot
        be updated once initially configured. New labels can be added in the
        `metric_descriptor`, but existing labels cannot be modified except for
        their description.
        """
        pass
    value_extractor: typing.Text = ...
    """Optional. A `value_extractor` is required when using a distribution
    logs-based metric to extract the values to record from a log entry.
    Two functions are supported for value extraction: `EXTRACT(field)` or
    `REGEXP_EXTRACT(field, regex)`. The argument are:
      1. field: The name of the log entry field from which the value is to be
         extracted.
      2. regex: A regular expression using the Google RE2 syntax
         (https://github.com/google/re2/wiki/Syntax) with a single capture
         group to extract data from the specified log entry field. The value
         of the field is converted to a string before applying the regex.
         It is an error to specify a regex that does not include exactly one
         capture group.

    The result of the extraction must be convertible to a double type, as the
    distribution always records double values. If either the extraction or
    the conversion to double fails, then those values are not recorded in the
    distribution.

    Example: `REGEXP_EXTRACT(jsonPayload.request, ".*quantity=(\\d+).*")`
    """

    @property
    def label_extractors(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Optional. A map from a label key string to an extractor expression which is
        used to extract data from a log entry field and assign as the label value.
        Each label key specified in the LabelDescriptor must have an associated
        extractor expression in this map. The syntax of the extractor expression
        is the same as for the `value_extractor` field.

        The extracted value is converted to the type defined in the label
        descriptor. If the either the extraction or the type conversion fails,
        the label will have a default value. The default value for a string
        label is an empty string, for an integer label its 0, and for a boolean
        label its `false`.

        Note that there are upper bounds on the maximum number of labels and the
        number of active time series that are allowed in a project.
        """
        pass
    @property
    def bucket_options(self) -> google.api.distribution_pb2.Distribution.BucketOptions:
        """Optional. The `bucket_options` are required when the logs-based metric is
        using a DISTRIBUTION value type and it describes the bucket boundaries
        used to create a histogram of the extracted values.
        """
        pass
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The creation timestamp of the metric.

        This field may not be present for older metrics.
        """
        pass
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The last update timestamp of the metric.

        This field may not be present for older metrics.
        """
        pass
    version: global___LogMetric.ApiVersion.ValueType = ...
    """Deprecated. The API version that created or updated this metric.
    The v2 format is used by default and cannot be changed.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        description : typing.Text = ...,
        filter : typing.Text = ...,
        metric_descriptor : typing.Optional[google.api.metric_pb2.MetricDescriptor] = ...,
        value_extractor : typing.Text = ...,
        label_extractors : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        bucket_options : typing.Optional[google.api.distribution_pb2.Distribution.BucketOptions] = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        update_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        version : global___LogMetric.ApiVersion.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bucket_options",b"bucket_options","create_time",b"create_time","metric_descriptor",b"metric_descriptor","update_time",b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bucket_options",b"bucket_options","create_time",b"create_time","description",b"description","filter",b"filter","label_extractors",b"label_extractors","metric_descriptor",b"metric_descriptor","name",b"name","update_time",b"update_time","value_extractor",b"value_extractor","version",b"version"]) -> None: ...
global___LogMetric = LogMetric

class ListLogMetricsRequest(google.protobuf.message.Message):
    """The parameters to ListLogMetrics."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The name of the project containing the metrics:

        "projects/[PROJECT_ID]"
    """

    page_token: typing.Text = ...
    """Optional. If present, then retrieve the next batch of results from the
    preceding call to this method. `pageToken` must be the value of
    `nextPageToken` from the previous response. The values of other method
    parameters should be identical to those in the previous call.
    """

    page_size: builtins.int = ...
    """Optional. The maximum number of results to return from this request.
    Non-positive values are ignored. The presence of `nextPageToken` in the
    response indicates that more results might be available.
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_token : typing.Text = ...,
        page_size : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["page_size",b"page_size","page_token",b"page_token","parent",b"parent"]) -> None: ...
global___ListLogMetricsRequest = ListLogMetricsRequest

class ListLogMetricsResponse(google.protobuf.message.Message):
    """Result returned from ListLogMetrics."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    METRICS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LogMetric]:
        """A list of logs-based metrics."""
        pass
    next_page_token: typing.Text = ...
    """If there might be more results than appear in this response, then
    `nextPageToken` is included. To get the next set of results, call this
    method again using the value of `nextPageToken` as `pageToken`.
    """

    def __init__(self,
        *,
        metrics : typing.Optional[typing.Iterable[global___LogMetric]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["metrics",b"metrics","next_page_token",b"next_page_token"]) -> None: ...
global___ListLogMetricsResponse = ListLogMetricsResponse

class GetLogMetricRequest(google.protobuf.message.Message):
    """The parameters to GetLogMetric."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    METRIC_NAME_FIELD_NUMBER: builtins.int
    metric_name: typing.Text = ...
    """Required. The resource name of the desired metric:

        "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
    """

    def __init__(self,
        *,
        metric_name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["metric_name",b"metric_name"]) -> None: ...
global___GetLogMetricRequest = GetLogMetricRequest

class CreateLogMetricRequest(google.protobuf.message.Message):
    """The parameters to CreateLogMetric."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    METRIC_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The resource name of the project in which to create the metric:

        "projects/[PROJECT_ID]"

    The new metric must be provided in the request.
    """

    @property
    def metric(self) -> global___LogMetric:
        """Required. The new logs-based metric, which must not have an identifier that
        already exists.
        """
        pass
    def __init__(self,
        *,
        parent : typing.Text = ...,
        metric : typing.Optional[global___LogMetric] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["metric",b"metric"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["metric",b"metric","parent",b"parent"]) -> None: ...
global___CreateLogMetricRequest = CreateLogMetricRequest

class UpdateLogMetricRequest(google.protobuf.message.Message):
    """The parameters to UpdateLogMetric."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    METRIC_NAME_FIELD_NUMBER: builtins.int
    METRIC_FIELD_NUMBER: builtins.int
    metric_name: typing.Text = ...
    """Required. The resource name of the metric to update:

        "projects/[PROJECT_ID]/metrics/[METRIC_ID]"

    The updated metric must be provided in the request and it's
    `name` field must be the same as `[METRIC_ID]` If the metric
    does not exist in `[PROJECT_ID]`, then a new metric is created.
    """

    @property
    def metric(self) -> global___LogMetric:
        """Required. The updated metric."""
        pass
    def __init__(self,
        *,
        metric_name : typing.Text = ...,
        metric : typing.Optional[global___LogMetric] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["metric",b"metric"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["metric",b"metric","metric_name",b"metric_name"]) -> None: ...
global___UpdateLogMetricRequest = UpdateLogMetricRequest

class DeleteLogMetricRequest(google.protobuf.message.Message):
    """The parameters to DeleteLogMetric."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    METRIC_NAME_FIELD_NUMBER: builtins.int
    metric_name: typing.Text = ...
    """Required. The resource name of the metric to delete:

        "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
    """

    def __init__(self,
        *,
        metric_name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["metric_name",b"metric_name"]) -> None: ...
global___DeleteLogMetricRequest = DeleteLogMetricRequest
