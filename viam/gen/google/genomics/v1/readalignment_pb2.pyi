"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.genomics.v1.cigar_pb2
import google.genomics.v1.position_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import google.protobuf.struct_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class LinearAlignment(google.protobuf.message.Message):
    """A linear alignment can be represented by one CIGAR string. Describes the
    mapped position and local alignment of the read to the reference.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    POSITION_FIELD_NUMBER: builtins.int
    MAPPING_QUALITY_FIELD_NUMBER: builtins.int
    CIGAR_FIELD_NUMBER: builtins.int
    @property
    def position(self) -> google.genomics.v1.position_pb2.Position:
        """The position of this alignment."""
        pass
    mapping_quality: builtins.int = ...
    """The mapping quality of this alignment. Represents how likely
    the read maps to this position as opposed to other locations.

    Specifically, this is -10 log10 Pr(mapping position is wrong), rounded to
    the nearest integer.
    """

    @property
    def cigar(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.genomics.v1.cigar_pb2.CigarUnit]:
        """Represents the local alignment of this sequence (alignment matches, indels,
        etc) against the reference.
        """
        pass
    def __init__(self,
        *,
        position : typing.Optional[google.genomics.v1.position_pb2.Position] = ...,
        mapping_quality : builtins.int = ...,
        cigar : typing.Optional[typing.Iterable[google.genomics.v1.cigar_pb2.CigarUnit]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["position",b"position"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cigar",b"cigar","mapping_quality",b"mapping_quality","position",b"position"]) -> None: ...
global___LinearAlignment = LinearAlignment

class Read(google.protobuf.message.Message):
    """A read alignment describes a linear alignment of a string of DNA to a
    [reference sequence][google.genomics.v1.Reference], in addition to metadata
    about the fragment (the molecule of DNA sequenced) and the read (the bases
    which were read by the sequencer). A read is equivalent to a line in a SAM
    file. A read belongs to exactly one read group and exactly one
    [read group set][google.genomics.v1.ReadGroupSet].

    For more genomics resource definitions, see [Fundamentals of Google
    Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)

    ### Reverse-stranded reads

    Mapped reads (reads having a non-null `alignment`) can be aligned to either
    the forward or the reverse strand of their associated reference. Strandedness
    of a mapped read is encoded by `alignment.position.reverseStrand`.

    If we consider the reference to be a forward-stranded coordinate space of
    `[0, reference.length)` with `0` as the left-most position and
    `reference.length` as the right-most position, reads are always aligned left
    to right. That is, `alignment.position.position` always refers to the
    left-most reference coordinate and `alignment.cigar` describes the alignment
    of this read to the reference from left to right. All per-base fields such as
    `alignedSequence` and `alignedQuality` share this same left-to-right
    orientation; this is true of reads which are aligned to either strand. For
    reverse-stranded reads, this means that `alignedSequence` is the reverse
    complement of the bases that were originally reported by the sequencing
    machine.

    ### Generating a reference-aligned sequence string

    When interacting with mapped reads, it's often useful to produce a string
    representing the local alignment of the read to reference. The following
    pseudocode demonstrates one way of doing this:

        out = ""
        offset = 0
        for c in read.alignment.cigar {
          switch c.operation {
          case "ALIGNMENT_MATCH", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH":
            out += read.alignedSequence[offset:offset+c.operationLength]
            offset += c.operationLength
            break
          case "CLIP_SOFT", "INSERT":
            offset += c.operationLength
            break
          case "PAD":
            out += repeat("*", c.operationLength)
            break
          case "DELETE":
            out += repeat("-", c.operationLength)
            break
          case "SKIP":
            out += repeat(" ", c.operationLength)
            break
          case "CLIP_HARD":
            break
          }
        }
        return out

    ### Converting to SAM's CIGAR string

    The following pseudocode generates a SAM CIGAR string from the
    `cigar` field. Note that this is a lossy conversion
    (`cigar.referenceSequence` is lost).

        cigarMap = {
          "ALIGNMENT_MATCH": "M",
          "INSERT": "I",
          "DELETE": "D",
          "SKIP": "N",
          "CLIP_SOFT": "S",
          "CLIP_HARD": "H",
          "PAD": "P",
          "SEQUENCE_MATCH": "=",
          "SEQUENCE_MISMATCH": "X",
        }
        cigarStr = ""
        for c in read.alignment.cigar {
          cigarStr += c.operationLength + cigarMap[c.operation]
        }
        return cigarStr
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class InfoEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> google.protobuf.struct_pb2.ListValue: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[google.protobuf.struct_pb2.ListValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    READ_GROUP_ID_FIELD_NUMBER: builtins.int
    READ_GROUP_SET_ID_FIELD_NUMBER: builtins.int
    FRAGMENT_NAME_FIELD_NUMBER: builtins.int
    PROPER_PLACEMENT_FIELD_NUMBER: builtins.int
    DUPLICATE_FRAGMENT_FIELD_NUMBER: builtins.int
    FRAGMENT_LENGTH_FIELD_NUMBER: builtins.int
    READ_NUMBER_FIELD_NUMBER: builtins.int
    NUMBER_READS_FIELD_NUMBER: builtins.int
    FAILED_VENDOR_QUALITY_CHECKS_FIELD_NUMBER: builtins.int
    ALIGNMENT_FIELD_NUMBER: builtins.int
    SECONDARY_ALIGNMENT_FIELD_NUMBER: builtins.int
    SUPPLEMENTARY_ALIGNMENT_FIELD_NUMBER: builtins.int
    ALIGNED_SEQUENCE_FIELD_NUMBER: builtins.int
    ALIGNED_QUALITY_FIELD_NUMBER: builtins.int
    NEXT_MATE_POSITION_FIELD_NUMBER: builtins.int
    INFO_FIELD_NUMBER: builtins.int
    id: typing.Text = ...
    """The server-generated read ID, unique across all reads. This is different
    from the `fragmentName`.
    """

    read_group_id: typing.Text = ...
    """The ID of the read group this read belongs to. A read belongs to exactly
    one read group. This is a server-generated ID which is distinct from SAM's
    RG tag (for that value, see
    [ReadGroup.name][google.genomics.v1.ReadGroup.name]).
    """

    read_group_set_id: typing.Text = ...
    """The ID of the read group set this read belongs to. A read belongs to
    exactly one read group set.
    """

    fragment_name: typing.Text = ...
    """The fragment name. Equivalent to QNAME (query template name) in SAM."""

    proper_placement: builtins.bool = ...
    """The orientation and the distance between reads from the fragment are
    consistent with the sequencing protocol (SAM flag 0x2).
    """

    duplicate_fragment: builtins.bool = ...
    """The fragment is a PCR or optical duplicate (SAM flag 0x400)."""

    fragment_length: builtins.int = ...
    """The observed length of the fragment, equivalent to TLEN in SAM."""

    read_number: builtins.int = ...
    """The read number in sequencing. 0-based and less than numberReads. This
    field replaces SAM flag 0x40 and 0x80.
    """

    number_reads: builtins.int = ...
    """The number of reads in the fragment (extension to SAM flag 0x1)."""

    failed_vendor_quality_checks: builtins.bool = ...
    """Whether this read did not pass filters, such as platform or vendor quality
    controls (SAM flag 0x200).
    """

    @property
    def alignment(self) -> global___LinearAlignment:
        """The linear alignment for this alignment record. This field is null for
        unmapped reads.
        """
        pass
    secondary_alignment: builtins.bool = ...
    """Whether this alignment is secondary. Equivalent to SAM flag 0x100.
    A secondary alignment represents an alternative to the primary alignment
    for this read. Aligners may return secondary alignments if a read can map
    ambiguously to multiple coordinates in the genome. By convention, each read
    has one and only one alignment where both `secondaryAlignment`
    and `supplementaryAlignment` are false.
    """

    supplementary_alignment: builtins.bool = ...
    """Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
    Supplementary alignments are used in the representation of a chimeric
    alignment. In a chimeric alignment, a read is split into multiple
    linear alignments that map to different reference contigs. The first
    linear alignment in the read will be designated as the representative
    alignment; the remaining linear alignments will be designated as
    supplementary alignments. These alignments may have different mapping
    quality scores. In each linear alignment in a chimeric alignment, the read
    will be hard clipped. The `alignedSequence` and
    `alignedQuality` fields in the alignment record will only
    represent the bases for its respective linear alignment.
    """

    aligned_sequence: typing.Text = ...
    """The bases of the read sequence contained in this alignment record,
    **without CIGAR operations applied** (equivalent to SEQ in SAM).
    `alignedSequence` and `alignedQuality` may be
    shorter than the full read sequence and quality. This will occur if the
    alignment is part of a chimeric alignment, or if the read was trimmed. When
    this occurs, the CIGAR for this read will begin/end with a hard clip
    operator that will indicate the length of the excised sequence.
    """

    @property
    def aligned_quality(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The quality of the read sequence contained in this alignment record
        (equivalent to QUAL in SAM).
        `alignedSequence` and `alignedQuality` may be shorter than the full read
        sequence and quality. This will occur if the alignment is part of a
        chimeric alignment, or if the read was trimmed. When this occurs, the CIGAR
        for this read will begin/end with a hard clip operator that will indicate
        the length of the excised sequence.
        """
        pass
    @property
    def next_mate_position(self) -> google.genomics.v1.position_pb2.Position:
        """The mapping of the primary alignment of the
        `(readNumber+1)%numberReads` read in the fragment. It replaces
        mate position and mate strand in SAM.
        """
        pass
    @property
    def info(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.protobuf.struct_pb2.ListValue]:
        """A map of additional read alignment information. This must be of the form
        map<string, string[]> (string key mapping to a list of string values).
        """
        pass
    def __init__(self,
        *,
        id : typing.Text = ...,
        read_group_id : typing.Text = ...,
        read_group_set_id : typing.Text = ...,
        fragment_name : typing.Text = ...,
        proper_placement : builtins.bool = ...,
        duplicate_fragment : builtins.bool = ...,
        fragment_length : builtins.int = ...,
        read_number : builtins.int = ...,
        number_reads : builtins.int = ...,
        failed_vendor_quality_checks : builtins.bool = ...,
        alignment : typing.Optional[global___LinearAlignment] = ...,
        secondary_alignment : builtins.bool = ...,
        supplementary_alignment : builtins.bool = ...,
        aligned_sequence : typing.Text = ...,
        aligned_quality : typing.Optional[typing.Iterable[builtins.int]] = ...,
        next_mate_position : typing.Optional[google.genomics.v1.position_pb2.Position] = ...,
        info : typing.Optional[typing.Mapping[typing.Text, google.protobuf.struct_pb2.ListValue]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["alignment",b"alignment","next_mate_position",b"next_mate_position"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["aligned_quality",b"aligned_quality","aligned_sequence",b"aligned_sequence","alignment",b"alignment","duplicate_fragment",b"duplicate_fragment","failed_vendor_quality_checks",b"failed_vendor_quality_checks","fragment_length",b"fragment_length","fragment_name",b"fragment_name","id",b"id","info",b"info","next_mate_position",b"next_mate_position","number_reads",b"number_reads","proper_placement",b"proper_placement","read_group_id",b"read_group_id","read_group_set_id",b"read_group_set_id","read_number",b"read_number","secondary_alignment",b"secondary_alignment","supplementary_alignment",b"supplementary_alignment"]) -> None: ...
global___Read = Read
