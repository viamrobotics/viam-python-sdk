"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import google.protobuf.wrappers_pb2
import google.rpc.status_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _AnnotationType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _AnnotationTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_AnnotationType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    ANNOTATION_TYPE_UNSPECIFIED: AnnotationType.ValueType = ...  # 0
    GENERIC: AnnotationType.ValueType = ...  # 1
    """A `GENERIC` annotation type should be used when no other annotation
    type will suffice. This represents an untyped annotation of the reference
    genome.
    """

    VARIANT: AnnotationType.ValueType = ...  # 2
    """A `VARIANT` annotation type."""

    GENE: AnnotationType.ValueType = ...  # 3
    """A `GENE` annotation type represents the existence of a gene at the
    associated reference coordinates. The start coordinate is typically the
    gene's transcription start site and the end is typically the end of the
    gene's last exon.
    """

    TRANSCRIPT: AnnotationType.ValueType = ...  # 4
    """A `TRANSCRIPT` annotation type represents the assertion that a
    particular region of the reference genome may be transcribed as RNA.
    """

class AnnotationType(_AnnotationType, metaclass=_AnnotationTypeEnumTypeWrapper):
    """When an [Annotation][google.genomics.v1.Annotation] or
    [AnnotationSet][google.genomics.v1.AnnotationSet] is created, if `type` is
    not specified it will be set to `GENERIC`.
    """
    pass

ANNOTATION_TYPE_UNSPECIFIED: AnnotationType.ValueType = ...  # 0
GENERIC: AnnotationType.ValueType = ...  # 1
"""A `GENERIC` annotation type should be used when no other annotation
type will suffice. This represents an untyped annotation of the reference
genome.
"""

VARIANT: AnnotationType.ValueType = ...  # 2
"""A `VARIANT` annotation type."""

GENE: AnnotationType.ValueType = ...  # 3
"""A `GENE` annotation type represents the existence of a gene at the
associated reference coordinates. The start coordinate is typically the
gene's transcription start site and the end is typically the end of the
gene's last exon.
"""

TRANSCRIPT: AnnotationType.ValueType = ...  # 4
"""A `TRANSCRIPT` annotation type represents the assertion that a
particular region of the reference genome may be transcribed as RNA.
"""

global___AnnotationType = AnnotationType


class AnnotationSet(google.protobuf.message.Message):
    """An annotation set is a logical grouping of annotations that share consistent
    type information and provenance. Examples of annotation sets include 'all
    genes from refseq', and 'all variant annotations from ClinVar'.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class InfoEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> google.protobuf.struct_pb2.ListValue: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[google.protobuf.struct_pb2.ListValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    DATASET_ID_FIELD_NUMBER: builtins.int
    REFERENCE_SET_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SOURCE_URI_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    INFO_FIELD_NUMBER: builtins.int
    id: typing.Text = ...
    """The server-generated annotation set ID, unique across all annotation sets."""

    dataset_id: typing.Text = ...
    """The dataset to which this annotation set belongs."""

    reference_set_id: typing.Text = ...
    """The ID of the reference set that defines the coordinate space for this
    set's annotations.
    """

    name: typing.Text = ...
    """The display name for this annotation set."""

    source_uri: typing.Text = ...
    """The source URI describing the file from which this annotation set was
    generated, if any.
    """

    type: global___AnnotationType.ValueType = ...
    """The type of annotations contained within this set."""

    @property
    def info(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.protobuf.struct_pb2.ListValue]:
        """A map of additional read alignment information. This must be of the form
        map<string, string[]> (string key mapping to a list of string values).
        """
        pass
    def __init__(self,
        *,
        id : typing.Text = ...,
        dataset_id : typing.Text = ...,
        reference_set_id : typing.Text = ...,
        name : typing.Text = ...,
        source_uri : typing.Text = ...,
        type : global___AnnotationType.ValueType = ...,
        info : typing.Optional[typing.Mapping[typing.Text, google.protobuf.struct_pb2.ListValue]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset_id",b"dataset_id","id",b"id","info",b"info","name",b"name","reference_set_id",b"reference_set_id","source_uri",b"source_uri","type",b"type"]) -> None: ...
global___AnnotationSet = AnnotationSet

class Annotation(google.protobuf.message.Message):
    """An annotation describes a region of reference genome. The value of an
    annotation may be one of several canonical types, supplemented by arbitrary
    info tags. An annotation is not inherently associated with a specific
    sample or individual (though a client could choose to use annotations in
    this way). Example canonical annotation types are `GENE` and
    `VARIANT`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class InfoEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> google.protobuf.struct_pb2.ListValue: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[google.protobuf.struct_pb2.ListValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    ANNOTATION_SET_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    REFERENCE_ID_FIELD_NUMBER: builtins.int
    REFERENCE_NAME_FIELD_NUMBER: builtins.int
    START_FIELD_NUMBER: builtins.int
    END_FIELD_NUMBER: builtins.int
    REVERSE_STRAND_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    VARIANT_FIELD_NUMBER: builtins.int
    TRANSCRIPT_FIELD_NUMBER: builtins.int
    INFO_FIELD_NUMBER: builtins.int
    id: typing.Text = ...
    """The server-generated annotation ID, unique across all annotations."""

    annotation_set_id: typing.Text = ...
    """The annotation set to which this annotation belongs."""

    name: typing.Text = ...
    """The display name of this annotation."""

    reference_id: typing.Text = ...
    """The ID of the Google Genomics reference associated with this range."""

    reference_name: typing.Text = ...
    """The display name corresponding to the reference specified by
    `referenceId`, for example `chr1`, `1`, or `chrX`.
    """

    start: builtins.int = ...
    """The start position of the range on the reference, 0-based inclusive."""

    end: builtins.int = ...
    """The end position of the range on the reference, 0-based exclusive."""

    reverse_strand: builtins.bool = ...
    """Whether this range refers to the reverse strand, as opposed to the forward
    strand. Note that regardless of this field, the start/end position of the
    range always refer to the forward strand.
    """

    type: global___AnnotationType.ValueType = ...
    """The data type for this annotation. Must match the containing annotation
    set's type.
    """

    @property
    def variant(self) -> global___VariantAnnotation:
        """A variant annotation, which describes the effect of a variant on the
        genome, the coding sequence, and/or higher level consequences at the
        organism level e.g. pathogenicity. This field is only set for annotations
        of type `VARIANT`.
        """
        pass
    @property
    def transcript(self) -> global___Transcript:
        """A transcript value represents the assertion that a particular region of
        the reference genome may be transcribed as RNA. An alternative splicing
        pattern would be represented as a separate transcript object. This field
        is only set for annotations of type `TRANSCRIPT`.
        """
        pass
    @property
    def info(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.protobuf.struct_pb2.ListValue]:
        """A map of additional read alignment information. This must be of the form
        map<string, string[]> (string key mapping to a list of string values).
        """
        pass
    def __init__(self,
        *,
        id : typing.Text = ...,
        annotation_set_id : typing.Text = ...,
        name : typing.Text = ...,
        reference_id : typing.Text = ...,
        reference_name : typing.Text = ...,
        start : builtins.int = ...,
        end : builtins.int = ...,
        reverse_strand : builtins.bool = ...,
        type : global___AnnotationType.ValueType = ...,
        variant : typing.Optional[global___VariantAnnotation] = ...,
        transcript : typing.Optional[global___Transcript] = ...,
        info : typing.Optional[typing.Mapping[typing.Text, google.protobuf.struct_pb2.ListValue]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["transcript",b"transcript","value",b"value","variant",b"variant"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_set_id",b"annotation_set_id","end",b"end","id",b"id","info",b"info","name",b"name","reference_id",b"reference_id","reference_name",b"reference_name","reverse_strand",b"reverse_strand","start",b"start","transcript",b"transcript","type",b"type","value",b"value","variant",b"variant"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["value",b"value"]) -> typing.Optional[typing_extensions.Literal["variant","transcript"]]: ...
global___Annotation = Annotation

class VariantAnnotation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        TYPE_UNSPECIFIED: VariantAnnotation.Type.ValueType = ...  # 0
        TYPE_OTHER: VariantAnnotation.Type.ValueType = ...  # 1
        """`TYPE_OTHER` should be used when no other Type will suffice.
        Further explanation of the variant type may be included in the
        [info][google.genomics.v1.Annotation.info] field.
        """

        INSERTION: VariantAnnotation.Type.ValueType = ...  # 2
        """`INSERTION` indicates an insertion."""

        DELETION: VariantAnnotation.Type.ValueType = ...  # 3
        """`DELETION` indicates a deletion."""

        SUBSTITUTION: VariantAnnotation.Type.ValueType = ...  # 4
        """`SUBSTITUTION` indicates a block substitution of
        two or more nucleotides.
        """

        SNP: VariantAnnotation.Type.ValueType = ...  # 5
        """`SNP` indicates a single nucleotide polymorphism."""

        STRUCTURAL: VariantAnnotation.Type.ValueType = ...  # 6
        """`STRUCTURAL` indicates a large structural variant,
        including chromosomal fusions, inversions, etc.
        """

        CNV: VariantAnnotation.Type.ValueType = ...  # 7
        """`CNV` indicates a variation in copy number."""

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        pass

    TYPE_UNSPECIFIED: VariantAnnotation.Type.ValueType = ...  # 0
    TYPE_OTHER: VariantAnnotation.Type.ValueType = ...  # 1
    """`TYPE_OTHER` should be used when no other Type will suffice.
    Further explanation of the variant type may be included in the
    [info][google.genomics.v1.Annotation.info] field.
    """

    INSERTION: VariantAnnotation.Type.ValueType = ...  # 2
    """`INSERTION` indicates an insertion."""

    DELETION: VariantAnnotation.Type.ValueType = ...  # 3
    """`DELETION` indicates a deletion."""

    SUBSTITUTION: VariantAnnotation.Type.ValueType = ...  # 4
    """`SUBSTITUTION` indicates a block substitution of
    two or more nucleotides.
    """

    SNP: VariantAnnotation.Type.ValueType = ...  # 5
    """`SNP` indicates a single nucleotide polymorphism."""

    STRUCTURAL: VariantAnnotation.Type.ValueType = ...  # 6
    """`STRUCTURAL` indicates a large structural variant,
    including chromosomal fusions, inversions, etc.
    """

    CNV: VariantAnnotation.Type.ValueType = ...  # 7
    """`CNV` indicates a variation in copy number."""


    class _Effect:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _EffectEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Effect.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        EFFECT_UNSPECIFIED: VariantAnnotation.Effect.ValueType = ...  # 0
        EFFECT_OTHER: VariantAnnotation.Effect.ValueType = ...  # 1
        """`EFFECT_OTHER` should be used when no other Effect
        will suffice.
        """

        FRAMESHIFT: VariantAnnotation.Effect.ValueType = ...  # 2
        """`FRAMESHIFT` indicates a mutation in which the insertion or
        deletion of nucleotides resulted in a frameshift change.
        """

        FRAME_PRESERVING_INDEL: VariantAnnotation.Effect.ValueType = ...  # 3
        """`FRAME_PRESERVING_INDEL` indicates a mutation in which a
        multiple of three nucleotides has been inserted or deleted, resulting
        in no change to the reading frame of the coding sequence.
        """

        SYNONYMOUS_SNP: VariantAnnotation.Effect.ValueType = ...  # 4
        """`SYNONYMOUS_SNP` indicates a single nucleotide polymorphism
        mutation that results in no amino acid change.
        """

        NONSYNONYMOUS_SNP: VariantAnnotation.Effect.ValueType = ...  # 5
        """`NONSYNONYMOUS_SNP` indicates a single nucleotide
        polymorphism mutation that results in an amino acid change.
        """

        STOP_GAIN: VariantAnnotation.Effect.ValueType = ...  # 6
        """`STOP_GAIN` indicates a mutation that leads to the creation
        of a stop codon at the variant site. Frameshift mutations creating
        downstream stop codons do not count as `STOP_GAIN`.
        """

        STOP_LOSS: VariantAnnotation.Effect.ValueType = ...  # 7
        """`STOP_LOSS` indicates a mutation that eliminates a
        stop codon at the variant site.
        """

        SPLICE_SITE_DISRUPTION: VariantAnnotation.Effect.ValueType = ...  # 8
        """`SPLICE_SITE_DISRUPTION` indicates that this variant is
        found in a splice site for the associated transcript, and alters the
        normal splicing pattern.
        """

    class Effect(_Effect, metaclass=_EffectEnumTypeWrapper):
        pass

    EFFECT_UNSPECIFIED: VariantAnnotation.Effect.ValueType = ...  # 0
    EFFECT_OTHER: VariantAnnotation.Effect.ValueType = ...  # 1
    """`EFFECT_OTHER` should be used when no other Effect
    will suffice.
    """

    FRAMESHIFT: VariantAnnotation.Effect.ValueType = ...  # 2
    """`FRAMESHIFT` indicates a mutation in which the insertion or
    deletion of nucleotides resulted in a frameshift change.
    """

    FRAME_PRESERVING_INDEL: VariantAnnotation.Effect.ValueType = ...  # 3
    """`FRAME_PRESERVING_INDEL` indicates a mutation in which a
    multiple of three nucleotides has been inserted or deleted, resulting
    in no change to the reading frame of the coding sequence.
    """

    SYNONYMOUS_SNP: VariantAnnotation.Effect.ValueType = ...  # 4
    """`SYNONYMOUS_SNP` indicates a single nucleotide polymorphism
    mutation that results in no amino acid change.
    """

    NONSYNONYMOUS_SNP: VariantAnnotation.Effect.ValueType = ...  # 5
    """`NONSYNONYMOUS_SNP` indicates a single nucleotide
    polymorphism mutation that results in an amino acid change.
    """

    STOP_GAIN: VariantAnnotation.Effect.ValueType = ...  # 6
    """`STOP_GAIN` indicates a mutation that leads to the creation
    of a stop codon at the variant site. Frameshift mutations creating
    downstream stop codons do not count as `STOP_GAIN`.
    """

    STOP_LOSS: VariantAnnotation.Effect.ValueType = ...  # 7
    """`STOP_LOSS` indicates a mutation that eliminates a
    stop codon at the variant site.
    """

    SPLICE_SITE_DISRUPTION: VariantAnnotation.Effect.ValueType = ...  # 8
    """`SPLICE_SITE_DISRUPTION` indicates that this variant is
    found in a splice site for the associated transcript, and alters the
    normal splicing pattern.
    """


    class _ClinicalSignificance:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ClinicalSignificanceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ClinicalSignificance.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        CLINICAL_SIGNIFICANCE_UNSPECIFIED: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 0
        CLINICAL_SIGNIFICANCE_OTHER: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 1
        """`OTHER` should be used when no other clinical significance
        value will suffice.
        """

        UNCERTAIN: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 2
        BENIGN: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 3
        LIKELY_BENIGN: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 4
        LIKELY_PATHOGENIC: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 5
        PATHOGENIC: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 6
        DRUG_RESPONSE: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 7
        HISTOCOMPATIBILITY: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 8
        CONFERS_SENSITIVITY: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 9
        RISK_FACTOR: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 10
        ASSOCIATION: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 11
        PROTECTIVE: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 12
        MULTIPLE_REPORTED: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 13
        """`MULTIPLE_REPORTED` should be used when multiple clinical
        signficances are reported for a variant. The original clinical
        significance values may be provided in the `info` field.
        """

    class ClinicalSignificance(_ClinicalSignificance, metaclass=_ClinicalSignificanceEnumTypeWrapper):
        pass

    CLINICAL_SIGNIFICANCE_UNSPECIFIED: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 0
    CLINICAL_SIGNIFICANCE_OTHER: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 1
    """`OTHER` should be used when no other clinical significance
    value will suffice.
    """

    UNCERTAIN: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 2
    BENIGN: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 3
    LIKELY_BENIGN: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 4
    LIKELY_PATHOGENIC: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 5
    PATHOGENIC: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 6
    DRUG_RESPONSE: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 7
    HISTOCOMPATIBILITY: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 8
    CONFERS_SENSITIVITY: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 9
    RISK_FACTOR: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 10
    ASSOCIATION: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 11
    PROTECTIVE: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 12
    MULTIPLE_REPORTED: VariantAnnotation.ClinicalSignificance.ValueType = ...  # 13
    """`MULTIPLE_REPORTED` should be used when multiple clinical
    signficances are reported for a variant. The original clinical
    significance values may be provided in the `info` field.
    """


    class ClinicalCondition(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        NAMES_FIELD_NUMBER: builtins.int
        EXTERNAL_IDS_FIELD_NUMBER: builtins.int
        CONCEPT_ID_FIELD_NUMBER: builtins.int
        OMIM_ID_FIELD_NUMBER: builtins.int
        @property
        def names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """A set of names for the condition."""
            pass
        @property
        def external_ids(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ExternalId]:
            """The set of external IDs for this condition."""
            pass
        concept_id: typing.Text = ...
        """The MedGen concept id associated with this gene.
        Search for these IDs at http://www.ncbi.nlm.nih.gov/medgen/
        """

        omim_id: typing.Text = ...
        """The OMIM id for this condition.
        Search for these IDs at http://omim.org/
        """

        def __init__(self,
            *,
            names : typing.Optional[typing.Iterable[typing.Text]] = ...,
            external_ids : typing.Optional[typing.Iterable[global___ExternalId]] = ...,
            concept_id : typing.Text = ...,
            omim_id : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["concept_id",b"concept_id","external_ids",b"external_ids","names",b"names","omim_id",b"omim_id"]) -> None: ...

    TYPE_FIELD_NUMBER: builtins.int
    EFFECT_FIELD_NUMBER: builtins.int
    ALTERNATE_BASES_FIELD_NUMBER: builtins.int
    GENE_ID_FIELD_NUMBER: builtins.int
    TRANSCRIPT_IDS_FIELD_NUMBER: builtins.int
    CONDITIONS_FIELD_NUMBER: builtins.int
    CLINICAL_SIGNIFICANCE_FIELD_NUMBER: builtins.int
    type: global___VariantAnnotation.Type.ValueType = ...
    """Type has been adapted from ClinVar's list of variant types."""

    effect: global___VariantAnnotation.Effect.ValueType = ...
    """Effect of the variant on the coding sequence."""

    alternate_bases: typing.Text = ...
    """The alternate allele for this variant. If multiple alternate alleles
    exist at this location, create a separate variant for each one, as they
    may represent distinct conditions.
    """

    gene_id: typing.Text = ...
    """Google annotation ID of the gene affected by this variant. This should
    be provided when the variant is created.
    """

    @property
    def transcript_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Google annotation IDs of the transcripts affected by this variant. These
        should be provided when the variant is created.
        """
        pass
    @property
    def conditions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VariantAnnotation.ClinicalCondition]:
        """The set of conditions associated with this variant.
        A condition describes the way a variant influences human health.
        """
        pass
    clinical_significance: global___VariantAnnotation.ClinicalSignificance.ValueType = ...
    """Describes the clinical significance of a variant.
    It is adapted from the ClinVar controlled vocabulary for clinical
    significance described at:
    http://www.ncbi.nlm.nih.gov/clinvar/docs/clinsig/
    """

    def __init__(self,
        *,
        type : global___VariantAnnotation.Type.ValueType = ...,
        effect : global___VariantAnnotation.Effect.ValueType = ...,
        alternate_bases : typing.Text = ...,
        gene_id : typing.Text = ...,
        transcript_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
        conditions : typing.Optional[typing.Iterable[global___VariantAnnotation.ClinicalCondition]] = ...,
        clinical_significance : global___VariantAnnotation.ClinicalSignificance.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["alternate_bases",b"alternate_bases","clinical_significance",b"clinical_significance","conditions",b"conditions","effect",b"effect","gene_id",b"gene_id","transcript_ids",b"transcript_ids","type",b"type"]) -> None: ...
global___VariantAnnotation = VariantAnnotation

class Transcript(google.protobuf.message.Message):
    """A transcript represents the assertion that a particular region of the
    reference genome may be transcribed as RNA.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Exon(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        START_FIELD_NUMBER: builtins.int
        END_FIELD_NUMBER: builtins.int
        FRAME_FIELD_NUMBER: builtins.int
        start: builtins.int = ...
        """The start position of the exon on this annotation's reference sequence,
        0-based inclusive. Note that this is relative to the reference start, and
        **not** the containing annotation start.
        """

        end: builtins.int = ...
        """The end position of the exon on this annotation's reference sequence,
        0-based exclusive. Note that this is relative to the reference start, and
        *not* the containing annotation start.
        """

        @property
        def frame(self) -> google.protobuf.wrappers_pb2.Int32Value:
            """The frame of this exon. Contains a value of 0, 1, or 2, which indicates
            the offset of the first coding base of the exon within the reading frame
            of the coding DNA sequence, if any. This field is dependent on the
            strandedness of this annotation (see
            [Annotation.reverse_strand][google.genomics.v1.Annotation.reverse_strand]).
            For forward stranded annotations, this offset is relative to the
            [exon.start][google.genomics.v1.Transcript.Exon.start]. For reverse
            strand annotations, this offset is relative to the
            [exon.end][google.genomics.v1.Transcript.Exon.end] `- 1`.

            Unset if this exon does not intersect the coding sequence. Upon creation
            of a transcript, the frame must be populated for all or none of the
            coding exons.
            """
            pass
        def __init__(self,
            *,
            start : builtins.int = ...,
            end : builtins.int = ...,
            frame : typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["frame",b"frame"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["end",b"end","frame",b"frame","start",b"start"]) -> None: ...

    class CodingSequence(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        START_FIELD_NUMBER: builtins.int
        END_FIELD_NUMBER: builtins.int
        start: builtins.int = ...
        """The start of the coding sequence on this annotation's reference sequence,
        0-based inclusive. Note that this position is relative to the reference
        start, and *not* the containing annotation start.
        """

        end: builtins.int = ...
        """The end of the coding sequence on this annotation's reference sequence,
        0-based exclusive. Note that this position is relative to the reference
        start, and *not* the containing annotation start.
        """

        def __init__(self,
            *,
            start : builtins.int = ...,
            end : builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["end",b"end","start",b"start"]) -> None: ...

    GENE_ID_FIELD_NUMBER: builtins.int
    EXONS_FIELD_NUMBER: builtins.int
    CODING_SEQUENCE_FIELD_NUMBER: builtins.int
    gene_id: typing.Text = ...
    """The annotation ID of the gene from which this transcript is transcribed."""

    @property
    def exons(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Transcript.Exon]:
        """The <a href="http://en.wikipedia.org/wiki/Exon">exons</a> that compose
        this transcript. This field should be unset for genomes where transcript
        splicing does not occur, for example prokaryotes.

        Introns are regions of the transcript that are not included in the
        spliced RNA product. Though not explicitly modeled here, intron ranges can
        be deduced; all regions of this transcript that are not exons are introns.

        Exonic sequences do not necessarily code for a translational product
        (amino acids). Only the regions of exons bounded by the
        [codingSequence][google.genomics.v1.Transcript.coding_sequence] correspond
        to coding DNA sequence.

        Exons are ordered by start position and may not overlap.
        """
        pass
    @property
    def coding_sequence(self) -> global___Transcript.CodingSequence:
        """The range of the coding sequence for this transcript, if any. To determine
        the exact ranges of coding sequence, intersect this range with those of the
        [exons][google.genomics.v1.Transcript.exons], if any. If there are any
        [exons][google.genomics.v1.Transcript.exons], the
        [codingSequence][google.genomics.v1.Transcript.coding_sequence] must start
        and end within them.

        Note that in some cases, the reference genome will not exactly match the
        observed mRNA transcript e.g. due to variance in the source genome from
        reference. In these cases,
        [exon.frame][google.genomics.v1.Transcript.Exon.frame] will not necessarily
        match the expected reference reading frame and coding exon reference bases
        cannot necessarily be concatenated to produce the original transcript mRNA.
        """
        pass
    def __init__(self,
        *,
        gene_id : typing.Text = ...,
        exons : typing.Optional[typing.Iterable[global___Transcript.Exon]] = ...,
        coding_sequence : typing.Optional[global___Transcript.CodingSequence] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["coding_sequence",b"coding_sequence"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["coding_sequence",b"coding_sequence","exons",b"exons","gene_id",b"gene_id"]) -> None: ...
global___Transcript = Transcript

class ExternalId(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SOURCE_NAME_FIELD_NUMBER: builtins.int
    ID_FIELD_NUMBER: builtins.int
    source_name: typing.Text = ...
    """The name of the source of this data."""

    id: typing.Text = ...
    """The id used by the source of this data."""

    def __init__(self,
        *,
        source_name : typing.Text = ...,
        id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["id",b"id","source_name",b"source_name"]) -> None: ...
global___ExternalId = ExternalId

class CreateAnnotationSetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATION_SET_FIELD_NUMBER: builtins.int
    @property
    def annotation_set(self) -> global___AnnotationSet:
        """The annotation set to create."""
        pass
    def __init__(self,
        *,
        annotation_set : typing.Optional[global___AnnotationSet] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["annotation_set",b"annotation_set"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_set",b"annotation_set"]) -> None: ...
global___CreateAnnotationSetRequest = CreateAnnotationSetRequest

class GetAnnotationSetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATION_SET_ID_FIELD_NUMBER: builtins.int
    annotation_set_id: typing.Text = ...
    """The ID of the annotation set to be retrieved."""

    def __init__(self,
        *,
        annotation_set_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_set_id",b"annotation_set_id"]) -> None: ...
global___GetAnnotationSetRequest = GetAnnotationSetRequest

class UpdateAnnotationSetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATION_SET_ID_FIELD_NUMBER: builtins.int
    ANNOTATION_SET_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    annotation_set_id: typing.Text = ...
    """The ID of the annotation set to be updated."""

    @property
    def annotation_set(self) -> global___AnnotationSet:
        """The new annotation set."""
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """An optional mask specifying which fields to update. Mutable fields are
        [name][google.genomics.v1.AnnotationSet.name],
        [source_uri][google.genomics.v1.AnnotationSet.source_uri], and
        [info][google.genomics.v1.AnnotationSet.info]. If unspecified, all
        mutable fields will be updated.
        """
        pass
    def __init__(self,
        *,
        annotation_set_id : typing.Text = ...,
        annotation_set : typing.Optional[global___AnnotationSet] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["annotation_set",b"annotation_set","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_set",b"annotation_set","annotation_set_id",b"annotation_set_id","update_mask",b"update_mask"]) -> None: ...
global___UpdateAnnotationSetRequest = UpdateAnnotationSetRequest

class DeleteAnnotationSetRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATION_SET_ID_FIELD_NUMBER: builtins.int
    annotation_set_id: typing.Text = ...
    """The ID of the annotation set to be deleted."""

    def __init__(self,
        *,
        annotation_set_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_set_id",b"annotation_set_id"]) -> None: ...
global___DeleteAnnotationSetRequest = DeleteAnnotationSetRequest

class SearchAnnotationSetsRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATASET_IDS_FIELD_NUMBER: builtins.int
    REFERENCE_SET_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    TYPES_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    @property
    def dataset_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Required. The dataset IDs to search within. Caller must have `READ` access
        to these datasets.
        """
        pass
    reference_set_id: typing.Text = ...
    """If specified, only annotation sets associated with the given reference set
    are returned.
    """

    name: typing.Text = ...
    """Only return annotations sets for which a substring of the name matches this
    string (case insensitive).
    """

    @property
    def types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___AnnotationType.ValueType]:
        """If specified, only annotation sets that have any of these types are
        returned.
        """
        pass
    page_token: typing.Text = ...
    """The continuation token, which is used to page through large result sets.
    To get the next page of results, set this parameter to the value of
    `nextPageToken` from the previous response.
    """

    page_size: builtins.int = ...
    """The maximum number of results to return in a single page. If unspecified,
    defaults to 128. The maximum value is 1024.
    """

    def __init__(self,
        *,
        dataset_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
        reference_set_id : typing.Text = ...,
        name : typing.Text = ...,
        types : typing.Optional[typing.Iterable[global___AnnotationType.ValueType]] = ...,
        page_token : typing.Text = ...,
        page_size : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset_ids",b"dataset_ids","name",b"name","page_size",b"page_size","page_token",b"page_token","reference_set_id",b"reference_set_id","types",b"types"]) -> None: ...
global___SearchAnnotationSetsRequest = SearchAnnotationSetsRequest

class SearchAnnotationSetsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATION_SETS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def annotation_sets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnnotationSet]:
        """The matching annotation sets."""
        pass
    next_page_token: typing.Text = ...
    """The continuation token, which is used to page through large result sets.
    Provide this value in a subsequent request to return the next page of
    results. This field will be empty if there aren't any additional results.
    """

    def __init__(self,
        *,
        annotation_sets : typing.Optional[typing.Iterable[global___AnnotationSet]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_sets",b"annotation_sets","next_page_token",b"next_page_token"]) -> None: ...
global___SearchAnnotationSetsResponse = SearchAnnotationSetsResponse

class CreateAnnotationRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATION_FIELD_NUMBER: builtins.int
    @property
    def annotation(self) -> global___Annotation:
        """The annotation to be created."""
        pass
    def __init__(self,
        *,
        annotation : typing.Optional[global___Annotation] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["annotation",b"annotation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation",b"annotation"]) -> None: ...
global___CreateAnnotationRequest = CreateAnnotationRequest

class BatchCreateAnnotationsRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    REQUEST_ID_FIELD_NUMBER: builtins.int
    @property
    def annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Annotation]:
        """The annotations to be created. At most 4096 can be specified in a single
        request.
        """
        pass
    request_id: typing.Text = ...
    """A unique request ID which enables the server to detect duplicated requests.
    If provided, duplicated requests will result in the same response; if not
    provided, duplicated requests may result in duplicated data. For a given
    annotation set, callers should not reuse `request_id`s when writing
    different batches of annotations - behavior in this case is undefined.
    A common approach is to use a UUID. For batch jobs where worker crashes are
    a possibility, consider using some unique variant of a worker or run ID.
    """

    def __init__(self,
        *,
        annotations : typing.Optional[typing.Iterable[global___Annotation]] = ...,
        request_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotations",b"annotations","request_id",b"request_id"]) -> None: ...
global___BatchCreateAnnotationsRequest = BatchCreateAnnotationsRequest

class BatchCreateAnnotationsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Entry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        STATUS_FIELD_NUMBER: builtins.int
        ANNOTATION_FIELD_NUMBER: builtins.int
        @property
        def status(self) -> google.rpc.status_pb2.Status:
            """The creation status."""
            pass
        @property
        def annotation(self) -> global___Annotation:
            """The created annotation, if creation was successful."""
            pass
        def __init__(self,
            *,
            status : typing.Optional[google.rpc.status_pb2.Status] = ...,
            annotation : typing.Optional[global___Annotation] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["annotation",b"annotation","status",b"status"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["annotation",b"annotation","status",b"status"]) -> None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BatchCreateAnnotationsResponse.Entry]:
        """The resulting per-annotation entries, ordered consistently with the
        original request.
        """
        pass
    def __init__(self,
        *,
        entries : typing.Optional[typing.Iterable[global___BatchCreateAnnotationsResponse.Entry]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["entries",b"entries"]) -> None: ...
global___BatchCreateAnnotationsResponse = BatchCreateAnnotationsResponse

class GetAnnotationRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATION_ID_FIELD_NUMBER: builtins.int
    annotation_id: typing.Text = ...
    """The ID of the annotation to be retrieved."""

    def __init__(self,
        *,
        annotation_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_id",b"annotation_id"]) -> None: ...
global___GetAnnotationRequest = GetAnnotationRequest

class UpdateAnnotationRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATION_ID_FIELD_NUMBER: builtins.int
    ANNOTATION_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    annotation_id: typing.Text = ...
    """The ID of the annotation to be updated."""

    @property
    def annotation(self) -> global___Annotation:
        """The new annotation."""
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """An optional mask specifying which fields to update. Mutable fields are
        [name][google.genomics.v1.Annotation.name],
        [variant][google.genomics.v1.Annotation.variant],
        [transcript][google.genomics.v1.Annotation.transcript], and
        [info][google.genomics.v1.Annotation.info]. If unspecified, all mutable
        fields will be updated.
        """
        pass
    def __init__(self,
        *,
        annotation_id : typing.Text = ...,
        annotation : typing.Optional[global___Annotation] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["annotation",b"annotation","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation",b"annotation","annotation_id",b"annotation_id","update_mask",b"update_mask"]) -> None: ...
global___UpdateAnnotationRequest = UpdateAnnotationRequest

class DeleteAnnotationRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATION_ID_FIELD_NUMBER: builtins.int
    annotation_id: typing.Text = ...
    """The ID of the annotation to be deleted."""

    def __init__(self,
        *,
        annotation_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_id",b"annotation_id"]) -> None: ...
global___DeleteAnnotationRequest = DeleteAnnotationRequest

class SearchAnnotationsRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATION_SET_IDS_FIELD_NUMBER: builtins.int
    REFERENCE_ID_FIELD_NUMBER: builtins.int
    REFERENCE_NAME_FIELD_NUMBER: builtins.int
    START_FIELD_NUMBER: builtins.int
    END_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    @property
    def annotation_set_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Required. The annotation sets to search within. The caller must have
        `READ` access to these annotation sets.
        All queried annotation sets must have the same type.
        """
        pass
    reference_id: typing.Text = ...
    """The ID of the reference to query."""

    reference_name: typing.Text = ...
    """The name of the reference to query, within the reference set associated
    with this query.
    """

    start: builtins.int = ...
    """The start position of the range on the reference, 0-based inclusive. If
    specified,
    [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
    [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
    must be specified. Defaults to 0.
    """

    end: builtins.int = ...
    """The end position of the range on the reference, 0-based exclusive. If
    [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
    [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
    must be specified, Defaults to the length of the reference.
    """

    page_token: typing.Text = ...
    """The continuation token, which is used to page through large result sets.
    To get the next page of results, set this parameter to the value of
    `nextPageToken` from the previous response.
    """

    page_size: builtins.int = ...
    """The maximum number of results to return in a single page. If unspecified,
    defaults to 256. The maximum value is 2048.
    """

    def __init__(self,
        *,
        annotation_set_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
        reference_id : typing.Text = ...,
        reference_name : typing.Text = ...,
        start : builtins.int = ...,
        end : builtins.int = ...,
        page_token : typing.Text = ...,
        page_size : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["reference",b"reference","reference_id",b"reference_id","reference_name",b"reference_name"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotation_set_ids",b"annotation_set_ids","end",b"end","page_size",b"page_size","page_token",b"page_token","reference",b"reference","reference_id",b"reference_id","reference_name",b"reference_name","start",b"start"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["reference",b"reference"]) -> typing.Optional[typing_extensions.Literal["reference_id","reference_name"]]: ...
global___SearchAnnotationsRequest = SearchAnnotationsRequest

class SearchAnnotationsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def annotations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Annotation]:
        """The matching annotations."""
        pass
    next_page_token: typing.Text = ...
    """The continuation token, which is used to page through large result sets.
    Provide this value in a subsequent request to return the next page of
    results. This field will be empty if there aren't any additional results.
    """

    def __init__(self,
        *,
        annotations : typing.Optional[typing.Iterable[global___Annotation]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["annotations",b"annotations","next_page_token",b"next_page_token"]) -> None: ...
global___SearchAnnotationsResponse = SearchAnnotationsResponse
