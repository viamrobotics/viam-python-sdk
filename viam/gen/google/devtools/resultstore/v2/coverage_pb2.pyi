"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class LineCoverage(google.protobuf.message.Message):
    """Describes line coverage for a file"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INSTRUMENTED_LINES_FIELD_NUMBER: builtins.int
    EXECUTED_LINES_FIELD_NUMBER: builtins.int
    instrumented_lines: builtins.bytes = ...
    """Which source lines in the file represent the start of a statement that was
    instrumented to detect whether it was executed by the test.

    This is a bitfield where i-th bit corresponds to the i-th line. Divide line
    number by 8 to get index into byte array. Mod line number by 8 to get bit
    number (0 = LSB, 7 = MSB).

    A 1 denotes the line was instrumented.
    A 0 denotes the line was not instrumented.
    """

    executed_lines: builtins.bytes = ...
    """Which of the instrumented source lines were executed by the test. Should
    include lines that were not instrumented.

    This is a bitfield where i-th bit corresponds to the i-th line. Divide line
    number by 8 to get index into byte array. Mod line number by 8 to get bit
    number (0 = LSB, 7 = MSB).

    A 1 denotes the line was executed.
    A 0 denotes the line was not executed.
    """

    def __init__(self,
        *,
        instrumented_lines : builtins.bytes = ...,
        executed_lines : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["executed_lines",b"executed_lines","instrumented_lines",b"instrumented_lines"]) -> None: ...
global___LineCoverage = LineCoverage

class BranchCoverage(google.protobuf.message.Message):
    """Describes branch coverage for a file"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    BRANCH_PRESENT_FIELD_NUMBER: builtins.int
    BRANCHES_IN_LINE_FIELD_NUMBER: builtins.int
    EXECUTED_FIELD_NUMBER: builtins.int
    TAKEN_FIELD_NUMBER: builtins.int
    branch_present: builtins.bytes = ...
    """The field branch_present denotes the lines containing at least one branch.

    This is a bitfield where i-th bit corresponds to the i-th line. Divide line
    number by 8 to get index into byte array. Mod line number by 8 to get bit
    number (0 = LSB, 7 = MSB).

    A 1 denotes the line contains at least one branch.
    A 0 denotes the line contains no branches.
    """

    @property
    def branches_in_line(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Contains the number of branches present, only for the lines which have the
        corresponding bit set in branch_present, in a relative order ignoring
        lines which do not have any branches.
        """
        pass
    executed: builtins.bytes = ...
    """As each branch can have any one of the following three states: not
    executed, executed but not taken, executed and taken.

    This is a bitfield where i-th bit corresponds to the i-th branch. Divide
    branch number by 8 to get index into byte array. Mod branch number by 8 to
    get bit number (0 = LSB, 7 = MSB).

    i-th bit of the following two byte arrays are used to denote the above
    mentioned states.

    not executed: i-th bit of executed == 0 && i-th bit of taken == 0
    executed but not taken: i-th bit of executed == 1 && i-th bit of taken == 0
    executed and taken: i-th bit of executed == 1 && i-th bit of taken == 1
    """

    taken: builtins.bytes = ...
    """Described above."""

    def __init__(self,
        *,
        branch_present : builtins.bytes = ...,
        branches_in_line : typing.Optional[typing.Iterable[builtins.int]] = ...,
        executed : builtins.bytes = ...,
        taken : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["branch_present",b"branch_present","branches_in_line",b"branches_in_line","executed",b"executed","taken",b"taken"]) -> None: ...
global___BranchCoverage = BranchCoverage

class FileCoverage(google.protobuf.message.Message):
    """Describes code coverage for a particular file under test."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PATH_FIELD_NUMBER: builtins.int
    LINE_COVERAGE_FIELD_NUMBER: builtins.int
    BRANCH_COVERAGE_FIELD_NUMBER: builtins.int
    path: typing.Text = ...
    """Path of source file within the SourceContext of this Invocation."""

    @property
    def line_coverage(self) -> global___LineCoverage:
        """Details of lines in a file for calculating line coverage."""
        pass
    @property
    def branch_coverage(self) -> global___BranchCoverage:
        """Details of branches in a file for calculating branch coverage."""
        pass
    def __init__(self,
        *,
        path : typing.Text = ...,
        line_coverage : typing.Optional[global___LineCoverage] = ...,
        branch_coverage : typing.Optional[global___BranchCoverage] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["branch_coverage",b"branch_coverage","line_coverage",b"line_coverage"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["branch_coverage",b"branch_coverage","line_coverage",b"line_coverage","path",b"path"]) -> None: ...
global___FileCoverage = FileCoverage

class ActionCoverage(google.protobuf.message.Message):
    """Describes code coverage for a build or test Action. This is used to store
    baseline coverage for build Actions and test coverage for test Actions.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FILE_COVERAGES_FIELD_NUMBER: builtins.int
    @property
    def file_coverages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FileCoverage]:
        """List of coverage info for all source files that the TestResult covers."""
        pass
    def __init__(self,
        *,
        file_coverages : typing.Optional[typing.Iterable[global___FileCoverage]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["file_coverages",b"file_coverages"]) -> None: ...
global___ActionCoverage = ActionCoverage

class AggregateCoverage(google.protobuf.message.Message):
    """Describes aggregate code coverage for a collection of build or test Actions.
    A line or branch is covered if and only if it is covered in any of the build
    or test actions.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FILE_COVERAGES_FIELD_NUMBER: builtins.int
    @property
    def file_coverages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FileCoverage]:
        """Aggregated coverage info for all source files that the actions cover."""
        pass
    def __init__(self,
        *,
        file_coverages : typing.Optional[typing.Iterable[global___FileCoverage]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["file_coverages",b"file_coverages"]) -> None: ...
global___AggregateCoverage = AggregateCoverage
