"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.devtools.resultstore.v2.action_pb2
import google.devtools.resultstore.v2.configuration_pb2
import google.devtools.resultstore.v2.configured_target_pb2
import google.devtools.resultstore.v2.file_set_pb2
import google.devtools.resultstore.v2.invocation_pb2
import google.devtools.resultstore.v2.target_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class GetInvocationRequest(google.protobuf.message.Message):
    """Request passed into GetInvocation"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the invocation to retrieve. It must match this format:
    invocations/${INVOCATION_ID}
    where INVOCATION_ID must be an RFC 4122-compliant UUID.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetInvocationRequest = GetInvocationRequest

class SearchInvocationsRequest(google.protobuf.message.Message):
    """Request passed into SearchInvocations"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    QUERY_FIELD_NUMBER: builtins.int
    PROJECT_ID_FIELD_NUMBER: builtins.int
    EXACT_MATCH_FIELD_NUMBER: builtins.int
    page_size: builtins.int = ...
    """The maximum number of items to return. Zero means all, but may be capped by
    the server.
    """

    page_token: typing.Text = ...
    """The next_page_token value returned from a previous Search request, if
    any.
    """

    offset: builtins.int = ...
    """Absolute number of results to skip. May be rejected if too high."""

    query: typing.Text = ...
    """A filtering query string.

    Only a limited number of fields and operators are supported. Not every
    field supports every operator.

    Fields that support equals ("=") restrictions:

    name
    status_attributes.status
    workspace_info.hostname

    Fields that support contains (":") restrictions:

    invocation_attributes.users
    invocation_attributes.labels

    Fields that support comparison ("<", "<=", ">", ">=") restrictions;

    timing.start_time

    Supported custom function global restrictions:

    propertyEquals("key", "value")
    """

    project_id: typing.Text = ...
    """The project id to search under."""

    exact_match: builtins.bool = ...
    """If true, all equals or contains restrictions on string fields in query will
    require exact match. Otherwise, a string field restriction may ignore case
    and punctuation.
    """

    def __init__(self,
        *,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        offset : builtins.int = ...,
        query : typing.Text = ...,
        project_id : typing.Text = ...,
        exact_match : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["offset",b"offset","page_start",b"page_start","page_token",b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["exact_match",b"exact_match","offset",b"offset","page_size",b"page_size","page_start",b"page_start","page_token",b"page_token","project_id",b"project_id","query",b"query"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["page_start",b"page_start"]) -> typing.Optional[typing_extensions.Literal["page_token","offset"]]: ...
global___SearchInvocationsRequest = SearchInvocationsRequest

class SearchInvocationsResponse(google.protobuf.message.Message):
    """Response from calling SearchInvocations"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INVOCATIONS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def invocations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.invocation_pb2.Invocation]:
        """Invocations matching the search, possibly capped at request.page_size or a
        server limit.
        """
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results, or empty if there are no
    more results.
    """

    def __init__(self,
        *,
        invocations : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.invocation_pb2.Invocation]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["invocations",b"invocations","next_page_token",b"next_page_token"]) -> None: ...
global___SearchInvocationsResponse = SearchInvocationsResponse

class ExportInvocationRequest(google.protobuf.message.Message):
    """Request passed into ExportInvocationRequest"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the invocation to retrieve. It must match this format:
    invocations/${INVOCATION_ID}
    where INVOCATION_ID must be an RFC 4122-compliant UUID.
    """

    page_size: builtins.int = ...
    """The maximum number of items to return. Zero means all, but may be capped by
    the server.
    """

    page_token: typing.Text = ...
    """The next_page_token value returned from a previous export request, if
    any.
    """

    offset: builtins.int = ...
    """Absolute number of results to skip."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        offset : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["offset",b"offset","page_start",b"page_start","page_token",b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name","offset",b"offset","page_size",b"page_size","page_start",b"page_start","page_token",b"page_token"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["page_start",b"page_start"]) -> typing.Optional[typing_extensions.Literal["page_token","offset"]]: ...
global___ExportInvocationRequest = ExportInvocationRequest

class ExportInvocationResponse(google.protobuf.message.Message):
    """Response from calling ExportInvocationResponse.
    Possibly capped at request.page_size or a server limit.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INVOCATION_FIELD_NUMBER: builtins.int
    TARGETS_FIELD_NUMBER: builtins.int
    CONFIGURATIONS_FIELD_NUMBER: builtins.int
    CONFIGURED_TARGETS_FIELD_NUMBER: builtins.int
    ACTIONS_FIELD_NUMBER: builtins.int
    FILE_SETS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def invocation(self) -> google.devtools.resultstore.v2.invocation_pb2.Invocation:
        """Parent Invocation resource."""
        pass
    @property
    def targets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.target_pb2.Target]:
        """Targets matching the request invocation."""
        pass
    @property
    def configurations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.configuration_pb2.Configuration]:
        """Configurations matching the request invocation."""
        pass
    @property
    def configured_targets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.configured_target_pb2.ConfiguredTarget]:
        """ConfiguredTargets matching the request invocation."""
        pass
    @property
    def actions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.action_pb2.Action]:
        """Actions matching the request invocation."""
        pass
    @property
    def file_sets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.file_set_pb2.FileSet]:
        """FileSets matching the request invocation."""
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results, or empty if there are no
    more results in the list.
    """

    def __init__(self,
        *,
        invocation : typing.Optional[google.devtools.resultstore.v2.invocation_pb2.Invocation] = ...,
        targets : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.target_pb2.Target]] = ...,
        configurations : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.configuration_pb2.Configuration]] = ...,
        configured_targets : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.configured_target_pb2.ConfiguredTarget]] = ...,
        actions : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.action_pb2.Action]] = ...,
        file_sets : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.file_set_pb2.FileSet]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["invocation",b"invocation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["actions",b"actions","configurations",b"configurations","configured_targets",b"configured_targets","file_sets",b"file_sets","invocation",b"invocation","next_page_token",b"next_page_token","targets",b"targets"]) -> None: ...
global___ExportInvocationResponse = ExportInvocationResponse

class GetInvocationDownloadMetadataRequest(google.protobuf.message.Message):
    """Request passed into GetInvocationDownloadMetadata"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the download metadata to retrieve. It must match this format:
    invocations/${INVOCATION_ID}/downloadMetadata
    where INVOCATION_ID must be an RFC 4122-compliant UUID.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetInvocationDownloadMetadataRequest = GetInvocationDownloadMetadataRequest

class GetConfigurationRequest(google.protobuf.message.Message):
    """Request passed into GetConfiguration"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the configuration to retrieve. It must match this format:
    invocations/${INVOCATION_ID}/configs/${CONFIGURATION_ID}
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetConfigurationRequest = GetConfigurationRequest

class ListConfigurationsRequest(google.protobuf.message.Message):
    """Request passed into ListConfigurations"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The invocation name of the configurations to retrieve.
    It must match this format: invocations/${INVOCATION_ID}
    """

    page_size: builtins.int = ...
    """The maximum number of items to return.
    Zero means all, but may be capped by the server.
    """

    page_token: typing.Text = ...
    """The next_page_token value returned from a previous List request, if any."""

    offset: builtins.int = ...
    """Absolute number of results to skip."""

    filter: typing.Text = ...
    """A filter to return only resources that match it.
    Any fields used in the filter must be also specified in the field mask.
    May cause pages with 0 results and a next_page_token to be returned.
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        offset : builtins.int = ...,
        filter : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["offset",b"offset","page_start",b"page_start","page_token",b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","offset",b"offset","page_size",b"page_size","page_start",b"page_start","page_token",b"page_token","parent",b"parent"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["page_start",b"page_start"]) -> typing.Optional[typing_extensions.Literal["page_token","offset"]]: ...
global___ListConfigurationsRequest = ListConfigurationsRequest

class ListConfigurationsResponse(google.protobuf.message.Message):
    """Response from calling ListConfigurations"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONFIGURATIONS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def configurations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.configuration_pb2.Configuration]:
        """Configurations matching the request invocation,
        possibly capped at request.page_size or a server limit.
        """
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results, or empty if there are no
    more results in the list.
    """

    def __init__(self,
        *,
        configurations : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.configuration_pb2.Configuration]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["configurations",b"configurations","next_page_token",b"next_page_token"]) -> None: ...
global___ListConfigurationsResponse = ListConfigurationsResponse

class GetTargetRequest(google.protobuf.message.Message):
    """Request passed into GetTarget"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the target to retrieve. It must match this format:
    invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetTargetRequest = GetTargetRequest

class ListTargetsRequest(google.protobuf.message.Message):
    """Request passed into ListTargets"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The invocation name of the targets to retrieve. It must match this format:
    invocations/${INVOCATION_ID}
    """

    page_size: builtins.int = ...
    """The maximum number of items to return.
    Zero means all, but may be capped by the server.
    """

    page_token: typing.Text = ...
    """The next_page_token value returned from a previous List request, if any."""

    offset: builtins.int = ...
    """Absolute number of results to skip."""

    filter: typing.Text = ...
    """A filter to return only resources that match it.
    Any fields used in the filter must be also specified in the field mask.
    May cause pages with 0 results and a next_page_token to be returned.
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        offset : builtins.int = ...,
        filter : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["offset",b"offset","page_start",b"page_start","page_token",b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","offset",b"offset","page_size",b"page_size","page_start",b"page_start","page_token",b"page_token","parent",b"parent"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["page_start",b"page_start"]) -> typing.Optional[typing_extensions.Literal["page_token","offset"]]: ...
global___ListTargetsRequest = ListTargetsRequest

class ListTargetsResponse(google.protobuf.message.Message):
    """Response from calling ListTargetsResponse"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TARGETS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def targets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.target_pb2.Target]:
        """Targets matching the request invocation,
        possibly capped at request.page_size or a server limit.
        """
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results, or empty if there are no
    more results in the list.
    """

    def __init__(self,
        *,
        targets : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.target_pb2.Target]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["next_page_token",b"next_page_token","targets",b"targets"]) -> None: ...
global___ListTargetsResponse = ListTargetsResponse

class GetConfiguredTargetRequest(google.protobuf.message.Message):
    """Request passed into GetConfiguredTarget"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the configured target to retrieve. It must match this format:
    invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIGURATION_ID}
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetConfiguredTargetRequest = GetConfiguredTargetRequest

class ListConfiguredTargetsRequest(google.protobuf.message.Message):
    """Request passed into ListConfiguredTargets"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The invocation and target name of the configured targets to retrieve.
    It must match this format:
    invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
    Supports '-' for ${TARGET_ID} meaning all targets.
    """

    page_size: builtins.int = ...
    """The maximum number of items to return.
    Zero means all, but may be capped by the server.
    """

    page_token: typing.Text = ...
    """The next_page_token value returned from a previous List request, if any."""

    offset: builtins.int = ...
    """Absolute number of results to skip."""

    filter: typing.Text = ...
    """A filter to return only resources that match it.
    Any fields used in the filter must be also specified in the field mask.
    May cause pages with 0 results and a next_page_token to be returned.
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        offset : builtins.int = ...,
        filter : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["offset",b"offset","page_start",b"page_start","page_token",b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","offset",b"offset","page_size",b"page_size","page_start",b"page_start","page_token",b"page_token","parent",b"parent"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["page_start",b"page_start"]) -> typing.Optional[typing_extensions.Literal["page_token","offset"]]: ...
global___ListConfiguredTargetsRequest = ListConfiguredTargetsRequest

class ListConfiguredTargetsResponse(google.protobuf.message.Message):
    """Response from calling ListConfiguredTargets"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONFIGURED_TARGETS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def configured_targets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.configured_target_pb2.ConfiguredTarget]:
        """ConfiguredTargets matching the request,
        possibly capped at request.page_size or a server limit.
        """
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results, or empty if there are no
    more results in the list.
    """

    def __init__(self,
        *,
        configured_targets : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.configured_target_pb2.ConfiguredTarget]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["configured_targets",b"configured_targets","next_page_token",b"next_page_token"]) -> None: ...
global___ListConfiguredTargetsResponse = ListConfiguredTargetsResponse

class SearchConfiguredTargetsRequest(google.protobuf.message.Message):
    """Request passed into SearchConfiguredTargets"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    QUERY_FIELD_NUMBER: builtins.int
    PROJECT_ID_FIELD_NUMBER: builtins.int
    EXACT_MATCH_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Must be set to invocations/-/targets/-
    This only supports searching all ConfiguredTargets across all Invocations.
    """

    page_size: builtins.int = ...
    """The maximum number of items to return. Zero means all, but may be capped by
    the server.
    """

    page_token: typing.Text = ...
    """The next_page_token value returned from a previous Search request, if
    any.
    """

    offset: builtins.int = ...
    """Absolute number of results to skip. May be rejected if too high."""

    query: typing.Text = ...
    """A filtering query string.

    Only a limited number of fields and operators are supported. Not every
    field supports every operator. Access to parent resources is provided
    via synthetic fields ‘invocation’, ‘configuration’, and ‘target’.

    Any search must contain an equals restriction on id.target_id.

    Fields that support equals ("=") restrictions:

    id.target_id
    status_attributes.status

    target.target_attributes.type
    target.target_attributes.language
    target.test_attributes.size

    configuration.configuration_attributes.cpu

    invocation.workspace_info.hostname

    Fields that support contains (":") restrictions:

    target.target_attributes.tags

    invocation.invocation_attributes.users
    invocation.invocation_attributes.labels

    Fields that support comparison ("<", "<=", ">", ">=") restrictions;

    timing.start_time

    Supported custom function global restrictions:

    invocationPropertyEquals("key", "value")
    targetPropertyEquals("key", "value")
    configurationPropertyEquals("key", "value")
    configuredTargetPropertyEquals("key", "value")
    """

    project_id: typing.Text = ...
    """The project id to search under."""

    exact_match: builtins.bool = ...
    """If true, all equals or contains restrictions on string fields in query will
    require exact match. Otherwise, a string field restriction may ignore case
    and punctuation.
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        offset : builtins.int = ...,
        query : typing.Text = ...,
        project_id : typing.Text = ...,
        exact_match : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["offset",b"offset","page_start",b"page_start","page_token",b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["exact_match",b"exact_match","offset",b"offset","page_size",b"page_size","page_start",b"page_start","page_token",b"page_token","parent",b"parent","project_id",b"project_id","query",b"query"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["page_start",b"page_start"]) -> typing.Optional[typing_extensions.Literal["page_token","offset"]]: ...
global___SearchConfiguredTargetsRequest = SearchConfiguredTargetsRequest

class SearchConfiguredTargetsResponse(google.protobuf.message.Message):
    """Response from calling SearchConfiguredTargets"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONFIGURED_TARGETS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def configured_targets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.configured_target_pb2.ConfiguredTarget]:
        """ConfiguredTargets matching the search, possibly capped at request.page_size
        or a server limit.
        """
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results, or empty if there are no
    more results.
    """

    def __init__(self,
        *,
        configured_targets : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.configured_target_pb2.ConfiguredTarget]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["configured_targets",b"configured_targets","next_page_token",b"next_page_token"]) -> None: ...
global___SearchConfiguredTargetsResponse = SearchConfiguredTargetsResponse

class GetActionRequest(google.protobuf.message.Message):
    """Request passed into GetAction"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the action to retrieve. It must match this format:
    invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIGURATION_ID}/actions/${ACTION_ID}
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetActionRequest = GetActionRequest

class ListActionsRequest(google.protobuf.message.Message):
    """Request passed into ListActions"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The invocation, target, and configuration name of the action to retrieve.
    It must match this format:
    invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIGURATION_ID}
    Supports '-' for ${CONFIGURATION_ID} to mean all Actions for all
    Configurations for a Target, or '-' for ${TARGET_ID} and
    ${CONFIGURATION_ID} to mean all Actions for all Configurations and all
    Targets. Does not support ${TARGET_ID} '-' with a specified configuration.
    """

    page_size: builtins.int = ...
    """The maximum number of items to return.
    Zero means all, but may be capped by the server.
    """

    page_token: typing.Text = ...
    """The next_page_token value returned from a previous List request, if any."""

    offset: builtins.int = ...
    """Absolute number of results to skip."""

    filter: typing.Text = ...
    """A filter to return only resources that match it.
    Any fields used in the filter must be also specified in the field mask.
    May cause pages with 0 results and a next_page_token to be returned.
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        offset : builtins.int = ...,
        filter : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["offset",b"offset","page_start",b"page_start","page_token",b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","offset",b"offset","page_size",b"page_size","page_start",b"page_start","page_token",b"page_token","parent",b"parent"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["page_start",b"page_start"]) -> typing.Optional[typing_extensions.Literal["page_token","offset"]]: ...
global___ListActionsRequest = ListActionsRequest

class ListActionsResponse(google.protobuf.message.Message):
    """Response from calling ListActions"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ACTIONS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def actions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.action_pb2.Action]:
        """Actions matching the request,
        possibly capped at request.page_size or a server limit.
        """
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results, or empty if there are no
    more results in the list.
    """

    def __init__(self,
        *,
        actions : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.action_pb2.Action]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["actions",b"actions","next_page_token",b"next_page_token"]) -> None: ...
global___ListActionsResponse = ListActionsResponse

class BatchListActionsRequest(google.protobuf.message.Message):
    """Request passed into BatchListActionsRequest"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    CONFIGURED_TARGETS_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The invocation name of the actions to retrieve. It must match this format:
    invocations/${INVOCATION_ID}
    """

    @property
    def configured_targets(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The names of the configured targets to retrieve.
        It must match this format:
        invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIGURATION_ID}
        """
        pass
    page_size: builtins.int = ...
    """The maximum number of items to return.
    Zero means all, but may be capped by the server.
    """

    page_token: typing.Text = ...
    """The next_page_token value returned from a previous List request, if any.
    Page tokens will become larger with every page returned, and if a page
    token becomes too large, it will no longer be possible to continue to
    calculate the transitive dependencies. The API will return a 400
    Bad request (HTTPS), or a INVALID_ARGUMENT (gRPC ) when
    this happens.
    """

    offset: builtins.int = ...
    """Absolute number of results to skip.
    Not yet implemented. 0 for default.
    """

    filter: typing.Text = ...
    """A filter to return only resources that match it.
    Any fields used in the filter must be also specified in the field mask.
    May cause pages with 0 results and a next_page_token to be returned.
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        configured_targets : typing.Optional[typing.Iterable[typing.Text]] = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        offset : builtins.int = ...,
        filter : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["offset",b"offset","page_start",b"page_start","page_token",b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["configured_targets",b"configured_targets","filter",b"filter","offset",b"offset","page_size",b"page_size","page_start",b"page_start","page_token",b"page_token","parent",b"parent"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["page_start",b"page_start"]) -> typing.Optional[typing_extensions.Literal["page_token","offset"]]: ...
global___BatchListActionsRequest = BatchListActionsRequest

class BatchListActionsResponse(google.protobuf.message.Message):
    """Response from calling BatchListActionsResponse"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ACTIONS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    NOT_FOUND_FIELD_NUMBER: builtins.int
    @property
    def actions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.action_pb2.Action]:
        """Actions matching the request,
        possibly capped at request.page_size or a server limit.
        """
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results, or empty if there are no
    more results in the list.
    """

    @property
    def not_found(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Not found configured target names."""
        pass
    def __init__(self,
        *,
        actions : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.action_pb2.Action]] = ...,
        next_page_token : typing.Text = ...,
        not_found : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["actions",b"actions","next_page_token",b"next_page_token","not_found",b"not_found"]) -> None: ...
global___BatchListActionsResponse = BatchListActionsResponse

class GetFileSetRequest(google.protobuf.message.Message):
    """Request passed into GetFileSet"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the file set to retrieve. It must match this format:
    invocations/${INVOCATION_ID}/fileSets/${FILE_SET_ID}
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetFileSetRequest = GetFileSetRequest

class ListFileSetsRequest(google.protobuf.message.Message):
    """Request passed into ListFileSets"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The invocation name of the file sets to retrieve.
    It must match this format: invocations/${INVOCATION_ID}
    """

    page_size: builtins.int = ...
    """The maximum number of items to return.
    Zero means all, but may be capped by the server.
    """

    page_token: typing.Text = ...
    """The next_page_token value returned from a previous List request, if any."""

    offset: builtins.int = ...
    """Absolute number of results to skip."""

    filter: typing.Text = ...
    """A filter to return only resources that match it.
    Any fields used in the filter must be also specified in the field mask.
    May cause pages with 0 results and a next_page_token to be returned.
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        offset : builtins.int = ...,
        filter : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["offset",b"offset","page_start",b"page_start","page_token",b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","offset",b"offset","page_size",b"page_size","page_start",b"page_start","page_token",b"page_token","parent",b"parent"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["page_start",b"page_start"]) -> typing.Optional[typing_extensions.Literal["page_token","offset"]]: ...
global___ListFileSetsRequest = ListFileSetsRequest

class ListFileSetsResponse(google.protobuf.message.Message):
    """Response from calling ListFileSets"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FILE_SETS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def file_sets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.file_set_pb2.FileSet]:
        """File sets matching the request,
        possibly capped at request.page_size or a server limit.
        """
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results, or empty if there are no
    more results in the list.
    """

    def __init__(self,
        *,
        file_sets : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.file_set_pb2.FileSet]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["file_sets",b"file_sets","next_page_token",b"next_page_token"]) -> None: ...
global___ListFileSetsResponse = ListFileSetsResponse

class TraverseFileSetsRequest(google.protobuf.message.Message):
    """Request passed into TraverseFileSets"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the resource to traverse.
    It must match one of the following formats:

    invocations/${INVOCATION_ID}/fileSets/${FILE_SET_ID}
    This returns the transitive closure of FileSets referenced by the given
    FileSet, including itself.

    invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${CONFIGURATION_ID}/actions/${ACTION_ID}
    This returns the transitive closure of FileSets referenced by the given
    Action. If ${ACTION_ID} is "-", this returns the transitive closure of
    FileSets referenced by all Actions under the given ConfiguredTarget.
    """

    page_size: builtins.int = ...
    """The maximum number of items to return.
    Zero means all, but may be capped by the server.
    """

    page_token: typing.Text = ...
    """The next_page_token value returned from a previous List request, if any.
    Page tokens will become larger with every page returned, and if a page
    token becomes too large, it will no longer be possible to continue to
    calculate the transitive dependencies. The API will return a 400
    Bad request (HTTPS), or a INVALID_ARGUMENT (gRPC ) when
    this happens.
    """

    offset: builtins.int = ...
    """Absolute number of results to skip.
    Not yet implemented. 0 for default.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        offset : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["offset",b"offset","page_start",b"page_start","page_token",b"page_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name","offset",b"offset","page_size",b"page_size","page_start",b"page_start","page_token",b"page_token"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["page_start",b"page_start"]) -> typing.Optional[typing_extensions.Literal["page_token","offset"]]: ...
global___TraverseFileSetsRequest = TraverseFileSetsRequest

class TraverseFileSetsResponse(google.protobuf.message.Message):
    """Response from calling TraverseFileSets"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FILE_SETS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def file_sets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.devtools.resultstore.v2.file_set_pb2.FileSet]:
        """File sets matching the request.
        The order in which results are returned is undefined, but stable.
        """
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results, or empty if there are no
    more results in the list.
    """

    def __init__(self,
        *,
        file_sets : typing.Optional[typing.Iterable[google.devtools.resultstore.v2.file_set_pb2.FileSet]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["file_sets",b"file_sets","next_page_token",b"next_page_token"]) -> None: ...
global___TraverseFileSetsResponse = TraverseFileSetsResponse
