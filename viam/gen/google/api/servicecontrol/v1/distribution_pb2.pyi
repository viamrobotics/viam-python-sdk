"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.api.distribution_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Distribution(google.protobuf.message.Message):
    """Distribution represents a frequency distribution of double-valued sample
    points. It contains the size of the population of sample points plus
    additional optional information:

    * the arithmetic mean of the samples
    * the minimum and maximum of the samples
    * the sum-squared-deviation of the samples, used to compute variance
    * a histogram of the values of the sample points
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LinearBuckets(google.protobuf.message.Message):
        """Describing buckets with constant width."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        NUM_FINITE_BUCKETS_FIELD_NUMBER: builtins.int
        WIDTH_FIELD_NUMBER: builtins.int
        OFFSET_FIELD_NUMBER: builtins.int
        num_finite_buckets: builtins.int = ...
        """The number of finite buckets. With the underflow and overflow buckets,
        the total number of buckets is `num_finite_buckets` + 2.
        See comments on `bucket_options` for details.
        """

        width: builtins.float = ...
        """The i'th linear bucket covers the interval
          [offset + (i-1) * width, offset + i * width)
        where i ranges from 1 to num_finite_buckets, inclusive.
        Must be strictly positive.
        """

        offset: builtins.float = ...
        """The i'th linear bucket covers the interval
          [offset + (i-1) * width, offset + i * width)
        where i ranges from 1 to num_finite_buckets, inclusive.
        """

        def __init__(self,
            *,
            num_finite_buckets : builtins.int = ...,
            width : builtins.float = ...,
            offset : builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["num_finite_buckets",b"num_finite_buckets","offset",b"offset","width",b"width"]) -> None: ...

    class ExponentialBuckets(google.protobuf.message.Message):
        """Describing buckets with exponentially growing width."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        NUM_FINITE_BUCKETS_FIELD_NUMBER: builtins.int
        GROWTH_FACTOR_FIELD_NUMBER: builtins.int
        SCALE_FIELD_NUMBER: builtins.int
        num_finite_buckets: builtins.int = ...
        """The number of finite buckets. With the underflow and overflow buckets,
        the total number of buckets is `num_finite_buckets` + 2.
        See comments on `bucket_options` for details.
        """

        growth_factor: builtins.float = ...
        """The i'th exponential bucket covers the interval
          [scale * growth_factor^(i-1), scale * growth_factor^i)
        where i ranges from 1 to num_finite_buckets inclusive.
        Must be larger than 1.0.
        """

        scale: builtins.float = ...
        """The i'th exponential bucket covers the interval
          [scale * growth_factor^(i-1), scale * growth_factor^i)
        where i ranges from 1 to num_finite_buckets inclusive.
        Must be > 0.
        """

        def __init__(self,
            *,
            num_finite_buckets : builtins.int = ...,
            growth_factor : builtins.float = ...,
            scale : builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["growth_factor",b"growth_factor","num_finite_buckets",b"num_finite_buckets","scale",b"scale"]) -> None: ...

    class ExplicitBuckets(google.protobuf.message.Message):
        """Describing buckets with arbitrary user-provided width."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        BOUNDS_FIELD_NUMBER: builtins.int
        @property
        def bounds(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
            """'bound' is a list of strictly increasing boundaries between
            buckets. Note that a list of length N-1 defines N buckets because
            of fenceposting. See comments on `bucket_options` for details.

            The i'th finite bucket covers the interval
              [bound[i-1], bound[i])
            where i ranges from 1 to bound_size() - 1. Note that there are no
            finite buckets at all if 'bound' only contains a single element; in
            that special case the single bound defines the boundary between the
            underflow and overflow buckets.

            bucket number                   lower bound    upper bound
             i == 0 (underflow)              -inf           bound[i]
             0 < i < bound_size()            bound[i-1]     bound[i]
             i == bound_size() (overflow)    bound[i-1]     +inf
            """
            pass
        def __init__(self,
            *,
            bounds : typing.Optional[typing.Iterable[builtins.float]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["bounds",b"bounds"]) -> None: ...

    COUNT_FIELD_NUMBER: builtins.int
    MEAN_FIELD_NUMBER: builtins.int
    MINIMUM_FIELD_NUMBER: builtins.int
    MAXIMUM_FIELD_NUMBER: builtins.int
    SUM_OF_SQUARED_DEVIATION_FIELD_NUMBER: builtins.int
    BUCKET_COUNTS_FIELD_NUMBER: builtins.int
    LINEAR_BUCKETS_FIELD_NUMBER: builtins.int
    EXPONENTIAL_BUCKETS_FIELD_NUMBER: builtins.int
    EXPLICIT_BUCKETS_FIELD_NUMBER: builtins.int
    EXEMPLARS_FIELD_NUMBER: builtins.int
    count: builtins.int = ...
    """The total number of samples in the distribution. Must be >= 0."""

    mean: builtins.float = ...
    """The arithmetic mean of the samples in the distribution. If `count` is
    zero then this field must be zero.
    """

    minimum: builtins.float = ...
    """The minimum of the population of values. Ignored if `count` is zero."""

    maximum: builtins.float = ...
    """The maximum of the population of values. Ignored if `count` is zero."""

    sum_of_squared_deviation: builtins.float = ...
    """The sum of squared deviations from the mean:
      Sum[i=1..count]((x_i - mean)^2)
    where each x_i is a sample values. If `count` is zero then this field
    must be zero, otherwise validation of the request fails.
    """

    @property
    def bucket_counts(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The number of samples in each histogram bucket. `bucket_counts` are
        optional. If present, they must sum to the `count` value.

        The buckets are defined below in `bucket_option`. There are N buckets.
        `bucket_counts[0]` is the number of samples in the underflow bucket.
        `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
        in each of the finite buckets. And `bucket_counts[N] is the number
        of samples in the overflow bucket. See the comments of `bucket_option`
        below for more details.

        Any suffix of trailing zeros may be omitted.
        """
        pass
    @property
    def linear_buckets(self) -> global___Distribution.LinearBuckets:
        """Buckets with constant width."""
        pass
    @property
    def exponential_buckets(self) -> global___Distribution.ExponentialBuckets:
        """Buckets with exponentially growing width."""
        pass
    @property
    def explicit_buckets(self) -> global___Distribution.ExplicitBuckets:
        """Buckets with arbitrary user-provided width."""
        pass
    @property
    def exemplars(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.api.distribution_pb2.Distribution.Exemplar]:
        """Example points. Must be in increasing order of `value` field."""
        pass
    def __init__(self,
        *,
        count : builtins.int = ...,
        mean : builtins.float = ...,
        minimum : builtins.float = ...,
        maximum : builtins.float = ...,
        sum_of_squared_deviation : builtins.float = ...,
        bucket_counts : typing.Optional[typing.Iterable[builtins.int]] = ...,
        linear_buckets : typing.Optional[global___Distribution.LinearBuckets] = ...,
        exponential_buckets : typing.Optional[global___Distribution.ExponentialBuckets] = ...,
        explicit_buckets : typing.Optional[global___Distribution.ExplicitBuckets] = ...,
        exemplars : typing.Optional[typing.Iterable[google.api.distribution_pb2.Distribution.Exemplar]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bucket_option",b"bucket_option","explicit_buckets",b"explicit_buckets","exponential_buckets",b"exponential_buckets","linear_buckets",b"linear_buckets"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bucket_counts",b"bucket_counts","bucket_option",b"bucket_option","count",b"count","exemplars",b"exemplars","explicit_buckets",b"explicit_buckets","exponential_buckets",b"exponential_buckets","linear_buckets",b"linear_buckets","maximum",b"maximum","mean",b"mean","minimum",b"minimum","sum_of_squared_deviation",b"sum_of_squared_deviation"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["bucket_option",b"bucket_option"]) -> typing.Optional[typing_extensions.Literal["linear_buckets","exponential_buckets","explicit_buckets"]]: ...
global___Distribution = Distribution
