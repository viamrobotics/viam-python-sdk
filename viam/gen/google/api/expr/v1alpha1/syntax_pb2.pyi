"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.message
import google.protobuf.struct_pb2
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class ParsedExpr(google.protobuf.message.Message):
    """A representation of the abstract syntax of the Common Expression Language.

    An expression together with source information as returned by the parser.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXPR_FIELD_NUMBER: builtins.int
    SOURCE_INFO_FIELD_NUMBER: builtins.int
    @property
    def expr(self) -> global___Expr:
        """The parsed expression."""
        pass
    @property
    def source_info(self) -> global___SourceInfo:
        """The source info derived from input that generated the parsed `expr`."""
        pass
    def __init__(self,
        *,
        expr : typing.Optional[global___Expr] = ...,
        source_info : typing.Optional[global___SourceInfo] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["expr",b"expr","source_info",b"source_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["expr",b"expr","source_info",b"source_info"]) -> None: ...
global___ParsedExpr = ParsedExpr

class Expr(google.protobuf.message.Message):
    """An abstract representation of a common expression.

    Expressions are abstractly represented as a collection of identifiers,
    select statements, function calls, literals, and comprehensions. All
    operators with the exception of the '.' operator are modelled as function
    calls. This makes it easy to represent new operators into the existing AST.

    All references within expressions must resolve to a [Decl][google.api.expr.v1alpha1.Decl] provided at
    type-check for an expression to be valid. A reference may either be a bare
    identifier `name` or a qualified identifier `google.api.name`. References
    may either refer to a value or a function declaration.

    For example, the expression `google.api.name.startsWith('expr')` references
    the declaration `google.api.name` within a [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and
    the function declaration `startsWith`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Ident(google.protobuf.message.Message):
        """An identifier expression. e.g. `request`."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        NAME_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        """Required. Holds a single, unqualified identifier, possibly preceded by a
        '.'.

        Qualified names are represented by the [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression.
        """

        def __init__(self,
            *,
            name : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...

    class Select(google.protobuf.message.Message):
        """A field selection expression. e.g. `request.auth`."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        OPERAND_FIELD_NUMBER: builtins.int
        FIELD_FIELD_NUMBER: builtins.int
        TEST_ONLY_FIELD_NUMBER: builtins.int
        @property
        def operand(self) -> global___Expr:
            """Required. The target of the selection expression.

            For example, in the select expression `request.auth`, the `request`
            portion of the expression is the `operand`.
            """
            pass
        field: typing.Text = ...
        """Required. The name of the field to select.

        For example, in the select expression `request.auth`, the `auth` portion
        of the expression would be the `field`.
        """

        test_only: builtins.bool = ...
        """Whether the select is to be interpreted as a field presence test.

        This results from the macro `has(request.auth)`.
        """

        def __init__(self,
            *,
            operand : typing.Optional[global___Expr] = ...,
            field : typing.Text = ...,
            test_only : builtins.bool = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["operand",b"operand"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["field",b"field","operand",b"operand","test_only",b"test_only"]) -> None: ...

    class Call(google.protobuf.message.Message):
        """A call expression, including calls to predefined functions and operators.

        For example, `value == 10`, `size(map_value)`.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TARGET_FIELD_NUMBER: builtins.int
        FUNCTION_FIELD_NUMBER: builtins.int
        ARGS_FIELD_NUMBER: builtins.int
        @property
        def target(self) -> global___Expr:
            """The target of an method call-style expression. For example, `x` in
            `x.f()`.
            """
            pass
        function: typing.Text = ...
        """Required. The name of the function or method being called."""

        @property
        def args(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expr]:
            """The arguments."""
            pass
        def __init__(self,
            *,
            target : typing.Optional[global___Expr] = ...,
            function : typing.Text = ...,
            args : typing.Optional[typing.Iterable[global___Expr]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["target",b"target"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["args",b"args","function",b"function","target",b"target"]) -> None: ...

    class CreateList(google.protobuf.message.Message):
        """A list creation expression.

        Lists may either be homogenous, e.g. `[1, 2, 3]`, or heterogeneous, e.g.
        `dyn([1, 'hello', 2.0])`
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        ELEMENTS_FIELD_NUMBER: builtins.int
        @property
        def elements(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expr]:
            """The elements part of the list."""
            pass
        def __init__(self,
            *,
            elements : typing.Optional[typing.Iterable[global___Expr]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["elements",b"elements"]) -> None: ...

    class CreateStruct(google.protobuf.message.Message):
        """A map or message creation expression.

        Maps are constructed as `{'key_name': 'value'}`. Message construction is
        similar, but prefixed with a type name and composed of field ids:
        `types.MyType{field_id: 'value'}`.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Entry(google.protobuf.message.Message):
            """Represents an entry."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            ID_FIELD_NUMBER: builtins.int
            FIELD_KEY_FIELD_NUMBER: builtins.int
            MAP_KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            id: builtins.int = ...
            """Required. An id assigned to this node by the parser which is unique
            in a given expression tree. This is used to associate type
            information and other attributes to the node.
            """

            field_key: typing.Text = ...
            """The field key for a message creator statement."""

            @property
            def map_key(self) -> global___Expr:
                """The key expression for a map creation statement."""
                pass
            @property
            def value(self) -> global___Expr:
                """Required. The value assigned to the key."""
                pass
            def __init__(self,
                *,
                id : builtins.int = ...,
                field_key : typing.Text = ...,
                map_key : typing.Optional[global___Expr] = ...,
                value : typing.Optional[global___Expr] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["field_key",b"field_key","key_kind",b"key_kind","map_key",b"map_key","value",b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["field_key",b"field_key","id",b"id","key_kind",b"key_kind","map_key",b"map_key","value",b"value"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["key_kind",b"key_kind"]) -> typing.Optional[typing_extensions.Literal["field_key","map_key"]]: ...

        MESSAGE_NAME_FIELD_NUMBER: builtins.int
        ENTRIES_FIELD_NUMBER: builtins.int
        message_name: typing.Text = ...
        """The type name of the message to be created, empty when creating map
        literals.
        """

        @property
        def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Expr.CreateStruct.Entry]:
            """The entries in the creation expression."""
            pass
        def __init__(self,
            *,
            message_name : typing.Text = ...,
            entries : typing.Optional[typing.Iterable[global___Expr.CreateStruct.Entry]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["entries",b"entries","message_name",b"message_name"]) -> None: ...

    class Comprehension(google.protobuf.message.Message):
        """A comprehension expression applied to a list or map.

        Comprehensions are not part of the core syntax, but enabled with macros.
        A macro matches a specific call signature within a parsed AST and replaces
        the call with an alternate AST block. Macro expansion happens at parse
        time.

        The following macros are supported within CEL:

        Aggregate type macros may be applied to all elements in a list or all keys
        in a map:

        *  `all`, `exists`, `exists_one` -  test a predicate expression against
           the inputs and return `true` if the predicate is satisfied for all,
           any, or only one value `list.all(x, x < 10)`.
        *  `filter` - test a predicate expression against the inputs and return
           the subset of elements which satisfy the predicate:
           `payments.filter(p, p > 1000)`.
        *  `map` - apply an expression to all elements in the input and return the
           output aggregate type: `[1, 2, 3].map(i, i * i)`.

        The `has(m.x)` macro tests whether the property `x` is present in struct
        `m`. The semantics of this macro depend on the type of `m`. For proto2
        messages `has(m.x)` is defined as 'defined, but not set`. For proto3, the
        macro tests whether the property is set to its default. For map and struct
        types, the macro tests whether the property `x` is defined on `m`.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        ITER_VAR_FIELD_NUMBER: builtins.int
        ITER_RANGE_FIELD_NUMBER: builtins.int
        ACCU_VAR_FIELD_NUMBER: builtins.int
        ACCU_INIT_FIELD_NUMBER: builtins.int
        LOOP_CONDITION_FIELD_NUMBER: builtins.int
        LOOP_STEP_FIELD_NUMBER: builtins.int
        RESULT_FIELD_NUMBER: builtins.int
        iter_var: typing.Text = ...
        """The name of the iteration variable."""

        @property
        def iter_range(self) -> global___Expr:
            """The range over which var iterates."""
            pass
        accu_var: typing.Text = ...
        """The name of the variable used for accumulation of the result."""

        @property
        def accu_init(self) -> global___Expr:
            """The initial value of the accumulator."""
            pass
        @property
        def loop_condition(self) -> global___Expr:
            """An expression which can contain iter_var and accu_var.

            Returns false when the result has been computed and may be used as
            a hint to short-circuit the remainder of the comprehension.
            """
            pass
        @property
        def loop_step(self) -> global___Expr:
            """An expression which can contain iter_var and accu_var.

            Computes the next value of accu_var.
            """
            pass
        @property
        def result(self) -> global___Expr:
            """An expression which can contain accu_var.

            Computes the result.
            """
            pass
        def __init__(self,
            *,
            iter_var : typing.Text = ...,
            iter_range : typing.Optional[global___Expr] = ...,
            accu_var : typing.Text = ...,
            accu_init : typing.Optional[global___Expr] = ...,
            loop_condition : typing.Optional[global___Expr] = ...,
            loop_step : typing.Optional[global___Expr] = ...,
            result : typing.Optional[global___Expr] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["accu_init",b"accu_init","iter_range",b"iter_range","loop_condition",b"loop_condition","loop_step",b"loop_step","result",b"result"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["accu_init",b"accu_init","accu_var",b"accu_var","iter_range",b"iter_range","iter_var",b"iter_var","loop_condition",b"loop_condition","loop_step",b"loop_step","result",b"result"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    CONST_EXPR_FIELD_NUMBER: builtins.int
    IDENT_EXPR_FIELD_NUMBER: builtins.int
    SELECT_EXPR_FIELD_NUMBER: builtins.int
    CALL_EXPR_FIELD_NUMBER: builtins.int
    LIST_EXPR_FIELD_NUMBER: builtins.int
    STRUCT_EXPR_FIELD_NUMBER: builtins.int
    COMPREHENSION_EXPR_FIELD_NUMBER: builtins.int
    id: builtins.int = ...
    """Required. An id assigned to this node by the parser which is unique in a
    given expression tree. This is used to associate type information and other
    attributes to a node in the parse tree.
    """

    @property
    def const_expr(self) -> global___Constant:
        """A literal expression."""
        pass
    @property
    def ident_expr(self) -> global___Expr.Ident:
        """An identifier expression."""
        pass
    @property
    def select_expr(self) -> global___Expr.Select:
        """A field selection expression, e.g. `request.auth`."""
        pass
    @property
    def call_expr(self) -> global___Expr.Call:
        """A call expression, including calls to predefined functions and operators."""
        pass
    @property
    def list_expr(self) -> global___Expr.CreateList:
        """A list creation expression."""
        pass
    @property
    def struct_expr(self) -> global___Expr.CreateStruct:
        """A map or message creation expression."""
        pass
    @property
    def comprehension_expr(self) -> global___Expr.Comprehension:
        """A comprehension expression."""
        pass
    def __init__(self,
        *,
        id : builtins.int = ...,
        const_expr : typing.Optional[global___Constant] = ...,
        ident_expr : typing.Optional[global___Expr.Ident] = ...,
        select_expr : typing.Optional[global___Expr.Select] = ...,
        call_expr : typing.Optional[global___Expr.Call] = ...,
        list_expr : typing.Optional[global___Expr.CreateList] = ...,
        struct_expr : typing.Optional[global___Expr.CreateStruct] = ...,
        comprehension_expr : typing.Optional[global___Expr.Comprehension] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["call_expr",b"call_expr","comprehension_expr",b"comprehension_expr","const_expr",b"const_expr","expr_kind",b"expr_kind","ident_expr",b"ident_expr","list_expr",b"list_expr","select_expr",b"select_expr","struct_expr",b"struct_expr"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["call_expr",b"call_expr","comprehension_expr",b"comprehension_expr","const_expr",b"const_expr","expr_kind",b"expr_kind","id",b"id","ident_expr",b"ident_expr","list_expr",b"list_expr","select_expr",b"select_expr","struct_expr",b"struct_expr"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["expr_kind",b"expr_kind"]) -> typing.Optional[typing_extensions.Literal["const_expr","ident_expr","select_expr","call_expr","list_expr","struct_expr","comprehension_expr"]]: ...
global___Expr = Expr

class Constant(google.protobuf.message.Message):
    """Represents a primitive literal.

    Named 'Constant' here for backwards compatibility.

    This is similar as the primitives supported in the well-known type
    `google.protobuf.Value`, but richer so it can represent CEL's full range of
    primitives.

    Lists and structs are not included as constants as these aggregate types may
    contain [Expr][google.api.expr.v1alpha1.Expr] elements which require evaluation and are thus not constant.

    Examples of literals include: `"hello"`, `b'bytes'`, `1u`, `4.2`, `-2`,
    `true`, `null`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NULL_VALUE_FIELD_NUMBER: builtins.int
    BOOL_VALUE_FIELD_NUMBER: builtins.int
    INT64_VALUE_FIELD_NUMBER: builtins.int
    UINT64_VALUE_FIELD_NUMBER: builtins.int
    DOUBLE_VALUE_FIELD_NUMBER: builtins.int
    STRING_VALUE_FIELD_NUMBER: builtins.int
    BYTES_VALUE_FIELD_NUMBER: builtins.int
    DURATION_VALUE_FIELD_NUMBER: builtins.int
    TIMESTAMP_VALUE_FIELD_NUMBER: builtins.int
    null_value: google.protobuf.struct_pb2.NullValue.ValueType = ...
    """null value."""

    bool_value: builtins.bool = ...
    """boolean value."""

    int64_value: builtins.int = ...
    """int64 value."""

    uint64_value: builtins.int = ...
    """uint64 value."""

    double_value: builtins.float = ...
    """double value."""

    string_value: typing.Text = ...
    """string value."""

    bytes_value: builtins.bytes = ...
    """bytes value."""

    @property
    def duration_value(self) -> google.protobuf.duration_pb2.Duration:
        """protobuf.Duration value.

        Deprecated: duration is no longer considered a builtin cel type.
        """
        pass
    @property
    def timestamp_value(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """protobuf.Timestamp value.

        Deprecated: timestamp is no longer considered a builtin cel type.
        """
        pass
    def __init__(self,
        *,
        null_value : google.protobuf.struct_pb2.NullValue.ValueType = ...,
        bool_value : builtins.bool = ...,
        int64_value : builtins.int = ...,
        uint64_value : builtins.int = ...,
        double_value : builtins.float = ...,
        string_value : typing.Text = ...,
        bytes_value : builtins.bytes = ...,
        duration_value : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        timestamp_value : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bool_value",b"bool_value","bytes_value",b"bytes_value","constant_kind",b"constant_kind","double_value",b"double_value","duration_value",b"duration_value","int64_value",b"int64_value","null_value",b"null_value","string_value",b"string_value","timestamp_value",b"timestamp_value","uint64_value",b"uint64_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bool_value",b"bool_value","bytes_value",b"bytes_value","constant_kind",b"constant_kind","double_value",b"double_value","duration_value",b"duration_value","int64_value",b"int64_value","null_value",b"null_value","string_value",b"string_value","timestamp_value",b"timestamp_value","uint64_value",b"uint64_value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["constant_kind",b"constant_kind"]) -> typing.Optional[typing_extensions.Literal["null_value","bool_value","int64_value","uint64_value","double_value","string_value","bytes_value","duration_value","timestamp_value"]]: ...
global___Constant = Constant

class SourceInfo(google.protobuf.message.Message):
    """Source information collected at parse time."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class PositionsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int = ...
        value: builtins.int = ...
        def __init__(self,
            *,
            key : builtins.int = ...,
            value : builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class MacroCallsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int = ...
        @property
        def value(self) -> global___Expr: ...
        def __init__(self,
            *,
            key : builtins.int = ...,
            value : typing.Optional[global___Expr] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    SYNTAX_VERSION_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    LINE_OFFSETS_FIELD_NUMBER: builtins.int
    POSITIONS_FIELD_NUMBER: builtins.int
    MACRO_CALLS_FIELD_NUMBER: builtins.int
    syntax_version: typing.Text = ...
    """The syntax version of the source, e.g. `cel1`."""

    location: typing.Text = ...
    """The location name. All position information attached to an expression is
    relative to this location.

    The location could be a file, UI element, or similar. For example,
    `acme/app/AnvilPolicy.cel`.
    """

    @property
    def line_offsets(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Monotonically increasing list of code point offsets where newlines
        `\\n` appear.

        The line number of a given position is the index `i` where for a given
        `id` the `line_offsets[i] < id_positions[id] < line_offsets[i+1]`. The
        column may be derivd from `id_positions[id] - line_offsets[i]`.
        """
        pass
    @property
    def positions(self) -> google.protobuf.internal.containers.ScalarMap[builtins.int, builtins.int]:
        """A map from the parse node id (e.g. `Expr.id`) to the code point offset
        within the source.
        """
        pass
    @property
    def macro_calls(self) -> google.protobuf.internal.containers.MessageMap[builtins.int, global___Expr]:
        """A map from the parse node id where a macro replacement was made to the
        call `Expr` that resulted in a macro expansion.

        For example, `has(value.field)` is a function call that is replaced by a
        `test_only` field selection in the AST. Likewise, the call
        `list.exists(e, e > 10)` translates to a comprehension expression. The key
        in the map corresponds to the expression id of the expanded macro, and the
        value is the call `Expr` that was replaced.
        """
        pass
    def __init__(self,
        *,
        syntax_version : typing.Text = ...,
        location : typing.Text = ...,
        line_offsets : typing.Optional[typing.Iterable[builtins.int]] = ...,
        positions : typing.Optional[typing.Mapping[builtins.int, builtins.int]] = ...,
        macro_calls : typing.Optional[typing.Mapping[builtins.int, global___Expr]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["line_offsets",b"line_offsets","location",b"location","macro_calls",b"macro_calls","positions",b"positions","syntax_version",b"syntax_version"]) -> None: ...
global___SourceInfo = SourceInfo

class SourcePosition(google.protobuf.message.Message):
    """A specific position in source."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LOCATION_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    LINE_FIELD_NUMBER: builtins.int
    COLUMN_FIELD_NUMBER: builtins.int
    location: typing.Text = ...
    """The soucre location name (e.g. file name)."""

    offset: builtins.int = ...
    """The UTF-8 code unit offset."""

    line: builtins.int = ...
    """The 1-based index of the starting line in the source text
    where the issue occurs, or 0 if unknown.
    """

    column: builtins.int = ...
    """The 0-based index of the starting position within the line of source text
    where the issue occurs.  Only meaningful if line is nonzero.
    """

    def __init__(self,
        *,
        location : typing.Text = ...,
        offset : builtins.int = ...,
        line : builtins.int = ...,
        column : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["column",b"column","line",b"line","location",b"location","offset",b"offset"]) -> None: ...
global___SourcePosition = SourcePosition
