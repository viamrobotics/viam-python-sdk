"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.bigtable.admin.v2.common_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Instance(google.protobuf.message.Message):
    """A collection of Bigtable [Tables][google.bigtable.admin.v2.Table] and
    the resources that serve them.
    All tables in an instance are served from all
    [Clusters][google.bigtable.admin.v2.Cluster] in the instance.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _State:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_State.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        STATE_NOT_KNOWN: Instance.State.ValueType = ...  # 0
        """The state of the instance could not be determined."""

        READY: Instance.State.ValueType = ...  # 1
        """The instance has been successfully created and can serve requests
        to its tables.
        """

        CREATING: Instance.State.ValueType = ...  # 2
        """The instance is currently being created, and may be destroyed
        if the creation process encounters an error.
        """

    class State(_State, metaclass=_StateEnumTypeWrapper):
        """Possible states of an instance."""
        pass

    STATE_NOT_KNOWN: Instance.State.ValueType = ...  # 0
    """The state of the instance could not be determined."""

    READY: Instance.State.ValueType = ...  # 1
    """The instance has been successfully created and can serve requests
    to its tables.
    """

    CREATING: Instance.State.ValueType = ...  # 2
    """The instance is currently being created, and may be destroyed
    if the creation process encounters an error.
    """


    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        TYPE_UNSPECIFIED: Instance.Type.ValueType = ...  # 0
        """The type of the instance is unspecified. If set when creating an
        instance, a `PRODUCTION` instance will be created. If set when updating
        an instance, the type will be left unchanged.
        """

        PRODUCTION: Instance.Type.ValueType = ...  # 1
        """An instance meant for production use. `serve_nodes` must be set
        on the cluster.
        """

        DEVELOPMENT: Instance.Type.ValueType = ...  # 2
        """The instance is meant for development and testing purposes only; it has
        no performance or uptime guarantees and is not covered by SLA.
        After a development instance is created, it can be upgraded by
        updating the instance to type `PRODUCTION`. An instance created
        as a production instance cannot be changed to a development instance.
        When creating a development instance, `serve_nodes` on the cluster must
        not be set.
        """

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """The type of the instance."""
        pass

    TYPE_UNSPECIFIED: Instance.Type.ValueType = ...  # 0
    """The type of the instance is unspecified. If set when creating an
    instance, a `PRODUCTION` instance will be created. If set when updating
    an instance, the type will be left unchanged.
    """

    PRODUCTION: Instance.Type.ValueType = ...  # 1
    """An instance meant for production use. `serve_nodes` must be set
    on the cluster.
    """

    DEVELOPMENT: Instance.Type.ValueType = ...  # 2
    """The instance is meant for development and testing purposes only; it has
    no performance or uptime guarantees and is not covered by SLA.
    After a development instance is created, it can be upgraded by
    updating the instance to type `PRODUCTION`. An instance created
    as a production instance cannot be changed to a development instance.
    When creating a development instance, `serve_nodes` on the cluster must
    not be set.
    """


    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The unique name of the instance. Values are of the form
    `projects/{project}/instances/[a-z][a-z0-9\\\\-]+[a-z0-9]`.
    """

    display_name: typing.Text = ...
    """Required. The descriptive name for this instance as it appears in UIs.
    Can be changed at any time, but should be kept globally unique
    to avoid confusion.
    """

    state: global___Instance.State.ValueType = ...
    """(`OutputOnly`)
    The current state of the instance.
    """

    type: global___Instance.Type.ValueType = ...
    """The type of the instance. Defaults to `PRODUCTION`."""

    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Labels are a flexible and lightweight mechanism for organizing cloud
        resources into groups that reflect a customer's organizational needs and
        deployment strategies. They can be used to filter resources and aggregate
        metrics.

        * Label keys must be between 1 and 63 characters long and must conform to
          the regular expression: `[\\p{Ll}\\p{Lo}][\\p{Ll}\\p{Lo}\\p{N}_-]{0,62}`.
        * Label values must be between 0 and 63 characters long and must conform to
          the regular expression: `[\\p{Ll}\\p{Lo}\\p{N}_-]{0,63}`.
        * No more than 64 labels can be associated with a given resource.
        * Keys and values must both be under 128 bytes.
        """
        pass
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. A server-assigned timestamp representing when this Instance was created.
        For instances created before this field was added (August 2021), this value
        is `seconds: 0, nanos: 1`.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        state : global___Instance.State.ValueType = ...,
        type : global___Instance.Type.ValueType = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time",b"create_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time",b"create_time","display_name",b"display_name","labels",b"labels","name",b"name","state",b"state","type",b"type"]) -> None: ...
global___Instance = Instance

class AutoscalingTargets(google.protobuf.message.Message):
    """The Autoscaling targets for a Cluster. These determine the recommended nodes."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CPU_UTILIZATION_PERCENT_FIELD_NUMBER: builtins.int
    cpu_utilization_percent: builtins.int = ...
    """The cpu utilization that the Autoscaler should be trying to achieve.
    This number is on a scale from 0 (no utilization) to
    100 (total utilization).
    """

    def __init__(self,
        *,
        cpu_utilization_percent : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["cpu_utilization_percent",b"cpu_utilization_percent"]) -> None: ...
global___AutoscalingTargets = AutoscalingTargets

class AutoscalingLimits(google.protobuf.message.Message):
    """Limits for the number of nodes a Cluster can autoscale up/down to."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MIN_SERVE_NODES_FIELD_NUMBER: builtins.int
    MAX_SERVE_NODES_FIELD_NUMBER: builtins.int
    min_serve_nodes: builtins.int = ...
    """Required. Minimum number of nodes to scale down to."""

    max_serve_nodes: builtins.int = ...
    """Required. Maximum number of nodes to scale up to."""

    def __init__(self,
        *,
        min_serve_nodes : builtins.int = ...,
        max_serve_nodes : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["max_serve_nodes",b"max_serve_nodes","min_serve_nodes",b"min_serve_nodes"]) -> None: ...
global___AutoscalingLimits = AutoscalingLimits

class Cluster(google.protobuf.message.Message):
    """A resizable group of nodes in a particular cloud location, capable
    of serving all [Tables][google.bigtable.admin.v2.Table] in the parent
    [Instance][google.bigtable.admin.v2.Instance].
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _State:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_State.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        STATE_NOT_KNOWN: Cluster.State.ValueType = ...  # 0
        """The state of the cluster could not be determined."""

        READY: Cluster.State.ValueType = ...  # 1
        """The cluster has been successfully created and is ready to serve requests."""

        CREATING: Cluster.State.ValueType = ...  # 2
        """The cluster is currently being created, and may be destroyed
        if the creation process encounters an error.
        A cluster may not be able to serve requests while being created.
        """

        RESIZING: Cluster.State.ValueType = ...  # 3
        """The cluster is currently being resized, and may revert to its previous
        node count if the process encounters an error.
        A cluster is still capable of serving requests while being resized,
        but may exhibit performance as if its number of allocated nodes is
        between the starting and requested states.
        """

        DISABLED: Cluster.State.ValueType = ...  # 4
        """The cluster has no backing nodes. The data (tables) still
        exist, but no operations can be performed on the cluster.
        """

    class State(_State, metaclass=_StateEnumTypeWrapper):
        """Possible states of a cluster."""
        pass

    STATE_NOT_KNOWN: Cluster.State.ValueType = ...  # 0
    """The state of the cluster could not be determined."""

    READY: Cluster.State.ValueType = ...  # 1
    """The cluster has been successfully created and is ready to serve requests."""

    CREATING: Cluster.State.ValueType = ...  # 2
    """The cluster is currently being created, and may be destroyed
    if the creation process encounters an error.
    A cluster may not be able to serve requests while being created.
    """

    RESIZING: Cluster.State.ValueType = ...  # 3
    """The cluster is currently being resized, and may revert to its previous
    node count if the process encounters an error.
    A cluster is still capable of serving requests while being resized,
    but may exhibit performance as if its number of allocated nodes is
    between the starting and requested states.
    """

    DISABLED: Cluster.State.ValueType = ...  # 4
    """The cluster has no backing nodes. The data (tables) still
    exist, but no operations can be performed on the cluster.
    """


    class ClusterAutoscalingConfig(google.protobuf.message.Message):
        """Autoscaling config for a cluster."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        AUTOSCALING_LIMITS_FIELD_NUMBER: builtins.int
        AUTOSCALING_TARGETS_FIELD_NUMBER: builtins.int
        @property
        def autoscaling_limits(self) -> global___AutoscalingLimits:
            """Required. Autoscaling limits for this cluster."""
            pass
        @property
        def autoscaling_targets(self) -> global___AutoscalingTargets:
            """Required. Autoscaling targets for this cluster."""
            pass
        def __init__(self,
            *,
            autoscaling_limits : typing.Optional[global___AutoscalingLimits] = ...,
            autoscaling_targets : typing.Optional[global___AutoscalingTargets] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["autoscaling_limits",b"autoscaling_limits","autoscaling_targets",b"autoscaling_targets"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["autoscaling_limits",b"autoscaling_limits","autoscaling_targets",b"autoscaling_targets"]) -> None: ...

    class ClusterConfig(google.protobuf.message.Message):
        """Configuration for a cluster."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        CLUSTER_AUTOSCALING_CONFIG_FIELD_NUMBER: builtins.int
        @property
        def cluster_autoscaling_config(self) -> global___Cluster.ClusterAutoscalingConfig:
            """Autoscaling configuration for this cluster."""
            pass
        def __init__(self,
            *,
            cluster_autoscaling_config : typing.Optional[global___Cluster.ClusterAutoscalingConfig] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["cluster_autoscaling_config",b"cluster_autoscaling_config"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["cluster_autoscaling_config",b"cluster_autoscaling_config"]) -> None: ...

    class EncryptionConfig(google.protobuf.message.Message):
        """Cloud Key Management Service (Cloud KMS) settings for a CMEK-protected
        cluster.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KMS_KEY_NAME_FIELD_NUMBER: builtins.int
        kms_key_name: typing.Text = ...
        """Describes the Cloud KMS encryption key that will be used to protect the
        destination Bigtable cluster. The requirements for this key are:
         1) The Cloud Bigtable service account associated with the project that
         contains this cluster must be granted the
         `cloudkms.cryptoKeyEncrypterDecrypter` role on the CMEK key.
         2) Only regional keys can be used and the region of the CMEK key must
         match the region of the cluster.
        3) All clusters within an instance must use the same CMEK key.
        """

        def __init__(self,
            *,
            kms_key_name : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["kms_key_name",b"kms_key_name"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    SERVE_NODES_FIELD_NUMBER: builtins.int
    CLUSTER_CONFIG_FIELD_NUMBER: builtins.int
    DEFAULT_STORAGE_TYPE_FIELD_NUMBER: builtins.int
    ENCRYPTION_CONFIG_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The unique name of the cluster. Values are of the form
    `projects/{project}/instances/{instance}/clusters/[a-z][-a-z0-9]*`.
    """

    location: typing.Text = ...
    """(`CreationOnly`)
    The location where this cluster's nodes and storage reside. For best
    performance, clients should be located as close as possible to this
    cluster. Currently only zones are supported, so values should be of the
    form `projects/{project}/locations/{zone}`.
    """

    state: global___Cluster.State.ValueType = ...
    """The current state of the cluster."""

    serve_nodes: builtins.int = ...
    """The number of nodes allocated to this cluster. More nodes enable higher
    throughput and more consistent performance.
    """

    @property
    def cluster_config(self) -> global___Cluster.ClusterConfig:
        """Configuration for this cluster."""
        pass
    default_storage_type: google.bigtable.admin.v2.common_pb2.StorageType.ValueType = ...
    """(`CreationOnly`)
    The type of storage used by this cluster to serve its
    parent instance's tables, unless explicitly overridden.
    """

    @property
    def encryption_config(self) -> global___Cluster.EncryptionConfig:
        """Immutable. The encryption configuration for CMEK-protected clusters."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        location : typing.Text = ...,
        state : global___Cluster.State.ValueType = ...,
        serve_nodes : builtins.int = ...,
        cluster_config : typing.Optional[global___Cluster.ClusterConfig] = ...,
        default_storage_type : google.bigtable.admin.v2.common_pb2.StorageType.ValueType = ...,
        encryption_config : typing.Optional[global___Cluster.EncryptionConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cluster_config",b"cluster_config","config",b"config","encryption_config",b"encryption_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cluster_config",b"cluster_config","config",b"config","default_storage_type",b"default_storage_type","encryption_config",b"encryption_config","location",b"location","name",b"name","serve_nodes",b"serve_nodes","state",b"state"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["config",b"config"]) -> typing.Optional[typing_extensions.Literal["cluster_config"]]: ...
global___Cluster = Cluster

class AppProfile(google.protobuf.message.Message):
    """A configuration object describing how Cloud Bigtable should treat traffic
    from a particular end user application.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class MultiClusterRoutingUseAny(google.protobuf.message.Message):
        """Read/write requests are routed to the nearest cluster in the instance, and
        will fail over to the nearest cluster that is available in the event of
        transient errors or delays. Clusters in a region are considered
        equidistant. Choosing this option sacrifices read-your-writes consistency
        to improve availability.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        CLUSTER_IDS_FIELD_NUMBER: builtins.int
        @property
        def cluster_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """The set of clusters to route to. The order is ignored; clusters will be
            tried in order of distance. If left empty, all clusters are eligible.
            """
            pass
        def __init__(self,
            *,
            cluster_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["cluster_ids",b"cluster_ids"]) -> None: ...

    class SingleClusterRouting(google.protobuf.message.Message):
        """Unconditionally routes all read/write requests to a specific cluster.
        This option preserves read-your-writes consistency but does not improve
        availability.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        CLUSTER_ID_FIELD_NUMBER: builtins.int
        ALLOW_TRANSACTIONAL_WRITES_FIELD_NUMBER: builtins.int
        cluster_id: typing.Text = ...
        """The cluster to which read/write requests should be routed."""

        allow_transactional_writes: builtins.bool = ...
        """Whether or not `CheckAndMutateRow` and `ReadModifyWriteRow` requests are
        allowed by this app profile. It is unsafe to send these requests to
        the same table/row/column in multiple clusters.
        """

        def __init__(self,
            *,
            cluster_id : typing.Text = ...,
            allow_transactional_writes : builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["allow_transactional_writes",b"allow_transactional_writes","cluster_id",b"cluster_id"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    ETAG_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    MULTI_CLUSTER_ROUTING_USE_ANY_FIELD_NUMBER: builtins.int
    SINGLE_CLUSTER_ROUTING_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """(`OutputOnly`)
    The unique name of the app profile. Values are of the form
    `projects/{project}/instances/{instance}/appProfiles/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
    """

    etag: typing.Text = ...
    """Strongly validated etag for optimistic concurrency control. Preserve the
    value returned from `GetAppProfile` when calling `UpdateAppProfile` to
    fail the request if there has been a modification in the mean time. The
    `update_mask` of the request need not include `etag` for this protection
    to apply.
    See [Wikipedia](https://en.wikipedia.org/wiki/HTTP_ETag) and
    [RFC 7232](https://tools.ietf.org/html/rfc7232#section-2.3) for more
    details.
    """

    description: typing.Text = ...
    """Optional long form description of the use case for this AppProfile."""

    @property
    def multi_cluster_routing_use_any(self) -> global___AppProfile.MultiClusterRoutingUseAny:
        """Use a multi-cluster routing policy."""
        pass
    @property
    def single_cluster_routing(self) -> global___AppProfile.SingleClusterRouting:
        """Use a single-cluster routing policy."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        etag : typing.Text = ...,
        description : typing.Text = ...,
        multi_cluster_routing_use_any : typing.Optional[global___AppProfile.MultiClusterRoutingUseAny] = ...,
        single_cluster_routing : typing.Optional[global___AppProfile.SingleClusterRouting] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["multi_cluster_routing_use_any",b"multi_cluster_routing_use_any","routing_policy",b"routing_policy","single_cluster_routing",b"single_cluster_routing"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["description",b"description","etag",b"etag","multi_cluster_routing_use_any",b"multi_cluster_routing_use_any","name",b"name","routing_policy",b"routing_policy","single_cluster_routing",b"single_cluster_routing"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["routing_policy",b"routing_policy"]) -> typing.Optional[typing_extensions.Literal["multi_cluster_routing_use_any","single_cluster_routing"]]: ...
global___AppProfile = AppProfile
