"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.cloud.talent.v4.common_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.type.latlng_pb2
import google.type.timeofday_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class JobQuery(google.protobuf.message.Message):
    """The query required to perform a search query."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    QUERY_FIELD_NUMBER: builtins.int
    QUERY_LANGUAGE_CODE_FIELD_NUMBER: builtins.int
    COMPANIES_FIELD_NUMBER: builtins.int
    LOCATION_FILTERS_FIELD_NUMBER: builtins.int
    JOB_CATEGORIES_FIELD_NUMBER: builtins.int
    COMMUTE_FILTER_FIELD_NUMBER: builtins.int
    COMPANY_DISPLAY_NAMES_FIELD_NUMBER: builtins.int
    COMPENSATION_FILTER_FIELD_NUMBER: builtins.int
    CUSTOM_ATTRIBUTE_FILTER_FIELD_NUMBER: builtins.int
    DISABLE_SPELL_CHECK_FIELD_NUMBER: builtins.int
    EMPLOYMENT_TYPES_FIELD_NUMBER: builtins.int
    LANGUAGE_CODES_FIELD_NUMBER: builtins.int
    PUBLISH_TIME_RANGE_FIELD_NUMBER: builtins.int
    EXCLUDED_JOBS_FIELD_NUMBER: builtins.int
    query: typing.Text = ...
    """The query string that matches against the job title, description, and
    location fields.

    The maximum number of allowed characters is 255.
    """

    query_language_code: typing.Text = ...
    """The language code of [query][google.cloud.talent.v4.JobQuery.query]. For example, "en-US". This field helps to
    better interpret the query.

    If a value isn't specified, the query language code is automatically
    detected, which may not be accurate.

    Language code should be in BCP-47 format, such as "en-US" or "sr-Latn".
    For more information, see
    [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
    """

    @property
    def companies(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """This filter specifies the company entities to search against.

        If a value isn't specified, jobs are searched for against all
        companies.

        If multiple values are specified, jobs are searched against the
        companies specified.

        The format is
        "projects/{project_id}/tenants/{tenant_id}/companies/{company_id}". For
        example, "projects/foo/tenants/bar/companies/baz".

        At most 20 company filters are allowed.
        """
        pass
    @property
    def location_filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LocationFilter]:
        """The location filter specifies geo-regions containing the jobs to
        search against. See [LocationFilter][google.cloud.talent.v4.LocationFilter] for more information.

        If a location value isn't specified, jobs fitting the other search
        criteria are retrieved regardless of where they're located.

        If multiple values are specified, jobs are retrieved from any of the
        specified locations. If different values are specified for the
        [LocationFilter.distance_in_miles][google.cloud.talent.v4.LocationFilter.distance_in_miles] parameter, the maximum provided
        distance is used for all locations.

        At most 5 location filters are allowed.
        """
        pass
    @property
    def job_categories(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[google.cloud.talent.v4.common_pb2.JobCategory.ValueType]:
        """The category filter specifies the categories of jobs to search against.
        See [JobCategory][google.cloud.talent.v4.JobCategory] for more information.

        If a value isn't specified, jobs from any category are searched against.

        If multiple values are specified, jobs from any of the specified
        categories are searched against.
        """
        pass
    @property
    def commute_filter(self) -> global___CommuteFilter:
        """Allows filtering jobs by commute time with different travel methods (for
         example, driving or public transit).

        Note: This only works when you specify a [CommuteMethod][google.cloud.talent.v4.CommuteMethod]. In this case,
        [location_filters][google.cloud.talent.v4.JobQuery.location_filters] is ignored.

         Currently we don't support sorting by commute time.
        """
        pass
    @property
    def company_display_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """This filter specifies the exact company [Company.display_name][google.cloud.talent.v4.Company.display_name]
        of the jobs to search against.

        If a value isn't specified, jobs within the search results are
        associated with any company.

        If multiple values are specified, jobs within the search results may be
        associated with any of the specified companies.

        At most 20 company display name filters are allowed.
        """
        pass
    @property
    def compensation_filter(self) -> global___CompensationFilter:
        """This search filter is applied only to
        [Job.compensation_info][google.cloud.talent.v4.Job.compensation_info]. For example, if the filter is specified
        as "Hourly job with per-hour compensation > $15", only jobs meeting
        these criteria are searched. If a filter isn't defined, all open jobs
        are searched.
        """
        pass
    custom_attribute_filter: typing.Text = ...
    """This filter specifies a structured syntax to match against the
    [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes] marked as `filterable`.

    The syntax for this expression is a subset of SQL syntax.

    Supported operators are: `=`, `!=`, `<`, `<=`, `>`, and `>=` where the
    left of the operator is a custom field key and the right of the operator
    is a number or a quoted string. You must escape backslash (\\\\) and
    quote (\\") characters.

    Supported functions are `LOWER([field_name])` to
    perform a case insensitive match and `EMPTY([field_name])` to filter on the
    existence of a key.

    Boolean expressions (AND/OR/NOT) are supported up to 3 levels of
    nesting (for example, "((A AND B AND C) OR NOT D) AND E"), a maximum of 100
    comparisons or functions are allowed in the expression. The expression
    must be < 10000 bytes in length.

    Sample Query:
    `(LOWER(driving_license)="class \\"a\\"" OR EMPTY(driving_license)) AND
    driving_years > 10`
    """

    disable_spell_check: builtins.bool = ...
    """This flag controls the spell-check feature. If false, the
    service attempts to correct a misspelled query,
    for example, "enginee" is corrected to "engineer".

    Defaults to false: a spell check is performed.
    """

    @property
    def employment_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[google.cloud.talent.v4.common_pb2.EmploymentType.ValueType]:
        """The employment type filter specifies the employment type of jobs to
        search against, such as [EmploymentType.FULL_TIME][google.cloud.talent.v4.EmploymentType.FULL_TIME].

        If a value isn't specified, jobs in the search results includes any
        employment type.

        If multiple values are specified, jobs in the search results include
        any of the specified employment types.
        """
        pass
    @property
    def language_codes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """This filter specifies the locale of jobs to search against,
        for example, "en-US".

        If a value isn't specified, the search results can contain jobs in any
        locale.


        Language codes should be in BCP-47 format, such as "en-US" or "sr-Latn".
        For more information, see
        [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).

        At most 10 language code filters are allowed.
        """
        pass
    @property
    def publish_time_range(self) -> google.cloud.talent.v4.common_pb2.TimestampRange:
        """Jobs published within a range specified by this filter are searched
        against.
        """
        pass
    @property
    def excluded_jobs(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """This filter specifies a list of job names to be excluded during search.

        At most 400 excluded job names are allowed.
        """
        pass
    def __init__(self,
        *,
        query : typing.Text = ...,
        query_language_code : typing.Text = ...,
        companies : typing.Optional[typing.Iterable[typing.Text]] = ...,
        location_filters : typing.Optional[typing.Iterable[global___LocationFilter]] = ...,
        job_categories : typing.Optional[typing.Iterable[google.cloud.talent.v4.common_pb2.JobCategory.ValueType]] = ...,
        commute_filter : typing.Optional[global___CommuteFilter] = ...,
        company_display_names : typing.Optional[typing.Iterable[typing.Text]] = ...,
        compensation_filter : typing.Optional[global___CompensationFilter] = ...,
        custom_attribute_filter : typing.Text = ...,
        disable_spell_check : builtins.bool = ...,
        employment_types : typing.Optional[typing.Iterable[google.cloud.talent.v4.common_pb2.EmploymentType.ValueType]] = ...,
        language_codes : typing.Optional[typing.Iterable[typing.Text]] = ...,
        publish_time_range : typing.Optional[google.cloud.talent.v4.common_pb2.TimestampRange] = ...,
        excluded_jobs : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["commute_filter",b"commute_filter","compensation_filter",b"compensation_filter","publish_time_range",b"publish_time_range"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["commute_filter",b"commute_filter","companies",b"companies","company_display_names",b"company_display_names","compensation_filter",b"compensation_filter","custom_attribute_filter",b"custom_attribute_filter","disable_spell_check",b"disable_spell_check","employment_types",b"employment_types","excluded_jobs",b"excluded_jobs","job_categories",b"job_categories","language_codes",b"language_codes","location_filters",b"location_filters","publish_time_range",b"publish_time_range","query",b"query","query_language_code",b"query_language_code"]) -> None: ...
global___JobQuery = JobQuery

class LocationFilter(google.protobuf.message.Message):
    """Geographic region of the search."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _TelecommutePreference:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TelecommutePreferenceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TelecommutePreference.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        TELECOMMUTE_PREFERENCE_UNSPECIFIED: LocationFilter.TelecommutePreference.ValueType = ...  # 0
        """Default value if the telecommute preference isn't specified."""

        TELECOMMUTE_EXCLUDED: LocationFilter.TelecommutePreference.ValueType = ...  # 1
        """Exclude telecommute jobs."""

        TELECOMMUTE_ALLOWED: LocationFilter.TelecommutePreference.ValueType = ...  # 2
        """Allow telecommute jobs."""

    class TelecommutePreference(_TelecommutePreference, metaclass=_TelecommutePreferenceEnumTypeWrapper):
        """Specify whether to include telecommute jobs."""
        pass

    TELECOMMUTE_PREFERENCE_UNSPECIFIED: LocationFilter.TelecommutePreference.ValueType = ...  # 0
    """Default value if the telecommute preference isn't specified."""

    TELECOMMUTE_EXCLUDED: LocationFilter.TelecommutePreference.ValueType = ...  # 1
    """Exclude telecommute jobs."""

    TELECOMMUTE_ALLOWED: LocationFilter.TelecommutePreference.ValueType = ...  # 2
    """Allow telecommute jobs."""


    ADDRESS_FIELD_NUMBER: builtins.int
    REGION_CODE_FIELD_NUMBER: builtins.int
    LAT_LNG_FIELD_NUMBER: builtins.int
    DISTANCE_IN_MILES_FIELD_NUMBER: builtins.int
    TELECOMMUTE_PREFERENCE_FIELD_NUMBER: builtins.int
    address: typing.Text = ...
    """The address name, such as "Mountain View" or "Bay Area"."""

    region_code: typing.Text = ...
    """CLDR region code of the country/region. This field may be used in two ways:

    1) If telecommute preference is not set, this field is used address
    ambiguity of the user-input address. For example, "Liverpool" may refer to
    "Liverpool, NY, US" or "Liverpool, UK". This region code biases the
    address resolution toward a specific country or territory. If this field is
    not set, address resolution is biased toward the United States by default.

    2) If telecommute preference is set to TELECOMMUTE_ALLOWED, the
    telecommute location filter will be limited to the region specified in this
    field. If this field is not set, the telecommute job locations will not be

    See
    https://unicode-org.github.io/cldr-staging/charts/latest/supplemental/territory_information.html
    for details. Example: "CH" for Switzerland.
    """

    @property
    def lat_lng(self) -> google.type.latlng_pb2.LatLng:
        """The latitude and longitude of the geographic center to search from. This
        field is ignored if `address` is provided.
        """
        pass
    distance_in_miles: builtins.float = ...
    """The distance_in_miles is applied when the location being searched for is
    identified as a city or smaller. This field is ignored if the location
    being searched for is a state or larger.
    """

    telecommute_preference: global___LocationFilter.TelecommutePreference.ValueType = ...
    """Allows the client to return jobs without a
    set location, specifically, telecommuting jobs (telecommuting is considered
    by the service as a special location.
    [Job.posting_region][google.cloud.talent.v4.Job.posting_region] indicates if a job permits telecommuting.
    If this field is set to [TelecommutePreference.TELECOMMUTE_ALLOWED][google.cloud.talent.v4.LocationFilter.TelecommutePreference.TELECOMMUTE_ALLOWED],
    telecommuting jobs are searched, and [address][google.cloud.talent.v4.LocationFilter.address] and [lat_lng][google.cloud.talent.v4.LocationFilter.lat_lng] are
    ignored. If not set or set to
    [TelecommutePreference.TELECOMMUTE_EXCLUDED][google.cloud.talent.v4.LocationFilter.TelecommutePreference.TELECOMMUTE_EXCLUDED], telecommute job are not
    searched.

    This filter can be used by itself to search exclusively for telecommuting
    jobs, or it can be combined with another location
    filter to search for a combination of job locations,
    such as "Mountain View" or "telecommuting" jobs. However, when used in
    combination with other location filters, telecommuting jobs can be
    treated as less relevant than other jobs in the search response.

    This field is only used for job search requests.
    """

    def __init__(self,
        *,
        address : typing.Text = ...,
        region_code : typing.Text = ...,
        lat_lng : typing.Optional[google.type.latlng_pb2.LatLng] = ...,
        distance_in_miles : builtins.float = ...,
        telecommute_preference : global___LocationFilter.TelecommutePreference.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["lat_lng",b"lat_lng"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["address",b"address","distance_in_miles",b"distance_in_miles","lat_lng",b"lat_lng","region_code",b"region_code","telecommute_preference",b"telecommute_preference"]) -> None: ...
global___LocationFilter = LocationFilter

class CompensationFilter(google.protobuf.message.Message):
    """Filter on job compensation type and amount."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _FilterType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _FilterTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_FilterType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        FILTER_TYPE_UNSPECIFIED: CompensationFilter.FilterType.ValueType = ...  # 0
        """Filter type unspecified. Position holder, INVALID, should never be used."""

        UNIT_ONLY: CompensationFilter.FilterType.ValueType = ...  # 1
        """Filter by `base compensation entry's` unit. A job is a match if and
        only if the job contains a base CompensationEntry and the base
        CompensationEntry's unit matches provided [units][google.cloud.talent.v4.CompensationFilter.units].
        Populate one or more [units][google.cloud.talent.v4.CompensationFilter.units].

        See [CompensationInfo.CompensationEntry][google.cloud.talent.v4.CompensationInfo.CompensationEntry] for definition of
        base compensation entry.
        """

        UNIT_AND_AMOUNT: CompensationFilter.FilterType.ValueType = ...  # 2
        """Filter by `base compensation entry's` unit and amount / range. A job
        is a match if and only if the job contains a base CompensationEntry, and
        the base entry's unit matches provided
        [CompensationUnit][google.cloud.talent.v4.CompensationInfo.CompensationUnit] and
        amount or range overlaps with provided
        [CompensationRange][google.cloud.talent.v4.CompensationInfo.CompensationRange].

        See [CompensationInfo.CompensationEntry][google.cloud.talent.v4.CompensationInfo.CompensationEntry] for definition of
        base compensation entry.

        Set exactly one [units][google.cloud.talent.v4.CompensationFilter.units] and populate [range][google.cloud.talent.v4.CompensationFilter.range].
        """

        ANNUALIZED_BASE_AMOUNT: CompensationFilter.FilterType.ValueType = ...  # 3
        """Filter by annualized base compensation amount and `base compensation
        entry's` unit. Populate [range][google.cloud.talent.v4.CompensationFilter.range] and zero or more [units][google.cloud.talent.v4.CompensationFilter.units].
        """

        ANNUALIZED_TOTAL_AMOUNT: CompensationFilter.FilterType.ValueType = ...  # 4
        """Filter by annualized total compensation amount and `base compensation
        entry's` unit . Populate [range][google.cloud.talent.v4.CompensationFilter.range] and zero or more [units][google.cloud.talent.v4.CompensationFilter.units].
        """

    class FilterType(_FilterType, metaclass=_FilterTypeEnumTypeWrapper):
        """Specify the type of filtering."""
        pass

    FILTER_TYPE_UNSPECIFIED: CompensationFilter.FilterType.ValueType = ...  # 0
    """Filter type unspecified. Position holder, INVALID, should never be used."""

    UNIT_ONLY: CompensationFilter.FilterType.ValueType = ...  # 1
    """Filter by `base compensation entry's` unit. A job is a match if and
    only if the job contains a base CompensationEntry and the base
    CompensationEntry's unit matches provided [units][google.cloud.talent.v4.CompensationFilter.units].
    Populate one or more [units][google.cloud.talent.v4.CompensationFilter.units].

    See [CompensationInfo.CompensationEntry][google.cloud.talent.v4.CompensationInfo.CompensationEntry] for definition of
    base compensation entry.
    """

    UNIT_AND_AMOUNT: CompensationFilter.FilterType.ValueType = ...  # 2
    """Filter by `base compensation entry's` unit and amount / range. A job
    is a match if and only if the job contains a base CompensationEntry, and
    the base entry's unit matches provided
    [CompensationUnit][google.cloud.talent.v4.CompensationInfo.CompensationUnit] and
    amount or range overlaps with provided
    [CompensationRange][google.cloud.talent.v4.CompensationInfo.CompensationRange].

    See [CompensationInfo.CompensationEntry][google.cloud.talent.v4.CompensationInfo.CompensationEntry] for definition of
    base compensation entry.

    Set exactly one [units][google.cloud.talent.v4.CompensationFilter.units] and populate [range][google.cloud.talent.v4.CompensationFilter.range].
    """

    ANNUALIZED_BASE_AMOUNT: CompensationFilter.FilterType.ValueType = ...  # 3
    """Filter by annualized base compensation amount and `base compensation
    entry's` unit. Populate [range][google.cloud.talent.v4.CompensationFilter.range] and zero or more [units][google.cloud.talent.v4.CompensationFilter.units].
    """

    ANNUALIZED_TOTAL_AMOUNT: CompensationFilter.FilterType.ValueType = ...  # 4
    """Filter by annualized total compensation amount and `base compensation
    entry's` unit . Populate [range][google.cloud.talent.v4.CompensationFilter.range] and zero or more [units][google.cloud.talent.v4.CompensationFilter.units].
    """


    TYPE_FIELD_NUMBER: builtins.int
    UNITS_FIELD_NUMBER: builtins.int
    RANGE_FIELD_NUMBER: builtins.int
    INCLUDE_JOBS_WITH_UNSPECIFIED_COMPENSATION_RANGE_FIELD_NUMBER: builtins.int
    type: global___CompensationFilter.FilterType.ValueType = ...
    """Required. Type of filter."""

    @property
    def units(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[google.cloud.talent.v4.common_pb2.CompensationInfo.CompensationUnit.ValueType]:
        """Required. Specify desired `base compensation entry's`
        [CompensationInfo.CompensationUnit][google.cloud.talent.v4.CompensationInfo.CompensationUnit].
        """
        pass
    @property
    def range(self) -> google.cloud.talent.v4.common_pb2.CompensationInfo.CompensationRange:
        """Compensation range."""
        pass
    include_jobs_with_unspecified_compensation_range: builtins.bool = ...
    """If set to true, jobs with unspecified compensation range fields are
    included.
    """

    def __init__(self,
        *,
        type : global___CompensationFilter.FilterType.ValueType = ...,
        units : typing.Optional[typing.Iterable[google.cloud.talent.v4.common_pb2.CompensationInfo.CompensationUnit.ValueType]] = ...,
        range : typing.Optional[google.cloud.talent.v4.common_pb2.CompensationInfo.CompensationRange] = ...,
        include_jobs_with_unspecified_compensation_range : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["range",b"range"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["include_jobs_with_unspecified_compensation_range",b"include_jobs_with_unspecified_compensation_range","range",b"range","type",b"type","units",b"units"]) -> None: ...
global___CompensationFilter = CompensationFilter

class CommuteFilter(google.protobuf.message.Message):
    """Parameters needed for commute search."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _RoadTraffic:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _RoadTrafficEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RoadTraffic.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        ROAD_TRAFFIC_UNSPECIFIED: CommuteFilter.RoadTraffic.ValueType = ...  # 0
        """Road traffic situation isn't specified."""

        TRAFFIC_FREE: CommuteFilter.RoadTraffic.ValueType = ...  # 1
        """Optimal commute time without considering any traffic impact."""

        BUSY_HOUR: CommuteFilter.RoadTraffic.ValueType = ...  # 2
        """Commute time calculation takes in account the peak traffic impact."""

    class RoadTraffic(_RoadTraffic, metaclass=_RoadTrafficEnumTypeWrapper):
        """The traffic density to use when calculating commute time."""
        pass

    ROAD_TRAFFIC_UNSPECIFIED: CommuteFilter.RoadTraffic.ValueType = ...  # 0
    """Road traffic situation isn't specified."""

    TRAFFIC_FREE: CommuteFilter.RoadTraffic.ValueType = ...  # 1
    """Optimal commute time without considering any traffic impact."""

    BUSY_HOUR: CommuteFilter.RoadTraffic.ValueType = ...  # 2
    """Commute time calculation takes in account the peak traffic impact."""


    COMMUTE_METHOD_FIELD_NUMBER: builtins.int
    START_COORDINATES_FIELD_NUMBER: builtins.int
    TRAVEL_DURATION_FIELD_NUMBER: builtins.int
    ALLOW_IMPRECISE_ADDRESSES_FIELD_NUMBER: builtins.int
    ROAD_TRAFFIC_FIELD_NUMBER: builtins.int
    DEPARTURE_TIME_FIELD_NUMBER: builtins.int
    commute_method: google.cloud.talent.v4.common_pb2.CommuteMethod.ValueType = ...
    """Required. The method of transportation to calculate the commute time for."""

    @property
    def start_coordinates(self) -> google.type.latlng_pb2.LatLng:
        """Required. The latitude and longitude of the location to calculate the
        commute time from.
        """
        pass
    @property
    def travel_duration(self) -> google.protobuf.duration_pb2.Duration:
        """Required. The maximum travel time in seconds. The maximum allowed value is `3600s`
        (one hour). Format is `123s`.
        """
        pass
    allow_imprecise_addresses: builtins.bool = ...
    """If `true`, jobs without street level addresses may also be returned.
    For city level addresses, the city center is used. For state and coarser
    level addresses, text matching is used.
    If this field is set to `false` or isn't specified, only jobs that include
    street level addresses will be returned by commute search.
    """

    road_traffic: global___CommuteFilter.RoadTraffic.ValueType = ...
    """Specifies the traffic density to use when calculating commute time."""

    @property
    def departure_time(self) -> google.type.timeofday_pb2.TimeOfDay:
        """The departure time used to calculate traffic impact, represented as
        [google.type.TimeOfDay][google.type.TimeOfDay] in local time zone.

        Currently traffic model is restricted to hour level resolution.
        """
        pass
    def __init__(self,
        *,
        commute_method : google.cloud.talent.v4.common_pb2.CommuteMethod.ValueType = ...,
        start_coordinates : typing.Optional[google.type.latlng_pb2.LatLng] = ...,
        travel_duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        allow_imprecise_addresses : builtins.bool = ...,
        road_traffic : global___CommuteFilter.RoadTraffic.ValueType = ...,
        departure_time : typing.Optional[google.type.timeofday_pb2.TimeOfDay] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["departure_time",b"departure_time","road_traffic",b"road_traffic","start_coordinates",b"start_coordinates","traffic_option",b"traffic_option","travel_duration",b"travel_duration"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["allow_imprecise_addresses",b"allow_imprecise_addresses","commute_method",b"commute_method","departure_time",b"departure_time","road_traffic",b"road_traffic","start_coordinates",b"start_coordinates","traffic_option",b"traffic_option","travel_duration",b"travel_duration"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["traffic_option",b"traffic_option"]) -> typing.Optional[typing_extensions.Literal["road_traffic","departure_time"]]: ...
global___CommuteFilter = CommuteFilter
