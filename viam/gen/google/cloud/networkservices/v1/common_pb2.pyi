"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class OperationMetadata(google.protobuf.message.Message):
    """Represents the metadata of the long-running operation."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CREATE_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    TARGET_FIELD_NUMBER: builtins.int
    VERB_FIELD_NUMBER: builtins.int
    STATUS_MESSAGE_FIELD_NUMBER: builtins.int
    REQUESTED_CANCELLATION_FIELD_NUMBER: builtins.int
    API_VERSION_FIELD_NUMBER: builtins.int
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The time the operation was created."""
        pass
    @property
    def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The time the operation finished running."""
        pass
    target: typing.Text = ...
    """Output only. Server-defined resource path for the target of the operation."""

    verb: typing.Text = ...
    """Output only. Name of the verb executed by the operation."""

    status_message: typing.Text = ...
    """Output only. Human-readable status of the operation, if any."""

    requested_cancellation: builtins.bool = ...
    """Output only. Identifies whether the user has requested cancellation
    of the operation. Operations that have successfully been cancelled
    have [Operation.error][] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    corresponding to `Code.CANCELLED`.
    """

    api_version: typing.Text = ...
    """Output only. API version used to start the operation."""

    def __init__(self,
        *,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        end_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        target : typing.Text = ...,
        verb : typing.Text = ...,
        status_message : typing.Text = ...,
        requested_cancellation : builtins.bool = ...,
        api_version : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time",b"create_time","end_time",b"end_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["api_version",b"api_version","create_time",b"create_time","end_time",b"end_time","requested_cancellation",b"requested_cancellation","status_message",b"status_message","target",b"target","verb",b"verb"]) -> None: ...
global___OperationMetadata = OperationMetadata

class TrafficPortSelector(google.protobuf.message.Message):
    """Specification of a port-based selector."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PORTS_FIELD_NUMBER: builtins.int
    @property
    def ports(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Optional. A list of ports. Can be port numbers or port range
        (example, [80-90] specifies all ports from 80 to 90, including
        80 and 90) or named ports or * to specify all ports. If the
        list is empty, all ports are selected.
        """
        pass
    def __init__(self,
        *,
        ports : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["ports",b"ports"]) -> None: ...
global___TrafficPortSelector = TrafficPortSelector

class EndpointMatcher(google.protobuf.message.Message):
    """A definition of a matcher that selects endpoints to which the policies
    should be applied.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class MetadataLabelMatcher(google.protobuf.message.Message):
        """The matcher that is based on node metadata presented by xDS clients."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _MetadataLabelMatchCriteria:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _MetadataLabelMatchCriteriaEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_MetadataLabelMatchCriteria.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED: EndpointMatcher.MetadataLabelMatcher.MetadataLabelMatchCriteria.ValueType = ...  # 0
            """Default value. Should not be used."""

            MATCH_ANY: EndpointMatcher.MetadataLabelMatcher.MetadataLabelMatchCriteria.ValueType = ...  # 1
            """At least one of the Labels specified in the matcher should match the
            metadata presented by xDS client.
            """

            MATCH_ALL: EndpointMatcher.MetadataLabelMatcher.MetadataLabelMatchCriteria.ValueType = ...  # 2
            """The metadata presented by the xDS client should contain all of the
            labels specified here.
            """

        class MetadataLabelMatchCriteria(_MetadataLabelMatchCriteria, metaclass=_MetadataLabelMatchCriteriaEnumTypeWrapper):
            """Possible criteria values that define logic of how matching is made."""
            pass

        METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED: EndpointMatcher.MetadataLabelMatcher.MetadataLabelMatchCriteria.ValueType = ...  # 0
        """Default value. Should not be used."""

        MATCH_ANY: EndpointMatcher.MetadataLabelMatcher.MetadataLabelMatchCriteria.ValueType = ...  # 1
        """At least one of the Labels specified in the matcher should match the
        metadata presented by xDS client.
        """

        MATCH_ALL: EndpointMatcher.MetadataLabelMatcher.MetadataLabelMatchCriteria.ValueType = ...  # 2
        """The metadata presented by the xDS client should contain all of the
        labels specified here.
        """


        class MetadataLabels(google.protobuf.message.Message):
            """Defines a name-pair value for a single label."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            LABEL_NAME_FIELD_NUMBER: builtins.int
            LABEL_VALUE_FIELD_NUMBER: builtins.int
            label_name: typing.Text = ...
            """Required. Label name presented as key in xDS Node Metadata."""

            label_value: typing.Text = ...
            """Required. Label value presented as value corresponding to the above
            key, in xDS Node Metadata.
            """

            def __init__(self,
                *,
                label_name : typing.Text = ...,
                label_value : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["label_name",b"label_name","label_value",b"label_value"]) -> None: ...

        METADATA_LABEL_MATCH_CRITERIA_FIELD_NUMBER: builtins.int
        METADATA_LABELS_FIELD_NUMBER: builtins.int
        metadata_label_match_criteria: global___EndpointMatcher.MetadataLabelMatcher.MetadataLabelMatchCriteria.ValueType = ...
        """Specifies how matching should be done.

        Supported values are:
        MATCH_ANY: At least one of the Labels specified in the
          matcher should match the metadata presented by xDS client.
        MATCH_ALL: The metadata presented by the xDS client should
          contain all of the labels specified here.

        The selection is determined based on the best match. For
        example, suppose there are three EndpointPolicy
        resources P1, P2 and P3 and if P1 has a the matcher as
        MATCH_ANY <A:1, B:1>, P2 has MATCH_ALL <A:1,B:1>, and P3 has
        MATCH_ALL <A:1,B:1,C:1>.

        If a client with label <A:1> connects, the config from P1
        will be selected.

        If a client with label <A:1,B:1> connects, the config from P2
        will be selected.

        If a client with label <A:1,B:1,C:1> connects, the config
        from P3 will be selected.

        If there is more than one best match, (for example, if a
        config P4 with selector <A:1,D:1> exists and if a client with
        label <A:1,B:1,D:1> connects), an error will be thrown.
        """

        @property
        def metadata_labels(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EndpointMatcher.MetadataLabelMatcher.MetadataLabels]:
            """The list of label value pairs that must match labels in the
            provided metadata based on filterMatchCriteria This list can
            have at most 64 entries. The list can be empty if the match
            criteria is MATCH_ANY, to specify a wildcard match (i.e this
            matches any client).
            """
            pass
        def __init__(self,
            *,
            metadata_label_match_criteria : global___EndpointMatcher.MetadataLabelMatcher.MetadataLabelMatchCriteria.ValueType = ...,
            metadata_labels : typing.Optional[typing.Iterable[global___EndpointMatcher.MetadataLabelMatcher.MetadataLabels]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["metadata_label_match_criteria",b"metadata_label_match_criteria","metadata_labels",b"metadata_labels"]) -> None: ...

    METADATA_LABEL_MATCHER_FIELD_NUMBER: builtins.int
    @property
    def metadata_label_matcher(self) -> global___EndpointMatcher.MetadataLabelMatcher:
        """The matcher is based on node metadata presented by xDS clients."""
        pass
    def __init__(self,
        *,
        metadata_label_matcher : typing.Optional[global___EndpointMatcher.MetadataLabelMatcher] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["matcher_type",b"matcher_type","metadata_label_matcher",b"metadata_label_matcher"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["matcher_type",b"matcher_type","metadata_label_matcher",b"metadata_label_matcher"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["matcher_type",b"matcher_type"]) -> typing.Optional[typing_extensions.Literal["metadata_label_matcher"]]: ...
global___EndpointMatcher = EndpointMatcher
