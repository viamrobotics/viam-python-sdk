"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Policy(google.protobuf.message.Message):
    """A [policy][google.cloud.binaryauthorization.v1.Policy] for container image binary authorization."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _GlobalPolicyEvaluationMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _GlobalPolicyEvaluationModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_GlobalPolicyEvaluationMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED: Policy.GlobalPolicyEvaluationMode.ValueType = ...  # 0
        """Not specified: DISABLE is assumed."""

        ENABLE: Policy.GlobalPolicyEvaluationMode.ValueType = ...  # 1
        """Enables system policy evaluation."""

        DISABLE: Policy.GlobalPolicyEvaluationMode.ValueType = ...  # 2
        """Disables system policy evaluation."""

    class GlobalPolicyEvaluationMode(_GlobalPolicyEvaluationMode, metaclass=_GlobalPolicyEvaluationModeEnumTypeWrapper):
        pass

    GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED: Policy.GlobalPolicyEvaluationMode.ValueType = ...  # 0
    """Not specified: DISABLE is assumed."""

    ENABLE: Policy.GlobalPolicyEvaluationMode.ValueType = ...  # 1
    """Enables system policy evaluation."""

    DISABLE: Policy.GlobalPolicyEvaluationMode.ValueType = ...  # 2
    """Disables system policy evaluation."""


    class ClusterAdmissionRulesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> global___AdmissionRule: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[global___AdmissionRule] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class KubernetesNamespaceAdmissionRulesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> global___AdmissionRule: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[global___AdmissionRule] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class KubernetesServiceAccountAdmissionRulesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> global___AdmissionRule: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[global___AdmissionRule] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class IstioServiceIdentityAdmissionRulesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> global___AdmissionRule: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[global___AdmissionRule] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    GLOBAL_POLICY_EVALUATION_MODE_FIELD_NUMBER: builtins.int
    ADMISSION_WHITELIST_PATTERNS_FIELD_NUMBER: builtins.int
    CLUSTER_ADMISSION_RULES_FIELD_NUMBER: builtins.int
    KUBERNETES_NAMESPACE_ADMISSION_RULES_FIELD_NUMBER: builtins.int
    KUBERNETES_SERVICE_ACCOUNT_ADMISSION_RULES_FIELD_NUMBER: builtins.int
    ISTIO_SERVICE_IDENTITY_ADMISSION_RULES_FIELD_NUMBER: builtins.int
    DEFAULT_ADMISSION_RULE_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Output only. The resource name, in the format `projects/*/policy`. There is
    at most one policy per project.
    """

    description: typing.Text = ...
    """Optional. A descriptive comment."""

    global_policy_evaluation_mode: global___Policy.GlobalPolicyEvaluationMode.ValueType = ...
    """Optional. Controls the evaluation of a Google-maintained global admission
    policy for common system-level images. Images not covered by the global
    policy will be subject to the project admission policy. This setting
    has no effect when specified inside a global admission policy.
    """

    @property
    def admission_whitelist_patterns(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AdmissionWhitelistPattern]:
        """Optional. Admission policy allowlisting. A matching admission request will
        always be permitted. This feature is typically used to exclude Google or
        third-party infrastructure images from Binary Authorization policies.
        """
        pass
    @property
    def cluster_admission_rules(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___AdmissionRule]:
        """Optional. Per-cluster admission rules. Cluster spec format:
        `location.clusterId`. There can be at most one admission rule per cluster
        spec.
        A `location` is either a compute zone (e.g. us-central1-a) or a region
        (e.g. us-central1).
        For `clusterId` syntax restrictions see
        https://cloud.google.com/container-engine/reference/rest/v1/projects.zones.clusters.
        """
        pass
    @property
    def kubernetes_namespace_admission_rules(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___AdmissionRule]:
        """Optional. Per-kubernetes-namespace admission rules. K8s namespace spec format:
        [a-z.-]+, e.g. 'some-namespace'
        """
        pass
    @property
    def kubernetes_service_account_admission_rules(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___AdmissionRule]:
        """Optional. Per-kubernetes-service-account admission rules. Service account
        spec format: `namespace:serviceaccount`. e.g. 'test-ns:default'
        """
        pass
    @property
    def istio_service_identity_admission_rules(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___AdmissionRule]:
        """Optional. Per-istio-service-identity admission rules. Istio service
        identity spec format:
        spiffe://<domain>/ns/<namespace>/sa/<serviceaccount> or
        <domain>/ns/<namespace>/sa/<serviceaccount>
        e.g. spiffe://example.com/ns/test-ns/sa/default
        """
        pass
    @property
    def default_admission_rule(self) -> global___AdmissionRule:
        """Required. Default admission rule for a cluster without a per-cluster, per-
        kubernetes-service-account, or per-istio-service-identity admission rule.
        """
        pass
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Time when the policy was last updated."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        description : typing.Text = ...,
        global_policy_evaluation_mode : global___Policy.GlobalPolicyEvaluationMode.ValueType = ...,
        admission_whitelist_patterns : typing.Optional[typing.Iterable[global___AdmissionWhitelistPattern]] = ...,
        cluster_admission_rules : typing.Optional[typing.Mapping[typing.Text, global___AdmissionRule]] = ...,
        kubernetes_namespace_admission_rules : typing.Optional[typing.Mapping[typing.Text, global___AdmissionRule]] = ...,
        kubernetes_service_account_admission_rules : typing.Optional[typing.Mapping[typing.Text, global___AdmissionRule]] = ...,
        istio_service_identity_admission_rules : typing.Optional[typing.Mapping[typing.Text, global___AdmissionRule]] = ...,
        default_admission_rule : typing.Optional[global___AdmissionRule] = ...,
        update_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["default_admission_rule",b"default_admission_rule","update_time",b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["admission_whitelist_patterns",b"admission_whitelist_patterns","cluster_admission_rules",b"cluster_admission_rules","default_admission_rule",b"default_admission_rule","description",b"description","global_policy_evaluation_mode",b"global_policy_evaluation_mode","istio_service_identity_admission_rules",b"istio_service_identity_admission_rules","kubernetes_namespace_admission_rules",b"kubernetes_namespace_admission_rules","kubernetes_service_account_admission_rules",b"kubernetes_service_account_admission_rules","name",b"name","update_time",b"update_time"]) -> None: ...
global___Policy = Policy

class AdmissionWhitelistPattern(google.protobuf.message.Message):
    """An [admission allowlist pattern][google.cloud.binaryauthorization.v1.AdmissionWhitelistPattern] exempts images
    from checks by [admission rules][google.cloud.binaryauthorization.v1.AdmissionRule].
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_PATTERN_FIELD_NUMBER: builtins.int
    name_pattern: typing.Text = ...
    """An image name pattern to allowlist, in the form `registry/path/to/image`.
    This supports a trailing `*` wildcard, but this is allowed only in
    text after the `registry/` part. This also supports a trailing `**`
    wildcard which matches subdirectories of a given entry.
    """

    def __init__(self,
        *,
        name_pattern : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name_pattern",b"name_pattern"]) -> None: ...
global___AdmissionWhitelistPattern = AdmissionWhitelistPattern

class AdmissionRule(google.protobuf.message.Message):
    """An [admission rule][google.cloud.binaryauthorization.v1.AdmissionRule] specifies either that all container images
    used in a pod creation request must be attested to by one or more
    [attestors][google.cloud.binaryauthorization.v1.Attestor], that all pod creations will be allowed, or that all
    pod creations will be denied.

    Images matching an [admission allowlist pattern][google.cloud.binaryauthorization.v1.AdmissionWhitelistPattern]
    are exempted from admission rules and will never block a pod creation.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _EvaluationMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _EvaluationModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EvaluationMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        EVALUATION_MODE_UNSPECIFIED: AdmissionRule.EvaluationMode.ValueType = ...  # 0
        """Do not use."""

        ALWAYS_ALLOW: AdmissionRule.EvaluationMode.ValueType = ...  # 1
        """This rule allows all all pod creations."""

        REQUIRE_ATTESTATION: AdmissionRule.EvaluationMode.ValueType = ...  # 2
        """This rule allows a pod creation if all the attestors listed in
        'require_attestations_by' have valid attestations for all of the
        images in the pod spec.
        """

        ALWAYS_DENY: AdmissionRule.EvaluationMode.ValueType = ...  # 3
        """This rule denies all pod creations."""

    class EvaluationMode(_EvaluationMode, metaclass=_EvaluationModeEnumTypeWrapper):
        pass

    EVALUATION_MODE_UNSPECIFIED: AdmissionRule.EvaluationMode.ValueType = ...  # 0
    """Do not use."""

    ALWAYS_ALLOW: AdmissionRule.EvaluationMode.ValueType = ...  # 1
    """This rule allows all all pod creations."""

    REQUIRE_ATTESTATION: AdmissionRule.EvaluationMode.ValueType = ...  # 2
    """This rule allows a pod creation if all the attestors listed in
    'require_attestations_by' have valid attestations for all of the
    images in the pod spec.
    """

    ALWAYS_DENY: AdmissionRule.EvaluationMode.ValueType = ...  # 3
    """This rule denies all pod creations."""


    class _EnforcementMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _EnforcementModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnforcementMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        ENFORCEMENT_MODE_UNSPECIFIED: AdmissionRule.EnforcementMode.ValueType = ...  # 0
        """Do not use."""

        ENFORCED_BLOCK_AND_AUDIT_LOG: AdmissionRule.EnforcementMode.ValueType = ...  # 1
        """Enforce the admission rule by blocking the pod creation."""

        DRYRUN_AUDIT_LOG_ONLY: AdmissionRule.EnforcementMode.ValueType = ...  # 2
        """Dryrun mode: Audit logging only.  This will allow the pod creation as if
        the admission request had specified break-glass.
        """

    class EnforcementMode(_EnforcementMode, metaclass=_EnforcementModeEnumTypeWrapper):
        """Defines the possible actions when a pod creation is denied by an admission
        rule.
        """
        pass

    ENFORCEMENT_MODE_UNSPECIFIED: AdmissionRule.EnforcementMode.ValueType = ...  # 0
    """Do not use."""

    ENFORCED_BLOCK_AND_AUDIT_LOG: AdmissionRule.EnforcementMode.ValueType = ...  # 1
    """Enforce the admission rule by blocking the pod creation."""

    DRYRUN_AUDIT_LOG_ONLY: AdmissionRule.EnforcementMode.ValueType = ...  # 2
    """Dryrun mode: Audit logging only.  This will allow the pod creation as if
    the admission request had specified break-glass.
    """


    EVALUATION_MODE_FIELD_NUMBER: builtins.int
    REQUIRE_ATTESTATIONS_BY_FIELD_NUMBER: builtins.int
    ENFORCEMENT_MODE_FIELD_NUMBER: builtins.int
    evaluation_mode: global___AdmissionRule.EvaluationMode.ValueType = ...
    """Required. How this admission rule will be evaluated."""

    @property
    def require_attestations_by(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Optional. The resource names of the attestors that must attest to
        a container image, in the format `projects/*/attestors/*`. Each
        attestor must exist before a policy can reference it.  To add an attestor
        to a policy the principal issuing the policy change request must be able
        to read the attestor resource.

        Note: this field must be non-empty when the evaluation_mode field specifies
        REQUIRE_ATTESTATION, otherwise it must be empty.
        """
        pass
    enforcement_mode: global___AdmissionRule.EnforcementMode.ValueType = ...
    """Required. The action when a pod creation is denied by the admission rule."""

    def __init__(self,
        *,
        evaluation_mode : global___AdmissionRule.EvaluationMode.ValueType = ...,
        require_attestations_by : typing.Optional[typing.Iterable[typing.Text]] = ...,
        enforcement_mode : global___AdmissionRule.EnforcementMode.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["enforcement_mode",b"enforcement_mode","evaluation_mode",b"evaluation_mode","require_attestations_by",b"require_attestations_by"]) -> None: ...
global___AdmissionRule = AdmissionRule

class Attestor(google.protobuf.message.Message):
    """An [attestor][google.cloud.binaryauthorization.v1.Attestor] that attests to container image
    artifacts. An existing attestor cannot be modified except where
    indicated.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    USER_OWNED_GRAFEAS_NOTE_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The resource name, in the format:
    `projects/*/attestors/*`. This field may not be updated.
    """

    description: typing.Text = ...
    """Optional. A descriptive comment.  This field may be updated.
    The field may be displayed in chooser dialogs.
    """

    @property
    def user_owned_grafeas_note(self) -> global___UserOwnedGrafeasNote:
        """This specifies how an attestation will be read, and how it will be used
        during policy enforcement.
        """
        pass
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Time when the attestor was last updated."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        description : typing.Text = ...,
        user_owned_grafeas_note : typing.Optional[global___UserOwnedGrafeasNote] = ...,
        update_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["attestor_type",b"attestor_type","update_time",b"update_time","user_owned_grafeas_note",b"user_owned_grafeas_note"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["attestor_type",b"attestor_type","description",b"description","name",b"name","update_time",b"update_time","user_owned_grafeas_note",b"user_owned_grafeas_note"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["attestor_type",b"attestor_type"]) -> typing.Optional[typing_extensions.Literal["user_owned_grafeas_note"]]: ...
global___Attestor = Attestor

class UserOwnedGrafeasNote(google.protobuf.message.Message):
    """An [user owned Grafeas note][google.cloud.binaryauthorization.v1.UserOwnedGrafeasNote] references a Grafeas
    Attestation.Authority Note created by the user.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NOTE_REFERENCE_FIELD_NUMBER: builtins.int
    PUBLIC_KEYS_FIELD_NUMBER: builtins.int
    DELEGATION_SERVICE_ACCOUNT_EMAIL_FIELD_NUMBER: builtins.int
    note_reference: typing.Text = ...
    """Required. The Grafeas resource name of a Attestation.Authority Note,
    created by the user, in the format: `projects/*/notes/*`. This field may
    not be updated.

    An attestation by this attestor is stored as a Grafeas
    Attestation.Authority Occurrence that names a container image and that
    links to this Note. Grafeas is an external dependency.
    """

    @property
    def public_keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AttestorPublicKey]:
        """Optional. Public keys that verify attestations signed by this
        attestor.  This field may be updated.

        If this field is non-empty, one of the specified public keys must
        verify that an attestation was signed by this attestor for the
        image specified in the admission request.

        If this field is empty, this attestor always returns that no
        valid attestations exist.
        """
        pass
    delegation_service_account_email: typing.Text = ...
    """Output only. This field will contain the service account email address
    that this Attestor will use as the principal when querying Container
    Analysis. Attestor administrators must grant this service account the
    IAM role needed to read attestations from the [note_reference][Note] in
    Container Analysis (`containeranalysis.notes.occurrences.viewer`).

    This email address is fixed for the lifetime of the Attestor, but callers
    should not make any other assumptions about the service account email;
    future versions may use an email based on a different naming pattern.
    """

    def __init__(self,
        *,
        note_reference : typing.Text = ...,
        public_keys : typing.Optional[typing.Iterable[global___AttestorPublicKey]] = ...,
        delegation_service_account_email : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["delegation_service_account_email",b"delegation_service_account_email","note_reference",b"note_reference","public_keys",b"public_keys"]) -> None: ...
global___UserOwnedGrafeasNote = UserOwnedGrafeasNote

class PkixPublicKey(google.protobuf.message.Message):
    """A public key in the PkixPublicKey format (see
    https://tools.ietf.org/html/rfc5280#section-4.1.2.7 for details).
    Public keys of this type are typically textually encoded using the PEM
    format.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _SignatureAlgorithm:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _SignatureAlgorithmEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SignatureAlgorithm.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        SIGNATURE_ALGORITHM_UNSPECIFIED: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 0
        """Not specified."""

        RSA_PSS_2048_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 1
        """RSASSA-PSS 2048 bit key with a SHA256 digest."""

        RSA_PSS_3072_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 2
        """RSASSA-PSS 3072 bit key with a SHA256 digest."""

        RSA_PSS_4096_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 3
        """RSASSA-PSS 4096 bit key with a SHA256 digest."""

        RSA_PSS_4096_SHA512: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 4
        """RSASSA-PSS 4096 bit key with a SHA512 digest."""

        RSA_SIGN_PKCS1_2048_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 5
        """RSASSA-PKCS1-v1_5 with a 2048 bit key and a SHA256 digest."""

        RSA_SIGN_PKCS1_3072_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 6
        """RSASSA-PKCS1-v1_5 with a 3072 bit key and a SHA256 digest."""

        RSA_SIGN_PKCS1_4096_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 7
        """RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA256 digest."""

        RSA_SIGN_PKCS1_4096_SHA512: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 8
        """RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA512 digest."""

        ECDSA_P256_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 9
        """ECDSA on the NIST P-256 curve with a SHA256 digest."""

        EC_SIGN_P256_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 9
        """ECDSA on the NIST P-256 curve with a SHA256 digest."""

        ECDSA_P384_SHA384: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 10
        """ECDSA on the NIST P-384 curve with a SHA384 digest."""

        EC_SIGN_P384_SHA384: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 10
        """ECDSA on the NIST P-384 curve with a SHA384 digest."""

        ECDSA_P521_SHA512: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 11
        """ECDSA on the NIST P-521 curve with a SHA512 digest."""

        EC_SIGN_P521_SHA512: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 11
        """ECDSA on the NIST P-521 curve with a SHA512 digest."""

    class SignatureAlgorithm(_SignatureAlgorithm, metaclass=_SignatureAlgorithmEnumTypeWrapper):
        """Represents a signature algorithm and other information necessary to verify
        signatures with a given public key.
        This is based primarily on the public key types supported by Tink's
        PemKeyType, which is in turn based on KMS's supported signing algorithms.
        See https://cloud.google.com/kms/docs/algorithms. In the future, BinAuthz
        might support additional public key types independently of Tink and/or KMS.
        """
        pass

    SIGNATURE_ALGORITHM_UNSPECIFIED: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 0
    """Not specified."""

    RSA_PSS_2048_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 1
    """RSASSA-PSS 2048 bit key with a SHA256 digest."""

    RSA_PSS_3072_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 2
    """RSASSA-PSS 3072 bit key with a SHA256 digest."""

    RSA_PSS_4096_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 3
    """RSASSA-PSS 4096 bit key with a SHA256 digest."""

    RSA_PSS_4096_SHA512: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 4
    """RSASSA-PSS 4096 bit key with a SHA512 digest."""

    RSA_SIGN_PKCS1_2048_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 5
    """RSASSA-PKCS1-v1_5 with a 2048 bit key and a SHA256 digest."""

    RSA_SIGN_PKCS1_3072_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 6
    """RSASSA-PKCS1-v1_5 with a 3072 bit key and a SHA256 digest."""

    RSA_SIGN_PKCS1_4096_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 7
    """RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA256 digest."""

    RSA_SIGN_PKCS1_4096_SHA512: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 8
    """RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA512 digest."""

    ECDSA_P256_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 9
    """ECDSA on the NIST P-256 curve with a SHA256 digest."""

    EC_SIGN_P256_SHA256: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 9
    """ECDSA on the NIST P-256 curve with a SHA256 digest."""

    ECDSA_P384_SHA384: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 10
    """ECDSA on the NIST P-384 curve with a SHA384 digest."""

    EC_SIGN_P384_SHA384: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 10
    """ECDSA on the NIST P-384 curve with a SHA384 digest."""

    ECDSA_P521_SHA512: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 11
    """ECDSA on the NIST P-521 curve with a SHA512 digest."""

    EC_SIGN_P521_SHA512: PkixPublicKey.SignatureAlgorithm.ValueType = ...  # 11
    """ECDSA on the NIST P-521 curve with a SHA512 digest."""


    PUBLIC_KEY_PEM_FIELD_NUMBER: builtins.int
    SIGNATURE_ALGORITHM_FIELD_NUMBER: builtins.int
    public_key_pem: typing.Text = ...
    """A PEM-encoded public key, as described in
    https://tools.ietf.org/html/rfc7468#section-13
    """

    signature_algorithm: global___PkixPublicKey.SignatureAlgorithm.ValueType = ...
    """The signature algorithm used to verify a message against a signature using
    this key.
    These signature algorithm must match the structure and any object
    identifiers encoded in `public_key_pem` (i.e. this algorithm must match
    that of the public key).
    """

    def __init__(self,
        *,
        public_key_pem : typing.Text = ...,
        signature_algorithm : global___PkixPublicKey.SignatureAlgorithm.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["public_key_pem",b"public_key_pem","signature_algorithm",b"signature_algorithm"]) -> None: ...
global___PkixPublicKey = PkixPublicKey

class AttestorPublicKey(google.protobuf.message.Message):
    """An [attestor public key][google.cloud.binaryauthorization.v1.AttestorPublicKey] that will be used to verify
    attestations signed by this attestor.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    COMMENT_FIELD_NUMBER: builtins.int
    ID_FIELD_NUMBER: builtins.int
    ASCII_ARMORED_PGP_PUBLIC_KEY_FIELD_NUMBER: builtins.int
    PKIX_PUBLIC_KEY_FIELD_NUMBER: builtins.int
    comment: typing.Text = ...
    """Optional. A descriptive comment. This field may be updated."""

    id: typing.Text = ...
    """The ID of this public key.
    Signatures verified by BinAuthz must include the ID of the public key that
    can be used to verify them, and that ID must match the contents of this
    field exactly.
    Additional restrictions on this field can be imposed based on which public
    key type is encapsulated. See the documentation on `public_key` cases below
    for details.
    """

    ascii_armored_pgp_public_key: typing.Text = ...
    """ASCII-armored representation of a PGP public key, as the entire output by
    the command `gpg --export --armor foo@example.com` (either LF or CRLF
    line endings).
    When using this field, `id` should be left blank.  The BinAuthz API
    handlers will calculate the ID and fill it in automatically.  BinAuthz
    computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as
    upper-case hex.  If `id` is provided by the caller, it will be
    overwritten by the API-calculated ID.
    """

    @property
    def pkix_public_key(self) -> global___PkixPublicKey:
        """A raw PKIX SubjectPublicKeyInfo format public key.

        NOTE: `id` may be explicitly provided by the caller when using this
        type of public key, but it MUST be a valid RFC3986 URI. If `id` is left
        blank, a default one will be computed based on the digest of the DER
        encoding of the public key.
        """
        pass
    def __init__(self,
        *,
        comment : typing.Text = ...,
        id : typing.Text = ...,
        ascii_armored_pgp_public_key : typing.Text = ...,
        pkix_public_key : typing.Optional[global___PkixPublicKey] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["ascii_armored_pgp_public_key",b"ascii_armored_pgp_public_key","pkix_public_key",b"pkix_public_key","public_key",b"public_key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["ascii_armored_pgp_public_key",b"ascii_armored_pgp_public_key","comment",b"comment","id",b"id","pkix_public_key",b"pkix_public_key","public_key",b"public_key"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["public_key",b"public_key"]) -> typing.Optional[typing_extensions.Literal["ascii_armored_pgp_public_key","pkix_public_key"]]: ...
global___AttestorPublicKey = AttestorPublicKey
