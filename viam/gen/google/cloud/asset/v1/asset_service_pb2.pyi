"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.cloud.asset.v1.assets_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.rpc.status_pb2
import google.type.expr_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _ContentType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _ContentTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ContentType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    CONTENT_TYPE_UNSPECIFIED: ContentType.ValueType = ...  # 0
    """Unspecified content type."""

    RESOURCE: ContentType.ValueType = ...  # 1
    """Resource metadata."""

    IAM_POLICY: ContentType.ValueType = ...  # 2
    """The actual IAM policy set on a resource."""

    ORG_POLICY: ContentType.ValueType = ...  # 4
    """The Cloud Organization Policy set on an asset."""

    ACCESS_POLICY: ContentType.ValueType = ...  # 5
    """The Cloud Access context manager Policy set on an asset."""

    OS_INVENTORY: ContentType.ValueType = ...  # 6
    """The runtime OS Inventory information."""

    RELATIONSHIP: ContentType.ValueType = ...  # 7
    """The related resources."""

class ContentType(_ContentType, metaclass=_ContentTypeEnumTypeWrapper):
    """Asset content type."""
    pass

CONTENT_TYPE_UNSPECIFIED: ContentType.ValueType = ...  # 0
"""Unspecified content type."""

RESOURCE: ContentType.ValueType = ...  # 1
"""Resource metadata."""

IAM_POLICY: ContentType.ValueType = ...  # 2
"""The actual IAM policy set on a resource."""

ORG_POLICY: ContentType.ValueType = ...  # 4
"""The Cloud Organization Policy set on an asset."""

ACCESS_POLICY: ContentType.ValueType = ...  # 5
"""The Cloud Access context manager Policy set on an asset."""

OS_INVENTORY: ContentType.ValueType = ...  # 6
"""The runtime OS Inventory information."""

RELATIONSHIP: ContentType.ValueType = ...  # 7
"""The related resources."""

global___ContentType = ContentType


class AnalyzeIamPolicyLongrunningMetadata(google.protobuf.message.Message):
    """Represents the metadata of the longrunning operation for the
    AnalyzeIamPolicyLongrunning rpc.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CREATE_TIME_FIELD_NUMBER: builtins.int
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The time the operation was created."""
        pass
    def __init__(self,
        *,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time",b"create_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time",b"create_time"]) -> None: ...
global___AnalyzeIamPolicyLongrunningMetadata = AnalyzeIamPolicyLongrunningMetadata

class ExportAssetsRequest(google.protobuf.message.Message):
    """Export asset request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    READ_TIME_FIELD_NUMBER: builtins.int
    ASSET_TYPES_FIELD_NUMBER: builtins.int
    CONTENT_TYPE_FIELD_NUMBER: builtins.int
    OUTPUT_CONFIG_FIELD_NUMBER: builtins.int
    RELATIONSHIP_TYPES_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The relative name of the root asset. This can only be an
    organization number (such as "organizations/123"), a project ID (such as
    "projects/my-project-id"), or a project number (such as "projects/12345"),
    or a folder number (such as "folders/123").
    """

    @property
    def read_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Timestamp to take an asset snapshot. This can only be set to a timestamp
        between the current time and the current time minus 35 days (inclusive).
        If not specified, the current time will be used. Due to delays in resource
        data collection and indexing, there is a volatile window during which
        running the same query may get different results.
        """
        pass
    @property
    def asset_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of asset types to take a snapshot for. For example:
        "compute.googleapis.com/Disk".

        Regular expressions are also supported. For example:

        * "compute.googleapis.com.*" snapshots resources whose asset type starts
        with "compute.googleapis.com".
        * ".*Instance" snapshots resources whose asset type ends with "Instance".
        * ".*Instance.*" snapshots resources whose asset type contains "Instance".

        See [RE2](https://github.com/google/re2/wiki/Syntax) for all supported
        regular expression syntax. If the regular expression does not match any
        supported asset type, an INVALID_ARGUMENT error will be returned.

        If specified, only matching assets will be returned, otherwise, it will
        snapshot all asset types. See [Introduction to Cloud Asset
        Inventory](https://cloud.google.com/asset-inventory/docs/overview)
        for all supported asset types.
        """
        pass
    content_type: global___ContentType.ValueType = ...
    """Asset content type. If not specified, no content but the asset name will be
    returned.
    """

    @property
    def output_config(self) -> global___OutputConfig:
        """Required. Output configuration indicating where the results will be output to."""
        pass
    @property
    def relationship_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of relationship types to export, for example:
        `INSTANCE_TO_INSTANCEGROUP`. This field should only be specified if
        content_type=RELATIONSHIP.
        * If specified:
        it snapshots specified relationships. It returns an error if
        any of the [relationship_types] doesn't belong to the supported
        relationship types of the [asset_types] or if any of the [asset_types]
        doesn't belong to the source types of the [relationship_types].
        * Otherwise:
        it snapshots the supported relationships for all [asset_types] or returns
        an error if any of the [asset_types] has no relationship support.
        An unspecified asset types field means all supported asset_types.
        See [Introduction to Cloud Asset
        Inventory](https://cloud.google.com/asset-inventory/docs/overview) for all
        supported asset types and relationship types.
        """
        pass
    def __init__(self,
        *,
        parent : typing.Text = ...,
        read_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        asset_types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        content_type : global___ContentType.ValueType = ...,
        output_config : typing.Optional[global___OutputConfig] = ...,
        relationship_types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["output_config",b"output_config","read_time",b"read_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["asset_types",b"asset_types","content_type",b"content_type","output_config",b"output_config","parent",b"parent","read_time",b"read_time","relationship_types",b"relationship_types"]) -> None: ...
global___ExportAssetsRequest = ExportAssetsRequest

class ExportAssetsResponse(google.protobuf.message.Message):
    """The export asset response. This message is returned by the
    [google.longrunning.Operations.GetOperation][google.longrunning.Operations.GetOperation] method in the returned
    [google.longrunning.Operation.response][google.longrunning.Operation.response] field.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    READ_TIME_FIELD_NUMBER: builtins.int
    OUTPUT_CONFIG_FIELD_NUMBER: builtins.int
    OUTPUT_RESULT_FIELD_NUMBER: builtins.int
    @property
    def read_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time the snapshot was taken."""
        pass
    @property
    def output_config(self) -> global___OutputConfig:
        """Output configuration indicating where the results were output to."""
        pass
    @property
    def output_result(self) -> global___OutputResult:
        """Output result indicating where the assets were exported to. For example, a
        set of actual Google Cloud Storage object uris where the assets are
        exported to. The uris can be different from what [output_config] has
        specified, as the service will split the output object into multiple ones
        once it exceeds a single Google Cloud Storage object limit.
        """
        pass
    def __init__(self,
        *,
        read_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        output_config : typing.Optional[global___OutputConfig] = ...,
        output_result : typing.Optional[global___OutputResult] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["output_config",b"output_config","output_result",b"output_result","read_time",b"read_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["output_config",b"output_config","output_result",b"output_result","read_time",b"read_time"]) -> None: ...
global___ExportAssetsResponse = ExportAssetsResponse

class ListAssetsRequest(google.protobuf.message.Message):
    """ListAssets request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    READ_TIME_FIELD_NUMBER: builtins.int
    ASSET_TYPES_FIELD_NUMBER: builtins.int
    CONTENT_TYPE_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    RELATIONSHIP_TYPES_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Name of the organization or project the assets belong to. Format:
    "organizations/[organization-number]" (such as "organizations/123"),
    "projects/[project-id]" (such as "projects/my-project-id"), or
    "projects/[project-number]" (such as "projects/12345").
    """

    @property
    def read_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Timestamp to take an asset snapshot. This can only be set to a timestamp
        between the current time and the current time minus 35 days (inclusive).
        If not specified, the current time will be used. Due to delays in resource
        data collection and indexing, there is a volatile window during which
        running the same query may get different results.
        """
        pass
    @property
    def asset_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of asset types to take a snapshot for. For example:
        "compute.googleapis.com/Disk".

        Regular expression is also supported. For example:

        * "compute.googleapis.com.*" snapshots resources whose asset type starts
        with "compute.googleapis.com".
        * ".*Instance" snapshots resources whose asset type ends with "Instance".
        * ".*Instance.*" snapshots resources whose asset type contains "Instance".

        See [RE2](https://github.com/google/re2/wiki/Syntax) for all supported
        regular expression syntax. If the regular expression does not match any
        supported asset type, an INVALID_ARGUMENT error will be returned.

        If specified, only matching assets will be returned, otherwise, it will
        snapshot all asset types. See [Introduction to Cloud Asset
        Inventory](https://cloud.google.com/asset-inventory/docs/overview)
        for all supported asset types.
        """
        pass
    content_type: global___ContentType.ValueType = ...
    """Asset content type. If not specified, no content but the asset name will
    be returned.
    """

    page_size: builtins.int = ...
    """The maximum number of assets to be returned in a single response. Default
    is 100, minimum is 1, and maximum is 1000.
    """

    page_token: typing.Text = ...
    """The `next_page_token` returned from the previous `ListAssetsResponse`, or
    unspecified for the first `ListAssetsRequest`. It is a continuation of a
    prior `ListAssets` call, and the API should return the next page of assets.
    """

    @property
    def relationship_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of relationship types to output, for example:
        `INSTANCE_TO_INSTANCEGROUP`. This field should only be specified if
        content_type=RELATIONSHIP.
        * If specified:
        it snapshots specified relationships. It returns an error if
        any of the [relationship_types] doesn't belong to the supported
        relationship types of the [asset_types] or if any of the [asset_types]
        doesn't belong to the source types of the [relationship_types].
        * Otherwise:
        it snapshots the supported relationships for all [asset_types] or returns
        an error if any of the [asset_types] has no relationship support.
        An unspecified asset types field means all supported asset_types.
        See [Introduction to Cloud Asset
        Inventory](https://cloud.google.com/asset-inventory/docs/overview)
        for all supported asset types and relationship types.
        """
        pass
    def __init__(self,
        *,
        parent : typing.Text = ...,
        read_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        asset_types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        content_type : global___ContentType.ValueType = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        relationship_types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["read_time",b"read_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["asset_types",b"asset_types","content_type",b"content_type","page_size",b"page_size","page_token",b"page_token","parent",b"parent","read_time",b"read_time","relationship_types",b"relationship_types"]) -> None: ...
global___ListAssetsRequest = ListAssetsRequest

class ListAssetsResponse(google.protobuf.message.Message):
    """ListAssets response."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    READ_TIME_FIELD_NUMBER: builtins.int
    ASSETS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def read_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time the snapshot was taken."""
        pass
    @property
    def assets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.cloud.asset.v1.assets_pb2.Asset]:
        """Assets."""
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results. It expires 72 hours after the
    page token for the first page is generated. Set to empty if there are no
    remaining results.
    """

    def __init__(self,
        *,
        read_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        assets : typing.Optional[typing.Iterable[google.cloud.asset.v1.assets_pb2.Asset]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["read_time",b"read_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["assets",b"assets","next_page_token",b"next_page_token","read_time",b"read_time"]) -> None: ...
global___ListAssetsResponse = ListAssetsResponse

class BatchGetAssetsHistoryRequest(google.protobuf.message.Message):
    """Batch get assets history request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    ASSET_NAMES_FIELD_NUMBER: builtins.int
    CONTENT_TYPE_FIELD_NUMBER: builtins.int
    READ_TIME_WINDOW_FIELD_NUMBER: builtins.int
    RELATIONSHIP_TYPES_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The relative name of the root asset. It can only be an
    organization number (such as "organizations/123"), a project ID (such as
    "projects/my-project-id")", or a project number (such as "projects/12345").
    """

    @property
    def asset_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of the full names of the assets.
        See: https://cloud.google.com/asset-inventory/docs/resource-name-format
        Example:

        `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.

        The request becomes a no-op if the asset name list is empty, and the max
        size of the asset name list is 100 in one request.
        """
        pass
    content_type: global___ContentType.ValueType = ...
    """Optional. The content type."""

    @property
    def read_time_window(self) -> google.cloud.asset.v1.assets_pb2.TimeWindow:
        """Optional. The time window for the asset history. Both start_time and
        end_time are optional and if set, it must be after the current time minus
        35 days. If end_time is not set, it is default to current timestamp.
        If start_time is not set, the snapshot of the assets at end_time will be
        returned. The returned results contain all temporal assets whose time
        window overlap with read_time_window.
        """
        pass
    @property
    def relationship_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Optional. A list of relationship types to output, for example:
        `INSTANCE_TO_INSTANCEGROUP`. This field should only be specified if
        content_type=RELATIONSHIP.
        * If specified:
        it outputs specified relationships' history on the [asset_names]. It
        returns an error if any of the [relationship_types] doesn't belong to the
        supported relationship types of the [asset_names] or if any of the
        [asset_names]'s types doesn't belong to the source types of the
        [relationship_types].
        * Otherwise:
        it outputs the supported relationships' history on the [asset_names] or
        returns an error if any of the [asset_names]'s types has no relationship
        support.
        See [Introduction to Cloud Asset
        Inventory](https://cloud.google.com/asset-inventory/docs/overview) for all
        supported asset types and relationship types.
        """
        pass
    def __init__(self,
        *,
        parent : typing.Text = ...,
        asset_names : typing.Optional[typing.Iterable[typing.Text]] = ...,
        content_type : global___ContentType.ValueType = ...,
        read_time_window : typing.Optional[google.cloud.asset.v1.assets_pb2.TimeWindow] = ...,
        relationship_types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["read_time_window",b"read_time_window"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["asset_names",b"asset_names","content_type",b"content_type","parent",b"parent","read_time_window",b"read_time_window","relationship_types",b"relationship_types"]) -> None: ...
global___BatchGetAssetsHistoryRequest = BatchGetAssetsHistoryRequest

class BatchGetAssetsHistoryResponse(google.protobuf.message.Message):
    """Batch get assets history response."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ASSETS_FIELD_NUMBER: builtins.int
    @property
    def assets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.cloud.asset.v1.assets_pb2.TemporalAsset]:
        """A list of assets with valid time windows."""
        pass
    def __init__(self,
        *,
        assets : typing.Optional[typing.Iterable[google.cloud.asset.v1.assets_pb2.TemporalAsset]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["assets",b"assets"]) -> None: ...
global___BatchGetAssetsHistoryResponse = BatchGetAssetsHistoryResponse

class CreateFeedRequest(google.protobuf.message.Message):
    """Create asset feed request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    FEED_ID_FIELD_NUMBER: builtins.int
    FEED_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The name of the project/folder/organization where this feed
    should be created in. It can only be an organization number (such as
    "organizations/123"), a folder number (such as "folders/123"), a project ID
    (such as "projects/my-project-id")", or a project number (such as
    "projects/12345").
    """

    feed_id: typing.Text = ...
    """Required. This is the client-assigned asset feed identifier and it needs to
    be unique under a specific parent project/folder/organization.
    """

    @property
    def feed(self) -> global___Feed:
        """Required. The feed details. The field `name` must be empty and it will be generated
        in the format of:
        projects/project_number/feeds/feed_id
        folders/folder_number/feeds/feed_id
        organizations/organization_number/feeds/feed_id
        """
        pass
    def __init__(self,
        *,
        parent : typing.Text = ...,
        feed_id : typing.Text = ...,
        feed : typing.Optional[global___Feed] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["feed",b"feed"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["feed",b"feed","feed_id",b"feed_id","parent",b"parent"]) -> None: ...
global___CreateFeedRequest = CreateFeedRequest

class GetFeedRequest(google.protobuf.message.Message):
    """Get asset feed request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the Feed and it must be in the format of:
    projects/project_number/feeds/feed_id
    folders/folder_number/feeds/feed_id
    organizations/organization_number/feeds/feed_id
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetFeedRequest = GetFeedRequest

class ListFeedsRequest(google.protobuf.message.Message):
    """List asset feeds request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The parent project/folder/organization whose feeds are to be
    listed. It can only be using project/folder/organization number (such as
    "folders/12345")", or a project ID (such as "projects/my-project-id").
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["parent",b"parent"]) -> None: ...
global___ListFeedsRequest = ListFeedsRequest

class ListFeedsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FEEDS_FIELD_NUMBER: builtins.int
    @property
    def feeds(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Feed]:
        """A list of feeds."""
        pass
    def __init__(self,
        *,
        feeds : typing.Optional[typing.Iterable[global___Feed]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["feeds",b"feeds"]) -> None: ...
global___ListFeedsResponse = ListFeedsResponse

class UpdateFeedRequest(google.protobuf.message.Message):
    """Update asset feed request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FEED_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    @property
    def feed(self) -> global___Feed:
        """Required. The new values of feed details. It must match an existing feed and the
        field `name` must be in the format of:
        projects/project_number/feeds/feed_id or
        folders/folder_number/feeds/feed_id or
        organizations/organization_number/feeds/feed_id.
        """
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Required. Only updates the `feed` fields indicated by this mask.
        The field mask must not be empty, and it must not contain fields that
        are immutable or only set by the server.
        """
        pass
    def __init__(self,
        *,
        feed : typing.Optional[global___Feed] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["feed",b"feed","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["feed",b"feed","update_mask",b"update_mask"]) -> None: ...
global___UpdateFeedRequest = UpdateFeedRequest

class DeleteFeedRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the feed and it must be in the format of:
    projects/project_number/feeds/feed_id
    folders/folder_number/feeds/feed_id
    organizations/organization_number/feeds/feed_id
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___DeleteFeedRequest = DeleteFeedRequest

class OutputConfig(google.protobuf.message.Message):
    """Output configuration for export assets destination."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GCS_DESTINATION_FIELD_NUMBER: builtins.int
    BIGQUERY_DESTINATION_FIELD_NUMBER: builtins.int
    @property
    def gcs_destination(self) -> global___GcsDestination:
        """Destination on Cloud Storage."""
        pass
    @property
    def bigquery_destination(self) -> global___BigQueryDestination:
        """Destination on BigQuery. The output table stores the fields in asset
        proto as columns in BigQuery.
        """
        pass
    def __init__(self,
        *,
        gcs_destination : typing.Optional[global___GcsDestination] = ...,
        bigquery_destination : typing.Optional[global___BigQueryDestination] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bigquery_destination",b"bigquery_destination","destination",b"destination","gcs_destination",b"gcs_destination"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bigquery_destination",b"bigquery_destination","destination",b"destination","gcs_destination",b"gcs_destination"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["destination",b"destination"]) -> typing.Optional[typing_extensions.Literal["gcs_destination","bigquery_destination"]]: ...
global___OutputConfig = OutputConfig

class OutputResult(google.protobuf.message.Message):
    """Output result of export assets."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GCS_RESULT_FIELD_NUMBER: builtins.int
    @property
    def gcs_result(self) -> global___GcsOutputResult:
        """Export result on Cloud Storage."""
        pass
    def __init__(self,
        *,
        gcs_result : typing.Optional[global___GcsOutputResult] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["gcs_result",b"gcs_result","result",b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["gcs_result",b"gcs_result","result",b"result"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["result",b"result"]) -> typing.Optional[typing_extensions.Literal["gcs_result"]]: ...
global___OutputResult = OutputResult

class GcsOutputResult(google.protobuf.message.Message):
    """A Cloud Storage output result."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    URIS_FIELD_NUMBER: builtins.int
    @property
    def uris(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """List of uris of the Cloud Storage objects. Example:
        "gs://bucket_name/object_name".
        """
        pass
    def __init__(self,
        *,
        uris : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["uris",b"uris"]) -> None: ...
global___GcsOutputResult = GcsOutputResult

class GcsDestination(google.protobuf.message.Message):
    """A Cloud Storage location."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    URI_FIELD_NUMBER: builtins.int
    URI_PREFIX_FIELD_NUMBER: builtins.int
    uri: typing.Text = ...
    """The uri of the Cloud Storage object. It's the same uri that is used by
    gsutil. Example: "gs://bucket_name/object_name". See [Viewing and
    Editing Object
    Metadata](https://cloud.google.com/storage/docs/viewing-editing-metadata)
    for more information.

    If the specified Cloud Storage object already exists and there is no
    [hold](https://cloud.google.com/storage/docs/object-holds), it will be
    overwritten with the exported result.
    """

    uri_prefix: typing.Text = ...
    """The uri prefix of all generated Cloud Storage objects. Example:
    "gs://bucket_name/object_name_prefix". Each object uri is in format:
    "gs://bucket_name/object_name_prefix/<asset type>/<shard number> and only
    contains assets for that type. <shard number> starts from 0. Example:
    "gs://bucket_name/object_name_prefix/compute.googleapis.com/Disk/0" is
    the first shard of output objects containing all
    compute.googleapis.com/Disk assets. An INVALID_ARGUMENT error will be
    returned if file with the same name "gs://bucket_name/object_name_prefix"
    already exists.
    """

    def __init__(self,
        *,
        uri : typing.Text = ...,
        uri_prefix : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["object_uri",b"object_uri","uri",b"uri","uri_prefix",b"uri_prefix"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["object_uri",b"object_uri","uri",b"uri","uri_prefix",b"uri_prefix"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["object_uri",b"object_uri"]) -> typing.Optional[typing_extensions.Literal["uri","uri_prefix"]]: ...
global___GcsDestination = GcsDestination

class BigQueryDestination(google.protobuf.message.Message):
    """A BigQuery destination for exporting assets to."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATASET_FIELD_NUMBER: builtins.int
    TABLE_FIELD_NUMBER: builtins.int
    FORCE_FIELD_NUMBER: builtins.int
    PARTITION_SPEC_FIELD_NUMBER: builtins.int
    SEPARATE_TABLES_PER_ASSET_TYPE_FIELD_NUMBER: builtins.int
    dataset: typing.Text = ...
    """Required. The BigQuery dataset in format
    "projects/projectId/datasets/datasetId", to which the snapshot result
    should be exported. If this dataset does not exist, the export call returns
    an INVALID_ARGUMENT error.
    """

    table: typing.Text = ...
    """Required. The BigQuery table to which the snapshot result should be
    written. If this table does not exist, a new table with the given name
    will be created.
    """

    force: builtins.bool = ...
    """If the destination table already exists and this flag is `TRUE`, the
    table will be overwritten by the contents of assets snapshot. If the flag
    is `FALSE` or unset and the destination table already exists, the export
    call returns an INVALID_ARGUMEMT error.
    """

    @property
    def partition_spec(self) -> global___PartitionSpec:
        """[partition_spec] determines whether to export to partitioned table(s) and
        how to partition the data.

        If [partition_spec] is unset or [partition_spec.partition_key] is unset or
        `PARTITION_KEY_UNSPECIFIED`, the snapshot results will be exported to
        non-partitioned table(s). [force] will decide whether to overwrite existing
        table(s).

        If [partition_spec] is specified. First, the snapshot results will be
        written to partitioned table(s) with two additional timestamp columns,
        readTime and requestTime, one of which will be the partition key. Secondly,
        in the case when any destination table already exists, it will first try to
        update existing table's schema as necessary by appending additional
        columns. Then, if [force] is `TRUE`, the corresponding partition will be
        overwritten by the snapshot results (data in different partitions will
        remain intact); if [force] is unset or `FALSE`, it will append the data. An
        error will be returned if the schema update or data appension fails.
        """
        pass
    separate_tables_per_asset_type: builtins.bool = ...
    """If this flag is `TRUE`, the snapshot results will be written to one or
    multiple tables, each of which contains results of one asset type. The
    [force] and [partition_spec] fields will apply to each of them.

    Field [table] will be concatenated with "_" and the asset type names (see
    https://cloud.google.com/asset-inventory/docs/supported-asset-types for
    supported asset types) to construct per-asset-type table names, in which
    all non-alphanumeric characters like "." and "/" will be substituted by
    "_". Example: if field [table] is "mytable" and snapshot results
    contain "storage.googleapis.com/Bucket" assets, the corresponding table
    name will be "mytable_storage_googleapis_com_Bucket". If any of these
    tables does not exist, a new table with the concatenated name will be
    created.

    When [content_type] in the ExportAssetsRequest is `RESOURCE`, the schema of
    each table will include RECORD-type columns mapped to the nested fields in
    the Asset.resource.data field of that asset type (up to the 15 nested level
    BigQuery supports
    (https://cloud.google.com/bigquery/docs/nested-repeated#limitations)). The
    fields in >15 nested levels will be stored in JSON format string as a child
    column of its parent RECORD column.

    If error occurs when exporting to any table, the whole export call will
    return an error but the export results that already succeed will persist.
    Example: if exporting to table_type_A succeeds when exporting to
    table_type_B fails during one export call, the results in table_type_A will
    persist and there will not be partial results persisting in a table.
    """

    def __init__(self,
        *,
        dataset : typing.Text = ...,
        table : typing.Text = ...,
        force : builtins.bool = ...,
        partition_spec : typing.Optional[global___PartitionSpec] = ...,
        separate_tables_per_asset_type : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["partition_spec",b"partition_spec"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset",b"dataset","force",b"force","partition_spec",b"partition_spec","separate_tables_per_asset_type",b"separate_tables_per_asset_type","table",b"table"]) -> None: ...
global___BigQueryDestination = BigQueryDestination

class PartitionSpec(google.protobuf.message.Message):
    """Specifications of BigQuery partitioned table as export destination."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _PartitionKey:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _PartitionKeyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PartitionKey.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        PARTITION_KEY_UNSPECIFIED: PartitionSpec.PartitionKey.ValueType = ...  # 0
        """Unspecified partition key. If used, it means using non-partitioned table."""

        READ_TIME: PartitionSpec.PartitionKey.ValueType = ...  # 1
        """The time when the snapshot is taken. If specified as partition key, the
        result table(s) is partitoned by the additional timestamp column,
        readTime. If [read_time] in ExportAssetsRequest is specified, the
        readTime column's value will be the same as it. Otherwise, its value will
        be the current time that is used to take the snapshot.
        """

        REQUEST_TIME: PartitionSpec.PartitionKey.ValueType = ...  # 2
        """The time when the request is received and started to be processed. If
        specified as partition key, the result table(s) is partitoned by the
        requestTime column, an additional timestamp column representing when the
        request was received.
        """

    class PartitionKey(_PartitionKey, metaclass=_PartitionKeyEnumTypeWrapper):
        """This enum is used to determine the partition key column when exporting
        assets to BigQuery partitioned table(s). Note that, if the partition key is
        a timestamp column, the actual partition is based on its date value
        (expressed in UTC. see details in
        https://cloud.google.com/bigquery/docs/partitioned-tables#date_timestamp_partitioned_tables).
        """
        pass

    PARTITION_KEY_UNSPECIFIED: PartitionSpec.PartitionKey.ValueType = ...  # 0
    """Unspecified partition key. If used, it means using non-partitioned table."""

    READ_TIME: PartitionSpec.PartitionKey.ValueType = ...  # 1
    """The time when the snapshot is taken. If specified as partition key, the
    result table(s) is partitoned by the additional timestamp column,
    readTime. If [read_time] in ExportAssetsRequest is specified, the
    readTime column's value will be the same as it. Otherwise, its value will
    be the current time that is used to take the snapshot.
    """

    REQUEST_TIME: PartitionSpec.PartitionKey.ValueType = ...  # 2
    """The time when the request is received and started to be processed. If
    specified as partition key, the result table(s) is partitoned by the
    requestTime column, an additional timestamp column representing when the
    request was received.
    """


    PARTITION_KEY_FIELD_NUMBER: builtins.int
    partition_key: global___PartitionSpec.PartitionKey.ValueType = ...
    """The partition key for BigQuery partitioned table."""

    def __init__(self,
        *,
        partition_key : global___PartitionSpec.PartitionKey.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["partition_key",b"partition_key"]) -> None: ...
global___PartitionSpec = PartitionSpec

class PubsubDestination(google.protobuf.message.Message):
    """A Pub/Sub destination."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TOPIC_FIELD_NUMBER: builtins.int
    topic: typing.Text = ...
    """The name of the Pub/Sub topic to publish to.
    Example: `projects/PROJECT_ID/topics/TOPIC_ID`.
    """

    def __init__(self,
        *,
        topic : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["topic",b"topic"]) -> None: ...
global___PubsubDestination = PubsubDestination

class FeedOutputConfig(google.protobuf.message.Message):
    """Output configuration for asset feed destination."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PUBSUB_DESTINATION_FIELD_NUMBER: builtins.int
    @property
    def pubsub_destination(self) -> global___PubsubDestination:
        """Destination on Pub/Sub."""
        pass
    def __init__(self,
        *,
        pubsub_destination : typing.Optional[global___PubsubDestination] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["destination",b"destination","pubsub_destination",b"pubsub_destination"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["destination",b"destination","pubsub_destination",b"pubsub_destination"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["destination",b"destination"]) -> typing.Optional[typing_extensions.Literal["pubsub_destination"]]: ...
global___FeedOutputConfig = FeedOutputConfig

class Feed(google.protobuf.message.Message):
    """An asset feed used to export asset updates to a destinations.
    An asset feed filter controls what updates are exported.
    The asset feed must be created within a project, organization, or
    folder. Supported destinations are:
    Pub/Sub topics.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    ASSET_NAMES_FIELD_NUMBER: builtins.int
    ASSET_TYPES_FIELD_NUMBER: builtins.int
    CONTENT_TYPE_FIELD_NUMBER: builtins.int
    FEED_OUTPUT_CONFIG_FIELD_NUMBER: builtins.int
    CONDITION_FIELD_NUMBER: builtins.int
    RELATIONSHIP_TYPES_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The format will be
    projects/{project_number}/feeds/{client-assigned_feed_identifier} or
    folders/{folder_number}/feeds/{client-assigned_feed_identifier} or
    organizations/{organization_number}/feeds/{client-assigned_feed_identifier}

    The client-assigned feed identifier must be unique within the parent
    project/folder/organization.
    """

    @property
    def asset_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of the full names of the assets to receive updates. You must specify
        either or both of asset_names and asset_types. Only asset updates matching
        specified asset_names or asset_types are exported to the feed.
        Example:
        `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
        See [Resource
        Names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
        for more info.
        """
        pass
    @property
    def asset_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of types of the assets to receive updates. You must specify either
        or both of asset_names and asset_types. Only asset updates matching
        specified asset_names or asset_types are exported to the feed.
        Example: `"compute.googleapis.com/Disk"`

        See [this
        topic](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
        for a list of all supported asset types.
        """
        pass
    content_type: global___ContentType.ValueType = ...
    """Asset content type. If not specified, no content but the asset name and
    type will be returned.
    """

    @property
    def feed_output_config(self) -> global___FeedOutputConfig:
        """Required. Feed output configuration defining where the asset updates are
        published to.
        """
        pass
    @property
    def condition(self) -> google.type.expr_pb2.Expr:
        """A condition which determines whether an asset update should be published.
        If specified, an asset will be returned only when the expression evaluates
        to true.
        When set, `expression` field in the `Expr` must be a valid [CEL expression]
        (https://github.com/google/cel-spec) on a TemporalAsset with name
        `temporal_asset`. Example: a Feed with expression ("temporal_asset.deleted
        == true") will only publish Asset deletions. Other fields of `Expr` are
        optional.

        See our [user
        guide](https://cloud.google.com/asset-inventory/docs/monitoring-asset-changes-with-condition)
        for detailed instructions.
        """
        pass
    @property
    def relationship_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of relationship types to output, for example:
        `INSTANCE_TO_INSTANCEGROUP`. This field should only be specified if
        content_type=RELATIONSHIP.
        * If specified:
        it outputs specified relationship updates on the [asset_names] or the
        [asset_types]. It returns an error if any of the [relationship_types]
        doesn't belong to the supported relationship types of the [asset_names] or
        [asset_types], or any of the [asset_names] or the [asset_types] doesn't
        belong to the source types of the [relationship_types].
        * Otherwise:
        it outputs the supported relationships of the types of [asset_names] and
        [asset_types] or returns an error if any of the [asset_names] or the
        [asset_types] has no replationship support.
        See [Introduction to Cloud Asset
        Inventory](https://cloud.google.com/asset-inventory/docs/overview)
        for all supported asset types and relationship types.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        asset_names : typing.Optional[typing.Iterable[typing.Text]] = ...,
        asset_types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        content_type : global___ContentType.ValueType = ...,
        feed_output_config : typing.Optional[global___FeedOutputConfig] = ...,
        condition : typing.Optional[google.type.expr_pb2.Expr] = ...,
        relationship_types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["condition",b"condition","feed_output_config",b"feed_output_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["asset_names",b"asset_names","asset_types",b"asset_types","condition",b"condition","content_type",b"content_type","feed_output_config",b"feed_output_config","name",b"name","relationship_types",b"relationship_types"]) -> None: ...
global___Feed = Feed

class SearchAllResourcesRequest(google.protobuf.message.Message):
    """Search all resources request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SCOPE_FIELD_NUMBER: builtins.int
    QUERY_FIELD_NUMBER: builtins.int
    ASSET_TYPES_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    ORDER_BY_FIELD_NUMBER: builtins.int
    READ_MASK_FIELD_NUMBER: builtins.int
    scope: typing.Text = ...
    """Required. A scope can be a project, a folder, or an organization. The search is
    limited to the resources within the `scope`. The caller must be granted the
    [`cloudasset.assets.searchAllResources`](https://cloud.google.com/asset-inventory/docs/access-control#required_permissions)
    permission on the desired scope.

    The allowed values are:

    * projects/{PROJECT_ID} (e.g., "projects/foo-bar")
    * projects/{PROJECT_NUMBER} (e.g., "projects/12345678")
    * folders/{FOLDER_NUMBER} (e.g., "folders/1234567")
    * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
    """

    query: typing.Text = ...
    """Optional. The query statement. See [how to construct a
    query](https://cloud.google.com/asset-inventory/docs/searching-resources#how_to_construct_a_query)
    for more information. If not specified or empty, it will search all the
    resources within the specified `scope`.

    Examples:

    * `name:Important` to find Cloud resources whose name contains
      "Important" as a word.
    * `name=Important` to find the Cloud resource whose name is exactly
      "Important".
    * `displayName:Impor*` to find Cloud resources whose display name
      contains "Impor" as a prefix of any word in the field.
    * `location:us-west*` to find Cloud resources whose location contains both
      "us" and "west" as prefixes.
    * `labels:prod` to find Cloud resources whose labels contain "prod" as
      a key or value.
    * `labels.env:prod` to find Cloud resources that have a label "env"
      and its value is "prod".
    * `labels.env:*` to find Cloud resources that have a label "env".
    * `kmsKey:key` to find Cloud resources encrypted with a customer-managed
      encryption key whose name contains the word "key".
    * `state:ACTIVE` to find Cloud resources whose state contains "ACTIVE" as a
      word.
    * `NOT state:ACTIVE` to find Cloud resources whose state doesn't contain
      "ACTIVE" as a word.
    * `createTime<1609459200` to find Cloud resources that were created before
      "2021-01-01 00:00:00 UTC". 1609459200 is the epoch timestamp of
      "2021-01-01 00:00:00 UTC" in seconds.
    * `updateTime>1609459200` to find Cloud resources that were updated after
      "2021-01-01 00:00:00 UTC". 1609459200 is the epoch timestamp of
      "2021-01-01 00:00:00 UTC" in seconds.
    * `Important` to find Cloud resources that contain "Important" as a word
      in any of the searchable fields.
    * `Impor*` to find Cloud resources that contain "Impor" as a prefix of any
      word in any of the searchable fields.
    * `Important location:(us-west1 OR global)` to find Cloud
      resources that contain "Important" as a word in any of the searchable
      fields and are also located in the "us-west1" region or the "global"
      location.
    """

    @property
    def asset_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Optional. A list of asset types that this request searches for. If empty, it will
        search all the [searchable asset
        types](https://cloud.google.com/asset-inventory/docs/supported-asset-types#searchable_asset_types).

        Regular expressions are also supported. For example:

        * "compute.googleapis.com.*" snapshots resources whose asset type starts
        with "compute.googleapis.com".
        * ".*Instance" snapshots resources whose asset type ends with "Instance".
        * ".*Instance.*" snapshots resources whose asset type contains "Instance".

        See [RE2](https://github.com/google/re2/wiki/Syntax) for all supported
        regular expression syntax. If the regular expression does not match any
        supported asset type, an INVALID_ARGUMENT error will be returned.
        """
        pass
    page_size: builtins.int = ...
    """Optional. The page size for search result pagination. Page size is capped at 500 even
    if a larger value is given. If set to zero, server will pick an appropriate
    default. Returned results may be fewer than requested. When this happens,
    there could be more results as long as `next_page_token` is returned.
    """

    page_token: typing.Text = ...
    """Optional. If present, then retrieve the next batch of results from the preceding call
    to this method. `page_token` must be the value of `next_page_token` from
    the previous response. The values of all other method parameters, must be
    identical to those in the previous call.
    """

    order_by: typing.Text = ...
    """Optional. A comma-separated list of fields specifying the sorting order of the
    results. The default order is ascending. Add " DESC" after the field name
    to indicate descending order. Redundant space characters are ignored.
    Example: "location DESC, name".
    Only singular primitive fields in the response are sortable:

      * name
      * assetType
      * project
      * displayName
      * description
      * location
      * kmsKey
      * createTime
      * updateTime
      * state
      * parentFullResourceName
      * parentAssetType

    All the other fields such as repeated fields (e.g., `networkTags`), map
    fields (e.g., `labels`) and struct fields (e.g., `additionalAttributes`)
    are not supported.
    """

    @property
    def read_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Optional. A comma-separated list of fields specifying which fields to be returned in
        ResourceSearchResult. Only '*' or combination of top level fields can be
        specified. Field names of both snake_case and camelCase are supported.
        Examples: `"*"`, `"name,location"`, `"name,versionedResources"`.

        The read_mask paths must be valid field paths listed but not limited to
        (both snake_case and camelCase are supported):

          * name
          * assetType
          * project
          * displayName
          * description
          * location
          * labels
          * networkTags
          * kmsKey
          * createTime
          * updateTime
          * state
          * additionalAttributes
          * versionedResources

        If read_mask is not specified, all fields except versionedResources will
        be returned.
        If only '*' is specified, all fields including versionedResources will be
        returned.
        Any invalid field path will trigger INVALID_ARGUMENT error.
        """
        pass
    def __init__(self,
        *,
        scope : typing.Text = ...,
        query : typing.Text = ...,
        asset_types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        order_by : typing.Text = ...,
        read_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["read_mask",b"read_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["asset_types",b"asset_types","order_by",b"order_by","page_size",b"page_size","page_token",b"page_token","query",b"query","read_mask",b"read_mask","scope",b"scope"]) -> None: ...
global___SearchAllResourcesRequest = SearchAllResourcesRequest

class SearchAllResourcesResponse(google.protobuf.message.Message):
    """Search all resources response."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RESULTS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.cloud.asset.v1.assets_pb2.ResourceSearchResult]:
        """A list of Resources that match the search query. It contains the resource
        standard metadata information.
        """
        pass
    next_page_token: typing.Text = ...
    """If there are more results than those appearing in this response, then
    `next_page_token` is included. To get the next set of results, call this
    method again using the value of `next_page_token` as `page_token`.
    """

    def __init__(self,
        *,
        results : typing.Optional[typing.Iterable[google.cloud.asset.v1.assets_pb2.ResourceSearchResult]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["next_page_token",b"next_page_token","results",b"results"]) -> None: ...
global___SearchAllResourcesResponse = SearchAllResourcesResponse

class SearchAllIamPoliciesRequest(google.protobuf.message.Message):
    """Search all IAM policies request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SCOPE_FIELD_NUMBER: builtins.int
    QUERY_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    ASSET_TYPES_FIELD_NUMBER: builtins.int
    ORDER_BY_FIELD_NUMBER: builtins.int
    scope: typing.Text = ...
    """Required. A scope can be a project, a folder, or an organization. The search is
    limited to the IAM policies within the `scope`. The caller must be granted
    the
    [`cloudasset.assets.searchAllIamPolicies`](https://cloud.google.com/asset-inventory/docs/access-control#required_permissions)
    permission on the desired scope.

    The allowed values are:

    * projects/{PROJECT_ID} (e.g., "projects/foo-bar")
    * projects/{PROJECT_NUMBER} (e.g., "projects/12345678")
    * folders/{FOLDER_NUMBER} (e.g., "folders/1234567")
    * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
    """

    query: typing.Text = ...
    """Optional. The query statement. See [how to construct a
    query](https://cloud.google.com/asset-inventory/docs/searching-iam-policies#how_to_construct_a_query)
    for more information. If not specified or empty, it will search all the
    IAM policies within the specified `scope`. Note that the query string is
    compared against each Cloud IAM policy binding, including its members,
    roles, and Cloud IAM conditions. The returned Cloud IAM policies will only
    contain the bindings that match your query. To learn more about the IAM
    policy structure, see [IAM policy
    doc](https://cloud.google.com/iam/docs/policies#structure).

    Examples:

    * `policy:amy@gmail.com` to find IAM policy bindings that specify user
      "amy@gmail.com".
    * `policy:roles/compute.admin` to find IAM policy bindings that specify
      the Compute Admin role.
    * `policy:comp*` to find IAM policy bindings that contain "comp" as a
      prefix of any word in the binding.
    * `policy.role.permissions:storage.buckets.update` to find IAM policy
      bindings that specify a role containing "storage.buckets.update"
      permission. Note that if callers don't have `iam.roles.get` access to a
      role's included permissions, policy bindings that specify this role will
      be dropped from the search results.
    * `policy.role.permissions:upd*` to find IAM policy bindings that specify a
      role containing "upd" as a prefix of any word in the role permission.
      Note that if callers don't have `iam.roles.get` access to a role's
      included permissions, policy bindings that specify this role will be
      dropped from the search results.
    * `resource:organizations/123456` to find IAM policy bindings
      that are set on "organizations/123456".
    * `resource=//cloudresourcemanager.googleapis.com/projects/myproject` to
      find IAM policy bindings that are set on the project named "myproject".
    * `Important` to find IAM policy bindings that contain "Important" as a
      word in any of the searchable fields (except for the included
      permissions).
    * `resource:(instance1 OR instance2) policy:amy` to find
      IAM policy bindings that are set on resources "instance1" or
      "instance2" and also specify user "amy".
    * `roles:roles/compute.admin` to find IAM policy bindings that specify the
      Compute Admin role.
    * `memberTypes:user` to find IAM policy bindings that contain the "user"
      member type.
    """

    page_size: builtins.int = ...
    """Optional. The page size for search result pagination. Page size is capped at 500 even
    if a larger value is given. If set to zero, server will pick an appropriate
    default. Returned results may be fewer than requested. When this happens,
    there could be more results as long as `next_page_token` is returned.
    """

    page_token: typing.Text = ...
    """Optional. If present, retrieve the next batch of results from the preceding call to
    this method. `page_token` must be the value of `next_page_token` from the
    previous response. The values of all other method parameters must be
    identical to those in the previous call.
    """

    @property
    def asset_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Optional. A list of asset types that the IAM policies are attached to. If empty, it
        will search the IAM policies that are attached to all the [searchable asset
        types](https://cloud.google.com/asset-inventory/docs/supported-asset-types#searchable_asset_types).

        Regular expressions are also supported. For example:

        * "compute.googleapis.com.*" snapshots IAM policies attached to asset type
        starts with "compute.googleapis.com".
        * ".*Instance" snapshots IAM policies attached to asset type ends with
        "Instance".
        * ".*Instance.*" snapshots IAM policies attached to asset type contains
        "Instance".

        See [RE2](https://github.com/google/re2/wiki/Syntax) for all supported
        regular expression syntax. If the regular expression does not match any
        supported asset type, an INVALID_ARGUMENT error will be returned.
        """
        pass
    order_by: typing.Text = ...
    """Optional. A comma-separated list of fields specifying the sorting order of the
    results. The default order is ascending. Add " DESC" after the field name
    to indicate descending order. Redundant space characters are ignored.
    Example: "assetType DESC, resource".
    Only singular primitive fields in the response are sortable:
      * resource
      * assetType
      * project
    All the other fields such as repeated fields (e.g., `folders`) and
    non-primitive fields (e.g., `policy`) are not supported.
    """

    def __init__(self,
        *,
        scope : typing.Text = ...,
        query : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        asset_types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        order_by : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["asset_types",b"asset_types","order_by",b"order_by","page_size",b"page_size","page_token",b"page_token","query",b"query","scope",b"scope"]) -> None: ...
global___SearchAllIamPoliciesRequest = SearchAllIamPoliciesRequest

class SearchAllIamPoliciesResponse(google.protobuf.message.Message):
    """Search all IAM policies response."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RESULTS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.cloud.asset.v1.assets_pb2.IamPolicySearchResult]:
        """A list of IamPolicy that match the search query. Related information such
        as the associated resource is returned along with the policy.
        """
        pass
    next_page_token: typing.Text = ...
    """Set if there are more results than those appearing in this response; to get
    the next set of results, call this method again, using this value as the
    `page_token`.
    """

    def __init__(self,
        *,
        results : typing.Optional[typing.Iterable[google.cloud.asset.v1.assets_pb2.IamPolicySearchResult]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["next_page_token",b"next_page_token","results",b"results"]) -> None: ...
global___SearchAllIamPoliciesResponse = SearchAllIamPoliciesResponse

class IamPolicyAnalysisQuery(google.protobuf.message.Message):
    """## IAM policy analysis query message."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ResourceSelector(google.protobuf.message.Message):
        """Specifies the resource to analyze for access policies, which may be set
        directly on the resource, or on ancestors such as organizations, folders or
        projects.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FULL_RESOURCE_NAME_FIELD_NUMBER: builtins.int
        full_resource_name: typing.Text = ...
        """Required. The [full resource name]
        (https://cloud.google.com/asset-inventory/docs/resource-name-format)
        of a resource of [supported resource
        types](https://cloud.google.com/asset-inventory/docs/supported-asset-types#analyzable_asset_types).
        """

        def __init__(self,
            *,
            full_resource_name : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["full_resource_name",b"full_resource_name"]) -> None: ...

    class IdentitySelector(google.protobuf.message.Message):
        """Specifies an identity for which to determine resource access, based on
        roles assigned either directly to them or to the groups they belong to,
        directly or indirectly.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        IDENTITY_FIELD_NUMBER: builtins.int
        identity: typing.Text = ...
        """Required. The identity appear in the form of members in
        [IAM policy
        binding](https://cloud.google.com/iam/reference/rest/v1/Binding).

        The examples of supported forms are:
        "user:mike@example.com",
        "group:admins@example.com",
        "domain:google.com",
        "serviceAccount:my-project-id@appspot.gserviceaccount.com".

        Notice that wildcard characters (such as * and ?) are not supported.
        You must give a specific identity.
        """

        def __init__(self,
            *,
            identity : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["identity",b"identity"]) -> None: ...

    class AccessSelector(google.protobuf.message.Message):
        """Specifies roles and/or permissions to analyze, to determine both the
        identities possessing them and the resources they control. If multiple
        values are specified, results will include roles or permissions matching
        any of them. The total number of roles and permissions should be equal or
        less than 10.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        ROLES_FIELD_NUMBER: builtins.int
        PERMISSIONS_FIELD_NUMBER: builtins.int
        @property
        def roles(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """Optional. The roles to appear in result."""
            pass
        @property
        def permissions(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """Optional. The permissions to appear in result."""
            pass
        def __init__(self,
            *,
            roles : typing.Optional[typing.Iterable[typing.Text]] = ...,
            permissions : typing.Optional[typing.Iterable[typing.Text]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["permissions",b"permissions","roles",b"roles"]) -> None: ...

    class Options(google.protobuf.message.Message):
        """Contains query options."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        EXPAND_GROUPS_FIELD_NUMBER: builtins.int
        EXPAND_ROLES_FIELD_NUMBER: builtins.int
        EXPAND_RESOURCES_FIELD_NUMBER: builtins.int
        OUTPUT_RESOURCE_EDGES_FIELD_NUMBER: builtins.int
        OUTPUT_GROUP_EDGES_FIELD_NUMBER: builtins.int
        ANALYZE_SERVICE_ACCOUNT_IMPERSONATION_FIELD_NUMBER: builtins.int
        expand_groups: builtins.bool = ...
        """Optional. If true, the identities section of the result will expand any
        Google groups appearing in an IAM policy binding.

        If [IamPolicyAnalysisQuery.identity_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.identity_selector] is specified, the
        identity in the result will be determined by the selector, and this flag
        is not allowed to set.

        Default is false.
        """

        expand_roles: builtins.bool = ...
        """Optional. If true, the access section of result will expand any roles
        appearing in IAM policy bindings to include their permissions.

        If [IamPolicyAnalysisQuery.access_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.access_selector] is specified, the access
        section of the result will be determined by the selector, and this flag
        is not allowed to set.

        Default is false.
        """

        expand_resources: builtins.bool = ...
        """Optional. If true and [IamPolicyAnalysisQuery.resource_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.resource_selector] is not
        specified, the resource section of the result will expand any resource
        attached to an IAM policy to include resources lower in the resource
        hierarchy.

        For example, if the request analyzes for which resources user A has
        permission P, and the results include an IAM policy with P on a GCP
        folder, the results will also include resources in that folder with
        permission P.

        If true and [IamPolicyAnalysisQuery.resource_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.resource_selector] is specified,
        the resource section of the result will expand the specified resource to
        include resources lower in the resource hierarchy. Only project or
        lower resources are supported. Folder and organization resource cannot be
        used together with this option.

        For example, if the request analyzes for which users have permission P on
        a GCP project with this option enabled, the results will include all
        users who have permission P on that project or any lower resource.

        Default is false.
        """

        output_resource_edges: builtins.bool = ...
        """Optional. If true, the result will output resource edges, starting
        from the policy attached resource, to any expanded resources.
        Default is false.
        """

        output_group_edges: builtins.bool = ...
        """Optional. If true, the result will output group identity edges, starting
        from the binding's group members, to any expanded identities.
        Default is false.
        """

        analyze_service_account_impersonation: builtins.bool = ...
        """Optional. If true, the response will include access analysis from identities to
        resources via service account impersonation. This is a very expensive
        operation, because many derived queries will be executed. We highly
        recommend you use [AssetService.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning] rpc
        instead.

        For example, if the request analyzes for which resources user A has
        permission P, and there's an IAM policy states user A has
        iam.serviceAccounts.getAccessToken permission to a service account SA,
        and there's another IAM policy states service account SA has permission P
        to a GCP folder F, then user A potentially has access to the GCP folder
        F. And those advanced analysis results will be included in
        [AnalyzeIamPolicyResponse.service_account_impersonation_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_impersonation_analysis].

        Another example, if the request analyzes for who has
        permission P to a GCP folder F, and there's an IAM policy states user A
        has iam.serviceAccounts.actAs permission to a service account SA, and
        there's another IAM policy states service account SA has permission P to
        the GCP folder F, then user A potentially has access to the GCP folder
        F. And those advanced analysis results will be included in
        [AnalyzeIamPolicyResponse.service_account_impersonation_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_impersonation_analysis].

        Default is false.
        """

        def __init__(self,
            *,
            expand_groups : builtins.bool = ...,
            expand_roles : builtins.bool = ...,
            expand_resources : builtins.bool = ...,
            output_resource_edges : builtins.bool = ...,
            output_group_edges : builtins.bool = ...,
            analyze_service_account_impersonation : builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["analyze_service_account_impersonation",b"analyze_service_account_impersonation","expand_groups",b"expand_groups","expand_resources",b"expand_resources","expand_roles",b"expand_roles","output_group_edges",b"output_group_edges","output_resource_edges",b"output_resource_edges"]) -> None: ...

    class ConditionContext(google.protobuf.message.Message):
        """The IAM conditions context."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        ACCESS_TIME_FIELD_NUMBER: builtins.int
        @property
        def access_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The hypothetical access timestamp to evaluate IAM conditions. Note that
            this value must not be earlier than the current time; otherwise, an
            INVALID_ARGUMENT error will be returned.
            """
            pass
        def __init__(self,
            *,
            access_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["TimeContext",b"TimeContext","access_time",b"access_time"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["TimeContext",b"TimeContext","access_time",b"access_time"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["TimeContext",b"TimeContext"]) -> typing.Optional[typing_extensions.Literal["access_time"]]: ...

    SCOPE_FIELD_NUMBER: builtins.int
    RESOURCE_SELECTOR_FIELD_NUMBER: builtins.int
    IDENTITY_SELECTOR_FIELD_NUMBER: builtins.int
    ACCESS_SELECTOR_FIELD_NUMBER: builtins.int
    OPTIONS_FIELD_NUMBER: builtins.int
    CONDITION_CONTEXT_FIELD_NUMBER: builtins.int
    scope: typing.Text = ...
    """Required. The relative name of the root asset. Only resources and IAM policies within
    the scope will be analyzed.

    This can only be an organization number (such as "organizations/123"), a
    folder number (such as "folders/123"), a project ID (such as
    "projects/my-project-id"), or a project number (such as "projects/12345").

    To know how to get organization id, visit [here
    ](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).

    To know how to get folder or project id, visit [here
    ](https://cloud.google.com/resource-manager/docs/creating-managing-folders#viewing_or_listing_folders_and_projects).
    """

    @property
    def resource_selector(self) -> global___IamPolicyAnalysisQuery.ResourceSelector:
        """Optional. Specifies a resource for analysis."""
        pass
    @property
    def identity_selector(self) -> global___IamPolicyAnalysisQuery.IdentitySelector:
        """Optional. Specifies an identity for analysis."""
        pass
    @property
    def access_selector(self) -> global___IamPolicyAnalysisQuery.AccessSelector:
        """Optional. Specifies roles or permissions for analysis. This is optional."""
        pass
    @property
    def options(self) -> global___IamPolicyAnalysisQuery.Options:
        """Optional. The query options."""
        pass
    @property
    def condition_context(self) -> global___IamPolicyAnalysisQuery.ConditionContext:
        """Optional. The hypothetical context for IAM conditions evaluation."""
        pass
    def __init__(self,
        *,
        scope : typing.Text = ...,
        resource_selector : typing.Optional[global___IamPolicyAnalysisQuery.ResourceSelector] = ...,
        identity_selector : typing.Optional[global___IamPolicyAnalysisQuery.IdentitySelector] = ...,
        access_selector : typing.Optional[global___IamPolicyAnalysisQuery.AccessSelector] = ...,
        options : typing.Optional[global___IamPolicyAnalysisQuery.Options] = ...,
        condition_context : typing.Optional[global___IamPolicyAnalysisQuery.ConditionContext] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["access_selector",b"access_selector","condition_context",b"condition_context","identity_selector",b"identity_selector","options",b"options","resource_selector",b"resource_selector"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["access_selector",b"access_selector","condition_context",b"condition_context","identity_selector",b"identity_selector","options",b"options","resource_selector",b"resource_selector","scope",b"scope"]) -> None: ...
global___IamPolicyAnalysisQuery = IamPolicyAnalysisQuery

class AnalyzeIamPolicyRequest(google.protobuf.message.Message):
    """A request message for [AssetService.AnalyzeIamPolicy][google.cloud.asset.v1.AssetService.AnalyzeIamPolicy]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANALYSIS_QUERY_FIELD_NUMBER: builtins.int
    EXECUTION_TIMEOUT_FIELD_NUMBER: builtins.int
    @property
    def analysis_query(self) -> global___IamPolicyAnalysisQuery:
        """Required. The request query."""
        pass
    @property
    def execution_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Optional. Amount of time executable has to complete.  See JSON representation of
        [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json).

        If this field is set with a value less than the RPC deadline, and the
        execution of your query hasn't finished in the specified
        execution timeout,  you will get a response with partial result.
        Otherwise, your query's execution will continue until the RPC deadline.
        If it's not finished until then, you will get a  DEADLINE_EXCEEDED error.

        Default is empty.
        """
        pass
    def __init__(self,
        *,
        analysis_query : typing.Optional[global___IamPolicyAnalysisQuery] = ...,
        execution_timeout : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["analysis_query",b"analysis_query","execution_timeout",b"execution_timeout"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["analysis_query",b"analysis_query","execution_timeout",b"execution_timeout"]) -> None: ...
global___AnalyzeIamPolicyRequest = AnalyzeIamPolicyRequest

class AnalyzeIamPolicyResponse(google.protobuf.message.Message):
    """A response message for [AssetService.AnalyzeIamPolicy][google.cloud.asset.v1.AssetService.AnalyzeIamPolicy]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class IamPolicyAnalysis(google.protobuf.message.Message):
        """An analysis message to group the query and results."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        ANALYSIS_QUERY_FIELD_NUMBER: builtins.int
        ANALYSIS_RESULTS_FIELD_NUMBER: builtins.int
        FULLY_EXPLORED_FIELD_NUMBER: builtins.int
        NON_CRITICAL_ERRORS_FIELD_NUMBER: builtins.int
        @property
        def analysis_query(self) -> global___IamPolicyAnalysisQuery:
            """The analysis query."""
            pass
        @property
        def analysis_results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.cloud.asset.v1.assets_pb2.IamPolicyAnalysisResult]:
            """A list of [IamPolicyAnalysisResult][google.cloud.asset.v1.IamPolicyAnalysisResult] that matches the analysis query, or
            empty if no result is found.
            """
            pass
        fully_explored: builtins.bool = ...
        """Represents whether all entries in the [analysis_results][google.cloud.asset.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysis.analysis_results] have been
        fully explored to answer the query.
        """

        @property
        def non_critical_errors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.cloud.asset.v1.assets_pb2.IamPolicyAnalysisState]:
            """A list of non-critical errors happened during the query handling."""
            pass
        def __init__(self,
            *,
            analysis_query : typing.Optional[global___IamPolicyAnalysisQuery] = ...,
            analysis_results : typing.Optional[typing.Iterable[google.cloud.asset.v1.assets_pb2.IamPolicyAnalysisResult]] = ...,
            fully_explored : builtins.bool = ...,
            non_critical_errors : typing.Optional[typing.Iterable[google.cloud.asset.v1.assets_pb2.IamPolicyAnalysisState]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["analysis_query",b"analysis_query"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["analysis_query",b"analysis_query","analysis_results",b"analysis_results","fully_explored",b"fully_explored","non_critical_errors",b"non_critical_errors"]) -> None: ...

    MAIN_ANALYSIS_FIELD_NUMBER: builtins.int
    SERVICE_ACCOUNT_IMPERSONATION_ANALYSIS_FIELD_NUMBER: builtins.int
    FULLY_EXPLORED_FIELD_NUMBER: builtins.int
    @property
    def main_analysis(self) -> global___AnalyzeIamPolicyResponse.IamPolicyAnalysis:
        """The main analysis that matches the original request."""
        pass
    @property
    def service_account_impersonation_analysis(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnalyzeIamPolicyResponse.IamPolicyAnalysis]:
        """The service account impersonation analysis if
        [AnalyzeIamPolicyRequest.analyze_service_account_impersonation][] is
        enabled.
        """
        pass
    fully_explored: builtins.bool = ...
    """Represents whether all entries in the [main_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.main_analysis] and
    [service_account_impersonation_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_impersonation_analysis] have been fully explored to
    answer the query in the request.
    """

    def __init__(self,
        *,
        main_analysis : typing.Optional[global___AnalyzeIamPolicyResponse.IamPolicyAnalysis] = ...,
        service_account_impersonation_analysis : typing.Optional[typing.Iterable[global___AnalyzeIamPolicyResponse.IamPolicyAnalysis]] = ...,
        fully_explored : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["main_analysis",b"main_analysis"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["fully_explored",b"fully_explored","main_analysis",b"main_analysis","service_account_impersonation_analysis",b"service_account_impersonation_analysis"]) -> None: ...
global___AnalyzeIamPolicyResponse = AnalyzeIamPolicyResponse

class IamPolicyAnalysisOutputConfig(google.protobuf.message.Message):
    """Output configuration for export IAM policy analysis destination."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class GcsDestination(google.protobuf.message.Message):
        """A Cloud Storage location."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        URI_FIELD_NUMBER: builtins.int
        uri: typing.Text = ...
        """Required. The uri of the Cloud Storage object. It's the same uri that is used by
        gsutil. Example: "gs://bucket_name/object_name". See [Viewing and
        Editing Object
        Metadata](https://cloud.google.com/storage/docs/viewing-editing-metadata)
        for more information.

        If the specified Cloud Storage object already exists and there is no
        [hold](https://cloud.google.com/storage/docs/object-holds), it will be
        overwritten with the analysis result.
        """

        def __init__(self,
            *,
            uri : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["uri",b"uri"]) -> None: ...

    class BigQueryDestination(google.protobuf.message.Message):
        """A BigQuery destination."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _PartitionKey:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _PartitionKeyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PartitionKey.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            PARTITION_KEY_UNSPECIFIED: IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey.ValueType = ...  # 0
            """Unspecified partition key. Tables won't be partitioned using this
            option.
            """

            REQUEST_TIME: IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey.ValueType = ...  # 1
            """The time when the request is received. If specified as partition key,
            the result table(s) is partitoned by the RequestTime column, an
            additional timestamp column representing when the request was received.
            """

        class PartitionKey(_PartitionKey, metaclass=_PartitionKeyEnumTypeWrapper):
            """This enum determines the partition key column for the bigquery tables.
            Partitioning can improve query performance and reduce query cost by
            filtering partitions. Refer to
            https://cloud.google.com/bigquery/docs/partitioned-tables for details.
            """
            pass

        PARTITION_KEY_UNSPECIFIED: IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey.ValueType = ...  # 0
        """Unspecified partition key. Tables won't be partitioned using this
        option.
        """

        REQUEST_TIME: IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey.ValueType = ...  # 1
        """The time when the request is received. If specified as partition key,
        the result table(s) is partitoned by the RequestTime column, an
        additional timestamp column representing when the request was received.
        """


        DATASET_FIELD_NUMBER: builtins.int
        TABLE_PREFIX_FIELD_NUMBER: builtins.int
        PARTITION_KEY_FIELD_NUMBER: builtins.int
        WRITE_DISPOSITION_FIELD_NUMBER: builtins.int
        dataset: typing.Text = ...
        """Required. The BigQuery dataset in format "projects/projectId/datasets/datasetId",
        to which the analysis results should be exported. If this dataset does
        not exist, the export call will return an INVALID_ARGUMENT error.
        """

        table_prefix: typing.Text = ...
        """Required. The prefix of the BigQuery tables to which the analysis results will be
        written. Tables will be created based on this table_prefix if not exist:
        * <table_prefix>_analysis table will contain export operation's metadata.
        * <table_prefix>_analysis_result will contain all the
          [IamPolicyAnalysisResult][google.cloud.asset.v1.IamPolicyAnalysisResult].
        When [partition_key] is specified, both tables will be partitioned based
        on the [partition_key].
        """

        partition_key: global___IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey.ValueType = ...
        """The partition key for BigQuery partitioned table."""

        write_disposition: typing.Text = ...
        """Optional. Specifies the action that occurs if the destination table or partition
        already exists. The following values are supported:

        * WRITE_TRUNCATE: If the table or partition already exists, BigQuery
        overwrites the entire table or all the partitions data.
        * WRITE_APPEND: If the table or partition already exists, BigQuery
        appends the data to the table or the latest partition.
        * WRITE_EMPTY: If the table already exists and contains data, an error is
        returned.

        The default value is WRITE_APPEND. Each action is atomic and only occurs
        if BigQuery is able to complete the job successfully. Details are at
        https://cloud.google.com/bigquery/docs/loading-data-local#appending_to_or_overwriting_a_table_using_a_local_file.
        """

        def __init__(self,
            *,
            dataset : typing.Text = ...,
            table_prefix : typing.Text = ...,
            partition_key : global___IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey.ValueType = ...,
            write_disposition : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["dataset",b"dataset","partition_key",b"partition_key","table_prefix",b"table_prefix","write_disposition",b"write_disposition"]) -> None: ...

    GCS_DESTINATION_FIELD_NUMBER: builtins.int
    BIGQUERY_DESTINATION_FIELD_NUMBER: builtins.int
    @property
    def gcs_destination(self) -> global___IamPolicyAnalysisOutputConfig.GcsDestination:
        """Destination on Cloud Storage."""
        pass
    @property
    def bigquery_destination(self) -> global___IamPolicyAnalysisOutputConfig.BigQueryDestination:
        """Destination on BigQuery."""
        pass
    def __init__(self,
        *,
        gcs_destination : typing.Optional[global___IamPolicyAnalysisOutputConfig.GcsDestination] = ...,
        bigquery_destination : typing.Optional[global___IamPolicyAnalysisOutputConfig.BigQueryDestination] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bigquery_destination",b"bigquery_destination","destination",b"destination","gcs_destination",b"gcs_destination"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bigquery_destination",b"bigquery_destination","destination",b"destination","gcs_destination",b"gcs_destination"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["destination",b"destination"]) -> typing.Optional[typing_extensions.Literal["gcs_destination","bigquery_destination"]]: ...
global___IamPolicyAnalysisOutputConfig = IamPolicyAnalysisOutputConfig

class AnalyzeIamPolicyLongrunningRequest(google.protobuf.message.Message):
    """A request message for [AssetService.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ANALYSIS_QUERY_FIELD_NUMBER: builtins.int
    OUTPUT_CONFIG_FIELD_NUMBER: builtins.int
    @property
    def analysis_query(self) -> global___IamPolicyAnalysisQuery:
        """Required. The request query."""
        pass
    @property
    def output_config(self) -> global___IamPolicyAnalysisOutputConfig:
        """Required. Output configuration indicating where the results will be output to."""
        pass
    def __init__(self,
        *,
        analysis_query : typing.Optional[global___IamPolicyAnalysisQuery] = ...,
        output_config : typing.Optional[global___IamPolicyAnalysisOutputConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["analysis_query",b"analysis_query","output_config",b"output_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["analysis_query",b"analysis_query","output_config",b"output_config"]) -> None: ...
global___AnalyzeIamPolicyLongrunningRequest = AnalyzeIamPolicyLongrunningRequest

class AnalyzeIamPolicyLongrunningResponse(google.protobuf.message.Message):
    """A response message for [AssetService.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___AnalyzeIamPolicyLongrunningResponse = AnalyzeIamPolicyLongrunningResponse

class AnalyzeMoveRequest(google.protobuf.message.Message):
    """The request message for performing resource move analysis."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _AnalysisView:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _AnalysisViewEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_AnalysisView.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        ANALYSIS_VIEW_UNSPECIFIED: AnalyzeMoveRequest.AnalysisView.ValueType = ...  # 0
        """The default/unset value.
        The API will default to the FULL view.
        """

        FULL: AnalyzeMoveRequest.AnalysisView.ValueType = ...  # 1
        """Full analysis including all level of impacts of the specified resource
        move.
        """

        BASIC: AnalyzeMoveRequest.AnalysisView.ValueType = ...  # 2
        """Basic analysis only including blockers which will prevent the specified
        resource move at runtime.
        """

    class AnalysisView(_AnalysisView, metaclass=_AnalysisViewEnumTypeWrapper):
        """View enum for supporting partial analysis responses."""
        pass

    ANALYSIS_VIEW_UNSPECIFIED: AnalyzeMoveRequest.AnalysisView.ValueType = ...  # 0
    """The default/unset value.
    The API will default to the FULL view.
    """

    FULL: AnalyzeMoveRequest.AnalysisView.ValueType = ...  # 1
    """Full analysis including all level of impacts of the specified resource
    move.
    """

    BASIC: AnalyzeMoveRequest.AnalysisView.ValueType = ...  # 2
    """Basic analysis only including blockers which will prevent the specified
    resource move at runtime.
    """


    RESOURCE_FIELD_NUMBER: builtins.int
    DESTINATION_PARENT_FIELD_NUMBER: builtins.int
    VIEW_FIELD_NUMBER: builtins.int
    resource: typing.Text = ...
    """Required. Name of the resource to perform the analysis against.
    Only GCP Project are supported as of today. Hence, this can only be Project
    ID (such as "projects/my-project-id") or a Project Number (such as
    "projects/12345").
    """

    destination_parent: typing.Text = ...
    """Required. Name of the GCP Folder or Organization to reparent the target
    resource. The analysis will be performed against hypothetically moving the
    resource to this specified desitination parent. This can only be a Folder
    number (such as "folders/123") or an Organization number (such as
    "organizations/123").
    """

    view: global___AnalyzeMoveRequest.AnalysisView.ValueType = ...
    """Analysis view indicating what information should be included in the
    analysis response. If unspecified, the default view is FULL.
    """

    def __init__(self,
        *,
        resource : typing.Text = ...,
        destination_parent : typing.Text = ...,
        view : global___AnalyzeMoveRequest.AnalysisView.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["destination_parent",b"destination_parent","resource",b"resource","view",b"view"]) -> None: ...
global___AnalyzeMoveRequest = AnalyzeMoveRequest

class AnalyzeMoveResponse(google.protobuf.message.Message):
    """The response message for resource move analysis."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MOVE_ANALYSIS_FIELD_NUMBER: builtins.int
    @property
    def move_analysis(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MoveAnalysis]:
        """The list of analyses returned from performing the intended resource move
        analysis. The analysis is grouped by different Cloud services.
        """
        pass
    def __init__(self,
        *,
        move_analysis : typing.Optional[typing.Iterable[global___MoveAnalysis]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["move_analysis",b"move_analysis"]) -> None: ...
global___AnalyzeMoveResponse = AnalyzeMoveResponse

class MoveAnalysis(google.protobuf.message.Message):
    """A message to group the analysis information."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    ANALYSIS_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    display_name: typing.Text = ...
    """The user friendly display name of the analysis. E.g. IAM, Organization
    Policy etc.
    """

    @property
    def analysis(self) -> global___MoveAnalysisResult:
        """Analysis result of moving the target resource."""
        pass
    @property
    def error(self) -> google.rpc.status_pb2.Status:
        """Description of error encountered when performing the analysis."""
        pass
    def __init__(self,
        *,
        display_name : typing.Text = ...,
        analysis : typing.Optional[global___MoveAnalysisResult] = ...,
        error : typing.Optional[google.rpc.status_pb2.Status] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["analysis",b"analysis","error",b"error","result",b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["analysis",b"analysis","display_name",b"display_name","error",b"error","result",b"result"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["result",b"result"]) -> typing.Optional[typing_extensions.Literal["analysis","error"]]: ...
global___MoveAnalysis = MoveAnalysis

class MoveAnalysisResult(google.protobuf.message.Message):
    """An analysis result including blockers and warnings."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    BLOCKERS_FIELD_NUMBER: builtins.int
    WARNINGS_FIELD_NUMBER: builtins.int
    @property
    def blockers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MoveImpact]:
        """Blocking information that would prevent the target resource from moving
        to the specified destination at runtime.
        """
        pass
    @property
    def warnings(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MoveImpact]:
        """Warning information indicating that moving the target resource to the
        specified destination might be unsafe. This can include important policy
        information and configuration changes, but will not block moves at runtime.
        """
        pass
    def __init__(self,
        *,
        blockers : typing.Optional[typing.Iterable[global___MoveImpact]] = ...,
        warnings : typing.Optional[typing.Iterable[global___MoveImpact]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["blockers",b"blockers","warnings",b"warnings"]) -> None: ...
global___MoveAnalysisResult = MoveAnalysisResult

class MoveImpact(google.protobuf.message.Message):
    """A message to group impacts of moving the target resource."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DETAIL_FIELD_NUMBER: builtins.int
    detail: typing.Text = ...
    """User friendly impact detail in a free form message."""

    def __init__(self,
        *,
        detail : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["detail",b"detail"]) -> None: ...
global___MoveImpact = MoveImpact
