"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _DesiredState:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _DesiredStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DesiredState.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    DESIRED_STATE_UNSPECIFIED: DesiredState.ValueType = ...  # 0
    """The default is to ensure the package is installed."""

    INSTALLED: DesiredState.ValueType = ...  # 1
    """The agent ensures that the package is installed."""

    UPDATED: DesiredState.ValueType = ...  # 2
    """The agent ensures that the package is installed and
    periodically checks for and install any updates.
    """

    REMOVED: DesiredState.ValueType = ...  # 3
    """The agent ensures that the package is not installed and uninstall it
    if detected.
    """

class DesiredState(_DesiredState, metaclass=_DesiredStateEnumTypeWrapper):
    """The desired state that the OS Config agent maintains on the VM instance."""
    pass

DESIRED_STATE_UNSPECIFIED: DesiredState.ValueType = ...  # 0
"""The default is to ensure the package is installed."""

INSTALLED: DesiredState.ValueType = ...  # 1
"""The agent ensures that the package is installed."""

UPDATED: DesiredState.ValueType = ...  # 2
"""The agent ensures that the package is installed and
periodically checks for and install any updates.
"""

REMOVED: DesiredState.ValueType = ...  # 3
"""The agent ensures that the package is not installed and uninstall it
if detected.
"""

global___DesiredState = DesiredState


class GuestPolicy(google.protobuf.message.Message):
    """An OS Config resource representing a guest configuration policy. These
    policies represent the desired state for VM instance guest environments
    including packages to install or remove, package repository configurations,
    and software to install.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    ASSIGNMENT_FIELD_NUMBER: builtins.int
    PACKAGES_FIELD_NUMBER: builtins.int
    PACKAGE_REPOSITORIES_FIELD_NUMBER: builtins.int
    RECIPES_FIELD_NUMBER: builtins.int
    ETAG_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Unique name of the resource in this project using one of the following
    forms:
    `projects/{project_number}/guestPolicies/{guest_policy_id}`.
    """

    description: typing.Text = ...
    """Description of the guest policy. Length of the description is limited
    to 1024 characters.
    """

    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Time this guest policy was created."""
        pass
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Last time this guest policy was updated."""
        pass
    @property
    def assignment(self) -> global___Assignment:
        """Required. Specifies the VM instances that are assigned to this policy. This allows
        you to target sets or groups of VM instances by different parameters such
        as labels, names, OS, or zones.

        If left empty, all VM instances underneath this policy are targeted.

        At the same level in the resource hierarchy (that is within a project), the
        service prevents the creation of multiple policies that conflict with
        each other. For more information, see how the service [handles assignment
        conflicts](/compute/docs/os-config-management/create-guest-policy#handle-conflicts).
        """
        pass
    @property
    def packages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Package]:
        """The software packages to be managed by this policy."""
        pass
    @property
    def package_repositories(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PackageRepository]:
        """A list of package repositories to configure on the VM instance. This is
        done before any other configs are applied so they can use these repos.
        Package repositories are only configured if the corresponding package
        manager(s) are available.
        """
        pass
    @property
    def recipes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SoftwareRecipe]:
        """A list of Recipes to install on the VM instance."""
        pass
    etag: typing.Text = ...
    """The etag for this guest policy.
    If this is provided on update, it must match the server's etag.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        description : typing.Text = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        update_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        assignment : typing.Optional[global___Assignment] = ...,
        packages : typing.Optional[typing.Iterable[global___Package]] = ...,
        package_repositories : typing.Optional[typing.Iterable[global___PackageRepository]] = ...,
        recipes : typing.Optional[typing.Iterable[global___SoftwareRecipe]] = ...,
        etag : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["assignment",b"assignment","create_time",b"create_time","update_time",b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["assignment",b"assignment","create_time",b"create_time","description",b"description","etag",b"etag","name",b"name","package_repositories",b"package_repositories","packages",b"packages","recipes",b"recipes","update_time",b"update_time"]) -> None: ...
global___GuestPolicy = GuestPolicy

class Assignment(google.protobuf.message.Message):
    """An assignment represents the group or groups of VM instances that the policy
    applies to.

    If an assignment is empty, it applies to all VM instances. Otherwise, the
    targeted VM instances must meet all the criteria specified. So if both
    labels and zones are specified, the policy applies to VM instances with those
    labels and in those zones.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class GroupLabel(google.protobuf.message.Message):
        """Represents a group of VM intances that can be identified as having all
        these labels, for example "env=prod and app=web".
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class LabelsEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            value: typing.Text = ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        LABELS_FIELD_NUMBER: builtins.int
        @property
        def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
            """Google Compute Engine instance labels that must be present for an
            instance to be included in this assignment group.
            """
            pass
        def __init__(self,
            *,
            labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["labels",b"labels"]) -> None: ...

    class OsType(google.protobuf.message.Message):
        """Defines the criteria for selecting VM Instances by OS type."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        OS_SHORT_NAME_FIELD_NUMBER: builtins.int
        OS_VERSION_FIELD_NUMBER: builtins.int
        OS_ARCHITECTURE_FIELD_NUMBER: builtins.int
        os_short_name: typing.Text = ...
        """Targets VM instances with OS Inventory enabled and having the following
        OS short name, for example "debian" or "windows".
        """

        os_version: typing.Text = ...
        """Targets VM instances with OS Inventory enabled and having the following
        following OS version.
        """

        os_architecture: typing.Text = ...
        """Targets VM instances with OS Inventory enabled and having the following
        OS architecture.
        """

        def __init__(self,
            *,
            os_short_name : typing.Text = ...,
            os_version : typing.Text = ...,
            os_architecture : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["os_architecture",b"os_architecture","os_short_name",b"os_short_name","os_version",b"os_version"]) -> None: ...

    GROUP_LABELS_FIELD_NUMBER: builtins.int
    ZONES_FIELD_NUMBER: builtins.int
    INSTANCES_FIELD_NUMBER: builtins.int
    INSTANCE_NAME_PREFIXES_FIELD_NUMBER: builtins.int
    OS_TYPES_FIELD_NUMBER: builtins.int
    @property
    def group_labels(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Assignment.GroupLabel]:
        """Targets instances matching at least one of these label sets. This allows
        an assignment to target disparate groups, for example "env=prod or
        env=staging".
        """
        pass
    @property
    def zones(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Targets instances in any of these zones. Leave empty to target instances
        in any zone.

        Zonal targeting is uncommon and is supported to facilitate the management
        of changes by zone.
        """
        pass
    @property
    def instances(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Targets any of the instances specified. Instances are specified by their
        URI in the form `zones/[ZONE]/instances/[INSTANCE_NAME]`.

        Instance targeting is uncommon and is supported to facilitate the
        management of changes by the instance or to target specific VM instances
        for development and testing.

        Only supported for project-level policies and must reference instances
        within this project.
        """
        pass
    @property
    def instance_name_prefixes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Targets VM instances whose name starts with one of these prefixes.

        Like labels, this is another way to group VM instances when targeting
        configs, for example prefix="prod-".

        Only supported for project-level policies.
        """
        pass
    @property
    def os_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Assignment.OsType]:
        """Targets VM instances matching at least one of the following OS types.

        VM instances must match all supplied criteria for a given OsType to be
        included.
        """
        pass
    def __init__(self,
        *,
        group_labels : typing.Optional[typing.Iterable[global___Assignment.GroupLabel]] = ...,
        zones : typing.Optional[typing.Iterable[typing.Text]] = ...,
        instances : typing.Optional[typing.Iterable[typing.Text]] = ...,
        instance_name_prefixes : typing.Optional[typing.Iterable[typing.Text]] = ...,
        os_types : typing.Optional[typing.Iterable[global___Assignment.OsType]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["group_labels",b"group_labels","instance_name_prefixes",b"instance_name_prefixes","instances",b"instances","os_types",b"os_types","zones",b"zones"]) -> None: ...
global___Assignment = Assignment

class Package(google.protobuf.message.Message):
    """Package is a reference to the software package to be installed or removed.
    The agent on the VM instance uses the system package manager to apply the
    config.


    These are the commands that the agent uses to install or remove
    packages.

    Apt
    install: `apt-get update && apt-get -y install package1 package2 package3`
    remove: `apt-get -y remove package1 package2 package3`

    Yum
    install: `yum -y install package1 package2 package3`
    remove: `yum -y remove package1 package2 package3`

    Zypper
    install: `zypper install package1 package2 package3`
    remove: `zypper rm package1 package2`

    Googet
    install: `googet -noconfirm install package1 package2 package3`
    remove: `googet -noconfirm remove package1 package2 package3`
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Manager:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ManagerEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Manager.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        MANAGER_UNSPECIFIED: Package.Manager.ValueType = ...  # 0
        """The default behavior is ANY."""

        ANY: Package.Manager.ValueType = ...  # 1
        """Apply this package config using the default system package manager."""

        APT: Package.Manager.ValueType = ...  # 2
        """Apply this package config only if Apt is available on the system."""

        YUM: Package.Manager.ValueType = ...  # 3
        """Apply this package config only if Yum is available on the system."""

        ZYPPER: Package.Manager.ValueType = ...  # 4
        """Apply this package config only if Zypper is available on the system."""

        GOO: Package.Manager.ValueType = ...  # 5
        """Apply this package config only if GooGet is available on the system."""

    class Manager(_Manager, metaclass=_ManagerEnumTypeWrapper):
        """Types of package managers that may be used to manage this package."""
        pass

    MANAGER_UNSPECIFIED: Package.Manager.ValueType = ...  # 0
    """The default behavior is ANY."""

    ANY: Package.Manager.ValueType = ...  # 1
    """Apply this package config using the default system package manager."""

    APT: Package.Manager.ValueType = ...  # 2
    """Apply this package config only if Apt is available on the system."""

    YUM: Package.Manager.ValueType = ...  # 3
    """Apply this package config only if Yum is available on the system."""

    ZYPPER: Package.Manager.ValueType = ...  # 4
    """Apply this package config only if Zypper is available on the system."""

    GOO: Package.Manager.ValueType = ...  # 5
    """Apply this package config only if GooGet is available on the system."""


    NAME_FIELD_NUMBER: builtins.int
    DESIRED_STATE_FIELD_NUMBER: builtins.int
    MANAGER_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the package. A package is uniquely identified for conflict
    validation by checking the package name and the manager(s) that the
    package targets.
    """

    desired_state: global___DesiredState.ValueType = ...
    """The desired_state the agent should maintain for this package. The
    default is to ensure the package is installed.
    """

    manager: global___Package.Manager.ValueType = ...
    """Type of package manager that can be used to install this package.
    If a system does not have the package manager, the package is not
    installed or removed no error message is returned. By default,
    or if you specify `ANY`,
    the agent attempts to install and remove this package using the default
    package manager. This is useful when creating a policy that applies to
    different types of systems.

    The default behavior is ANY.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        desired_state : global___DesiredState.ValueType = ...,
        manager : global___Package.Manager.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["desired_state",b"desired_state","manager",b"manager","name",b"name"]) -> None: ...
global___Package = Package

class AptRepository(google.protobuf.message.Message):
    """Represents a single Apt package repository. This repository is added to
    a repo file that is stored at
    `/etc/apt/sources.list.d/google_osconfig.list`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _ArchiveType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ArchiveTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ArchiveType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        ARCHIVE_TYPE_UNSPECIFIED: AptRepository.ArchiveType.ValueType = ...  # 0
        """Unspecified."""

        DEB: AptRepository.ArchiveType.ValueType = ...  # 1
        """DEB indicates that the archive contains binary files."""

        DEB_SRC: AptRepository.ArchiveType.ValueType = ...  # 2
        """DEB_SRC indicates that the archive contains source files."""

    class ArchiveType(_ArchiveType, metaclass=_ArchiveTypeEnumTypeWrapper):
        """Type of archive."""
        pass

    ARCHIVE_TYPE_UNSPECIFIED: AptRepository.ArchiveType.ValueType = ...  # 0
    """Unspecified."""

    DEB: AptRepository.ArchiveType.ValueType = ...  # 1
    """DEB indicates that the archive contains binary files."""

    DEB_SRC: AptRepository.ArchiveType.ValueType = ...  # 2
    """DEB_SRC indicates that the archive contains source files."""


    ARCHIVE_TYPE_FIELD_NUMBER: builtins.int
    URI_FIELD_NUMBER: builtins.int
    DISTRIBUTION_FIELD_NUMBER: builtins.int
    COMPONENTS_FIELD_NUMBER: builtins.int
    GPG_KEY_FIELD_NUMBER: builtins.int
    archive_type: global___AptRepository.ArchiveType.ValueType = ...
    """Type of archive files in this repository. The default behavior is DEB."""

    uri: typing.Text = ...
    """Required. URI for this repository."""

    distribution: typing.Text = ...
    """Required. Distribution of this repository."""

    @property
    def components(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Required. List of components for this repository. Must contain at least one item."""
        pass
    gpg_key: typing.Text = ...
    """URI of the key file for this repository. The agent maintains
    a keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg` containing
    all the keys in any applied guest policy.
    """

    def __init__(self,
        *,
        archive_type : global___AptRepository.ArchiveType.ValueType = ...,
        uri : typing.Text = ...,
        distribution : typing.Text = ...,
        components : typing.Optional[typing.Iterable[typing.Text]] = ...,
        gpg_key : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["archive_type",b"archive_type","components",b"components","distribution",b"distribution","gpg_key",b"gpg_key","uri",b"uri"]) -> None: ...
global___AptRepository = AptRepository

class YumRepository(google.protobuf.message.Message):
    """Represents a single Yum package repository. This repository is added to a
    repo file that is stored at `/etc/yum.repos.d/google_osconfig.repo`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    BASE_URL_FIELD_NUMBER: builtins.int
    GPG_KEYS_FIELD_NUMBER: builtins.int
    id: typing.Text = ...
    """Required. A one word, unique name for this repository. This is
    the `repo id` in the Yum config file and also the `display_name` if
    `display_name` is omitted. This id is also used as the unique identifier
    when checking for guest policy conflicts.
    """

    display_name: typing.Text = ...
    """The display name of the repository."""

    base_url: typing.Text = ...
    """Required. The location of the repository directory."""

    @property
    def gpg_keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """URIs of GPG keys."""
        pass
    def __init__(self,
        *,
        id : typing.Text = ...,
        display_name : typing.Text = ...,
        base_url : typing.Text = ...,
        gpg_keys : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["base_url",b"base_url","display_name",b"display_name","gpg_keys",b"gpg_keys","id",b"id"]) -> None: ...
global___YumRepository = YumRepository

class ZypperRepository(google.protobuf.message.Message):
    """Represents a single Zypper package repository. This repository is added to a
    repo file that is stored at `/etc/zypp/repos.d/google_osconfig.repo`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    BASE_URL_FIELD_NUMBER: builtins.int
    GPG_KEYS_FIELD_NUMBER: builtins.int
    id: typing.Text = ...
    """Required. A one word, unique name for this repository. This is
    the `repo id` in the zypper config file and also the `display_name` if
    `display_name` is omitted. This id is also used as the unique identifier
    when checking for guest policy conflicts.
    """

    display_name: typing.Text = ...
    """The display name of the repository."""

    base_url: typing.Text = ...
    """Required. The location of the repository directory."""

    @property
    def gpg_keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """URIs of GPG keys."""
        pass
    def __init__(self,
        *,
        id : typing.Text = ...,
        display_name : typing.Text = ...,
        base_url : typing.Text = ...,
        gpg_keys : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["base_url",b"base_url","display_name",b"display_name","gpg_keys",b"gpg_keys","id",b"id"]) -> None: ...
global___ZypperRepository = ZypperRepository

class GooRepository(google.protobuf.message.Message):
    """Represents a Goo package repository. These is added to a repo file
    that is stored at C:/ProgramData/GooGet/repos/google_osconfig.repo.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    URL_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the repository."""

    url: typing.Text = ...
    """Required. The url of the repository."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        url : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name","url",b"url"]) -> None: ...
global___GooRepository = GooRepository

class PackageRepository(google.protobuf.message.Message):
    """A package repository."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    APT_FIELD_NUMBER: builtins.int
    YUM_FIELD_NUMBER: builtins.int
    ZYPPER_FIELD_NUMBER: builtins.int
    GOO_FIELD_NUMBER: builtins.int
    @property
    def apt(self) -> global___AptRepository:
        """An Apt Repository."""
        pass
    @property
    def yum(self) -> global___YumRepository:
        """A Yum Repository."""
        pass
    @property
    def zypper(self) -> global___ZypperRepository:
        """A Zypper Repository."""
        pass
    @property
    def goo(self) -> global___GooRepository:
        """A Goo Repository."""
        pass
    def __init__(self,
        *,
        apt : typing.Optional[global___AptRepository] = ...,
        yum : typing.Optional[global___YumRepository] = ...,
        zypper : typing.Optional[global___ZypperRepository] = ...,
        goo : typing.Optional[global___GooRepository] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["apt",b"apt","goo",b"goo","repository",b"repository","yum",b"yum","zypper",b"zypper"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["apt",b"apt","goo",b"goo","repository",b"repository","yum",b"yum","zypper",b"zypper"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["repository",b"repository"]) -> typing.Optional[typing_extensions.Literal["apt","yum","zypper","goo"]]: ...
global___PackageRepository = PackageRepository

class SoftwareRecipe(google.protobuf.message.Message):
    """A software recipe is a set of instructions for installing and configuring a
    piece of software. It consists of a set of artifacts that are
    downloaded, and a set of steps that install, configure, and/or update the
    software.

    Recipes support installing and updating software from artifacts in the
    following formats:
    Zip archive, Tar archive, Windows MSI, Debian package, and RPM package.

    Additionally, recipes support executing a script (either defined in a file or
    directly in this api) in bash, sh, cmd, and powershell.

    Updating a software recipe

    If a recipe is assigned to an instance and there is a recipe with the same
    name but a lower version already installed and the assigned state
    of the recipe is `INSTALLED_KEEP_UPDATED`, then the recipe is updated to
    the new version.

    Script Working Directories

    Each script or execution step is run in its own temporary directory which
    is deleted after completing the step.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Artifact(google.protobuf.message.Message):
        """Specifies a resource to be used in the recipe."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Remote(google.protobuf.message.Message):
            """Specifies an artifact available via some URI."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            URI_FIELD_NUMBER: builtins.int
            CHECKSUM_FIELD_NUMBER: builtins.int
            uri: typing.Text = ...
            """URI from which to fetch the object. It should contain both the protocol
            and path following the format {protocol}://{location}.
            """

            checksum: typing.Text = ...
            """Must be provided if `allow_insecure` is `false`.
            SHA256 checksum in hex format, to compare to the checksum of the
            artifact. If the checksum is not empty and it doesn't match the
            artifact then the recipe installation fails before running any of the
            steps.
            """

            def __init__(self,
                *,
                uri : typing.Text = ...,
                checksum : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["checksum",b"checksum","uri",b"uri"]) -> None: ...

        class Gcs(google.protobuf.message.Message):
            """Specifies an artifact available as a Google Cloud Storage object."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            BUCKET_FIELD_NUMBER: builtins.int
            OBJECT_FIELD_NUMBER: builtins.int
            GENERATION_FIELD_NUMBER: builtins.int
            bucket: typing.Text = ...
            """Bucket of the Google Cloud Storage object.
            Given an example URL:
            `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
            this value would be `my-bucket`.
            """

            object: typing.Text = ...
            """Name of the Google Cloud Storage object.
            As specified [here]
            (https://cloud.google.com/storage/docs/naming#objectnames)
            Given an example URL:
            `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
            this value would be `foo/bar`.
            """

            generation: builtins.int = ...
            """Must be provided if allow_insecure is false.
            Generation number of the Google Cloud Storage object.
            `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
            this value would be `1234567`.
            """

            def __init__(self,
                *,
                bucket : typing.Text = ...,
                object : typing.Text = ...,
                generation : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["bucket",b"bucket","generation",b"generation","object",b"object"]) -> None: ...

        ID_FIELD_NUMBER: builtins.int
        REMOTE_FIELD_NUMBER: builtins.int
        GCS_FIELD_NUMBER: builtins.int
        ALLOW_INSECURE_FIELD_NUMBER: builtins.int
        id: typing.Text = ...
        """Required. Id of the artifact, which the installation and update steps of this
        recipe can reference. Artifacts in a recipe cannot have the same id.
        """

        @property
        def remote(self) -> global___SoftwareRecipe.Artifact.Remote:
            """A generic remote artifact."""
            pass
        @property
        def gcs(self) -> global___SoftwareRecipe.Artifact.Gcs:
            """A Google Cloud Storage artifact."""
            pass
        allow_insecure: builtins.bool = ...
        """Defaults to false. When false, recipes are subject to validations
        based on the artifact type:

        Remote: A checksum must be specified, and only protocols with
        transport-layer security are permitted.
        GCS:    An object generation number must be specified.
        """

        def __init__(self,
            *,
            id : typing.Text = ...,
            remote : typing.Optional[global___SoftwareRecipe.Artifact.Remote] = ...,
            gcs : typing.Optional[global___SoftwareRecipe.Artifact.Gcs] = ...,
            allow_insecure : builtins.bool = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["artifact",b"artifact","gcs",b"gcs","remote",b"remote"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["allow_insecure",b"allow_insecure","artifact",b"artifact","gcs",b"gcs","id",b"id","remote",b"remote"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["artifact",b"artifact"]) -> typing.Optional[typing_extensions.Literal["remote","gcs"]]: ...

    class Step(google.protobuf.message.Message):
        """An action that can be taken as part of installing or updating a recipe."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class CopyFile(google.protobuf.message.Message):
            """Copies the artifact to the specified path on the instance."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            DESTINATION_FIELD_NUMBER: builtins.int
            OVERWRITE_FIELD_NUMBER: builtins.int
            PERMISSIONS_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """Required. The id of the relevant artifact in the recipe."""

            destination: typing.Text = ...
            """Required. The absolute path on the instance to put the file."""

            overwrite: builtins.bool = ...
            """Whether to allow this step to overwrite existing files. If this is
            false and the file already exists the file is not overwritten
            and the step is considered a success. Defaults to false.
            """

            permissions: typing.Text = ...
            """Consists of three octal digits which represent, in
            order, the permissions of the owner, group, and other users for the
            file (similarly to the numeric mode used in the linux chmod utility).
            Each digit represents a three bit number with the 4 bit
            corresponding to the read permissions, the 2 bit corresponds to the
            write bit, and the one bit corresponds to the execute permission.
            Default behavior is 755.

            Below are some examples of permissions and their associated values:
            read, write, and execute: 7
            read and execute: 5
            read and write: 6
            read only: 4
            """

            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                destination : typing.Text = ...,
                overwrite : builtins.bool = ...,
                permissions : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["artifact_id",b"artifact_id","destination",b"destination","overwrite",b"overwrite","permissions",b"permissions"]) -> None: ...

        class ExtractArchive(google.protobuf.message.Message):
            """Extracts an archive of the type specified in the specified directory."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class _ArchiveType:
                ValueType = typing.NewType('ValueType', builtins.int)
                V: typing_extensions.TypeAlias = ValueType
            class _ArchiveTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ArchiveType.ValueType], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
                ARCHIVE_TYPE_UNSPECIFIED: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 0
                """Indicates that the archive type isn't specified."""

                TAR: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 1
                """Indicates that the archive is a tar archive with no encryption."""

                TAR_GZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 2
                """Indicates that the archive is a tar archive with gzip encryption."""

                TAR_BZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 3
                """Indicates that the archive is a tar archive with bzip encryption."""

                TAR_LZMA: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 4
                """Indicates that the archive is a tar archive with lzma encryption."""

                TAR_XZ: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 5
                """Indicates that the archive is a tar archive with xz encryption."""

                ZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 11
                """Indicates that the archive is a zip archive."""

            class ArchiveType(_ArchiveType, metaclass=_ArchiveTypeEnumTypeWrapper):
                """Specifying the type of archive."""
                pass

            ARCHIVE_TYPE_UNSPECIFIED: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 0
            """Indicates that the archive type isn't specified."""

            TAR: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 1
            """Indicates that the archive is a tar archive with no encryption."""

            TAR_GZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 2
            """Indicates that the archive is a tar archive with gzip encryption."""

            TAR_BZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 3
            """Indicates that the archive is a tar archive with bzip encryption."""

            TAR_LZMA: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 4
            """Indicates that the archive is a tar archive with lzma encryption."""

            TAR_XZ: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 5
            """Indicates that the archive is a tar archive with xz encryption."""

            ZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 11
            """Indicates that the archive is a zip archive."""


            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            DESTINATION_FIELD_NUMBER: builtins.int
            TYPE_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """Required. The id of the relevant artifact in the recipe."""

            destination: typing.Text = ...
            """Directory to extract archive to.
            Defaults to `/` on Linux or `C:\\` on Windows.
            """

            type: global___SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...
            """Required. The type of the archive to extract."""

            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                destination : typing.Text = ...,
                type : global___SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["artifact_id",b"artifact_id","destination",b"destination","type",b"type"]) -> None: ...

        class InstallMsi(google.protobuf.message.Message):
            """Installs an MSI file."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            FLAGS_FIELD_NUMBER: builtins.int
            ALLOWED_EXIT_CODES_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """Required. The id of the relevant artifact in the recipe."""

            @property
            def flags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """The flags to use when installing the MSI
                defaults to ["/i"] (i.e. the install flag).
                """
                pass
            @property
            def allowed_exit_codes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """Return codes that indicate that the software installed or updated
                successfully. Behaviour defaults to [0]
                """
                pass
            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                flags : typing.Optional[typing.Iterable[typing.Text]] = ...,
                allowed_exit_codes : typing.Optional[typing.Iterable[builtins.int]] = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["allowed_exit_codes",b"allowed_exit_codes","artifact_id",b"artifact_id","flags",b"flags"]) -> None: ...

        class InstallDpkg(google.protobuf.message.Message):
            """Installs a deb via dpkg."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """Required. The id of the relevant artifact in the recipe."""

            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["artifact_id",b"artifact_id"]) -> None: ...

        class InstallRpm(google.protobuf.message.Message):
            """Installs an rpm file via the rpm utility."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """Required. The id of the relevant artifact in the recipe."""

            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["artifact_id",b"artifact_id"]) -> None: ...

        class ExecFile(google.protobuf.message.Message):
            """Executes an artifact or local file."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            LOCAL_PATH_FIELD_NUMBER: builtins.int
            ARGS_FIELD_NUMBER: builtins.int
            ALLOWED_EXIT_CODES_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """The id of the relevant artifact in the recipe."""

            local_path: typing.Text = ...
            """The absolute path of the file on the local filesystem."""

            @property
            def args(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """Arguments to be passed to the provided executable."""
                pass
            @property
            def allowed_exit_codes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """Defaults to [0]. A list of possible return values that the program
                can return to indicate a success.
                """
                pass
            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                local_path : typing.Text = ...,
                args : typing.Optional[typing.Iterable[typing.Text]] = ...,
                allowed_exit_codes : typing.Optional[typing.Iterable[builtins.int]] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["artifact_id",b"artifact_id","local_path",b"local_path","location_type",b"location_type"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["allowed_exit_codes",b"allowed_exit_codes","args",b"args","artifact_id",b"artifact_id","local_path",b"local_path","location_type",b"location_type"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["location_type",b"location_type"]) -> typing.Optional[typing_extensions.Literal["artifact_id","local_path"]]: ...

        class RunScript(google.protobuf.message.Message):
            """Runs a script through an interpreter."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class _Interpreter:
                ValueType = typing.NewType('ValueType', builtins.int)
                V: typing_extensions.TypeAlias = ValueType
            class _InterpreterEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Interpreter.ValueType], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
                INTERPRETER_UNSPECIFIED: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 0
                """Default value for ScriptType."""

                SHELL: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 1
                """Indicates that the script is run with `/bin/sh` on Linux and `cmd`
                on windows.
                """

                POWERSHELL: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 3
                """Indicates that the script is run with powershell."""

            class Interpreter(_Interpreter, metaclass=_InterpreterEnumTypeWrapper):
                """The interpreter used to execute a script."""
                pass

            INTERPRETER_UNSPECIFIED: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 0
            """Default value for ScriptType."""

            SHELL: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 1
            """Indicates that the script is run with `/bin/sh` on Linux and `cmd`
            on windows.
            """

            POWERSHELL: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 3
            """Indicates that the script is run with powershell."""


            SCRIPT_FIELD_NUMBER: builtins.int
            ALLOWED_EXIT_CODES_FIELD_NUMBER: builtins.int
            INTERPRETER_FIELD_NUMBER: builtins.int
            script: typing.Text = ...
            """Required. The shell script to be executed."""

            @property
            def allowed_exit_codes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """Return codes that indicate that the software installed or updated
                successfully. Behaviour defaults to [0]
                """
                pass
            interpreter: global___SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...
            """The script interpreter to use to run the script. If no interpreter is
            specified the script is executed directly, which likely
            only succeed for scripts with
            [shebang lines](https://en.wikipedia.org/wiki/Shebang_\\(Unix\\)).
            """

            def __init__(self,
                *,
                script : typing.Text = ...,
                allowed_exit_codes : typing.Optional[typing.Iterable[builtins.int]] = ...,
                interpreter : global___SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["allowed_exit_codes",b"allowed_exit_codes","interpreter",b"interpreter","script",b"script"]) -> None: ...

        FILE_COPY_FIELD_NUMBER: builtins.int
        ARCHIVE_EXTRACTION_FIELD_NUMBER: builtins.int
        MSI_INSTALLATION_FIELD_NUMBER: builtins.int
        DPKG_INSTALLATION_FIELD_NUMBER: builtins.int
        RPM_INSTALLATION_FIELD_NUMBER: builtins.int
        FILE_EXEC_FIELD_NUMBER: builtins.int
        SCRIPT_RUN_FIELD_NUMBER: builtins.int
        @property
        def file_copy(self) -> global___SoftwareRecipe.Step.CopyFile:
            """Copies a file onto the instance."""
            pass
        @property
        def archive_extraction(self) -> global___SoftwareRecipe.Step.ExtractArchive:
            """Extracts an archive into the specified directory."""
            pass
        @property
        def msi_installation(self) -> global___SoftwareRecipe.Step.InstallMsi:
            """Installs an MSI file."""
            pass
        @property
        def dpkg_installation(self) -> global___SoftwareRecipe.Step.InstallDpkg:
            """Installs a deb file via dpkg."""
            pass
        @property
        def rpm_installation(self) -> global___SoftwareRecipe.Step.InstallRpm:
            """Installs an rpm file via the rpm utility."""
            pass
        @property
        def file_exec(self) -> global___SoftwareRecipe.Step.ExecFile:
            """Executes an artifact or local file."""
            pass
        @property
        def script_run(self) -> global___SoftwareRecipe.Step.RunScript:
            """Runs commands in a shell."""
            pass
        def __init__(self,
            *,
            file_copy : typing.Optional[global___SoftwareRecipe.Step.CopyFile] = ...,
            archive_extraction : typing.Optional[global___SoftwareRecipe.Step.ExtractArchive] = ...,
            msi_installation : typing.Optional[global___SoftwareRecipe.Step.InstallMsi] = ...,
            dpkg_installation : typing.Optional[global___SoftwareRecipe.Step.InstallDpkg] = ...,
            rpm_installation : typing.Optional[global___SoftwareRecipe.Step.InstallRpm] = ...,
            file_exec : typing.Optional[global___SoftwareRecipe.Step.ExecFile] = ...,
            script_run : typing.Optional[global___SoftwareRecipe.Step.RunScript] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["archive_extraction",b"archive_extraction","dpkg_installation",b"dpkg_installation","file_copy",b"file_copy","file_exec",b"file_exec","msi_installation",b"msi_installation","rpm_installation",b"rpm_installation","script_run",b"script_run","step",b"step"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["archive_extraction",b"archive_extraction","dpkg_installation",b"dpkg_installation","file_copy",b"file_copy","file_exec",b"file_exec","msi_installation",b"msi_installation","rpm_installation",b"rpm_installation","script_run",b"script_run","step",b"step"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["step",b"step"]) -> typing.Optional[typing_extensions.Literal["file_copy","archive_extraction","msi_installation","dpkg_installation","rpm_installation","file_exec","script_run"]]: ...

    NAME_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    ARTIFACTS_FIELD_NUMBER: builtins.int
    INSTALL_STEPS_FIELD_NUMBER: builtins.int
    UPDATE_STEPS_FIELD_NUMBER: builtins.int
    DESIRED_STATE_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Unique identifier for the recipe. Only one recipe with a given name is
    installed on an instance.

    Names are also used to identify resources which helps to determine whether
    guest policies have conflicts. This means that requests to create multiple
    recipes with the same name and version are rejected since they
    could potentially have conflicting assignments.
    """

    version: typing.Text = ...
    """The version of this software recipe. Version can be up to 4 period
    separated numbers (e.g. 12.34.56.78).
    """

    @property
    def artifacts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SoftwareRecipe.Artifact]:
        """Resources available to be used in the steps in the recipe."""
        pass
    @property
    def install_steps(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SoftwareRecipe.Step]:
        """Actions to be taken for installing this recipe. On failure it stops
        executing steps and does not attempt another installation. Any steps taken
        (including partially completed steps) are not rolled back.
        """
        pass
    @property
    def update_steps(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SoftwareRecipe.Step]:
        """Actions to be taken for updating this recipe. On failure it stops
        executing steps and  does not attempt another update for this recipe. Any
        steps taken (including partially completed steps) are not rolled back.
        """
        pass
    desired_state: global___DesiredState.ValueType = ...
    """Default is INSTALLED. The desired state the agent should maintain for this
    recipe.

    INSTALLED: The software recipe is installed on the instance but
               won't be updated to new versions.
    INSTALLED_KEEP_UPDATED: The software recipe is installed on the
                            instance. The recipe is updated to a higher
                            version, if a higher version of the recipe is
                            assigned to this instance.
    REMOVE: Remove is unsupported for software recipes and attempts to
            create or update a recipe to the REMOVE state is rejected.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        version : typing.Text = ...,
        artifacts : typing.Optional[typing.Iterable[global___SoftwareRecipe.Artifact]] = ...,
        install_steps : typing.Optional[typing.Iterable[global___SoftwareRecipe.Step]] = ...,
        update_steps : typing.Optional[typing.Iterable[global___SoftwareRecipe.Step]] = ...,
        desired_state : global___DesiredState.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["artifacts",b"artifacts","desired_state",b"desired_state","install_steps",b"install_steps","name",b"name","update_steps",b"update_steps","version",b"version"]) -> None: ...
global___SoftwareRecipe = SoftwareRecipe

class CreateGuestPolicyRequest(google.protobuf.message.Message):
    """A request message for creating a guest policy."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    GUEST_POLICY_ID_FIELD_NUMBER: builtins.int
    GUEST_POLICY_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The resource name of the parent using one of the following forms:
    `projects/{project_number}`.
    """

    guest_policy_id: typing.Text = ...
    """Required. The logical name of the guest policy in the project
    with the following restrictions:

    * Must contain only lowercase letters, numbers, and hyphens.
    * Must start with a letter.
    * Must be between 1-63 characters.
    * Must end with a number or a letter.
    * Must be unique within the project.
    """

    @property
    def guest_policy(self) -> global___GuestPolicy:
        """Required. The GuestPolicy to create."""
        pass
    def __init__(self,
        *,
        parent : typing.Text = ...,
        guest_policy_id : typing.Text = ...,
        guest_policy : typing.Optional[global___GuestPolicy] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["guest_policy",b"guest_policy"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["guest_policy",b"guest_policy","guest_policy_id",b"guest_policy_id","parent",b"parent"]) -> None: ...
global___CreateGuestPolicyRequest = CreateGuestPolicyRequest

class GetGuestPolicyRequest(google.protobuf.message.Message):
    """A request message for retrieving a guest policy."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The resource name of the guest policy using one of the following forms:
    `projects/{project_number}/guestPolicies/{guest_policy_id}`.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetGuestPolicyRequest = GetGuestPolicyRequest

class ListGuestPoliciesRequest(google.protobuf.message.Message):
    """A request message for listing guest policies."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The resource name of the parent using one of the following forms:
    `projects/{project_number}`.
    """

    page_size: builtins.int = ...
    """The maximum number of guest policies to return."""

    page_token: typing.Text = ...
    """A pagination token returned from a previous call to `ListGuestPolicies`
    that indicates where this listing should continue from.
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["page_size",b"page_size","page_token",b"page_token","parent",b"parent"]) -> None: ...
global___ListGuestPoliciesRequest = ListGuestPoliciesRequest

class ListGuestPoliciesResponse(google.protobuf.message.Message):
    """A response message for listing guest policies."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GUEST_POLICIES_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def guest_policies(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___GuestPolicy]:
        """The list of GuestPolicies."""
        pass
    next_page_token: typing.Text = ...
    """A pagination token that can be used to get the next page
    of guest policies.
    """

    def __init__(self,
        *,
        guest_policies : typing.Optional[typing.Iterable[global___GuestPolicy]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["guest_policies",b"guest_policies","next_page_token",b"next_page_token"]) -> None: ...
global___ListGuestPoliciesResponse = ListGuestPoliciesResponse

class UpdateGuestPolicyRequest(google.protobuf.message.Message):
    """A request message for updating a guest policy."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GUEST_POLICY_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    @property
    def guest_policy(self) -> global___GuestPolicy:
        """Required. The updated GuestPolicy."""
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Field mask that controls which fields of the guest policy should be
        updated.
        """
        pass
    def __init__(self,
        *,
        guest_policy : typing.Optional[global___GuestPolicy] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["guest_policy",b"guest_policy","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["guest_policy",b"guest_policy","update_mask",b"update_mask"]) -> None: ...
global___UpdateGuestPolicyRequest = UpdateGuestPolicyRequest

class DeleteGuestPolicyRequest(google.protobuf.message.Message):
    """A request message for deleting a guest policy."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The resource name of the guest policy  using one of the following forms:
    `projects/{project_number}/guestPolicies/{guest_policy_id}`.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___DeleteGuestPolicyRequest = DeleteGuestPolicyRequest

class LookupEffectiveGuestPolicyRequest(google.protobuf.message.Message):
    """A request message for getting the effective guest policy assigned to the
    instance.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INSTANCE_FIELD_NUMBER: builtins.int
    OS_SHORT_NAME_FIELD_NUMBER: builtins.int
    OS_VERSION_FIELD_NUMBER: builtins.int
    OS_ARCHITECTURE_FIELD_NUMBER: builtins.int
    instance: typing.Text = ...
    """Required. The VM instance whose policies are being looked up."""

    os_short_name: typing.Text = ...
    """Short name of the OS running on the instance. The OS Config agent only
    provides this field for targeting if OS Inventory is enabled for that
    instance.
    """

    os_version: typing.Text = ...
    """Version of the OS running on the instance. The OS Config agent only
    provides this field for targeting if OS Inventory is enabled for that
    VM instance.
    """

    os_architecture: typing.Text = ...
    """Architecture of OS running on the instance. The OS Config agent only
    provides this field for targeting if OS Inventory is enabled for that
    instance.
    """

    def __init__(self,
        *,
        instance : typing.Text = ...,
        os_short_name : typing.Text = ...,
        os_version : typing.Text = ...,
        os_architecture : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["instance",b"instance","os_architecture",b"os_architecture","os_short_name",b"os_short_name","os_version",b"os_version"]) -> None: ...
global___LookupEffectiveGuestPolicyRequest = LookupEffectiveGuestPolicyRequest

class EffectiveGuestPolicy(google.protobuf.message.Message):
    """The effective guest policy that applies to a VM instance."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SourcedPackage(google.protobuf.message.Message):
        """A guest policy package including its source."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SOURCE_FIELD_NUMBER: builtins.int
        PACKAGE_FIELD_NUMBER: builtins.int
        source: typing.Text = ...
        """Name of the guest policy providing this config."""

        @property
        def package(self) -> global___Package:
            """A software package to configure on the VM instance."""
            pass
        def __init__(self,
            *,
            source : typing.Text = ...,
            package : typing.Optional[global___Package] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["package",b"package"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["package",b"package","source",b"source"]) -> None: ...

    class SourcedPackageRepository(google.protobuf.message.Message):
        """A guest policy package repository including its source."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SOURCE_FIELD_NUMBER: builtins.int
        PACKAGE_REPOSITORY_FIELD_NUMBER: builtins.int
        source: typing.Text = ...
        """Name of the guest policy providing this config."""

        @property
        def package_repository(self) -> global___PackageRepository:
            """A software package repository to configure on the VM instance."""
            pass
        def __init__(self,
            *,
            source : typing.Text = ...,
            package_repository : typing.Optional[global___PackageRepository] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["package_repository",b"package_repository"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["package_repository",b"package_repository","source",b"source"]) -> None: ...

    class SourcedSoftwareRecipe(google.protobuf.message.Message):
        """A guest policy recipe including its source."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SOURCE_FIELD_NUMBER: builtins.int
        SOFTWARE_RECIPE_FIELD_NUMBER: builtins.int
        source: typing.Text = ...
        """Name of the guest policy providing this config."""

        @property
        def software_recipe(self) -> global___SoftwareRecipe:
            """A software recipe to configure on the VM instance."""
            pass
        def __init__(self,
            *,
            source : typing.Text = ...,
            software_recipe : typing.Optional[global___SoftwareRecipe] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["software_recipe",b"software_recipe"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["software_recipe",b"software_recipe","source",b"source"]) -> None: ...

    PACKAGES_FIELD_NUMBER: builtins.int
    PACKAGE_REPOSITORIES_FIELD_NUMBER: builtins.int
    SOFTWARE_RECIPES_FIELD_NUMBER: builtins.int
    @property
    def packages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EffectiveGuestPolicy.SourcedPackage]:
        """List of package configurations assigned to the VM instance."""
        pass
    @property
    def package_repositories(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EffectiveGuestPolicy.SourcedPackageRepository]:
        """List of package repository configurations assigned to the VM instance."""
        pass
    @property
    def software_recipes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EffectiveGuestPolicy.SourcedSoftwareRecipe]:
        """List of recipes assigned to the VM instance."""
        pass
    def __init__(self,
        *,
        packages : typing.Optional[typing.Iterable[global___EffectiveGuestPolicy.SourcedPackage]] = ...,
        package_repositories : typing.Optional[typing.Iterable[global___EffectiveGuestPolicy.SourcedPackageRepository]] = ...,
        software_recipes : typing.Optional[typing.Iterable[global___EffectiveGuestPolicy.SourcedSoftwareRecipe]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["package_repositories",b"package_repositories","packages",b"packages","software_recipes",b"software_recipes"]) -> None: ...
global___EffectiveGuestPolicy = EffectiveGuestPolicy
