"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _DesiredState:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _DesiredStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DesiredState.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    DESIRED_STATE_UNSPECIFIED: DesiredState.ValueType = ...  # 0
    """The default is to ensure the package is installed."""

    INSTALLED: DesiredState.ValueType = ...  # 1
    """The agent ensures that the package is installed."""

    UPDATED: DesiredState.ValueType = ...  # 2
    """The agent ensures that the package is installed and
    periodically checks for and install any updates.
    """

    REMOVED: DesiredState.ValueType = ...  # 3
    """The agent ensures that the package is not installed and uninstall it
    if detected.
    """

class DesiredState(_DesiredState, metaclass=_DesiredStateEnumTypeWrapper):
    """The desired state that the OS Config agent will maintain on the VM."""
    pass

DESIRED_STATE_UNSPECIFIED: DesiredState.ValueType = ...  # 0
"""The default is to ensure the package is installed."""

INSTALLED: DesiredState.ValueType = ...  # 1
"""The agent ensures that the package is installed."""

UPDATED: DesiredState.ValueType = ...  # 2
"""The agent ensures that the package is installed and
periodically checks for and install any updates.
"""

REMOVED: DesiredState.ValueType = ...  # 3
"""The agent ensures that the package is not installed and uninstall it
if detected.
"""

global___DesiredState = DesiredState


class Package(google.protobuf.message.Message):
    """Package is a reference to the software package to be installed or removed.
    The agent on the VM instance uses the system package manager to apply the
    config.


    These are the commands that the agent uses to install or remove
    packages.

    Apt
    install: `apt-get update && apt-get -y install package1 package2 package3`
    remove: `apt-get -y remove package1 package2 package3`

    Yum
    install: `yum -y install package1 package2 package3`
    remove: `yum -y remove package1 package2 package3`

    Zypper
    install: `zypper install package1 package2 package3`
    remove: `zypper rm package1 package2`

    Googet
    install: `googet -noconfirm install package1 package2 package3`
    remove: `googet -noconfirm remove package1 package2 package3`
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Manager:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ManagerEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Manager.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        MANAGER_UNSPECIFIED: Package.Manager.ValueType = ...  # 0
        """The default behavior is ANY."""

        ANY: Package.Manager.ValueType = ...  # 1
        """Apply this package config using the default system package manager."""

        APT: Package.Manager.ValueType = ...  # 2
        """Apply this package config only if Apt is available on the system."""

        YUM: Package.Manager.ValueType = ...  # 3
        """Apply this package config only if Yum is available on the system."""

        ZYPPER: Package.Manager.ValueType = ...  # 4
        """Apply this package config only if Zypper is available on the system."""

        GOO: Package.Manager.ValueType = ...  # 5
        """Apply this package config only if GooGet is available on the system."""

    class Manager(_Manager, metaclass=_ManagerEnumTypeWrapper):
        """Types of package managers that may be used to manage this package."""
        pass

    MANAGER_UNSPECIFIED: Package.Manager.ValueType = ...  # 0
    """The default behavior is ANY."""

    ANY: Package.Manager.ValueType = ...  # 1
    """Apply this package config using the default system package manager."""

    APT: Package.Manager.ValueType = ...  # 2
    """Apply this package config only if Apt is available on the system."""

    YUM: Package.Manager.ValueType = ...  # 3
    """Apply this package config only if Yum is available on the system."""

    ZYPPER: Package.Manager.ValueType = ...  # 4
    """Apply this package config only if Zypper is available on the system."""

    GOO: Package.Manager.ValueType = ...  # 5
    """Apply this package config only if GooGet is available on the system."""


    NAME_FIELD_NUMBER: builtins.int
    DESIRED_STATE_FIELD_NUMBER: builtins.int
    MANAGER_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The name of the package. A package is uniquely identified for conflict
    validation by checking the package name and the manager(s) that the
    package targets.
    """

    desired_state: global___DesiredState.ValueType = ...
    """The desired_state the agent should maintain for this package. The
    default is to ensure the package is installed.
    """

    manager: global___Package.Manager.ValueType = ...
    """Type of package manager that can be used to install this package.
    If a system does not have the package manager, the package is not
    installed or removed no error message is returned. By default,
    or if you specify `ANY`,
    the agent attempts to install and remove this package using the default
    package manager. This is useful when creating a policy that applies to
    different types of systems.

    The default behavior is ANY.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        desired_state : global___DesiredState.ValueType = ...,
        manager : global___Package.Manager.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["desired_state",b"desired_state","manager",b"manager","name",b"name"]) -> None: ...
global___Package = Package

class AptRepository(google.protobuf.message.Message):
    """Represents a single Apt package repository. This repository is added to
    a repo file that is stored at
    `/etc/apt/sources.list.d/google_osconfig.list`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _ArchiveType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ArchiveTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ArchiveType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        ARCHIVE_TYPE_UNSPECIFIED: AptRepository.ArchiveType.ValueType = ...  # 0
        """Unspecified."""

        DEB: AptRepository.ArchiveType.ValueType = ...  # 1
        """DEB indicates that the archive contains binary files."""

        DEB_SRC: AptRepository.ArchiveType.ValueType = ...  # 2
        """DEB_SRC indicates that the archive contains source files."""

    class ArchiveType(_ArchiveType, metaclass=_ArchiveTypeEnumTypeWrapper):
        """Type of archive."""
        pass

    ARCHIVE_TYPE_UNSPECIFIED: AptRepository.ArchiveType.ValueType = ...  # 0
    """Unspecified."""

    DEB: AptRepository.ArchiveType.ValueType = ...  # 1
    """DEB indicates that the archive contains binary files."""

    DEB_SRC: AptRepository.ArchiveType.ValueType = ...  # 2
    """DEB_SRC indicates that the archive contains source files."""


    ARCHIVE_TYPE_FIELD_NUMBER: builtins.int
    URI_FIELD_NUMBER: builtins.int
    DISTRIBUTION_FIELD_NUMBER: builtins.int
    COMPONENTS_FIELD_NUMBER: builtins.int
    GPG_KEY_FIELD_NUMBER: builtins.int
    archive_type: global___AptRepository.ArchiveType.ValueType = ...
    """Type of archive files in this repository. The default behavior is DEB."""

    uri: typing.Text = ...
    """URI for this repository."""

    distribution: typing.Text = ...
    """Distribution of this repository."""

    @property
    def components(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """List of components for this repository. Must contain at least one item."""
        pass
    gpg_key: typing.Text = ...
    """URI of the key file for this repository. The agent maintains
    a keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg` containing
    all the keys in any applied guest policy.
    """

    def __init__(self,
        *,
        archive_type : global___AptRepository.ArchiveType.ValueType = ...,
        uri : typing.Text = ...,
        distribution : typing.Text = ...,
        components : typing.Optional[typing.Iterable[typing.Text]] = ...,
        gpg_key : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["archive_type",b"archive_type","components",b"components","distribution",b"distribution","gpg_key",b"gpg_key","uri",b"uri"]) -> None: ...
global___AptRepository = AptRepository

class YumRepository(google.protobuf.message.Message):
    """Represents a single Yum package repository. This repository is added to a
    repo file that is stored at `/etc/yum.repos.d/google_osconfig.repo`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    BASE_URL_FIELD_NUMBER: builtins.int
    GPG_KEYS_FIELD_NUMBER: builtins.int
    id: typing.Text = ...
    """A one word, unique name for this repository. This is
    the `repo id` in the Yum config file and also the `display_name` if
    `display_name` is omitted. This id is also used as the unique identifier
    when checking for guest policy conflicts.
    """

    display_name: typing.Text = ...
    """The display name of the repository."""

    base_url: typing.Text = ...
    """The location of the repository directory."""

    @property
    def gpg_keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """URIs of GPG keys."""
        pass
    def __init__(self,
        *,
        id : typing.Text = ...,
        display_name : typing.Text = ...,
        base_url : typing.Text = ...,
        gpg_keys : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["base_url",b"base_url","display_name",b"display_name","gpg_keys",b"gpg_keys","id",b"id"]) -> None: ...
global___YumRepository = YumRepository

class ZypperRepository(google.protobuf.message.Message):
    """Represents a single Zypper package repository. This repository is added to a
    repo file that is stored at `/etc/zypp/repos.d/google_osconfig.repo`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    BASE_URL_FIELD_NUMBER: builtins.int
    GPG_KEYS_FIELD_NUMBER: builtins.int
    id: typing.Text = ...
    """A one word, unique name for this repository. This is
    the `repo id` in the zypper config file and also the `display_name` if
    `display_name` is omitted. This id is also used as the unique identifier
    when checking for guest policy conflicts.
    """

    display_name: typing.Text = ...
    """The display name of the repository."""

    base_url: typing.Text = ...
    """The location of the repository directory."""

    @property
    def gpg_keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """URIs of GPG keys."""
        pass
    def __init__(self,
        *,
        id : typing.Text = ...,
        display_name : typing.Text = ...,
        base_url : typing.Text = ...,
        gpg_keys : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["base_url",b"base_url","display_name",b"display_name","gpg_keys",b"gpg_keys","id",b"id"]) -> None: ...
global___ZypperRepository = ZypperRepository

class GooRepository(google.protobuf.message.Message):
    """Represents a Goo package repository. These is added to a repo file
    that is stored at C:/ProgramData/GooGet/repos/google_osconfig.repo.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    URL_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The name of the repository."""

    url: typing.Text = ...
    """The url of the repository."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        url : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name","url",b"url"]) -> None: ...
global___GooRepository = GooRepository

class PackageRepository(google.protobuf.message.Message):
    """A package repository."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    APT_FIELD_NUMBER: builtins.int
    YUM_FIELD_NUMBER: builtins.int
    ZYPPER_FIELD_NUMBER: builtins.int
    GOO_FIELD_NUMBER: builtins.int
    @property
    def apt(self) -> global___AptRepository:
        """An Apt Repository."""
        pass
    @property
    def yum(self) -> global___YumRepository:
        """A Yum Repository."""
        pass
    @property
    def zypper(self) -> global___ZypperRepository:
        """A Zypper Repository."""
        pass
    @property
    def goo(self) -> global___GooRepository:
        """A Goo Repository."""
        pass
    def __init__(self,
        *,
        apt : typing.Optional[global___AptRepository] = ...,
        yum : typing.Optional[global___YumRepository] = ...,
        zypper : typing.Optional[global___ZypperRepository] = ...,
        goo : typing.Optional[global___GooRepository] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["apt",b"apt","goo",b"goo","repository",b"repository","yum",b"yum","zypper",b"zypper"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["apt",b"apt","goo",b"goo","repository",b"repository","yum",b"yum","zypper",b"zypper"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["repository",b"repository"]) -> typing.Optional[typing_extensions.Literal["apt","yum","zypper","goo"]]: ...
global___PackageRepository = PackageRepository

class SoftwareRecipe(google.protobuf.message.Message):
    """A software recipe is a set of instructions for installing and configuring a
    piece of software. It consists of a set of artifacts that are
    downloaded, and a set of steps that install, configure, and/or update the
    software.

    Recipes support installing and updating software from artifacts in the
    following formats:
    Zip archive, Tar archive, Windows MSI, Debian package, and RPM package.

    Additionally, recipes support executing a script (either defined in a file or
    directly in this api) in bash, sh, cmd, and powershell.

    Updating a software recipe

    If a recipe is assigned to an instance and there is a recipe with the same
    name but a lower version already installed and the assigned state
    of the recipe is `INSTALLED_KEEP_UPDATED`, then the recipe is updated to
    the new version.

    Script Working Directories

    Each script or execution step is run in its own temporary directory which
    is deleted after completing the step.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Artifact(google.protobuf.message.Message):
        """Specifies a resource to be used in the recipe."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Remote(google.protobuf.message.Message):
            """Specifies an artifact available via some URI."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            URI_FIELD_NUMBER: builtins.int
            CHECKSUM_FIELD_NUMBER: builtins.int
            uri: typing.Text = ...
            """URI from which to fetch the object. It should contain both the protocol
            and path following the format {protocol}://{location}.
            """

            checksum: typing.Text = ...
            """Must be provided if `allow_insecure` is `false`.
            SHA256 checksum in hex format, to compare to the checksum of the
            artifact. If the checksum is not empty and it doesn't match the
            artifact then the recipe installation fails before running any of the
            steps.
            """

            def __init__(self,
                *,
                uri : typing.Text = ...,
                checksum : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["checksum",b"checksum","uri",b"uri"]) -> None: ...

        class Gcs(google.protobuf.message.Message):
            """Specifies an artifact available as a Cloud Storage object."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            BUCKET_FIELD_NUMBER: builtins.int
            OBJECT_FIELD_NUMBER: builtins.int
            GENERATION_FIELD_NUMBER: builtins.int
            bucket: typing.Text = ...
            """Bucket of the Cloud Storage object.
            Given an example URL:
            `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
            this value would be `my-bucket`.
            """

            object: typing.Text = ...
            """Name of the Cloud Storage object.
            As specified [here]
            (https://cloud.google.com/storage/docs/naming#objectnames)
            Given an example URL:
            `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
            this value would be `foo/bar`.
            """

            generation: builtins.int = ...
            """Must be provided if allow_insecure is false.
            Generation number of the Cloud Storage object.
            `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
            this value would be `1234567`.
            """

            def __init__(self,
                *,
                bucket : typing.Text = ...,
                object : typing.Text = ...,
                generation : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["bucket",b"bucket","generation",b"generation","object",b"object"]) -> None: ...

        ID_FIELD_NUMBER: builtins.int
        REMOTE_FIELD_NUMBER: builtins.int
        GCS_FIELD_NUMBER: builtins.int
        ALLOW_INSECURE_FIELD_NUMBER: builtins.int
        id: typing.Text = ...
        """Id of the artifact, which the installation and update steps of this
        recipe can reference. Artifacts in a recipe cannot have the same id.
        """

        @property
        def remote(self) -> global___SoftwareRecipe.Artifact.Remote:
            """A generic remote artifact."""
            pass
        @property
        def gcs(self) -> global___SoftwareRecipe.Artifact.Gcs:
            """A Cloud Storage artifact."""
            pass
        allow_insecure: builtins.bool = ...
        """Defaults to false. When false, recipes are subject to validations
        based on the artifact type:

        Remote: A checksum must be specified, and only protocols with
                transport-layer security are permitted.
        GCS:    An object generation number must be specified.
        """

        def __init__(self,
            *,
            id : typing.Text = ...,
            remote : typing.Optional[global___SoftwareRecipe.Artifact.Remote] = ...,
            gcs : typing.Optional[global___SoftwareRecipe.Artifact.Gcs] = ...,
            allow_insecure : builtins.bool = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["artifact",b"artifact","gcs",b"gcs","remote",b"remote"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["allow_insecure",b"allow_insecure","artifact",b"artifact","gcs",b"gcs","id",b"id","remote",b"remote"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["artifact",b"artifact"]) -> typing.Optional[typing_extensions.Literal["remote","gcs"]]: ...

    class Step(google.protobuf.message.Message):
        """An action that can be taken as part of installing or updating a recipe."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class CopyFile(google.protobuf.message.Message):
            """Copies the artifact to the specified path on the instance."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            DESTINATION_FIELD_NUMBER: builtins.int
            OVERWRITE_FIELD_NUMBER: builtins.int
            PERMISSIONS_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """The id of the relevant artifact in the recipe."""

            destination: typing.Text = ...
            """The absolute path on the instance to put the file."""

            overwrite: builtins.bool = ...
            """Whether to allow this step to overwrite existing files. If this is
            false and the file already exists the file is not overwritten
            and the step is considered a success. Defaults to false.
            """

            permissions: typing.Text = ...
            """Consists of three octal digits which represent, in
            order, the permissions of the owner, group, and other users for the
            file (similarly to the numeric mode used in the linux chmod utility).
            Each digit represents a three bit number with the 4 bit
            corresponding to the read permissions, the 2 bit corresponds to the
            write bit, and the one bit corresponds to the execute permission.
            Default behavior is 755.

            Below are some examples of permissions and their associated values:
            read, write, and execute: 7
            read and execute: 5
            read and write: 6
            read only: 4
            """

            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                destination : typing.Text = ...,
                overwrite : builtins.bool = ...,
                permissions : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["artifact_id",b"artifact_id","destination",b"destination","overwrite",b"overwrite","permissions",b"permissions"]) -> None: ...

        class ExtractArchive(google.protobuf.message.Message):
            """Extracts an archive of the type specified in the specified directory."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class _ArchiveType:
                ValueType = typing.NewType('ValueType', builtins.int)
                V: typing_extensions.TypeAlias = ValueType
            class _ArchiveTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ArchiveType.ValueType], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
                ARCHIVE_TYPE_UNSPECIFIED: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 0
                """Indicates that the archive type isn't specified."""

                TAR: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 1
                """Indicates that the archive is a tar archive with no encryption."""

                TAR_GZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 2
                """Indicates that the archive is a tar archive with gzip encryption."""

                TAR_BZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 3
                """Indicates that the archive is a tar archive with bzip encryption."""

                TAR_LZMA: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 4
                """Indicates that the archive is a tar archive with lzma encryption."""

                TAR_XZ: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 5
                """Indicates that the archive is a tar archive with xz encryption."""

                ZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 11
                """Indicates that the archive is a zip archive."""

            class ArchiveType(_ArchiveType, metaclass=_ArchiveTypeEnumTypeWrapper):
                """Specifying the type of archive."""
                pass

            ARCHIVE_TYPE_UNSPECIFIED: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 0
            """Indicates that the archive type isn't specified."""

            TAR: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 1
            """Indicates that the archive is a tar archive with no encryption."""

            TAR_GZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 2
            """Indicates that the archive is a tar archive with gzip encryption."""

            TAR_BZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 3
            """Indicates that the archive is a tar archive with bzip encryption."""

            TAR_LZMA: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 4
            """Indicates that the archive is a tar archive with lzma encryption."""

            TAR_XZ: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 5
            """Indicates that the archive is a tar archive with xz encryption."""

            ZIP: SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...  # 11
            """Indicates that the archive is a zip archive."""


            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            DESTINATION_FIELD_NUMBER: builtins.int
            TYPE_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """The id of the relevant artifact in the recipe."""

            destination: typing.Text = ...
            """Directory to extract archive to.
            Defaults to `/` on Linux or `C:\\` on Windows.
            """

            type: global___SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...
            """The type of the archive to extract."""

            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                destination : typing.Text = ...,
                type : global___SoftwareRecipe.Step.ExtractArchive.ArchiveType.ValueType = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["artifact_id",b"artifact_id","destination",b"destination","type",b"type"]) -> None: ...

        class InstallMsi(google.protobuf.message.Message):
            """Installs an MSI file."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            FLAGS_FIELD_NUMBER: builtins.int
            ALLOWED_EXIT_CODES_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """The id of the relevant artifact in the recipe."""

            @property
            def flags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """The flags to use when installing the MSI
                defaults to ["/i"] (i.e. the install flag).
                """
                pass
            @property
            def allowed_exit_codes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """Return codes that indicate that the software installed or updated
                successfully. Behaviour defaults to [0]
                """
                pass
            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                flags : typing.Optional[typing.Iterable[typing.Text]] = ...,
                allowed_exit_codes : typing.Optional[typing.Iterable[builtins.int]] = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["allowed_exit_codes",b"allowed_exit_codes","artifact_id",b"artifact_id","flags",b"flags"]) -> None: ...

        class InstallDpkg(google.protobuf.message.Message):
            """Installs a deb via dpkg."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """The id of the relevant artifact in the recipe."""

            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["artifact_id",b"artifact_id"]) -> None: ...

        class InstallRpm(google.protobuf.message.Message):
            """Installs an rpm file via the rpm utility."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """The id of the relevant artifact in the recipe."""

            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["artifact_id",b"artifact_id"]) -> None: ...

        class ExecFile(google.protobuf.message.Message):
            """Executes an artifact or local file."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            ARTIFACT_ID_FIELD_NUMBER: builtins.int
            LOCAL_PATH_FIELD_NUMBER: builtins.int
            ARGS_FIELD_NUMBER: builtins.int
            ALLOWED_EXIT_CODES_FIELD_NUMBER: builtins.int
            artifact_id: typing.Text = ...
            """The id of the relevant artifact in the recipe."""

            local_path: typing.Text = ...
            """The absolute path of the file on the local filesystem."""

            @property
            def args(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """Arguments to be passed to the provided executable."""
                pass
            @property
            def allowed_exit_codes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """Defaults to [0]. A list of possible return values that the program
                can return to indicate a success.
                """
                pass
            def __init__(self,
                *,
                artifact_id : typing.Text = ...,
                local_path : typing.Text = ...,
                args : typing.Optional[typing.Iterable[typing.Text]] = ...,
                allowed_exit_codes : typing.Optional[typing.Iterable[builtins.int]] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["artifact_id",b"artifact_id","local_path",b"local_path","location_type",b"location_type"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["allowed_exit_codes",b"allowed_exit_codes","args",b"args","artifact_id",b"artifact_id","local_path",b"local_path","location_type",b"location_type"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["location_type",b"location_type"]) -> typing.Optional[typing_extensions.Literal["artifact_id","local_path"]]: ...

        class RunScript(google.protobuf.message.Message):
            """Runs a script through an interpreter."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class _Interpreter:
                ValueType = typing.NewType('ValueType', builtins.int)
                V: typing_extensions.TypeAlias = ValueType
            class _InterpreterEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Interpreter.ValueType], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
                INTERPRETER_UNSPECIFIED: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 0
                """Default value for ScriptType."""

                SHELL: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 1
                """Indicates that the script is run with `/bin/sh` on Linux and `cmd`
                on windows.
                """

                POWERSHELL: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 3
                """Indicates that the script is run with powershell."""

            class Interpreter(_Interpreter, metaclass=_InterpreterEnumTypeWrapper):
                """The interpreter used to execute a script."""
                pass

            INTERPRETER_UNSPECIFIED: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 0
            """Default value for ScriptType."""

            SHELL: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 1
            """Indicates that the script is run with `/bin/sh` on Linux and `cmd`
            on windows.
            """

            POWERSHELL: SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...  # 3
            """Indicates that the script is run with powershell."""


            SCRIPT_FIELD_NUMBER: builtins.int
            ALLOWED_EXIT_CODES_FIELD_NUMBER: builtins.int
            INTERPRETER_FIELD_NUMBER: builtins.int
            script: typing.Text = ...
            """The shell script to be executed."""

            @property
            def allowed_exit_codes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """Return codes that indicate that the software installed or updated
                successfully. Behaviour defaults to [0]
                """
                pass
            interpreter: global___SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...
            """The script interpreter to use to run the script. If no interpreter is
            specified the script is executed directly, which likely
            only succeed for scripts with
            [shebang lines](https://en.wikipedia.org/wiki/Shebang_(Unix)).
            """

            def __init__(self,
                *,
                script : typing.Text = ...,
                allowed_exit_codes : typing.Optional[typing.Iterable[builtins.int]] = ...,
                interpreter : global___SoftwareRecipe.Step.RunScript.Interpreter.ValueType = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["allowed_exit_codes",b"allowed_exit_codes","interpreter",b"interpreter","script",b"script"]) -> None: ...

        FILE_COPY_FIELD_NUMBER: builtins.int
        ARCHIVE_EXTRACTION_FIELD_NUMBER: builtins.int
        MSI_INSTALLATION_FIELD_NUMBER: builtins.int
        DPKG_INSTALLATION_FIELD_NUMBER: builtins.int
        RPM_INSTALLATION_FIELD_NUMBER: builtins.int
        FILE_EXEC_FIELD_NUMBER: builtins.int
        SCRIPT_RUN_FIELD_NUMBER: builtins.int
        @property
        def file_copy(self) -> global___SoftwareRecipe.Step.CopyFile:
            """Copies a file onto the instance."""
            pass
        @property
        def archive_extraction(self) -> global___SoftwareRecipe.Step.ExtractArchive:
            """Extracts an archive into the specified directory."""
            pass
        @property
        def msi_installation(self) -> global___SoftwareRecipe.Step.InstallMsi:
            """Installs an MSI file."""
            pass
        @property
        def dpkg_installation(self) -> global___SoftwareRecipe.Step.InstallDpkg:
            """Installs a deb file via dpkg."""
            pass
        @property
        def rpm_installation(self) -> global___SoftwareRecipe.Step.InstallRpm:
            """Installs an rpm file via the rpm utility."""
            pass
        @property
        def file_exec(self) -> global___SoftwareRecipe.Step.ExecFile:
            """Executes an artifact or local file."""
            pass
        @property
        def script_run(self) -> global___SoftwareRecipe.Step.RunScript:
            """Runs commands in a shell."""
            pass
        def __init__(self,
            *,
            file_copy : typing.Optional[global___SoftwareRecipe.Step.CopyFile] = ...,
            archive_extraction : typing.Optional[global___SoftwareRecipe.Step.ExtractArchive] = ...,
            msi_installation : typing.Optional[global___SoftwareRecipe.Step.InstallMsi] = ...,
            dpkg_installation : typing.Optional[global___SoftwareRecipe.Step.InstallDpkg] = ...,
            rpm_installation : typing.Optional[global___SoftwareRecipe.Step.InstallRpm] = ...,
            file_exec : typing.Optional[global___SoftwareRecipe.Step.ExecFile] = ...,
            script_run : typing.Optional[global___SoftwareRecipe.Step.RunScript] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["archive_extraction",b"archive_extraction","dpkg_installation",b"dpkg_installation","file_copy",b"file_copy","file_exec",b"file_exec","msi_installation",b"msi_installation","rpm_installation",b"rpm_installation","script_run",b"script_run","step",b"step"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["archive_extraction",b"archive_extraction","dpkg_installation",b"dpkg_installation","file_copy",b"file_copy","file_exec",b"file_exec","msi_installation",b"msi_installation","rpm_installation",b"rpm_installation","script_run",b"script_run","step",b"step"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["step",b"step"]) -> typing.Optional[typing_extensions.Literal["file_copy","archive_extraction","msi_installation","dpkg_installation","rpm_installation","file_exec","script_run"]]: ...

    NAME_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    ARTIFACTS_FIELD_NUMBER: builtins.int
    INSTALL_STEPS_FIELD_NUMBER: builtins.int
    UPDATE_STEPS_FIELD_NUMBER: builtins.int
    DESIRED_STATE_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Unique identifier for the recipe. Only one recipe with a given name is
    installed on an instance.

    Names are also used to identify resources which helps to determine whether
    guest policies have conflicts. This means that requests to create multiple
    recipes with the same name and version are rejected since they
    could potentially have conflicting assignments.
    """

    version: typing.Text = ...
    """The version of this software recipe. Version can be up to 4 period
    separated numbers (e.g. 12.34.56.78).
    """

    @property
    def artifacts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SoftwareRecipe.Artifact]:
        """Resources available to be used in the steps in the recipe."""
        pass
    @property
    def install_steps(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SoftwareRecipe.Step]:
        """Actions to be taken for installing this recipe. On failure it stops
        executing steps and does not attempt another installation. Any steps taken
        (including partially completed steps) are not rolled back.  Install steps
        must be specified and are used on first installation.
        """
        pass
    @property
    def update_steps(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SoftwareRecipe.Step]:
        """Actions to be taken for updating this recipe. On failure it stops
        executing steps and  does not attempt another update for this recipe. Any
        steps taken (including partially completed steps) are not rolled back.
        Upgrade steps are not mandatory and are only used when upgrading.
        """
        pass
    desired_state: global___DesiredState.ValueType = ...
    """Default is INSTALLED. The desired state the agent should maintain for this
    recipe.

    INSTALLED: The software recipe is installed on the instance but won't be
                            updated to new versions.
    UPDATED: The software recipe is installed on the instance. The recipe is
                            updated to a higher version, if a higher version of
                            the recipe is assigned to this instance.
    REMOVE: Remove is unsupported for software recipes and attempts to
            create or update a recipe to the REMOVE state is rejected.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        version : typing.Text = ...,
        artifacts : typing.Optional[typing.Iterable[global___SoftwareRecipe.Artifact]] = ...,
        install_steps : typing.Optional[typing.Iterable[global___SoftwareRecipe.Step]] = ...,
        update_steps : typing.Optional[typing.Iterable[global___SoftwareRecipe.Step]] = ...,
        desired_state : global___DesiredState.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["artifacts",b"artifacts","desired_state",b"desired_state","install_steps",b"install_steps","name",b"name","update_steps",b"update_steps","version",b"version"]) -> None: ...
global___SoftwareRecipe = SoftwareRecipe

class LookupEffectiveGuestPolicyRequest(google.protobuf.message.Message):
    """A request message for getting effective policy assigned to the instance."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INSTANCE_ID_TOKEN_FIELD_NUMBER: builtins.int
    OS_SHORT_NAME_FIELD_NUMBER: builtins.int
    OS_VERSION_FIELD_NUMBER: builtins.int
    OS_ARCHITECTURE_FIELD_NUMBER: builtins.int
    instance_id_token: typing.Text = ...
    """Required. This is the GCE instance identity token described in
    https://cloud.google.com/compute/docs/instances/verifying-instance-identity
    where the audience is 'osconfig.googleapis.com' and the format is 'full'.
    """

    os_short_name: typing.Text = ...
    """Short name of the OS running on the instance. The OS Config agent only
    provideS this field for targeting if OS Inventory is enabled for that
    instance.
    """

    os_version: typing.Text = ...
    """Version of the OS running on the instance. The OS Config agent only
    provide this field for targeting if OS Inventory is enabled for that
    VM instance.
    """

    os_architecture: typing.Text = ...
    """Architecture of OS running on the instance. The OS Config agent only
    provide this field for targeting if OS Inventory is enabled for that
    instance.
    """

    def __init__(self,
        *,
        instance_id_token : typing.Text = ...,
        os_short_name : typing.Text = ...,
        os_version : typing.Text = ...,
        os_architecture : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["instance_id_token",b"instance_id_token","os_architecture",b"os_architecture","os_short_name",b"os_short_name","os_version",b"os_version"]) -> None: ...
global___LookupEffectiveGuestPolicyRequest = LookupEffectiveGuestPolicyRequest

class EffectiveGuestPolicy(google.protobuf.message.Message):
    """The effective guest policy assigned to the instance."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SourcedPackage(google.protobuf.message.Message):
        """A guest policy package including its source."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SOURCE_FIELD_NUMBER: builtins.int
        PACKAGE_FIELD_NUMBER: builtins.int
        source: typing.Text = ...
        """Name of the guest policy providing this config."""

        @property
        def package(self) -> global___Package:
            """A software package to configure on the VM instance."""
            pass
        def __init__(self,
            *,
            source : typing.Text = ...,
            package : typing.Optional[global___Package] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["package",b"package"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["package",b"package","source",b"source"]) -> None: ...

    class SourcedPackageRepository(google.protobuf.message.Message):
        """A guest policy package repository including its source."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SOURCE_FIELD_NUMBER: builtins.int
        PACKAGE_REPOSITORY_FIELD_NUMBER: builtins.int
        source: typing.Text = ...
        """Name of the guest policy providing this config."""

        @property
        def package_repository(self) -> global___PackageRepository:
            """A software package repository to configure on the VM instance."""
            pass
        def __init__(self,
            *,
            source : typing.Text = ...,
            package_repository : typing.Optional[global___PackageRepository] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["package_repository",b"package_repository"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["package_repository",b"package_repository","source",b"source"]) -> None: ...

    class SourcedSoftwareRecipe(google.protobuf.message.Message):
        """A guest policy recipe including its source."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SOURCE_FIELD_NUMBER: builtins.int
        SOFTWARE_RECIPE_FIELD_NUMBER: builtins.int
        source: typing.Text = ...
        """Name of the guest policy providing this config."""

        @property
        def software_recipe(self) -> global___SoftwareRecipe:
            """A software recipe to configure on the VM instance."""
            pass
        def __init__(self,
            *,
            source : typing.Text = ...,
            software_recipe : typing.Optional[global___SoftwareRecipe] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["software_recipe",b"software_recipe"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["software_recipe",b"software_recipe","source",b"source"]) -> None: ...

    PACKAGES_FIELD_NUMBER: builtins.int
    PACKAGE_REPOSITORIES_FIELD_NUMBER: builtins.int
    SOFTWARE_RECIPES_FIELD_NUMBER: builtins.int
    @property
    def packages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EffectiveGuestPolicy.SourcedPackage]:
        """List of package configurations assigned to the VM instance."""
        pass
    @property
    def package_repositories(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EffectiveGuestPolicy.SourcedPackageRepository]:
        """List of package repository configurations assigned to the VM instance."""
        pass
    @property
    def software_recipes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EffectiveGuestPolicy.SourcedSoftwareRecipe]:
        """List of recipes assigned to the VM instance."""
        pass
    def __init__(self,
        *,
        packages : typing.Optional[typing.Iterable[global___EffectiveGuestPolicy.SourcedPackage]] = ...,
        package_repositories : typing.Optional[typing.Iterable[global___EffectiveGuestPolicy.SourcedPackageRepository]] = ...,
        software_recipes : typing.Optional[typing.Iterable[global___EffectiveGuestPolicy.SourcedSoftwareRecipe]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["package_repositories",b"package_repositories","packages",b"packages","software_recipes",b"software_recipes"]) -> None: ...
global___EffectiveGuestPolicy = EffectiveGuestPolicy
