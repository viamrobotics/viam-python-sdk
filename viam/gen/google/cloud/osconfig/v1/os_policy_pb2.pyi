"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class OSPolicy(google.protobuf.message.Message):
    """An OS policy defines the desired state configuration for a VM."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Mode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Mode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        MODE_UNSPECIFIED: OSPolicy.Mode.ValueType = ...  # 0
        """Invalid mode"""

        VALIDATION: OSPolicy.Mode.ValueType = ...  # 1
        """This mode checks if the configuration resources in the policy are in
        their desired state. No actions are performed if they are not in the
        desired state. This mode is used for reporting purposes.
        """

        ENFORCEMENT: OSPolicy.Mode.ValueType = ...  # 2
        """This mode checks if the configuration resources in the policy are in
        their desired state, and if not, enforces the desired state.
        """

    class Mode(_Mode, metaclass=_ModeEnumTypeWrapper):
        """Policy mode"""
        pass

    MODE_UNSPECIFIED: OSPolicy.Mode.ValueType = ...  # 0
    """Invalid mode"""

    VALIDATION: OSPolicy.Mode.ValueType = ...  # 1
    """This mode checks if the configuration resources in the policy are in
    their desired state. No actions are performed if they are not in the
    desired state. This mode is used for reporting purposes.
    """

    ENFORCEMENT: OSPolicy.Mode.ValueType = ...  # 2
    """This mode checks if the configuration resources in the policy are in
    their desired state, and if not, enforces the desired state.
    """


    class InventoryFilter(google.protobuf.message.Message):
        """Filtering criteria to select VMs based on inventory details."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        OS_SHORT_NAME_FIELD_NUMBER: builtins.int
        OS_VERSION_FIELD_NUMBER: builtins.int
        os_short_name: typing.Text = ...
        """Required. The OS short name"""

        os_version: typing.Text = ...
        """The OS version

        Prefix matches are supported if asterisk(*) is provided as the
        last character. For example, to match all versions with a major
        version of `7`, specify the following value for this field `7.*`

        An empty string matches all OS versions.
        """

        def __init__(self,
            *,
            os_short_name : typing.Text = ...,
            os_version : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["os_short_name",b"os_short_name","os_version",b"os_version"]) -> None: ...

    class Resource(google.protobuf.message.Message):
        """An OS policy resource is used to define the desired state configuration
        and provides a specific functionality like installing/removing packages,
        executing a script etc.

        The system ensures that resources are always in their desired state by
        taking necessary actions if they have drifted from their desired state.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class File(google.protobuf.message.Message):
            """A remote or local file."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class Remote(google.protobuf.message.Message):
                """Specifies a file available via some URI."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                URI_FIELD_NUMBER: builtins.int
                SHA256_CHECKSUM_FIELD_NUMBER: builtins.int
                uri: typing.Text = ...
                """Required. URI from which to fetch the object. It should contain both
                the protocol and path following the format `{protocol}://{location}`.
                """

                sha256_checksum: typing.Text = ...
                """SHA256 checksum of the remote file."""

                def __init__(self,
                    *,
                    uri : typing.Text = ...,
                    sha256_checksum : typing.Text = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["sha256_checksum",b"sha256_checksum","uri",b"uri"]) -> None: ...

            class Gcs(google.protobuf.message.Message):
                """Specifies a file available as a Cloud Storage Object."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                BUCKET_FIELD_NUMBER: builtins.int
                OBJECT_FIELD_NUMBER: builtins.int
                GENERATION_FIELD_NUMBER: builtins.int
                bucket: typing.Text = ...
                """Required. Bucket of the Cloud Storage object."""

                object: typing.Text = ...
                """Required. Name of the Cloud Storage object."""

                generation: builtins.int = ...
                """Generation number of the Cloud Storage object."""

                def __init__(self,
                    *,
                    bucket : typing.Text = ...,
                    object : typing.Text = ...,
                    generation : builtins.int = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["bucket",b"bucket","generation",b"generation","object",b"object"]) -> None: ...

            REMOTE_FIELD_NUMBER: builtins.int
            GCS_FIELD_NUMBER: builtins.int
            LOCAL_PATH_FIELD_NUMBER: builtins.int
            ALLOW_INSECURE_FIELD_NUMBER: builtins.int
            @property
            def remote(self) -> global___OSPolicy.Resource.File.Remote:
                """A generic remote file."""
                pass
            @property
            def gcs(self) -> global___OSPolicy.Resource.File.Gcs:
                """A Cloud Storage object."""
                pass
            local_path: typing.Text = ...
            """A local path within the VM to use."""

            allow_insecure: builtins.bool = ...
            """Defaults to false. When false, files are subject to validations
            based on the file type:

            Remote: A checksum must be specified.
            Cloud Storage: An object generation number must be specified.
            """

            def __init__(self,
                *,
                remote : typing.Optional[global___OSPolicy.Resource.File.Remote] = ...,
                gcs : typing.Optional[global___OSPolicy.Resource.File.Gcs] = ...,
                local_path : typing.Text = ...,
                allow_insecure : builtins.bool = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["gcs",b"gcs","local_path",b"local_path","remote",b"remote","type",b"type"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["allow_insecure",b"allow_insecure","gcs",b"gcs","local_path",b"local_path","remote",b"remote","type",b"type"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["remote","gcs","local_path"]]: ...

        class PackageResource(google.protobuf.message.Message):
            """A resource that manages a system package."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class _DesiredState:
                ValueType = typing.NewType('ValueType', builtins.int)
                V: typing_extensions.TypeAlias = ValueType
            class _DesiredStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DesiredState.ValueType], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
                DESIRED_STATE_UNSPECIFIED: OSPolicy.Resource.PackageResource.DesiredState.ValueType = ...  # 0
                """Unspecified is invalid."""

                INSTALLED: OSPolicy.Resource.PackageResource.DesiredState.ValueType = ...  # 1
                """Ensure that the package is installed."""

                REMOVED: OSPolicy.Resource.PackageResource.DesiredState.ValueType = ...  # 2
                """The agent ensures that the package is not installed and
                uninstalls it if detected.
                """

            class DesiredState(_DesiredState, metaclass=_DesiredStateEnumTypeWrapper):
                """The desired state that the OS Config agent maintains on the VM."""
                pass

            DESIRED_STATE_UNSPECIFIED: OSPolicy.Resource.PackageResource.DesiredState.ValueType = ...  # 0
            """Unspecified is invalid."""

            INSTALLED: OSPolicy.Resource.PackageResource.DesiredState.ValueType = ...  # 1
            """Ensure that the package is installed."""

            REMOVED: OSPolicy.Resource.PackageResource.DesiredState.ValueType = ...  # 2
            """The agent ensures that the package is not installed and
            uninstalls it if detected.
            """


            class Deb(google.protobuf.message.Message):
                """A deb package file. dpkg packages only support INSTALLED state."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                SOURCE_FIELD_NUMBER: builtins.int
                PULL_DEPS_FIELD_NUMBER: builtins.int
                @property
                def source(self) -> global___OSPolicy.Resource.File:
                    """Required. A deb package."""
                    pass
                pull_deps: builtins.bool = ...
                """Whether dependencies should also be installed.
                - install when false: `dpkg -i package`
                - install when true: `apt-get update && apt-get -y install
                package.deb`
                """

                def __init__(self,
                    *,
                    source : typing.Optional[global___OSPolicy.Resource.File] = ...,
                    pull_deps : builtins.bool = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["source",b"source"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["pull_deps",b"pull_deps","source",b"source"]) -> None: ...

            class APT(google.protobuf.message.Message):
                """A package managed by APT.
                - install: `apt-get update && apt-get -y install [name]`
                - remove: `apt-get -y remove [name]`
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                NAME_FIELD_NUMBER: builtins.int
                name: typing.Text = ...
                """Required. Package name."""

                def __init__(self,
                    *,
                    name : typing.Text = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...

            class RPM(google.protobuf.message.Message):
                """An RPM package file. RPM packages only support INSTALLED state."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                SOURCE_FIELD_NUMBER: builtins.int
                PULL_DEPS_FIELD_NUMBER: builtins.int
                @property
                def source(self) -> global___OSPolicy.Resource.File:
                    """Required. An rpm package."""
                    pass
                pull_deps: builtins.bool = ...
                """Whether dependencies should also be installed.
                - install when false: `rpm --upgrade --replacepkgs package.rpm`
                - install when true: `yum -y install package.rpm` or
                `zypper -y install package.rpm`
                """

                def __init__(self,
                    *,
                    source : typing.Optional[global___OSPolicy.Resource.File] = ...,
                    pull_deps : builtins.bool = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["source",b"source"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["pull_deps",b"pull_deps","source",b"source"]) -> None: ...

            class YUM(google.protobuf.message.Message):
                """A package managed by YUM.
                - install: `yum -y install package`
                - remove: `yum -y remove package`
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                NAME_FIELD_NUMBER: builtins.int
                name: typing.Text = ...
                """Required. Package name."""

                def __init__(self,
                    *,
                    name : typing.Text = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...

            class Zypper(google.protobuf.message.Message):
                """A package managed by Zypper.
                - install: `zypper -y install package`
                - remove: `zypper -y rm package`
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                NAME_FIELD_NUMBER: builtins.int
                name: typing.Text = ...
                """Required. Package name."""

                def __init__(self,
                    *,
                    name : typing.Text = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...

            class GooGet(google.protobuf.message.Message):
                """A package managed by GooGet.
                - install: `googet -noconfirm install package`
                - remove: `googet -noconfirm remove package`
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                NAME_FIELD_NUMBER: builtins.int
                name: typing.Text = ...
                """Required. Package name."""

                def __init__(self,
                    *,
                    name : typing.Text = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...

            class MSI(google.protobuf.message.Message):
                """An MSI package. MSI packages only support INSTALLED state."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                SOURCE_FIELD_NUMBER: builtins.int
                PROPERTIES_FIELD_NUMBER: builtins.int
                @property
                def source(self) -> global___OSPolicy.Resource.File:
                    """Required. The MSI package."""
                    pass
                @property
                def properties(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                    """Additional properties to use during installation.
                    This should be in the format of Property=Setting.
                    Appended to the defaults of `ACTION=INSTALL
                    REBOOT=ReallySuppress`.
                    """
                    pass
                def __init__(self,
                    *,
                    source : typing.Optional[global___OSPolicy.Resource.File] = ...,
                    properties : typing.Optional[typing.Iterable[typing.Text]] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["source",b"source"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["properties",b"properties","source",b"source"]) -> None: ...

            DESIRED_STATE_FIELD_NUMBER: builtins.int
            APT_FIELD_NUMBER: builtins.int
            DEB_FIELD_NUMBER: builtins.int
            YUM_FIELD_NUMBER: builtins.int
            ZYPPER_FIELD_NUMBER: builtins.int
            RPM_FIELD_NUMBER: builtins.int
            GOOGET_FIELD_NUMBER: builtins.int
            MSI_FIELD_NUMBER: builtins.int
            desired_state: global___OSPolicy.Resource.PackageResource.DesiredState.ValueType = ...
            """Required. The desired state the agent should maintain for this package."""

            @property
            def apt(self) -> global___OSPolicy.Resource.PackageResource.APT:
                """A package managed by Apt."""
                pass
            @property
            def deb(self) -> global___OSPolicy.Resource.PackageResource.Deb:
                """A deb package file."""
                pass
            @property
            def yum(self) -> global___OSPolicy.Resource.PackageResource.YUM:
                """A package managed by YUM."""
                pass
            @property
            def zypper(self) -> global___OSPolicy.Resource.PackageResource.Zypper:
                """A package managed by Zypper."""
                pass
            @property
            def rpm(self) -> global___OSPolicy.Resource.PackageResource.RPM:
                """An rpm package file."""
                pass
            @property
            def googet(self) -> global___OSPolicy.Resource.PackageResource.GooGet:
                """A package managed by GooGet."""
                pass
            @property
            def msi(self) -> global___OSPolicy.Resource.PackageResource.MSI:
                """An MSI package."""
                pass
            def __init__(self,
                *,
                desired_state : global___OSPolicy.Resource.PackageResource.DesiredState.ValueType = ...,
                apt : typing.Optional[global___OSPolicy.Resource.PackageResource.APT] = ...,
                deb : typing.Optional[global___OSPolicy.Resource.PackageResource.Deb] = ...,
                yum : typing.Optional[global___OSPolicy.Resource.PackageResource.YUM] = ...,
                zypper : typing.Optional[global___OSPolicy.Resource.PackageResource.Zypper] = ...,
                rpm : typing.Optional[global___OSPolicy.Resource.PackageResource.RPM] = ...,
                googet : typing.Optional[global___OSPolicy.Resource.PackageResource.GooGet] = ...,
                msi : typing.Optional[global___OSPolicy.Resource.PackageResource.MSI] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["apt",b"apt","deb",b"deb","googet",b"googet","msi",b"msi","rpm",b"rpm","system_package",b"system_package","yum",b"yum","zypper",b"zypper"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["apt",b"apt","deb",b"deb","desired_state",b"desired_state","googet",b"googet","msi",b"msi","rpm",b"rpm","system_package",b"system_package","yum",b"yum","zypper",b"zypper"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["system_package",b"system_package"]) -> typing.Optional[typing_extensions.Literal["apt","deb","yum","zypper","rpm","googet","msi"]]: ...

        class RepositoryResource(google.protobuf.message.Message):
            """A resource that manages a package repository."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class AptRepository(google.protobuf.message.Message):
                """Represents a single apt package repository. These will be added to
                a repo file that will be managed at
                `/etc/apt/sources.list.d/google_osconfig.list`.
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                class _ArchiveType:
                    ValueType = typing.NewType('ValueType', builtins.int)
                    V: typing_extensions.TypeAlias = ValueType
                class _ArchiveTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ArchiveType.ValueType], builtins.type):
                    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
                    ARCHIVE_TYPE_UNSPECIFIED: OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType.ValueType = ...  # 0
                    """Unspecified is invalid."""

                    DEB: OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType.ValueType = ...  # 1
                    """Deb indicates that the archive contains binary files."""

                    DEB_SRC: OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType.ValueType = ...  # 2
                    """Deb-src indicates that the archive contains source files."""

                class ArchiveType(_ArchiveType, metaclass=_ArchiveTypeEnumTypeWrapper):
                    """Type of archive."""
                    pass

                ARCHIVE_TYPE_UNSPECIFIED: OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType.ValueType = ...  # 0
                """Unspecified is invalid."""

                DEB: OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType.ValueType = ...  # 1
                """Deb indicates that the archive contains binary files."""

                DEB_SRC: OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType.ValueType = ...  # 2
                """Deb-src indicates that the archive contains source files."""


                ARCHIVE_TYPE_FIELD_NUMBER: builtins.int
                URI_FIELD_NUMBER: builtins.int
                DISTRIBUTION_FIELD_NUMBER: builtins.int
                COMPONENTS_FIELD_NUMBER: builtins.int
                GPG_KEY_FIELD_NUMBER: builtins.int
                archive_type: global___OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType.ValueType = ...
                """Required. Type of archive files in this repository."""

                uri: typing.Text = ...
                """Required. URI for this repository."""

                distribution: typing.Text = ...
                """Required. Distribution of this repository."""

                @property
                def components(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                    """Required. List of components for this repository. Must contain at
                    least one item.
                    """
                    pass
                gpg_key: typing.Text = ...
                """URI of the key file for this repository. The agent maintains a
                keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg`.
                """

                def __init__(self,
                    *,
                    archive_type : global___OSPolicy.Resource.RepositoryResource.AptRepository.ArchiveType.ValueType = ...,
                    uri : typing.Text = ...,
                    distribution : typing.Text = ...,
                    components : typing.Optional[typing.Iterable[typing.Text]] = ...,
                    gpg_key : typing.Text = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["archive_type",b"archive_type","components",b"components","distribution",b"distribution","gpg_key",b"gpg_key","uri",b"uri"]) -> None: ...

            class YumRepository(google.protobuf.message.Message):
                """Represents a single yum package repository. These are added to a
                repo file that is managed at
                `/etc/yum.repos.d/google_osconfig.repo`.
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                ID_FIELD_NUMBER: builtins.int
                DISPLAY_NAME_FIELD_NUMBER: builtins.int
                BASE_URL_FIELD_NUMBER: builtins.int
                GPG_KEYS_FIELD_NUMBER: builtins.int
                id: typing.Text = ...
                """Required. A one word, unique name for this repository. This is  the
                `repo id` in the yum config file and also the `display_name` if
                `display_name` is omitted. This id is also used as the unique
                identifier when checking for resource conflicts.
                """

                display_name: typing.Text = ...
                """The display name of the repository."""

                base_url: typing.Text = ...
                """Required. The location of the repository directory."""

                @property
                def gpg_keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                    """URIs of GPG keys."""
                    pass
                def __init__(self,
                    *,
                    id : typing.Text = ...,
                    display_name : typing.Text = ...,
                    base_url : typing.Text = ...,
                    gpg_keys : typing.Optional[typing.Iterable[typing.Text]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["base_url",b"base_url","display_name",b"display_name","gpg_keys",b"gpg_keys","id",b"id"]) -> None: ...

            class ZypperRepository(google.protobuf.message.Message):
                """Represents a single zypper package repository. These are added to a
                repo file that is managed at
                `/etc/zypp/repos.d/google_osconfig.repo`.
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                ID_FIELD_NUMBER: builtins.int
                DISPLAY_NAME_FIELD_NUMBER: builtins.int
                BASE_URL_FIELD_NUMBER: builtins.int
                GPG_KEYS_FIELD_NUMBER: builtins.int
                id: typing.Text = ...
                """Required. A one word, unique name for this repository. This is the
                `repo id` in the zypper config file and also the `display_name` if
                `display_name` is omitted. This id is also used as the unique
                identifier when checking for GuestPolicy conflicts.
                """

                display_name: typing.Text = ...
                """The display name of the repository."""

                base_url: typing.Text = ...
                """Required. The location of the repository directory."""

                @property
                def gpg_keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                    """URIs of GPG keys."""
                    pass
                def __init__(self,
                    *,
                    id : typing.Text = ...,
                    display_name : typing.Text = ...,
                    base_url : typing.Text = ...,
                    gpg_keys : typing.Optional[typing.Iterable[typing.Text]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["base_url",b"base_url","display_name",b"display_name","gpg_keys",b"gpg_keys","id",b"id"]) -> None: ...

            class GooRepository(google.protobuf.message.Message):
                """Represents a Goo package repository. These are added to a repo file
                that is managed at
                `C:/ProgramData/GooGet/repos/google_osconfig.repo`.
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                NAME_FIELD_NUMBER: builtins.int
                URL_FIELD_NUMBER: builtins.int
                name: typing.Text = ...
                """Required. The name of the repository."""

                url: typing.Text = ...
                """Required. The url of the repository."""

                def __init__(self,
                    *,
                    name : typing.Text = ...,
                    url : typing.Text = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["name",b"name","url",b"url"]) -> None: ...

            APT_FIELD_NUMBER: builtins.int
            YUM_FIELD_NUMBER: builtins.int
            ZYPPER_FIELD_NUMBER: builtins.int
            GOO_FIELD_NUMBER: builtins.int
            @property
            def apt(self) -> global___OSPolicy.Resource.RepositoryResource.AptRepository:
                """An Apt Repository."""
                pass
            @property
            def yum(self) -> global___OSPolicy.Resource.RepositoryResource.YumRepository:
                """A Yum Repository."""
                pass
            @property
            def zypper(self) -> global___OSPolicy.Resource.RepositoryResource.ZypperRepository:
                """A Zypper Repository."""
                pass
            @property
            def goo(self) -> global___OSPolicy.Resource.RepositoryResource.GooRepository:
                """A Goo Repository."""
                pass
            def __init__(self,
                *,
                apt : typing.Optional[global___OSPolicy.Resource.RepositoryResource.AptRepository] = ...,
                yum : typing.Optional[global___OSPolicy.Resource.RepositoryResource.YumRepository] = ...,
                zypper : typing.Optional[global___OSPolicy.Resource.RepositoryResource.ZypperRepository] = ...,
                goo : typing.Optional[global___OSPolicy.Resource.RepositoryResource.GooRepository] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["apt",b"apt","goo",b"goo","repository",b"repository","yum",b"yum","zypper",b"zypper"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["apt",b"apt","goo",b"goo","repository",b"repository","yum",b"yum","zypper",b"zypper"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["repository",b"repository"]) -> typing.Optional[typing_extensions.Literal["apt","yum","zypper","goo"]]: ...

        class ExecResource(google.protobuf.message.Message):
            """A resource that allows executing scripts on the VM.

            The `ExecResource` has 2 stages: `validate` and `enforce` and both stages
            accept a script as an argument to execute.

            When the `ExecResource` is applied by the agent, it first executes the
            script in the `validate` stage. The `validate` stage can signal that the
            `ExecResource` is already in the desired state by returning an exit code
            of `100`. If the `ExecResource` is not in the desired state, it should
            return an exit code of `101`. Any other exit code returned by this stage
            is considered an error.

            If the `ExecResource` is not in the desired state based on the exit code
            from the `validate` stage, the agent proceeds to execute the script from
            the `enforce` stage. If the `ExecResource` is already in the desired
            state, the `enforce` stage will not be run.
            Similar to `validate` stage, the `enforce` stage should return an exit
            code of `100` to indicate that the resource in now in its desired state.
            Any other exit code is considered an error.

            NOTE: An exit code of `100` was chosen over `0` (and `101` vs `1`) to
            have an explicit indicator of `in desired state`, `not in desired state`
            and errors. Because, for example, Powershell will always return an exit
            code of `0` unless an `exit` statement is provided in the script. So, for
            reasons of consistency and being explicit, exit codes `100` and `101`
            were chosen.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class Exec(google.protobuf.message.Message):
                """A file or script to execute."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                class _Interpreter:
                    ValueType = typing.NewType('ValueType', builtins.int)
                    V: typing_extensions.TypeAlias = ValueType
                class _InterpreterEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Interpreter.ValueType], builtins.type):
                    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
                    INTERPRETER_UNSPECIFIED: OSPolicy.Resource.ExecResource.Exec.Interpreter.ValueType = ...  # 0
                    """Defaults to NONE."""

                    NONE: OSPolicy.Resource.ExecResource.Exec.Interpreter.ValueType = ...  # 1
                    """If an interpreter is not specified, the
                    source is executed directly. This execution, without an
                    interpreter, only succeeds for executables and scripts that have <a
                    href="https://en.wikipedia.org/wiki/Shebang_(Unix)"
                    class="external">shebang lines</a>.
                    """

                    SHELL: OSPolicy.Resource.ExecResource.Exec.Interpreter.ValueType = ...  # 2
                    """Indicates that the script runs with `/bin/sh` on Linux and
                    `cmd.exe` on Windows.
                    """

                    POWERSHELL: OSPolicy.Resource.ExecResource.Exec.Interpreter.ValueType = ...  # 3
                    """Indicates that the script runs with PowerShell."""

                class Interpreter(_Interpreter, metaclass=_InterpreterEnumTypeWrapper):
                    """The interpreter to use."""
                    pass

                INTERPRETER_UNSPECIFIED: OSPolicy.Resource.ExecResource.Exec.Interpreter.ValueType = ...  # 0
                """Defaults to NONE."""

                NONE: OSPolicy.Resource.ExecResource.Exec.Interpreter.ValueType = ...  # 1
                """If an interpreter is not specified, the
                source is executed directly. This execution, without an
                interpreter, only succeeds for executables and scripts that have <a
                href="https://en.wikipedia.org/wiki/Shebang_(Unix)"
                class="external">shebang lines</a>.
                """

                SHELL: OSPolicy.Resource.ExecResource.Exec.Interpreter.ValueType = ...  # 2
                """Indicates that the script runs with `/bin/sh` on Linux and
                `cmd.exe` on Windows.
                """

                POWERSHELL: OSPolicy.Resource.ExecResource.Exec.Interpreter.ValueType = ...  # 3
                """Indicates that the script runs with PowerShell."""


                FILE_FIELD_NUMBER: builtins.int
                SCRIPT_FIELD_NUMBER: builtins.int
                ARGS_FIELD_NUMBER: builtins.int
                INTERPRETER_FIELD_NUMBER: builtins.int
                OUTPUT_FILE_PATH_FIELD_NUMBER: builtins.int
                @property
                def file(self) -> global___OSPolicy.Resource.File:
                    """A remote or local file."""
                    pass
                script: typing.Text = ...
                """An inline script.
                The size of the script is limited to 1024 characters.
                """

                @property
                def args(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                    """Optional arguments to pass to the source during execution."""
                    pass
                interpreter: global___OSPolicy.Resource.ExecResource.Exec.Interpreter.ValueType = ...
                """Required. The script interpreter to use."""

                output_file_path: typing.Text = ...
                """Only recorded for enforce Exec.
                Path to an output file (that is created by this Exec) whose
                content will be recorded in OSPolicyResourceCompliance after a
                successful run. Absence or failure to read this file will result in
                this ExecResource being non-compliant. Output file size is limited to
                100K bytes.
                """

                def __init__(self,
                    *,
                    file : typing.Optional[global___OSPolicy.Resource.File] = ...,
                    script : typing.Text = ...,
                    args : typing.Optional[typing.Iterable[typing.Text]] = ...,
                    interpreter : global___OSPolicy.Resource.ExecResource.Exec.Interpreter.ValueType = ...,
                    output_file_path : typing.Text = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["file",b"file","script",b"script","source",b"source"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["args",b"args","file",b"file","interpreter",b"interpreter","output_file_path",b"output_file_path","script",b"script","source",b"source"]) -> None: ...
                def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["file","script"]]: ...

            VALIDATE_FIELD_NUMBER: builtins.int
            ENFORCE_FIELD_NUMBER: builtins.int
            @property
            def validate(self) -> global___OSPolicy.Resource.ExecResource.Exec:
                """Required. What to run to validate this resource is in the desired
                state. An exit code of 100 indicates "in desired state", and exit code
                of 101 indicates "not in desired state". Any other exit code indicates
                a failure running validate.
                """
                pass
            @property
            def enforce(self) -> global___OSPolicy.Resource.ExecResource.Exec:
                """What to run to bring this resource into the desired state.
                An exit code of 100 indicates "success", any other exit code indicates
                a failure running enforce.
                """
                pass
            def __init__(self,
                *,
                validate : typing.Optional[global___OSPolicy.Resource.ExecResource.Exec] = ...,
                enforce : typing.Optional[global___OSPolicy.Resource.ExecResource.Exec] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["enforce",b"enforce","validate",b"validate"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["enforce",b"enforce","validate",b"validate"]) -> None: ...

        class FileResource(google.protobuf.message.Message):
            """A resource that manages the state of a file."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class _DesiredState:
                ValueType = typing.NewType('ValueType', builtins.int)
                V: typing_extensions.TypeAlias = ValueType
            class _DesiredStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DesiredState.ValueType], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
                DESIRED_STATE_UNSPECIFIED: OSPolicy.Resource.FileResource.DesiredState.ValueType = ...  # 0
                """Unspecified is invalid."""

                PRESENT: OSPolicy.Resource.FileResource.DesiredState.ValueType = ...  # 1
                """Ensure file at path is present."""

                ABSENT: OSPolicy.Resource.FileResource.DesiredState.ValueType = ...  # 2
                """Ensure file at path is absent."""

                CONTENTS_MATCH: OSPolicy.Resource.FileResource.DesiredState.ValueType = ...  # 3
                """Ensure the contents of the file at path matches. If the file does
                not exist it will be created.
                """

            class DesiredState(_DesiredState, metaclass=_DesiredStateEnumTypeWrapper):
                """Desired state of the file."""
                pass

            DESIRED_STATE_UNSPECIFIED: OSPolicy.Resource.FileResource.DesiredState.ValueType = ...  # 0
            """Unspecified is invalid."""

            PRESENT: OSPolicy.Resource.FileResource.DesiredState.ValueType = ...  # 1
            """Ensure file at path is present."""

            ABSENT: OSPolicy.Resource.FileResource.DesiredState.ValueType = ...  # 2
            """Ensure file at path is absent."""

            CONTENTS_MATCH: OSPolicy.Resource.FileResource.DesiredState.ValueType = ...  # 3
            """Ensure the contents of the file at path matches. If the file does
            not exist it will be created.
            """


            FILE_FIELD_NUMBER: builtins.int
            CONTENT_FIELD_NUMBER: builtins.int
            PATH_FIELD_NUMBER: builtins.int
            STATE_FIELD_NUMBER: builtins.int
            PERMISSIONS_FIELD_NUMBER: builtins.int
            @property
            def file(self) -> global___OSPolicy.Resource.File:
                """A remote or local source."""
                pass
            content: typing.Text = ...
            """A a file with this content.
            The size of the content is limited to 1024 characters.
            """

            path: typing.Text = ...
            """Required. The absolute path of the file within the VM."""

            state: global___OSPolicy.Resource.FileResource.DesiredState.ValueType = ...
            """Required. Desired state of the file."""

            permissions: typing.Text = ...
            """Consists of three octal digits which represent, in
            order, the permissions of the owner, group, and other users for the
            file (similarly to the numeric mode used in the linux chmod
            utility). Each digit represents a three bit number with the 4 bit
            corresponding to the read permissions, the 2 bit corresponds to the
            write bit, and the one bit corresponds to the execute permission.
            Default behavior is 755.

            Below are some examples of permissions and their associated values:
            read, write, and execute: 7
            read and execute: 5
            read and write: 6
            read only: 4
            """

            def __init__(self,
                *,
                file : typing.Optional[global___OSPolicy.Resource.File] = ...,
                content : typing.Text = ...,
                path : typing.Text = ...,
                state : global___OSPolicy.Resource.FileResource.DesiredState.ValueType = ...,
                permissions : typing.Text = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["content",b"content","file",b"file","source",b"source"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["content",b"content","file",b"file","path",b"path","permissions",b"permissions","source",b"source","state",b"state"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["file","content"]]: ...

        ID_FIELD_NUMBER: builtins.int
        PKG_FIELD_NUMBER: builtins.int
        REPOSITORY_FIELD_NUMBER: builtins.int
        EXEC_FIELD_NUMBER: builtins.int
        FILE_FIELD_NUMBER: builtins.int
        id: typing.Text = ...
        """Required. The id of the resource with the following restrictions:

        * Must contain only lowercase letters, numbers, and hyphens.
        * Must start with a letter.
        * Must be between 1-63 characters.
        * Must end with a number or a letter.
        * Must be unique within the OS policy.
        """

        @property
        def pkg(self) -> global___OSPolicy.Resource.PackageResource:
            """Package resource"""
            pass
        @property
        def repository(self) -> global___OSPolicy.Resource.RepositoryResource:
            """Package repository resource"""
            pass
        @property
        def exec(self) -> global___OSPolicy.Resource.ExecResource:
            """Exec resource"""
            pass
        @property
        def file(self) -> global___OSPolicy.Resource.FileResource:
            """File resource"""
            pass
        def __init__(self,
            *,
            id : typing.Text = ...,
            pkg : typing.Optional[global___OSPolicy.Resource.PackageResource] = ...,
            repository : typing.Optional[global___OSPolicy.Resource.RepositoryResource] = ...,
            exec : typing.Optional[global___OSPolicy.Resource.ExecResource] = ...,
            file : typing.Optional[global___OSPolicy.Resource.FileResource] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["exec",b"exec","file",b"file","pkg",b"pkg","repository",b"repository","resource_type",b"resource_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["exec",b"exec","file",b"file","id",b"id","pkg",b"pkg","repository",b"repository","resource_type",b"resource_type"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["resource_type",b"resource_type"]) -> typing.Optional[typing_extensions.Literal["pkg","repository","exec","file"]]: ...

    class ResourceGroup(google.protobuf.message.Message):
        """Resource groups provide a mechanism to group OS policy resources.

        Resource groups enable OS policy authors to create a single OS policy
        to be applied to VMs running different operating Systems.

        When the OS policy is applied to a target VM, the appropriate resource
        group within the OS policy is selected based on the `OSFilter` specified
        within the resource group.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        INVENTORY_FILTERS_FIELD_NUMBER: builtins.int
        RESOURCES_FIELD_NUMBER: builtins.int
        @property
        def inventory_filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OSPolicy.InventoryFilter]:
            """List of inventory filters for the resource group.

            The resources in this resource group are applied to the target VM if it
            satisfies at least one of the following inventory filters.

            For example, to apply this resource group to VMs running either `RHEL` or
            `CentOS` operating systems, specify 2 items for the list with following
            values:
            inventory_filters[0].os_short_name='rhel' and
            inventory_filters[1].os_short_name='centos'

            If the list is empty, this resource group will be applied to the target
            VM unconditionally.
            """
            pass
        @property
        def resources(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OSPolicy.Resource]:
            """Required. List of resources configured for this resource group.
            The resources are executed in the exact order specified here.
            """
            pass
        def __init__(self,
            *,
            inventory_filters : typing.Optional[typing.Iterable[global___OSPolicy.InventoryFilter]] = ...,
            resources : typing.Optional[typing.Iterable[global___OSPolicy.Resource]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["inventory_filters",b"inventory_filters","resources",b"resources"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    MODE_FIELD_NUMBER: builtins.int
    RESOURCE_GROUPS_FIELD_NUMBER: builtins.int
    ALLOW_NO_RESOURCE_GROUP_MATCH_FIELD_NUMBER: builtins.int
    id: typing.Text = ...
    """Required. The id of the OS policy with the following restrictions:

    * Must contain only lowercase letters, numbers, and hyphens.
    * Must start with a letter.
    * Must be between 1-63 characters.
    * Must end with a number or a letter.
    * Must be unique within the assignment.
    """

    description: typing.Text = ...
    """Policy description.
    Length of the description is limited to 1024 characters.
    """

    mode: global___OSPolicy.Mode.ValueType = ...
    """Required. Policy mode"""

    @property
    def resource_groups(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OSPolicy.ResourceGroup]:
        """Required. List of resource groups for the policy.
        For a particular VM, resource groups are evaluated in the order specified
        and the first resource group that is applicable is selected and the rest
        are ignored.

        If none of the resource groups are applicable for a VM, the VM is
        considered to be non-compliant w.r.t this policy. This behavior can be
        toggled by the flag `allow_no_resource_group_match`
        """
        pass
    allow_no_resource_group_match: builtins.bool = ...
    """This flag determines the OS policy compliance status when none of the
    resource groups within the policy are applicable for a VM. Set this value
    to `true` if the policy needs to be reported as compliant even if the
    policy has nothing to validate or enforce.
    """

    def __init__(self,
        *,
        id : typing.Text = ...,
        description : typing.Text = ...,
        mode : global___OSPolicy.Mode.ValueType = ...,
        resource_groups : typing.Optional[typing.Iterable[global___OSPolicy.ResourceGroup]] = ...,
        allow_no_resource_group_match : builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["allow_no_resource_group_match",b"allow_no_resource_group_match","description",b"description","id",b"id","mode",b"mode","resource_groups",b"resource_groups"]) -> None: ...
global___OSPolicy = OSPolicy
