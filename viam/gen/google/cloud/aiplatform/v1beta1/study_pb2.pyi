"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Study(google.protobuf.message.Message):
    """LINT.IfChange
    A message representing a Study.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _State:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_State.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        STATE_UNSPECIFIED: Study.State.ValueType = ...  # 0
        """The study state is unspecified."""

        ACTIVE: Study.State.ValueType = ...  # 1
        """The study is active."""

        INACTIVE: Study.State.ValueType = ...  # 2
        """The study is stopped due to an internal error."""

        COMPLETED: Study.State.ValueType = ...  # 3
        """The study is done when the service exhausts the parameter search space
        or max_trial_count is reached.
        """

    class State(_State, metaclass=_StateEnumTypeWrapper):
        """Describes the Study state."""
        pass

    STATE_UNSPECIFIED: Study.State.ValueType = ...  # 0
    """The study state is unspecified."""

    ACTIVE: Study.State.ValueType = ...  # 1
    """The study is active."""

    INACTIVE: Study.State.ValueType = ...  # 2
    """The study is stopped due to an internal error."""

    COMPLETED: Study.State.ValueType = ...  # 3
    """The study is done when the service exhausts the parameter search space
    or max_trial_count is reached.
    """


    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    STUDY_SPEC_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    INACTIVE_REASON_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Output only. The name of a study. The study's globally unique identifier.
    Format: `projects/{project}/locations/{location}/studies/{study}`
    """

    display_name: typing.Text = ...
    """Required. Describes the Study, default value is empty string."""

    @property
    def study_spec(self) -> global___StudySpec:
        """Required. Configuration of the Study."""
        pass
    state: global___Study.State.ValueType = ...
    """Output only. The detailed state of a Study."""

    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Time at which the study was created."""
        pass
    inactive_reason: typing.Text = ...
    """Output only. A human readable reason why the Study is inactive.
    This should be empty if a study is ACTIVE or COMPLETED.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        study_spec : typing.Optional[global___StudySpec] = ...,
        state : global___Study.State.ValueType = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        inactive_reason : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time",b"create_time","study_spec",b"study_spec"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time",b"create_time","display_name",b"display_name","inactive_reason",b"inactive_reason","name",b"name","state",b"state","study_spec",b"study_spec"]) -> None: ...
global___Study = Study

class Trial(google.protobuf.message.Message):
    """A message representing a Trial. A Trial contains a unique set of Parameters
    that has been or will be evaluated, along with the objective metrics got by
    running the Trial.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _State:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_State.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        STATE_UNSPECIFIED: Trial.State.ValueType = ...  # 0
        """The Trial state is unspecified."""

        REQUESTED: Trial.State.ValueType = ...  # 1
        """Indicates that a specific Trial has been requested, but it has not yet
        been suggested by the service.
        """

        ACTIVE: Trial.State.ValueType = ...  # 2
        """Indicates that the Trial has been suggested."""

        STOPPING: Trial.State.ValueType = ...  # 3
        """Indicates that the Trial should stop according to the service."""

        SUCCEEDED: Trial.State.ValueType = ...  # 4
        """Indicates that the Trial is completed successfully."""

        INFEASIBLE: Trial.State.ValueType = ...  # 5
        """Indicates that the Trial should not be attempted again.
        The service will set a Trial to INFEASIBLE when it's done but missing
        the final_measurement.
        """

    class State(_State, metaclass=_StateEnumTypeWrapper):
        """Describes a Trial state."""
        pass

    STATE_UNSPECIFIED: Trial.State.ValueType = ...  # 0
    """The Trial state is unspecified."""

    REQUESTED: Trial.State.ValueType = ...  # 1
    """Indicates that a specific Trial has been requested, but it has not yet
    been suggested by the service.
    """

    ACTIVE: Trial.State.ValueType = ...  # 2
    """Indicates that the Trial has been suggested."""

    STOPPING: Trial.State.ValueType = ...  # 3
    """Indicates that the Trial should stop according to the service."""

    SUCCEEDED: Trial.State.ValueType = ...  # 4
    """Indicates that the Trial is completed successfully."""

    INFEASIBLE: Trial.State.ValueType = ...  # 5
    """Indicates that the Trial should not be attempted again.
    The service will set a Trial to INFEASIBLE when it's done but missing
    the final_measurement.
    """


    class Parameter(google.protobuf.message.Message):
        """A message representing a parameter to be tuned."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        PARAMETER_ID_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        parameter_id: typing.Text = ...
        """Output only. The ID of the parameter. The parameter should be defined in
        [StudySpec's Parameters][google.cloud.aiplatform.v1beta1.StudySpec.parameters].
        """

        @property
        def value(self) -> google.protobuf.struct_pb2.Value:
            """Output only. The value of the parameter.
            `number_value` will be set if a parameter defined in StudySpec is
            in type 'INTEGER', 'DOUBLE' or 'DISCRETE'.
            `string_value` will be set if a parameter defined in StudySpec is
            in type 'CATEGORICAL'.
            """
            pass
        def __init__(self,
            *,
            parameter_id : typing.Text = ...,
            value : typing.Optional[google.protobuf.struct_pb2.Value] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["parameter_id",b"parameter_id","value",b"value"]) -> None: ...

    class WebAccessUrisEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    ID_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    FINAL_MEASUREMENT_FIELD_NUMBER: builtins.int
    MEASUREMENTS_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    CLIENT_ID_FIELD_NUMBER: builtins.int
    INFEASIBLE_REASON_FIELD_NUMBER: builtins.int
    CUSTOM_JOB_FIELD_NUMBER: builtins.int
    WEB_ACCESS_URIS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Output only. Resource name of the Trial assigned by the service."""

    id: typing.Text = ...
    """Output only. The identifier of the Trial assigned by the service."""

    state: global___Trial.State.ValueType = ...
    """Output only. The detailed state of the Trial."""

    @property
    def parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Trial.Parameter]:
        """Output only. The parameters of the Trial."""
        pass
    @property
    def final_measurement(self) -> global___Measurement:
        """Output only. The final measurement containing the objective value."""
        pass
    @property
    def measurements(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Measurement]:
        """Output only. A list of measurements that are strictly lexicographically
        ordered by their induced tuples (steps, elapsed_duration).
        These are used for early stopping computations.
        """
        pass
    @property
    def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Time when the Trial was started."""
        pass
    @property
    def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Time when the Trial's status changed to `SUCCEEDED` or `INFEASIBLE`."""
        pass
    client_id: typing.Text = ...
    """Output only. The identifier of the client that originally requested this Trial.
    Each client is identified by a unique client_id. When a client
    asks for a suggestion, Vertex AI Vizier will assign it a Trial. The client
    should evaluate the Trial, complete it, and report back to Vertex AI
    Vizier. If suggestion is asked again by same client_id before the Trial is
    completed, the same Trial will be returned. Multiple clients with
    different client_ids can ask for suggestions simultaneously, each of them
    will get their own Trial.
    """

    infeasible_reason: typing.Text = ...
    """Output only. A human readable string describing why the Trial is
    infeasible. This is set only if Trial state is `INFEASIBLE`.
    """

    custom_job: typing.Text = ...
    """Output only. The CustomJob name linked to the Trial.
    It's set for a HyperparameterTuningJob's Trial.
    """

    @property
    def web_access_uris(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Output only. URIs for accessing [interactive
        shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
        (one URI for each training node). Only available if this trial is part of
        a [HyperparameterTuningJob][google.cloud.aiplatform.v1beta1.HyperparameterTuningJob] and the job's
        [trial_job_spec.enable_web_access][google.cloud.aiplatform.v1beta1.CustomJobSpec.enable_web_access] field
        is `true`.

        The keys are names of each node used for the trial; for example,
        `workerpool0-0` for the primary node, `workerpool1-0` for the first node in
        the second worker pool, and `workerpool1-1` for the second node in the
        second worker pool.

        The values are the URIs for each node's interactive shell.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        id : typing.Text = ...,
        state : global___Trial.State.ValueType = ...,
        parameters : typing.Optional[typing.Iterable[global___Trial.Parameter]] = ...,
        final_measurement : typing.Optional[global___Measurement] = ...,
        measurements : typing.Optional[typing.Iterable[global___Measurement]] = ...,
        start_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        end_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        client_id : typing.Text = ...,
        infeasible_reason : typing.Text = ...,
        custom_job : typing.Text = ...,
        web_access_uris : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_time",b"end_time","final_measurement",b"final_measurement","start_time",b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["client_id",b"client_id","custom_job",b"custom_job","end_time",b"end_time","final_measurement",b"final_measurement","id",b"id","infeasible_reason",b"infeasible_reason","measurements",b"measurements","name",b"name","parameters",b"parameters","start_time",b"start_time","state",b"state","web_access_uris",b"web_access_uris"]) -> None: ...
global___Trial = Trial

class StudySpec(google.protobuf.message.Message):
    """Represents specification of a Study."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Algorithm:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _AlgorithmEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Algorithm.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        ALGORITHM_UNSPECIFIED: StudySpec.Algorithm.ValueType = ...  # 0
        """The default algorithm used by Vertex AI for [hyperparameter
        tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview)
        and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
        """

        GRID_SEARCH: StudySpec.Algorithm.ValueType = ...  # 2
        """Simple grid search within the feasible space. To use grid search,
        all parameters must be `INTEGER`, `CATEGORICAL`, or `DISCRETE`.
        """

        RANDOM_SEARCH: StudySpec.Algorithm.ValueType = ...  # 3
        """Simple random search within the feasible space."""

    class Algorithm(_Algorithm, metaclass=_AlgorithmEnumTypeWrapper):
        """The available search algorithms for the Study."""
        pass

    ALGORITHM_UNSPECIFIED: StudySpec.Algorithm.ValueType = ...  # 0
    """The default algorithm used by Vertex AI for [hyperparameter
    tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview)
    and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
    """

    GRID_SEARCH: StudySpec.Algorithm.ValueType = ...  # 2
    """Simple grid search within the feasible space. To use grid search,
    all parameters must be `INTEGER`, `CATEGORICAL`, or `DISCRETE`.
    """

    RANDOM_SEARCH: StudySpec.Algorithm.ValueType = ...  # 3
    """Simple random search within the feasible space."""


    class _ObservationNoise:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ObservationNoiseEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ObservationNoise.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        OBSERVATION_NOISE_UNSPECIFIED: StudySpec.ObservationNoise.ValueType = ...  # 0
        """The default noise level chosen by Vertex AI."""

        LOW: StudySpec.ObservationNoise.ValueType = ...  # 1
        """Vertex AI assumes that the objective function is (nearly)
        perfectly reproducible, and will never repeat the same Trial
        parameters.
        """

        HIGH: StudySpec.ObservationNoise.ValueType = ...  # 2
        """Vertex AI will estimate the amount of noise in metric
        evaluations, it may repeat the same Trial parameters more than once.
        """

    class ObservationNoise(_ObservationNoise, metaclass=_ObservationNoiseEnumTypeWrapper):
        """Describes the noise level of the repeated observations.

        "Noisy" means that the repeated observations with the same Trial parameters
        may lead to different metric evaluations.
        """
        pass

    OBSERVATION_NOISE_UNSPECIFIED: StudySpec.ObservationNoise.ValueType = ...  # 0
    """The default noise level chosen by Vertex AI."""

    LOW: StudySpec.ObservationNoise.ValueType = ...  # 1
    """Vertex AI assumes that the objective function is (nearly)
    perfectly reproducible, and will never repeat the same Trial
    parameters.
    """

    HIGH: StudySpec.ObservationNoise.ValueType = ...  # 2
    """Vertex AI will estimate the amount of noise in metric
    evaluations, it may repeat the same Trial parameters more than once.
    """


    class _MeasurementSelectionType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _MeasurementSelectionTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_MeasurementSelectionType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        MEASUREMENT_SELECTION_TYPE_UNSPECIFIED: StudySpec.MeasurementSelectionType.ValueType = ...  # 0
        """Will be treated as LAST_MEASUREMENT."""

        LAST_MEASUREMENT: StudySpec.MeasurementSelectionType.ValueType = ...  # 1
        """Use the last measurement reported."""

        BEST_MEASUREMENT: StudySpec.MeasurementSelectionType.ValueType = ...  # 2
        """Use the best measurement reported."""

    class MeasurementSelectionType(_MeasurementSelectionType, metaclass=_MeasurementSelectionTypeEnumTypeWrapper):
        """This indicates which measurement to use if/when the service automatically
        selects the final measurement from previously reported intermediate
        measurements. Choose this based on two considerations:
         A) Do you expect your measurements to monotonically improve?
            If so, choose LAST_MEASUREMENT. On the other hand, if you're in a
            situation where your system can "over-train" and you expect the
            performance to get better for a while but then start declining,
            choose BEST_MEASUREMENT.
         B) Are your measurements significantly noisy and/or irreproducible?
            If so, BEST_MEASUREMENT will tend to be over-optimistic, and it
            may be better to choose LAST_MEASUREMENT.
         If both or neither of (A) and (B) apply, it doesn't matter which
         selection type is chosen.
        """
        pass

    MEASUREMENT_SELECTION_TYPE_UNSPECIFIED: StudySpec.MeasurementSelectionType.ValueType = ...  # 0
    """Will be treated as LAST_MEASUREMENT."""

    LAST_MEASUREMENT: StudySpec.MeasurementSelectionType.ValueType = ...  # 1
    """Use the last measurement reported."""

    BEST_MEASUREMENT: StudySpec.MeasurementSelectionType.ValueType = ...  # 2
    """Use the best measurement reported."""


    class MetricSpec(google.protobuf.message.Message):
        """Represents a metric to optimize."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _GoalType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _GoalTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_GoalType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            GOAL_TYPE_UNSPECIFIED: StudySpec.MetricSpec.GoalType.ValueType = ...  # 0
            """Goal Type will default to maximize."""

            MAXIMIZE: StudySpec.MetricSpec.GoalType.ValueType = ...  # 1
            """Maximize the goal metric."""

            MINIMIZE: StudySpec.MetricSpec.GoalType.ValueType = ...  # 2
            """Minimize the goal metric."""

        class GoalType(_GoalType, metaclass=_GoalTypeEnumTypeWrapper):
            """The available types of optimization goals."""
            pass

        GOAL_TYPE_UNSPECIFIED: StudySpec.MetricSpec.GoalType.ValueType = ...  # 0
        """Goal Type will default to maximize."""

        MAXIMIZE: StudySpec.MetricSpec.GoalType.ValueType = ...  # 1
        """Maximize the goal metric."""

        MINIMIZE: StudySpec.MetricSpec.GoalType.ValueType = ...  # 2
        """Minimize the goal metric."""


        METRIC_ID_FIELD_NUMBER: builtins.int
        GOAL_FIELD_NUMBER: builtins.int
        metric_id: typing.Text = ...
        """Required. The ID of the metric. Must not contain whitespaces and must be unique
        amongst all MetricSpecs.
        """

        goal: global___StudySpec.MetricSpec.GoalType.ValueType = ...
        """Required. The optimization goal of the metric."""

        def __init__(self,
            *,
            metric_id : typing.Text = ...,
            goal : global___StudySpec.MetricSpec.GoalType.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["goal",b"goal","metric_id",b"metric_id"]) -> None: ...

    class ParameterSpec(google.protobuf.message.Message):
        """Represents a single parameter to optimize."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _ScaleType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _ScaleTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ScaleType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            SCALE_TYPE_UNSPECIFIED: StudySpec.ParameterSpec.ScaleType.ValueType = ...  # 0
            """By default, no scaling is applied."""

            UNIT_LINEAR_SCALE: StudySpec.ParameterSpec.ScaleType.ValueType = ...  # 1
            """Scales the feasible space to (0, 1) linearly."""

            UNIT_LOG_SCALE: StudySpec.ParameterSpec.ScaleType.ValueType = ...  # 2
            """Scales the feasible space logarithmically to (0, 1). The entire
            feasible space must be strictly positive.
            """

            UNIT_REVERSE_LOG_SCALE: StudySpec.ParameterSpec.ScaleType.ValueType = ...  # 3
            """Scales the feasible space "reverse" logarithmically to (0, 1). The
            result is that values close to the top of the feasible space are spread
            out more than points near the bottom. The entire feasible space must be
            strictly positive.
            """

        class ScaleType(_ScaleType, metaclass=_ScaleTypeEnumTypeWrapper):
            """The type of scaling that should be applied to this parameter."""
            pass

        SCALE_TYPE_UNSPECIFIED: StudySpec.ParameterSpec.ScaleType.ValueType = ...  # 0
        """By default, no scaling is applied."""

        UNIT_LINEAR_SCALE: StudySpec.ParameterSpec.ScaleType.ValueType = ...  # 1
        """Scales the feasible space to (0, 1) linearly."""

        UNIT_LOG_SCALE: StudySpec.ParameterSpec.ScaleType.ValueType = ...  # 2
        """Scales the feasible space logarithmically to (0, 1). The entire
        feasible space must be strictly positive.
        """

        UNIT_REVERSE_LOG_SCALE: StudySpec.ParameterSpec.ScaleType.ValueType = ...  # 3
        """Scales the feasible space "reverse" logarithmically to (0, 1). The
        result is that values close to the top of the feasible space are spread
        out more than points near the bottom. The entire feasible space must be
        strictly positive.
        """


        class DoubleValueSpec(google.protobuf.message.Message):
            """Value specification for a parameter in `DOUBLE` type."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            MIN_VALUE_FIELD_NUMBER: builtins.int
            MAX_VALUE_FIELD_NUMBER: builtins.int
            DEFAULT_VALUE_FIELD_NUMBER: builtins.int
            min_value: builtins.float = ...
            """Required. Inclusive minimum value of the parameter."""

            max_value: builtins.float = ...
            """Required. Inclusive maximum value of the parameter."""

            default_value: builtins.float = ...
            """A default value for a `DOUBLE` parameter that is assumed to be a
            relatively good starting point.  Unset value signals that there is no
            offered starting point.

            Currently only supported by the Vertex AI Vizier service. Not supported
            by HyperparamterTuningJob or TrainingPipeline.
            """

            def __init__(self,
                *,
                min_value : builtins.float = ...,
                max_value : builtins.float = ...,
                default_value : typing.Optional[builtins.float] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["_default_value",b"_default_value","default_value",b"default_value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["_default_value",b"_default_value","default_value",b"default_value","max_value",b"max_value","min_value",b"min_value"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["_default_value",b"_default_value"]) -> typing.Optional[typing_extensions.Literal["default_value"]]: ...

        class IntegerValueSpec(google.protobuf.message.Message):
            """Value specification for a parameter in `INTEGER` type."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            MIN_VALUE_FIELD_NUMBER: builtins.int
            MAX_VALUE_FIELD_NUMBER: builtins.int
            DEFAULT_VALUE_FIELD_NUMBER: builtins.int
            min_value: builtins.int = ...
            """Required. Inclusive minimum value of the parameter."""

            max_value: builtins.int = ...
            """Required. Inclusive maximum value of the parameter."""

            default_value: builtins.int = ...
            """A default value for an `INTEGER` parameter that is assumed to be a
            relatively good starting point.  Unset value signals that there is no
            offered starting point.

            Currently only supported by the Vertex AI Vizier service. Not supported
            by HyperparamterTuningJob or TrainingPipeline.
            """

            def __init__(self,
                *,
                min_value : builtins.int = ...,
                max_value : builtins.int = ...,
                default_value : typing.Optional[builtins.int] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["_default_value",b"_default_value","default_value",b"default_value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["_default_value",b"_default_value","default_value",b"default_value","max_value",b"max_value","min_value",b"min_value"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["_default_value",b"_default_value"]) -> typing.Optional[typing_extensions.Literal["default_value"]]: ...

        class CategoricalValueSpec(google.protobuf.message.Message):
            """Value specification for a parameter in `CATEGORICAL` type."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            VALUES_FIELD_NUMBER: builtins.int
            DEFAULT_VALUE_FIELD_NUMBER: builtins.int
            @property
            def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """Required. The list of possible categories."""
                pass
            default_value: typing.Text = ...
            """A default value for a `CATEGORICAL` parameter that is assumed to be a
            relatively good starting point.  Unset value signals that there is no
            offered starting point.

            Currently only supported by the Vizier service. Not supported by
            HyperparamterTuningJob or TrainingPipeline.
            """

            def __init__(self,
                *,
                values : typing.Optional[typing.Iterable[typing.Text]] = ...,
                default_value : typing.Optional[typing.Text] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["_default_value",b"_default_value","default_value",b"default_value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["_default_value",b"_default_value","default_value",b"default_value","values",b"values"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["_default_value",b"_default_value"]) -> typing.Optional[typing_extensions.Literal["default_value"]]: ...

        class DiscreteValueSpec(google.protobuf.message.Message):
            """Value specification for a parameter in `DISCRETE` type."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            VALUES_FIELD_NUMBER: builtins.int
            DEFAULT_VALUE_FIELD_NUMBER: builtins.int
            @property
            def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Required. A list of possible values.
                The list should be in increasing order and at least 1e-10 apart.
                For instance, this parameter might have possible settings of 1.5, 2.5,
                and 4.0. This list should not contain more than 1,000 values.
                """
                pass
            default_value: builtins.float = ...
            """A default value for a `DISCRETE` parameter that is assumed to be a
            relatively good starting point.  Unset value signals that there is no
            offered starting point.  It automatically rounds to the
            nearest feasible discrete point.

            Currently only supported by the Vizier service. Not supported by
            HyperparamterTuningJob or TrainingPipeline.
            """

            def __init__(self,
                *,
                values : typing.Optional[typing.Iterable[builtins.float]] = ...,
                default_value : typing.Optional[builtins.float] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["_default_value",b"_default_value","default_value",b"default_value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["_default_value",b"_default_value","default_value",b"default_value","values",b"values"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["_default_value",b"_default_value"]) -> typing.Optional[typing_extensions.Literal["default_value"]]: ...

        class ConditionalParameterSpec(google.protobuf.message.Message):
            """Represents a parameter spec with condition from its parent parameter."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class DiscreteValueCondition(google.protobuf.message.Message):
                """Represents the spec to match discrete values from parent parameter."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                VALUES_FIELD_NUMBER: builtins.int
                @property
                def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                    """Required. Matches values of the parent parameter of 'DISCRETE' type.
                    All values must exist in `discrete_value_spec` of parent parameter.

                    The Epsilon of the value matching is 1e-10.
                    """
                    pass
                def __init__(self,
                    *,
                    values : typing.Optional[typing.Iterable[builtins.float]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["values",b"values"]) -> None: ...

            class IntValueCondition(google.protobuf.message.Message):
                """Represents the spec to match integer values from parent parameter."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                VALUES_FIELD_NUMBER: builtins.int
                @property
                def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                    """Required. Matches values of the parent parameter of 'INTEGER' type.
                    All values must lie in `integer_value_spec` of parent parameter.
                    """
                    pass
                def __init__(self,
                    *,
                    values : typing.Optional[typing.Iterable[builtins.int]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["values",b"values"]) -> None: ...

            class CategoricalValueCondition(google.protobuf.message.Message):
                """Represents the spec to match categorical values from parent parameter."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                VALUES_FIELD_NUMBER: builtins.int
                @property
                def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                    """Required. Matches values of the parent parameter of 'CATEGORICAL' type.
                    All values must exist in `categorical_value_spec` of parent
                    parameter.
                    """
                    pass
                def __init__(self,
                    *,
                    values : typing.Optional[typing.Iterable[typing.Text]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["values",b"values"]) -> None: ...

            PARENT_DISCRETE_VALUES_FIELD_NUMBER: builtins.int
            PARENT_INT_VALUES_FIELD_NUMBER: builtins.int
            PARENT_CATEGORICAL_VALUES_FIELD_NUMBER: builtins.int
            PARAMETER_SPEC_FIELD_NUMBER: builtins.int
            @property
            def parent_discrete_values(self) -> global___StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition:
                """The spec for matching values from a parent parameter of
                `DISCRETE` type.
                """
                pass
            @property
            def parent_int_values(self) -> global___StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition:
                """The spec for matching values from a parent parameter of `INTEGER`
                type.
                """
                pass
            @property
            def parent_categorical_values(self) -> global___StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition:
                """The spec for matching values from a parent parameter of
                `CATEGORICAL` type.
                """
                pass
            @property
            def parameter_spec(self) -> global___StudySpec.ParameterSpec:
                """Required. The spec for a conditional parameter."""
                pass
            def __init__(self,
                *,
                parent_discrete_values : typing.Optional[global___StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition] = ...,
                parent_int_values : typing.Optional[global___StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition] = ...,
                parent_categorical_values : typing.Optional[global___StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition] = ...,
                parameter_spec : typing.Optional[global___StudySpec.ParameterSpec] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["parameter_spec",b"parameter_spec","parent_categorical_values",b"parent_categorical_values","parent_discrete_values",b"parent_discrete_values","parent_int_values",b"parent_int_values","parent_value_condition",b"parent_value_condition"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["parameter_spec",b"parameter_spec","parent_categorical_values",b"parent_categorical_values","parent_discrete_values",b"parent_discrete_values","parent_int_values",b"parent_int_values","parent_value_condition",b"parent_value_condition"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["parent_value_condition",b"parent_value_condition"]) -> typing.Optional[typing_extensions.Literal["parent_discrete_values","parent_int_values","parent_categorical_values"]]: ...

        DOUBLE_VALUE_SPEC_FIELD_NUMBER: builtins.int
        INTEGER_VALUE_SPEC_FIELD_NUMBER: builtins.int
        CATEGORICAL_VALUE_SPEC_FIELD_NUMBER: builtins.int
        DISCRETE_VALUE_SPEC_FIELD_NUMBER: builtins.int
        PARAMETER_ID_FIELD_NUMBER: builtins.int
        SCALE_TYPE_FIELD_NUMBER: builtins.int
        CONDITIONAL_PARAMETER_SPECS_FIELD_NUMBER: builtins.int
        @property
        def double_value_spec(self) -> global___StudySpec.ParameterSpec.DoubleValueSpec:
            """The value spec for a 'DOUBLE' parameter."""
            pass
        @property
        def integer_value_spec(self) -> global___StudySpec.ParameterSpec.IntegerValueSpec:
            """The value spec for an 'INTEGER' parameter."""
            pass
        @property
        def categorical_value_spec(self) -> global___StudySpec.ParameterSpec.CategoricalValueSpec:
            """The value spec for a 'CATEGORICAL' parameter."""
            pass
        @property
        def discrete_value_spec(self) -> global___StudySpec.ParameterSpec.DiscreteValueSpec:
            """The value spec for a 'DISCRETE' parameter."""
            pass
        parameter_id: typing.Text = ...
        """Required. The ID of the parameter. Must not contain whitespaces and must be unique
        amongst all ParameterSpecs.
        """

        scale_type: global___StudySpec.ParameterSpec.ScaleType.ValueType = ...
        """How the parameter should be scaled.
        Leave unset for `CATEGORICAL` parameters.
        """

        @property
        def conditional_parameter_specs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StudySpec.ParameterSpec.ConditionalParameterSpec]:
            """A conditional parameter node is active if the parameter's value matches
            the conditional node's parent_value_condition.

            If two items in conditional_parameter_specs have the same name, they
            must have disjoint parent_value_condition.
            """
            pass
        def __init__(self,
            *,
            double_value_spec : typing.Optional[global___StudySpec.ParameterSpec.DoubleValueSpec] = ...,
            integer_value_spec : typing.Optional[global___StudySpec.ParameterSpec.IntegerValueSpec] = ...,
            categorical_value_spec : typing.Optional[global___StudySpec.ParameterSpec.CategoricalValueSpec] = ...,
            discrete_value_spec : typing.Optional[global___StudySpec.ParameterSpec.DiscreteValueSpec] = ...,
            parameter_id : typing.Text = ...,
            scale_type : global___StudySpec.ParameterSpec.ScaleType.ValueType = ...,
            conditional_parameter_specs : typing.Optional[typing.Iterable[global___StudySpec.ParameterSpec.ConditionalParameterSpec]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["categorical_value_spec",b"categorical_value_spec","discrete_value_spec",b"discrete_value_spec","double_value_spec",b"double_value_spec","integer_value_spec",b"integer_value_spec","parameter_value_spec",b"parameter_value_spec"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["categorical_value_spec",b"categorical_value_spec","conditional_parameter_specs",b"conditional_parameter_specs","discrete_value_spec",b"discrete_value_spec","double_value_spec",b"double_value_spec","integer_value_spec",b"integer_value_spec","parameter_id",b"parameter_id","parameter_value_spec",b"parameter_value_spec","scale_type",b"scale_type"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["parameter_value_spec",b"parameter_value_spec"]) -> typing.Optional[typing_extensions.Literal["double_value_spec","integer_value_spec","categorical_value_spec","discrete_value_spec"]]: ...

    class DecayCurveAutomatedStoppingSpec(google.protobuf.message.Message):
        """The decay curve automated stopping rule builds a Gaussian Process
        Regressor to predict the final objective value of a Trial based on the
        already completed Trials and the intermediate measurements of the current
        Trial. Early stopping is requested for the current Trial if there is very
        low probability to exceed the optimal value found so far.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        USE_ELAPSED_DURATION_FIELD_NUMBER: builtins.int
        use_elapsed_duration: builtins.bool = ...
        """True if [Measurement.elapsed_duration][google.cloud.aiplatform.v1beta1.Measurement.elapsed_duration] is used as the x-axis of each
        Trials Decay Curve. Otherwise, [Measurement.step_count][google.cloud.aiplatform.v1beta1.Measurement.step_count] will be used
        as the x-axis.
        """

        def __init__(self,
            *,
            use_elapsed_duration : builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["use_elapsed_duration",b"use_elapsed_duration"]) -> None: ...

    class MedianAutomatedStoppingSpec(google.protobuf.message.Message):
        """The median automated stopping rule stops a pending Trial if the Trial's
        best objective_value is strictly below the median 'performance' of all
        completed Trials reported up to the Trial's last measurement.
        Currently, 'performance' refers to the running average of the objective
        values reported by the Trial in each measurement.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        USE_ELAPSED_DURATION_FIELD_NUMBER: builtins.int
        use_elapsed_duration: builtins.bool = ...
        """True if median automated stopping rule applies on
        [Measurement.elapsed_duration][google.cloud.aiplatform.v1beta1.Measurement.elapsed_duration]. It means that elapsed_duration
        field of latest measurement of current Trial is used to compute median
        objective value for each completed Trials.
        """

        def __init__(self,
            *,
            use_elapsed_duration : builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["use_elapsed_duration",b"use_elapsed_duration"]) -> None: ...

    class ConvexStopConfig(google.protobuf.message.Message):
        """Configuration for ConvexStopPolicy."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MAX_NUM_STEPS_FIELD_NUMBER: builtins.int
        MIN_NUM_STEPS_FIELD_NUMBER: builtins.int
        AUTOREGRESSIVE_ORDER_FIELD_NUMBER: builtins.int
        LEARNING_RATE_PARAMETER_NAME_FIELD_NUMBER: builtins.int
        USE_SECONDS_FIELD_NUMBER: builtins.int
        max_num_steps: builtins.int = ...
        """Steps used in predicting the final objective for early stopped trials. In
        general, it's set to be the same as the defined steps in training /
        tuning. When use_steps is false, this field is set to the maximum elapsed
        seconds.
        """

        min_num_steps: builtins.int = ...
        """Minimum number of steps for a trial to complete. Trials which do not have
        a measurement with num_steps > min_num_steps won't be considered for
        early stopping. It's ok to set it to 0, and a trial can be early stopped
        at any stage. By default, min_num_steps is set to be one-tenth of the
        max_num_steps.
        When use_steps is false, this field is set to the minimum elapsed
        seconds.
        """

        autoregressive_order: builtins.int = ...
        """The number of Trial measurements used in autoregressive model for
        value prediction. A trial won't be considered early stopping if has fewer
        measurement points.
        """

        learning_rate_parameter_name: typing.Text = ...
        """The hyper-parameter name used in the tuning job that stands for learning
        rate. Leave it blank if learning rate is not in a parameter in tuning.
        The learning_rate is used to estimate the objective value of the ongoing
        trial.
        """

        use_seconds: builtins.bool = ...
        """This bool determines whether or not the rule is applied based on
        elapsed_secs or steps. If use_seconds==false, the early stopping decision
        is made according to the predicted objective values according to the
        target steps. If use_seconds==true, elapsed_secs is used instead of
        steps. Also, in this case, the parameters max_num_steps and min_num_steps
        are overloaded to contain max_elapsed_seconds and min_elapsed_seconds.
        """

        def __init__(self,
            *,
            max_num_steps : builtins.int = ...,
            min_num_steps : builtins.int = ...,
            autoregressive_order : builtins.int = ...,
            learning_rate_parameter_name : typing.Text = ...,
            use_seconds : builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["autoregressive_order",b"autoregressive_order","learning_rate_parameter_name",b"learning_rate_parameter_name","max_num_steps",b"max_num_steps","min_num_steps",b"min_num_steps","use_seconds",b"use_seconds"]) -> None: ...

    DECAY_CURVE_STOPPING_SPEC_FIELD_NUMBER: builtins.int
    MEDIAN_AUTOMATED_STOPPING_SPEC_FIELD_NUMBER: builtins.int
    CONVEX_STOP_CONFIG_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    ALGORITHM_FIELD_NUMBER: builtins.int
    OBSERVATION_NOISE_FIELD_NUMBER: builtins.int
    MEASUREMENT_SELECTION_TYPE_FIELD_NUMBER: builtins.int
    @property
    def decay_curve_stopping_spec(self) -> global___StudySpec.DecayCurveAutomatedStoppingSpec:
        """The automated early stopping spec using decay curve rule."""
        pass
    @property
    def median_automated_stopping_spec(self) -> global___StudySpec.MedianAutomatedStoppingSpec:
        """The automated early stopping spec using median rule."""
        pass
    @property
    def convex_stop_config(self) -> global___StudySpec.ConvexStopConfig:
        """Deprecated.
        The automated early stopping using convex stopping rule.
        """
        pass
    @property
    def metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StudySpec.MetricSpec]:
        """Required. Metric specs for the Study."""
        pass
    @property
    def parameters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StudySpec.ParameterSpec]:
        """Required. The set of parameters to tune."""
        pass
    algorithm: global___StudySpec.Algorithm.ValueType = ...
    """The search algorithm specified for the Study."""

    observation_noise: global___StudySpec.ObservationNoise.ValueType = ...
    """The observation noise level of the study.
    Currently only supported by the Vertex AI Vizier service. Not supported by
    HyperparamterTuningJob or TrainingPipeline.
    """

    measurement_selection_type: global___StudySpec.MeasurementSelectionType.ValueType = ...
    """Describe which measurement selection type will be used"""

    def __init__(self,
        *,
        decay_curve_stopping_spec : typing.Optional[global___StudySpec.DecayCurveAutomatedStoppingSpec] = ...,
        median_automated_stopping_spec : typing.Optional[global___StudySpec.MedianAutomatedStoppingSpec] = ...,
        convex_stop_config : typing.Optional[global___StudySpec.ConvexStopConfig] = ...,
        metrics : typing.Optional[typing.Iterable[global___StudySpec.MetricSpec]] = ...,
        parameters : typing.Optional[typing.Iterable[global___StudySpec.ParameterSpec]] = ...,
        algorithm : global___StudySpec.Algorithm.ValueType = ...,
        observation_noise : global___StudySpec.ObservationNoise.ValueType = ...,
        measurement_selection_type : global___StudySpec.MeasurementSelectionType.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["automated_stopping_spec",b"automated_stopping_spec","convex_stop_config",b"convex_stop_config","decay_curve_stopping_spec",b"decay_curve_stopping_spec","median_automated_stopping_spec",b"median_automated_stopping_spec"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["algorithm",b"algorithm","automated_stopping_spec",b"automated_stopping_spec","convex_stop_config",b"convex_stop_config","decay_curve_stopping_spec",b"decay_curve_stopping_spec","measurement_selection_type",b"measurement_selection_type","median_automated_stopping_spec",b"median_automated_stopping_spec","metrics",b"metrics","observation_noise",b"observation_noise","parameters",b"parameters"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["automated_stopping_spec",b"automated_stopping_spec"]) -> typing.Optional[typing_extensions.Literal["decay_curve_stopping_spec","median_automated_stopping_spec","convex_stop_config"]]: ...
global___StudySpec = StudySpec

class Measurement(google.protobuf.message.Message):
    """A message representing a Measurement of a Trial. A Measurement contains
    the Metrics got by executing a Trial using suggested hyperparameter
    values.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Metric(google.protobuf.message.Message):
        """A message representing a metric in the measurement."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        METRIC_ID_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        metric_id: typing.Text = ...
        """Output only. The ID of the Metric. The Metric should be defined in
        [StudySpec's Metrics][google.cloud.aiplatform.v1beta1.StudySpec.metrics].
        """

        value: builtins.float = ...
        """Output only. The value for this metric."""

        def __init__(self,
            *,
            metric_id : typing.Text = ...,
            value : builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["metric_id",b"metric_id","value",b"value"]) -> None: ...

    ELAPSED_DURATION_FIELD_NUMBER: builtins.int
    STEP_COUNT_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    @property
    def elapsed_duration(self) -> google.protobuf.duration_pb2.Duration:
        """Output only. Time that the Trial has been running at the point of this Measurement."""
        pass
    step_count: builtins.int = ...
    """Output only. The number of steps the machine learning model has been trained for.
    Must be non-negative.
    """

    @property
    def metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Measurement.Metric]:
        """Output only. A list of metrics got by evaluating the objective functions using suggested
        Parameter values.
        """
        pass
    def __init__(self,
        *,
        elapsed_duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        step_count : builtins.int = ...,
        metrics : typing.Optional[typing.Iterable[global___Measurement.Metric]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["elapsed_duration",b"elapsed_duration"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["elapsed_duration",b"elapsed_duration","metrics",b"metrics","step_count",b"step_count"]) -> None: ...
global___Measurement = Measurement
