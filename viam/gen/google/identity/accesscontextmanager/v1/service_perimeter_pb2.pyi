"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class ServicePerimeter(google.protobuf.message.Message):
    """`ServicePerimeter` describes a set of Google Cloud resources which can freely
    import and export data amongst themselves, but not export outside of the
    `ServicePerimeter`. If a request with a source within this `ServicePerimeter`
    has a target outside of the `ServicePerimeter`, the request will be blocked.
    Otherwise the request is allowed. There are two types of Service Perimeter -
    Regular and Bridge. Regular Service Perimeters cannot overlap, a single
    Google Cloud project can only belong to a single regular Service Perimeter.
    Service Perimeter Bridges can contain only Google Cloud projects as members,
    a single Google Cloud project may belong to multiple Service Perimeter
    Bridges.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _PerimeterType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _PerimeterTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PerimeterType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        PERIMETER_TYPE_REGULAR: ServicePerimeter.PerimeterType.ValueType = ...  # 0
        """Regular Perimeter."""

        PERIMETER_TYPE_BRIDGE: ServicePerimeter.PerimeterType.ValueType = ...  # 1
        """Perimeter Bridge."""

    class PerimeterType(_PerimeterType, metaclass=_PerimeterTypeEnumTypeWrapper):
        """Specifies the type of the Perimeter. There are two types: regular and
        bridge. Regular Service Perimeter contains resources, access levels, and
        restricted services. Every resource can be in at most ONE
        regular Service Perimeter.

        In addition to being in a regular service perimeter, a resource can also
        be in zero or more perimeter bridges.  A perimeter bridge only contains
        resources.  Cross project operations are permitted if all effected
        resources share some perimeter (whether bridge or regular). Perimeter
        Bridge does not contain access levels or services: those are governed
        entirely by the regular perimeter that resource is in.

        Perimeter Bridges are typically useful when building more complex toplogies
        with many independent perimeters that need to share some data with a common
        perimeter, but should not be able to share data among themselves.
        """
        pass

    PERIMETER_TYPE_REGULAR: ServicePerimeter.PerimeterType.ValueType = ...  # 0
    """Regular Perimeter."""

    PERIMETER_TYPE_BRIDGE: ServicePerimeter.PerimeterType.ValueType = ...  # 1
    """Perimeter Bridge."""


    NAME_FIELD_NUMBER: builtins.int
    TITLE_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    PERIMETER_TYPE_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    SPEC_FIELD_NUMBER: builtins.int
    USE_EXPLICIT_DRY_RUN_SPEC_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name for the ServicePerimeter.  The `short_name`
    component must begin with a letter and only include alphanumeric and '_'.
    Format:
    `accessPolicies/{access_policy}/servicePerimeters/{service_perimeter}`
    """

    title: typing.Text = ...
    """Human readable title. Must be unique within the Policy."""

    description: typing.Text = ...
    """Description of the `ServicePerimeter` and its use. Does not affect
    behavior.
    """

    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Time the `ServicePerimeter` was created in UTC."""
        pass
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Time the `ServicePerimeter` was updated in UTC."""
        pass
    perimeter_type: global___ServicePerimeter.PerimeterType.ValueType = ...
    """Perimeter type indicator. A single project is
    allowed to be a member of single regular perimeter, but multiple service
    perimeter bridges. A project cannot be a included in a perimeter bridge
    without being included in regular perimeter. For perimeter bridges,
    the restricted service list as well as access level lists must be
    empty.
    """

    @property
    def status(self) -> global___ServicePerimeterConfig:
        """Current ServicePerimeter configuration. Specifies sets of resources,
        restricted services and access levels that determine perimeter
        content and boundaries.
        """
        pass
    @property
    def spec(self) -> global___ServicePerimeterConfig:
        """Proposed (or dry run) ServicePerimeter configuration. This configuration
        allows to specify and test ServicePerimeter configuration without enforcing
        actual access restrictions. Only allowed to be set when the
        "use_explicit_dry_run_spec" flag is set.
        """
        pass
    use_explicit_dry_run_spec: builtins.bool = ...
    """Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly
    exists  for all Service Perimeters, and that spec is identical to the
    status for those Service Perimeters. When this flag is set, it inhibits the
    generation of the implicit spec, thereby allowing the user to explicitly
    provide a configuration ("spec") to use in a dry-run version of the Service
    Perimeter. This allows the user to test changes to the enforced config
    ("status") without actually enforcing them. This testing is done through
    analyzing the differences between currently enforced and suggested
    restrictions. use_explicit_dry_run_spec must bet set to True if any of the
    fields in the spec are set to non-default values.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        title : typing.Text = ...,
        description : typing.Text = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        update_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        perimeter_type : global___ServicePerimeter.PerimeterType.ValueType = ...,
        status : typing.Optional[global___ServicePerimeterConfig] = ...,
        spec : typing.Optional[global___ServicePerimeterConfig] = ...,
        use_explicit_dry_run_spec : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time",b"create_time","spec",b"spec","status",b"status","update_time",b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time",b"create_time","description",b"description","name",b"name","perimeter_type",b"perimeter_type","spec",b"spec","status",b"status","title",b"title","update_time",b"update_time","use_explicit_dry_run_spec",b"use_explicit_dry_run_spec"]) -> None: ...
global___ServicePerimeter = ServicePerimeter

class ServicePerimeterConfig(google.protobuf.message.Message):
    """`ServicePerimeterConfig` specifies a set of Google Cloud resources that
    describe specific Service Perimeter configuration.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _IdentityType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _IdentityTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_IdentityType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        IDENTITY_TYPE_UNSPECIFIED: ServicePerimeterConfig.IdentityType.ValueType = ...  # 0
        """No blanket identity group specified."""

        ANY_IDENTITY: ServicePerimeterConfig.IdentityType.ValueType = ...  # 1
        """Authorize access from all identities outside the perimeter."""

        ANY_USER_ACCOUNT: ServicePerimeterConfig.IdentityType.ValueType = ...  # 2
        """Authorize access from all human users outside the perimeter."""

        ANY_SERVICE_ACCOUNT: ServicePerimeterConfig.IdentityType.ValueType = ...  # 3
        """Authorize access from all service accounts outside the perimeter."""

    class IdentityType(_IdentityType, metaclass=_IdentityTypeEnumTypeWrapper):
        """Specifies the types of identities that are allowed access in either
        [IngressFrom]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom]
        or [EgressFrom]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom]
        rules.
        """
        pass

    IDENTITY_TYPE_UNSPECIFIED: ServicePerimeterConfig.IdentityType.ValueType = ...  # 0
    """No blanket identity group specified."""

    ANY_IDENTITY: ServicePerimeterConfig.IdentityType.ValueType = ...  # 1
    """Authorize access from all identities outside the perimeter."""

    ANY_USER_ACCOUNT: ServicePerimeterConfig.IdentityType.ValueType = ...  # 2
    """Authorize access from all human users outside the perimeter."""

    ANY_SERVICE_ACCOUNT: ServicePerimeterConfig.IdentityType.ValueType = ...  # 3
    """Authorize access from all service accounts outside the perimeter."""


    class VpcAccessibleServices(google.protobuf.message.Message):
        """Specifies how APIs are allowed to communicate within the Service
        Perimeter.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        ENABLE_RESTRICTION_FIELD_NUMBER: builtins.int
        ALLOWED_SERVICES_FIELD_NUMBER: builtins.int
        enable_restriction: builtins.bool = ...
        """Whether to restrict API calls within the Service Perimeter to the list of
        APIs specified in 'allowed_services'.
        """

        @property
        def allowed_services(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """The list of APIs usable within the Service Perimeter. Must be empty
            unless 'enable_restriction' is True. You can specify a list of individual
            services, as well as include the 'RESTRICTED-SERVICES' value, which
            automatically includes all of the services protected by the perimeter.
            """
            pass
        def __init__(self,
            *,
            enable_restriction : builtins.bool = ...,
            allowed_services : typing.Optional[typing.Iterable[typing.Text]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["allowed_services",b"allowed_services","enable_restriction",b"enable_restriction"]) -> None: ...

    class MethodSelector(google.protobuf.message.Message):
        """An allowed method or permission of a service specified in [ApiOperation]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation].
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        METHOD_FIELD_NUMBER: builtins.int
        PERMISSION_FIELD_NUMBER: builtins.int
        method: typing.Text = ...
        """Value for `method` should be a valid method name for the corresponding
        `service_name` in [ApiOperation]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation].
        If `*` used as value for `method`, then ALL methods and permissions are
        allowed.
        """

        permission: typing.Text = ...
        """Value for `permission` should be a valid Cloud IAM permission for the
        corresponding `service_name` in [ApiOperation]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation].
        """

        def __init__(self,
            *,
            method : typing.Text = ...,
            permission : typing.Text = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["kind",b"kind","method",b"method","permission",b"permission"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["kind",b"kind","method",b"method","permission",b"permission"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["kind",b"kind"]) -> typing.Optional[typing_extensions.Literal["method","permission"]]: ...

    class ApiOperation(google.protobuf.message.Message):
        """Identification for an API Operation."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SERVICE_NAME_FIELD_NUMBER: builtins.int
        METHOD_SELECTORS_FIELD_NUMBER: builtins.int
        service_name: typing.Text = ...
        """The name of the API whose methods or permissions the [IngressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
        or [EgressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
        want to allow. A single [ApiOperation]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
        with `service_name` field set to `*` will allow all methods AND
        permissions for all services.
        """

        @property
        def method_selectors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ServicePerimeterConfig.MethodSelector]:
            """API methods or permissions to allow. Method or permission must belong to
            the service specified by `service_name` field. A single [MethodSelector]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.MethodSelector]
            entry with `*` specified for the `method` field will allow all methods
            AND permissions for the service specified in `service_name`.
            """
            pass
        def __init__(self,
            *,
            service_name : typing.Text = ...,
            method_selectors : typing.Optional[typing.Iterable[global___ServicePerimeterConfig.MethodSelector]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["method_selectors",b"method_selectors","service_name",b"service_name"]) -> None: ...

    class IngressSource(google.protobuf.message.Message):
        """The source that [IngressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
        authorizes access from.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        ACCESS_LEVEL_FIELD_NUMBER: builtins.int
        RESOURCE_FIELD_NUMBER: builtins.int
        access_level: typing.Text = ...
        """An [AccessLevel]
        [google.identity.accesscontextmanager.v1.AccessLevel] resource
        name that allow resources within the [ServicePerimeters]
        [google.identity.accesscontextmanager.v1.ServicePerimeter] to be
        accessed from the internet. [AccessLevels]
        [google.identity.accesscontextmanager.v1.AccessLevel] listed must
        be in the same policy as this [ServicePerimeter]
        [google.identity.accesscontextmanager.v1.ServicePerimeter].
        Referencing a nonexistent [AccessLevel]
        [google.identity.accesscontextmanager.v1.AccessLevel] will cause
        an error. If no [AccessLevel]
        [google.identity.accesscontextmanager.v1.AccessLevel] names are
        listed, resources within the perimeter can only be accessed via Google
        Cloud calls with request origins within the perimeter. Example:
        `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL`. If a single `*` is
        specified for `access_level`, then all [IngressSources]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressSource]
        will be allowed.
        """

        resource: typing.Text = ...
        """A Google Cloud resource that is allowed to ingress the perimeter.
        Requests from these resources will be allowed to access perimeter data.
        Currently only projects are allowed.
        Format: `projects/{project_number}`
        The project may be in any Google Cloud organization, not just the
        organization that the perimeter is defined in. `*` is not allowed, the
        case of allowing all Google Cloud resources only is not supported.
        """

        def __init__(self,
            *,
            access_level : typing.Text = ...,
            resource : typing.Text = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["access_level",b"access_level","resource",b"resource","source",b"source"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["access_level",b"access_level","resource",b"resource","source",b"source"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["access_level","resource"]]: ...

    class EgressTo(google.protobuf.message.Message):
        """Defines the conditions under which an [EgressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
        matches a request. Conditions are based on information about the
        [ApiOperation]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
        intended to be performed on the `resources` specified. Note that if the
        destination of the request is also protected by a [ServicePerimeter]
        [google.identity.accesscontextmanager.v1.ServicePerimeter], then that
        [ServicePerimeter]
        [google.identity.accesscontextmanager.v1.ServicePerimeter] must have
        an [IngressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
        which allows access in order for this request to succeed. The request must
        match `operations` AND `resources` fields in order to be allowed egress out
        of the perimeter.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        RESOURCES_FIELD_NUMBER: builtins.int
        OPERATIONS_FIELD_NUMBER: builtins.int
        @property
        def resources(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """A list of resources, currently only projects in the form
            `projects/<projectnumber>`, that are allowed to be accessed by sources
            defined in the corresponding [EgressFrom]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom].
            A request matches if it contains a resource in this list.  If `*` is
            specified for `resources`, then this [EgressTo]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressTo]
            rule will authorize access to all resources outside the perimeter.
            """
            pass
        @property
        def operations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ServicePerimeterConfig.ApiOperation]:
            """A list of [ApiOperations]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
            allowed to be performed by the sources specified in the corresponding
            [EgressFrom]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom].
            A request matches if it uses an operation/service in this list.
            """
            pass
        def __init__(self,
            *,
            resources : typing.Optional[typing.Iterable[typing.Text]] = ...,
            operations : typing.Optional[typing.Iterable[global___ServicePerimeterConfig.ApiOperation]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["operations",b"operations","resources",b"resources"]) -> None: ...

    class IngressFrom(google.protobuf.message.Message):
        """Defines the conditions under which an [IngressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
        matches a request. Conditions are based on information about the source of
        the request. The request must satisfy what is defined in `sources` AND
        identity related fields in order to match.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SOURCES_FIELD_NUMBER: builtins.int
        IDENTITIES_FIELD_NUMBER: builtins.int
        IDENTITY_TYPE_FIELD_NUMBER: builtins.int
        @property
        def sources(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ServicePerimeterConfig.IngressSource]:
            """Sources that this [IngressPolicy]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
            authorizes access from.
            """
            pass
        @property
        def identities(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """A list of identities that are allowed access through this ingress
            policy. Should be in the format of email address. The email address
            should represent individual user or service account only.
            """
            pass
        identity_type: global___ServicePerimeterConfig.IdentityType.ValueType = ...
        """Specifies the type of identities that are allowed access from outside the
        perimeter. If left unspecified, then members of `identities` field will
        be allowed access.
        """

        def __init__(self,
            *,
            sources : typing.Optional[typing.Iterable[global___ServicePerimeterConfig.IngressSource]] = ...,
            identities : typing.Optional[typing.Iterable[typing.Text]] = ...,
            identity_type : global___ServicePerimeterConfig.IdentityType.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["identities",b"identities","identity_type",b"identity_type","sources",b"sources"]) -> None: ...

    class IngressTo(google.protobuf.message.Message):
        """Defines the conditions under which an [IngressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
        matches a request. Conditions are based on information about the
        [ApiOperation]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
        intended to be performed on the target resource of the request. The request
        must satisfy what is defined in `operations` AND `resources` in order to
        match.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        OPERATIONS_FIELD_NUMBER: builtins.int
        RESOURCES_FIELD_NUMBER: builtins.int
        @property
        def operations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ServicePerimeterConfig.ApiOperation]:
            """A list of [ApiOperations]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
            allowed to be performed by the sources specified in corresponding
            [IngressFrom]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom]
            in this [ServicePerimeter]
            [google.identity.accesscontextmanager.v1.ServicePerimeter].
            """
            pass
        @property
        def resources(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """A list of resources, currently only projects in the form
            `projects/<projectnumber>`, protected by this [ServicePerimeter]
            [google.identity.accesscontextmanager.v1.ServicePerimeter] that are
            allowed to be accessed by sources defined in the corresponding
            [IngressFrom]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom].
            If a single `*` is specified, then access to all resources inside the
            perimeter are allowed.
            """
            pass
        def __init__(self,
            *,
            operations : typing.Optional[typing.Iterable[global___ServicePerimeterConfig.ApiOperation]] = ...,
            resources : typing.Optional[typing.Iterable[typing.Text]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["operations",b"operations","resources",b"resources"]) -> None: ...

    class IngressPolicy(google.protobuf.message.Message):
        """Policy for ingress into [ServicePerimeter]
        [google.identity.accesscontextmanager.v1.ServicePerimeter].

        [IngressPolicies]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
        match requests based on `ingress_from` and `ingress_to` stanzas.  For an
        ingress policy to match, both the `ingress_from` and `ingress_to` stanzas
        must be matched. If an [IngressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
        matches a request, the request is allowed through the perimeter boundary
        from outside the perimeter.

        For example, access from the internet can be allowed either
        based on an [AccessLevel]
        [google.identity.accesscontextmanager.v1.AccessLevel] or, for traffic
        hosted on Google Cloud, the project of the source network. For access from
        private networks, using the project of the hosting network is required.

        Individual ingress policies can be limited by restricting which
        services and/or actions they match using the `ingress_to` field.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        INGRESS_FROM_FIELD_NUMBER: builtins.int
        INGRESS_TO_FIELD_NUMBER: builtins.int
        @property
        def ingress_from(self) -> global___ServicePerimeterConfig.IngressFrom:
            """Defines the conditions on the source of a request causing this
            [IngressPolicy]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
            to apply.
            """
            pass
        @property
        def ingress_to(self) -> global___ServicePerimeterConfig.IngressTo:
            """Defines the conditions on the [ApiOperation]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
            and request destination that cause this [IngressPolicy]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
            to apply.
            """
            pass
        def __init__(self,
            *,
            ingress_from : typing.Optional[global___ServicePerimeterConfig.IngressFrom] = ...,
            ingress_to : typing.Optional[global___ServicePerimeterConfig.IngressTo] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["ingress_from",b"ingress_from","ingress_to",b"ingress_to"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["ingress_from",b"ingress_from","ingress_to",b"ingress_to"]) -> None: ...

    class EgressPolicy(google.protobuf.message.Message):
        """Policy for egress from perimeter.

        [EgressPolicies]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
        match requests based on `egress_from` and `egress_to` stanzas.  For an
        [EgressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
        to match, both `egress_from` and `egress_to` stanzas must be matched. If an
        [EgressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
        matches a request, the request is allowed to span the [ServicePerimeter]
        [google.identity.accesscontextmanager.v1.ServicePerimeter] boundary.
        For example, an [EgressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
        can be used to allow VMs on networks within the [ServicePerimeter]
        [google.identity.accesscontextmanager.v1.ServicePerimeter] to access a
        defined set of projects outside the perimeter in certain contexts (e.g. to
        read data from a Cloud Storage bucket or query against a BigQuery dataset).

        [EgressPolicies]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
        are concerned with the *resources* that a request relates as well as the
        API services and API actions being used.  They do not related to the
        direction of data movement.  More detailed documentation for this concept
        can be found in the descriptions of [EgressFrom]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom]
        and [EgressTo]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressTo].
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        EGRESS_FROM_FIELD_NUMBER: builtins.int
        EGRESS_TO_FIELD_NUMBER: builtins.int
        @property
        def egress_from(self) -> global___ServicePerimeterConfig.EgressFrom:
            """Defines conditions on the source of a request causing this [EgressPolicy]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
            to apply.
            """
            pass
        @property
        def egress_to(self) -> global___ServicePerimeterConfig.EgressTo:
            """Defines the conditions on the [ApiOperation]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
            and destination resources that cause this [EgressPolicy]
            [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
            to apply.
            """
            pass
        def __init__(self,
            *,
            egress_from : typing.Optional[global___ServicePerimeterConfig.EgressFrom] = ...,
            egress_to : typing.Optional[global___ServicePerimeterConfig.EgressTo] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["egress_from",b"egress_from","egress_to",b"egress_to"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["egress_from",b"egress_from","egress_to",b"egress_to"]) -> None: ...

    class EgressFrom(google.protobuf.message.Message):
        """Defines the conditions under which an [EgressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
        matches a request. Conditions based on information about the source of the
        request. Note that if the destination of the request is also protected by a
        [ServicePerimeter]
        [google.identity.accesscontextmanager.v1.ServicePerimeter], then that
        [ServicePerimeter]
        [google.identity.accesscontextmanager.v1.ServicePerimeter] must have
        an [IngressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
        which allows access in order for this request to succeed.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        IDENTITIES_FIELD_NUMBER: builtins.int
        IDENTITY_TYPE_FIELD_NUMBER: builtins.int
        @property
        def identities(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """A list of identities that are allowed access through this [EgressPolicy].
            Should be in the format of email address. The email address should
            represent individual user or service account only.
            """
            pass
        identity_type: global___ServicePerimeterConfig.IdentityType.ValueType = ...
        """Specifies the type of identities that are allowed access to outside the
        perimeter. If left unspecified, then members of `identities` field will
        be allowed access.
        """

        def __init__(self,
            *,
            identities : typing.Optional[typing.Iterable[typing.Text]] = ...,
            identity_type : global___ServicePerimeterConfig.IdentityType.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["identities",b"identities","identity_type",b"identity_type"]) -> None: ...

    RESOURCES_FIELD_NUMBER: builtins.int
    ACCESS_LEVELS_FIELD_NUMBER: builtins.int
    RESTRICTED_SERVICES_FIELD_NUMBER: builtins.int
    VPC_ACCESSIBLE_SERVICES_FIELD_NUMBER: builtins.int
    INGRESS_POLICIES_FIELD_NUMBER: builtins.int
    EGRESS_POLICIES_FIELD_NUMBER: builtins.int
    @property
    def resources(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of Google Cloud resources that are inside of the service perimeter.
        Currently only projects are allowed. Format: `projects/{project_number}`
        """
        pass
    @property
    def access_levels(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of `AccessLevel` resource names that allow resources within the
        `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed
        must be in the same policy as this `ServicePerimeter`. Referencing a
        nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are
        listed, resources within the perimeter can only be accessed via Google
        Cloud calls with request origins within the perimeter. Example:
        `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`.
        For Service Perimeter Bridge, must be empty.
        """
        pass
    @property
    def restricted_services(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Google Cloud services that are subject to the Service Perimeter
        restrictions. For example, if `storage.googleapis.com` is specified, access
        to the storage buckets inside the perimeter must meet the perimeter's
        access restrictions.
        """
        pass
    @property
    def vpc_accessible_services(self) -> global___ServicePerimeterConfig.VpcAccessibleServices:
        """Configuration for APIs allowed within Perimeter."""
        pass
    @property
    def ingress_policies(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ServicePerimeterConfig.IngressPolicy]:
        """List of [IngressPolicies]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
        to apply to the perimeter. A perimeter may have multiple [IngressPolicies]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy],
        each of which is evaluated separately. Access is granted if any [Ingress
        Policy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
        grants it. Must be empty for a perimeter bridge.
        """
        pass
    @property
    def egress_policies(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ServicePerimeterConfig.EgressPolicy]:
        """List of [EgressPolicies]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
        to apply to the perimeter. A perimeter may have multiple [EgressPolicies]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy],
        each of which is evaluated separately. Access is granted if any
        [EgressPolicy]
        [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
        grants it. Must be empty for a perimeter bridge.
        """
        pass
    def __init__(self,
        *,
        resources : typing.Optional[typing.Iterable[typing.Text]] = ...,
        access_levels : typing.Optional[typing.Iterable[typing.Text]] = ...,
        restricted_services : typing.Optional[typing.Iterable[typing.Text]] = ...,
        vpc_accessible_services : typing.Optional[global___ServicePerimeterConfig.VpcAccessibleServices] = ...,
        ingress_policies : typing.Optional[typing.Iterable[global___ServicePerimeterConfig.IngressPolicy]] = ...,
        egress_policies : typing.Optional[typing.Iterable[global___ServicePerimeterConfig.EgressPolicy]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["vpc_accessible_services",b"vpc_accessible_services"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["access_levels",b"access_levels","egress_policies",b"egress_policies","ingress_policies",b"ingress_policies","resources",b"resources","restricted_services",b"restricted_services","vpc_accessible_services",b"vpc_accessible_services"]) -> None: ...
global___ServicePerimeterConfig = ServicePerimeterConfig
