"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _Likelihood:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _LikelihoodEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Likelihood.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    LIKELIHOOD_UNSPECIFIED: Likelihood.ValueType = ...  # 0
    """Default value; same as POSSIBLE."""

    VERY_UNLIKELY: Likelihood.ValueType = ...  # 1
    """Few matching elements."""

    UNLIKELY: Likelihood.ValueType = ...  # 2
    POSSIBLE: Likelihood.ValueType = ...  # 3
    """Some matching elements."""

    LIKELY: Likelihood.ValueType = ...  # 4
    VERY_LIKELY: Likelihood.ValueType = ...  # 5
    """Many matching elements."""

class Likelihood(_Likelihood, metaclass=_LikelihoodEnumTypeWrapper):
    """Categorization of results based on how likely they are to represent a match,
    based on the number of elements they contain which imply a match.
    """
    pass

LIKELIHOOD_UNSPECIFIED: Likelihood.ValueType = ...  # 0
"""Default value; same as POSSIBLE."""

VERY_UNLIKELY: Likelihood.ValueType = ...  # 1
"""Few matching elements."""

UNLIKELY: Likelihood.ValueType = ...  # 2
POSSIBLE: Likelihood.ValueType = ...  # 3
"""Some matching elements."""

LIKELY: Likelihood.ValueType = ...  # 4
VERY_LIKELY: Likelihood.ValueType = ...  # 5
"""Many matching elements."""

global___Likelihood = Likelihood


class _FileType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _FileTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_FileType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    FILE_TYPE_UNSPECIFIED: FileType.ValueType = ...  # 0
    """Includes all files."""

    BINARY_FILE: FileType.ValueType = ...  # 1
    """Includes all file extensions not covered by another entry. Binary
    scanning attempts to convert the content of the file to utf_8 to scan
    the file.
    If you wish to avoid this fall back, specify one or more of the other
    FileType's in your storage scan.
    """

    TEXT_FILE: FileType.ValueType = ...  # 2
    """Included file extensions:
      asc,asp, aspx, brf, c, cc,cfm, cgi, cpp, csv, cxx, c++, cs, css, dart,
      dat, dot, eml,, epbub, ged, go, h, hh, hpp, hxx, h++, hs, html, htm,
      mkd, markdown, m, ml, mli, perl, pl, plist, pm, php, phtml, pht,
      properties, py, pyw, rb, rbw, rs, rss,  rc, scala, sh, sql, swift, tex,
      shtml, shtm, xhtml, lhs, ics, ini, java, js, json, kix, kml, ocaml, md,
      txt, text, tsv, vb, vcard, vcs, wml, xcodeproj, xml, xsl, xsd, yml, yaml.
    """

    IMAGE: FileType.ValueType = ...  # 3
    """Included file extensions:
      bmp, gif, jpg, jpeg, jpe, png.
    bytes_limit_per_file has no effect on image files.
    Image inspection is restricted to 'global', 'us', 'asia', and 'europe'.
    """

    WORD: FileType.ValueType = ...  # 5
    """Word files >30 MB will be scanned as binary files.
    Included file extensions:
      docx, dotx, docm, dotm
    """

    PDF: FileType.ValueType = ...  # 6
    """PDF files >30 MB will be scanned as binary files.
    Included file extensions:
      pdf
    """

    AVRO: FileType.ValueType = ...  # 7
    """Included file extensions:
      avro
    """

    CSV: FileType.ValueType = ...  # 8
    """Included file extensions:
      csv
    """

    TSV: FileType.ValueType = ...  # 9
    """Included file extensions:
      tsv
    """

class FileType(_FileType, metaclass=_FileTypeEnumTypeWrapper):
    """Definitions of file type groups to scan. New types will be added to this
    list.
    """
    pass

FILE_TYPE_UNSPECIFIED: FileType.ValueType = ...  # 0
"""Includes all files."""

BINARY_FILE: FileType.ValueType = ...  # 1
"""Includes all file extensions not covered by another entry. Binary
scanning attempts to convert the content of the file to utf_8 to scan
the file.
If you wish to avoid this fall back, specify one or more of the other
FileType's in your storage scan.
"""

TEXT_FILE: FileType.ValueType = ...  # 2
"""Included file extensions:
  asc,asp, aspx, brf, c, cc,cfm, cgi, cpp, csv, cxx, c++, cs, css, dart,
  dat, dot, eml,, epbub, ged, go, h, hh, hpp, hxx, h++, hs, html, htm,
  mkd, markdown, m, ml, mli, perl, pl, plist, pm, php, phtml, pht,
  properties, py, pyw, rb, rbw, rs, rss,  rc, scala, sh, sql, swift, tex,
  shtml, shtm, xhtml, lhs, ics, ini, java, js, json, kix, kml, ocaml, md,
  txt, text, tsv, vb, vcard, vcs, wml, xcodeproj, xml, xsl, xsd, yml, yaml.
"""

IMAGE: FileType.ValueType = ...  # 3
"""Included file extensions:
  bmp, gif, jpg, jpeg, jpe, png.
bytes_limit_per_file has no effect on image files.
Image inspection is restricted to 'global', 'us', 'asia', and 'europe'.
"""

WORD: FileType.ValueType = ...  # 5
"""Word files >30 MB will be scanned as binary files.
Included file extensions:
  docx, dotx, docm, dotm
"""

PDF: FileType.ValueType = ...  # 6
"""PDF files >30 MB will be scanned as binary files.
Included file extensions:
  pdf
"""

AVRO: FileType.ValueType = ...  # 7
"""Included file extensions:
  avro
"""

CSV: FileType.ValueType = ...  # 8
"""Included file extensions:
  csv
"""

TSV: FileType.ValueType = ...  # 9
"""Included file extensions:
  tsv
"""

global___FileType = FileType


class InfoType(google.protobuf.message.Message):
    """Type of information detected by the API."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Name of the information type. Either a name of your choosing when
    creating a CustomInfoType, or one of the names listed
    at https://cloud.google.com/dlp/docs/infotypes-reference when specifying
    a built-in type.  When sending Cloud DLP results to Data Catalog, infoType
    names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
    """

    version: typing.Text = ...
    """Optional version name for this InfoType."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        version : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name","version",b"version"]) -> None: ...
global___InfoType = InfoType

class StoredType(google.protobuf.message.Message):
    """A reference to a StoredInfoType to use with scanning."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Resource name of the requested `StoredInfoType`, for example
    `organizations/433245324/storedInfoTypes/432452342` or
    `projects/project-id/storedInfoTypes/432452342`.
    """

    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Timestamp indicating when the version of the `StoredInfoType` used for
        inspection was created. Output-only field, populated by the system.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time",b"create_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time",b"create_time","name",b"name"]) -> None: ...
global___StoredType = StoredType

class CustomInfoType(google.protobuf.message.Message):
    """Custom information type provided by the user. Used to find domain-specific
    sensitive information configurable to the data in question.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _ExclusionType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ExclusionTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ExclusionType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        EXCLUSION_TYPE_UNSPECIFIED: CustomInfoType.ExclusionType.ValueType = ...  # 0
        """A finding of this custom info type will not be excluded from results."""

        EXCLUSION_TYPE_EXCLUDE: CustomInfoType.ExclusionType.ValueType = ...  # 1
        """A finding of this custom info type will be excluded from final results,
        but can still affect rule execution.
        """

    class ExclusionType(_ExclusionType, metaclass=_ExclusionTypeEnumTypeWrapper):
        pass

    EXCLUSION_TYPE_UNSPECIFIED: CustomInfoType.ExclusionType.ValueType = ...  # 0
    """A finding of this custom info type will not be excluded from results."""

    EXCLUSION_TYPE_EXCLUDE: CustomInfoType.ExclusionType.ValueType = ...  # 1
    """A finding of this custom info type will be excluded from final results,
    but can still affect rule execution.
    """


    class Dictionary(google.protobuf.message.Message):
        """Custom information type based on a dictionary of words or phrases. This can
        be used to match sensitive information specific to the data, such as a list
        of employee IDs or job titles.

        Dictionary words are case-insensitive and all characters other than letters
        and digits in the unicode [Basic Multilingual
        Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane)
        will be replaced with whitespace when scanning for matches, so the
        dictionary phrase "Sam Johnson" will match all three phrases "sam johnson",
        Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane)
        surrounding any match must be of a different type than the adjacent
        characters within the word, so letters must be next to non-letters and
        digits next to non-digits. For example, the dictionary word "jen" will
        match the first three letters of the text "jen123" but will return no
        matches for "jennifer".

        Dictionary words containing a large number of characters that are not
        letters or digits may result in unexpected findings because such characters
        are treated as whitespace. The
        [limits](https://cloud.google.com/dlp/limits) page contains details about
        the size limits of dictionaries. For dictionaries that do not fit within
        these constraints, consider using `LargeCustomDictionaryConfig` in the
        [limits](https://cloud.google.com/dlp/limits) page contains details about
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class WordList(google.protobuf.message.Message):
            """Message defining a list of words or phrases to search for in the data."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            WORDS_FIELD_NUMBER: builtins.int
            @property
            def words(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """Words or phrases defining the dictionary. The dictionary must contain
                at least one phrase and every phrase must contain at least 2 characters
                that are letters or digits. [required]
                """
                pass
            def __init__(self,
                *,
                words : typing.Optional[typing.Iterable[typing.Text]] = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["words",b"words"]) -> None: ...

        WORD_LIST_FIELD_NUMBER: builtins.int
        CLOUD_STORAGE_PATH_FIELD_NUMBER: builtins.int
        @property
        def word_list(self) -> global___CustomInfoType.Dictionary.WordList:
            """List of words or phrases to search for."""
            pass
        @property
        def cloud_storage_path(self) -> global___CloudStoragePath:
            """Newline-delimited file of words in Cloud Storage. Only a single file
            is accepted.
            """
            pass
        def __init__(self,
            *,
            word_list : typing.Optional[global___CustomInfoType.Dictionary.WordList] = ...,
            cloud_storage_path : typing.Optional[global___CloudStoragePath] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["cloud_storage_path",b"cloud_storage_path","source",b"source","word_list",b"word_list"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["cloud_storage_path",b"cloud_storage_path","source",b"source","word_list",b"word_list"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["word_list","cloud_storage_path"]]: ...

    class Regex(google.protobuf.message.Message):
        """Message defining a custom regular expression."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        PATTERN_FIELD_NUMBER: builtins.int
        GROUP_INDEXES_FIELD_NUMBER: builtins.int
        pattern: typing.Text = ...
        """Pattern defining the regular expression. Its syntax
        (https://github.com/google/re2/wiki/Syntax) can be found under the
        google/re2 repository on GitHub.
        """

        @property
        def group_indexes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
            """(https://github.com/google/re2/wiki/Syntax) can be found under the
            The index of the submatch to extract as findings. When not
            specified, the entire match is returned. No more than 3 may be included.
            """
            pass
        def __init__(self,
            *,
            pattern : typing.Text = ...,
            group_indexes : typing.Optional[typing.Iterable[builtins.int]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["group_indexes",b"group_indexes","pattern",b"pattern"]) -> None: ...

    class SurrogateType(google.protobuf.message.Message):
        """Message for detecting output from deidentification transformations
        such as
        [`CryptoReplaceFfxFpeConfig`](https://cloud.google.com/dlp/docs/reference/rest/v2/organizations.deidentifyTemplates#cryptoreplaceffxfpeconfig).
        These types of transformations are
        those that perform pseudonymization, thereby producing a "surrogate" as
        [`CryptoReplaceFfxFpeConfig`](https://cloud.google.com/dlp/docs/reference/rest/v2/organizations.deidentifyTemplates#cryptoreplaceffxfpeconfig).
        transformation such as `surrogate_info_type`. This CustomInfoType does
        not support the use of `detection_rules`.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    class DetectionRule(google.protobuf.message.Message):
        """Deprecated; use `InspectionRuleSet` instead. Rule for modifying a
        `CustomInfoType` to alter behavior under certain circumstances, depending
        on the specific details of the rule. Not supported for the `surrogate_type`
        custom infoType.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Proximity(google.protobuf.message.Message):
            """Message for specifying a window around a finding to apply a detection
            rule.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            WINDOW_BEFORE_FIELD_NUMBER: builtins.int
            WINDOW_AFTER_FIELD_NUMBER: builtins.int
            window_before: builtins.int = ...
            """Number of characters before the finding to consider."""

            window_after: builtins.int = ...
            """Number of characters after the finding to consider."""

            def __init__(self,
                *,
                window_before : builtins.int = ...,
                window_after : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["window_after",b"window_after","window_before",b"window_before"]) -> None: ...

        class LikelihoodAdjustment(google.protobuf.message.Message):
            """Message for specifying an adjustment to the likelihood of a finding as
            part of a detection rule.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            FIXED_LIKELIHOOD_FIELD_NUMBER: builtins.int
            RELATIVE_LIKELIHOOD_FIELD_NUMBER: builtins.int
            fixed_likelihood: global___Likelihood.ValueType = ...
            """Set the likelihood of a finding to a fixed value."""

            relative_likelihood: builtins.int = ...
            """Increase or decrease the likelihood by the specified number of
            levels. For example, if a finding would be `POSSIBLE` without the
            detection rule and `relative_likelihood` is 1, then it is upgraded to
            `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`.
            Likelihood may never drop below `VERY_UNLIKELY` or exceed
            `VERY_LIKELY`, so applying an adjustment of 1 followed by an
            adjustment of -1 when base likelihood is `VERY_LIKELY` will result in
            a final likelihood of `LIKELY`.
            """

            def __init__(self,
                *,
                fixed_likelihood : global___Likelihood.ValueType = ...,
                relative_likelihood : builtins.int = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["adjustment",b"adjustment","fixed_likelihood",b"fixed_likelihood","relative_likelihood",b"relative_likelihood"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["adjustment",b"adjustment","fixed_likelihood",b"fixed_likelihood","relative_likelihood",b"relative_likelihood"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["adjustment",b"adjustment"]) -> typing.Optional[typing_extensions.Literal["fixed_likelihood","relative_likelihood"]]: ...

        class HotwordRule(google.protobuf.message.Message):
            """The rule that adjusts the likelihood of findings within a certain
            proximity of hotwords.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            HOTWORD_REGEX_FIELD_NUMBER: builtins.int
            PROXIMITY_FIELD_NUMBER: builtins.int
            LIKELIHOOD_ADJUSTMENT_FIELD_NUMBER: builtins.int
            @property
            def hotword_regex(self) -> global___CustomInfoType.Regex:
                """Regular expression pattern defining what qualifies as a hotword."""
                pass
            @property
            def proximity(self) -> global___CustomInfoType.DetectionRule.Proximity:
                """Proximity of the finding within which the entire hotword must reside.
                The total length of the window cannot exceed 1000 characters. Note that
                the finding itself will be included in the window, so that hotwords may
                be used to match substrings of the finding itself. For example, the
                certainty of a phone number regex "\\(\\d{3}\\) \\d{3}-\\d{4}" could be
                adjusted upwards if the area code is known to be the local area code of
                a company office using the hotword regex "\\(xxx\\)", where "xxx"
                is the area code in question.
                """
                pass
            @property
            def likelihood_adjustment(self) -> global___CustomInfoType.DetectionRule.LikelihoodAdjustment:
                """Likelihood adjustment to apply to all matching findings."""
                pass
            def __init__(self,
                *,
                hotword_regex : typing.Optional[global___CustomInfoType.Regex] = ...,
                proximity : typing.Optional[global___CustomInfoType.DetectionRule.Proximity] = ...,
                likelihood_adjustment : typing.Optional[global___CustomInfoType.DetectionRule.LikelihoodAdjustment] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["hotword_regex",b"hotword_regex","likelihood_adjustment",b"likelihood_adjustment","proximity",b"proximity"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["hotword_regex",b"hotword_regex","likelihood_adjustment",b"likelihood_adjustment","proximity",b"proximity"]) -> None: ...

        HOTWORD_RULE_FIELD_NUMBER: builtins.int
        @property
        def hotword_rule(self) -> global___CustomInfoType.DetectionRule.HotwordRule:
            """Hotword-based detection rule."""
            pass
        def __init__(self,
            *,
            hotword_rule : typing.Optional[global___CustomInfoType.DetectionRule.HotwordRule] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["hotword_rule",b"hotword_rule","type",b"type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["hotword_rule",b"hotword_rule","type",b"type"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["hotword_rule"]]: ...

    INFO_TYPE_FIELD_NUMBER: builtins.int
    LIKELIHOOD_FIELD_NUMBER: builtins.int
    DICTIONARY_FIELD_NUMBER: builtins.int
    REGEX_FIELD_NUMBER: builtins.int
    SURROGATE_TYPE_FIELD_NUMBER: builtins.int
    STORED_TYPE_FIELD_NUMBER: builtins.int
    DETECTION_RULES_FIELD_NUMBER: builtins.int
    EXCLUSION_TYPE_FIELD_NUMBER: builtins.int
    @property
    def info_type(self) -> global___InfoType:
        """CustomInfoType can either be a new infoType, or an extension of built-in
        infoType, when the name matches one of existing infoTypes and that infoType
        is specified in `InspectContent.info_types` field. Specifying the latter
        adds findings to the one detected by the system. If built-in info type is
        not specified in `InspectContent.info_types` list then the name is treated
        as a custom info type.
        """
        pass
    likelihood: global___Likelihood.ValueType = ...
    """Likelihood to return for this CustomInfoType. This base value can be
    altered by a detection rule if the finding meets the criteria specified by
    the rule. Defaults to `VERY_LIKELY` if not specified.
    """

    @property
    def dictionary(self) -> global___CustomInfoType.Dictionary:
        """A list of phrases to detect as a CustomInfoType."""
        pass
    @property
    def regex(self) -> global___CustomInfoType.Regex:
        """Regular expression based CustomInfoType."""
        pass
    @property
    def surrogate_type(self) -> global___CustomInfoType.SurrogateType:
        """Message for detecting output from deidentification transformations that
        support reversing.
        """
        pass
    @property
    def stored_type(self) -> global___StoredType:
        """Load an existing `StoredInfoType` resource for use in
        `InspectDataSource`. Not currently supported in `InspectContent`.
        """
        pass
    @property
    def detection_rules(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CustomInfoType.DetectionRule]:
        """Set of detection rules to apply to all findings of this CustomInfoType.
        Rules are applied in order that they are specified. Not supported for the
        `surrogate_type` CustomInfoType.
        """
        pass
    exclusion_type: global___CustomInfoType.ExclusionType.ValueType = ...
    """If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding
    to be returned. It still can be used for rules matching.
    """

    def __init__(self,
        *,
        info_type : typing.Optional[global___InfoType] = ...,
        likelihood : global___Likelihood.ValueType = ...,
        dictionary : typing.Optional[global___CustomInfoType.Dictionary] = ...,
        regex : typing.Optional[global___CustomInfoType.Regex] = ...,
        surrogate_type : typing.Optional[global___CustomInfoType.SurrogateType] = ...,
        stored_type : typing.Optional[global___StoredType] = ...,
        detection_rules : typing.Optional[typing.Iterable[global___CustomInfoType.DetectionRule]] = ...,
        exclusion_type : global___CustomInfoType.ExclusionType.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dictionary",b"dictionary","info_type",b"info_type","regex",b"regex","stored_type",b"stored_type","surrogate_type",b"surrogate_type","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["detection_rules",b"detection_rules","dictionary",b"dictionary","exclusion_type",b"exclusion_type","info_type",b"info_type","likelihood",b"likelihood","regex",b"regex","stored_type",b"stored_type","surrogate_type",b"surrogate_type","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["dictionary","regex","surrogate_type","stored_type"]]: ...
global___CustomInfoType = CustomInfoType

class FieldId(google.protobuf.message.Message):
    """General identifier of a data field in a storage service."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Name describing the field."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___FieldId = FieldId

class PartitionId(google.protobuf.message.Message):
    """Datastore partition ID.
    A partition ID identifies a grouping of entities. The grouping is always
    by project and namespace, however the namespace ID may be empty.

    A partition ID contains several dimensions:
    project ID and namespace ID.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_ID_FIELD_NUMBER: builtins.int
    NAMESPACE_ID_FIELD_NUMBER: builtins.int
    project_id: typing.Text = ...
    """The ID of the project to which the entities belong."""

    namespace_id: typing.Text = ...
    """If not empty, the ID of the namespace to which the entities belong."""

    def __init__(self,
        *,
        project_id : typing.Text = ...,
        namespace_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["namespace_id",b"namespace_id","project_id",b"project_id"]) -> None: ...
global___PartitionId = PartitionId

class KindExpression(google.protobuf.message.Message):
    """A representation of a Datastore kind."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The name of the kind."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___KindExpression = KindExpression

class DatastoreOptions(google.protobuf.message.Message):
    """Options defining a data set within Google Cloud Datastore."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARTITION_ID_FIELD_NUMBER: builtins.int
    KIND_FIELD_NUMBER: builtins.int
    @property
    def partition_id(self) -> global___PartitionId:
        """A partition ID identifies a grouping of entities. The grouping is always
        by project and namespace, however the namespace ID may be empty.
        """
        pass
    @property
    def kind(self) -> global___KindExpression:
        """The kind to process."""
        pass
    def __init__(self,
        *,
        partition_id : typing.Optional[global___PartitionId] = ...,
        kind : typing.Optional[global___KindExpression] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["kind",b"kind","partition_id",b"partition_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["kind",b"kind","partition_id",b"partition_id"]) -> None: ...
global___DatastoreOptions = DatastoreOptions

class CloudStorageRegexFileSet(google.protobuf.message.Message):
    """Message representing a set of files in a Cloud Storage bucket. Regular
    expressions are used to allow fine-grained control over which files in the
    bucket to include.

    Included files are those that match at least one item in `include_regex` and
    do not match any items in `exclude_regex`. Note that a file that matches
    items from both lists will _not_ be included. For a match to occur, the
    entire file path (i.e., everything in the url after the bucket name) must
    match the regular expression.

    For example, given the input `{bucket_name: "mybucket", include_regex:
    ["directory1/.*"], exclude_regex:
    ["directory1/excluded.*"]}`:

    * `gs://mybucket/directory1/myfile` will be included
    * `gs://mybucket/directory1/directory2/myfile` will be included (`.*` matches
    across `/`)
    * `gs://mybucket/directory0/directory1/myfile` will _not_ be included (the
    full path doesn't match any items in `include_regex`)
    * `gs://mybucket/directory1/excludedfile` will _not_ be included (the path
    matches an item in `exclude_regex`)

    If `include_regex` is left empty, it will match all files by default
    (this is equivalent to setting `include_regex: [".*"]`).

    Some other common use cases:

    * `{bucket_name: "mybucket", exclude_regex: [".*\\.pdf"]}` will include all
    files in `mybucket` except for .pdf files
    * `{bucket_name: "mybucket", include_regex: ["directory/[^/]+"]}` will
    include all files directly under `gs://mybucket/directory/`, without matching
    across `/`
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    BUCKET_NAME_FIELD_NUMBER: builtins.int
    INCLUDE_REGEX_FIELD_NUMBER: builtins.int
    EXCLUDE_REGEX_FIELD_NUMBER: builtins.int
    bucket_name: typing.Text = ...
    """The name of a Cloud Storage bucket. Required."""

    @property
    def include_regex(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of regular expressions matching file paths to include. All files in
        the bucket that match at least one of these regular expressions will be
        included in the set of files, except for those that also match an item in
        `exclude_regex`. Leaving this field empty will match all files by default
        (this is equivalent to including `.*` in the list).

        Regular expressions use RE2
        [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
        under the google/re2 repository on GitHub.
        """
        pass
    @property
    def exclude_regex(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """[syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
        A list of regular expressions matching file paths to exclude. All files in
        the bucket that match at least one of these regular expressions will be
        excluded from the scan.

        Regular expressions use RE2
        [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
        under the google/re2 repository on GitHub.
        [syntax](https://github.com/google/re2/wiki/Syntax); a guide can be found
        """
        pass
    def __init__(self,
        *,
        bucket_name : typing.Text = ...,
        include_regex : typing.Optional[typing.Iterable[typing.Text]] = ...,
        exclude_regex : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["bucket_name",b"bucket_name","exclude_regex",b"exclude_regex","include_regex",b"include_regex"]) -> None: ...
global___CloudStorageRegexFileSet = CloudStorageRegexFileSet

class CloudStorageOptions(google.protobuf.message.Message):
    """Options defining a file or a set of files within a Google Cloud Storage
    bucket.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _SampleMethod:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _SampleMethodEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SampleMethod.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        SAMPLE_METHOD_UNSPECIFIED: CloudStorageOptions.SampleMethod.ValueType = ...  # 0
        TOP: CloudStorageOptions.SampleMethod.ValueType = ...  # 1
        """Scan from the top (default)."""

        RANDOM_START: CloudStorageOptions.SampleMethod.ValueType = ...  # 2
        """For each file larger than bytes_limit_per_file, randomly pick the offset
        to start scanning. The scanned bytes are contiguous.
        """

    class SampleMethod(_SampleMethod, metaclass=_SampleMethodEnumTypeWrapper):
        """How to sample bytes if not all bytes are scanned. Meaningful only when used
        in conjunction with bytes_limit_per_file. If not specified, scanning would
        start from the top.
        """
        pass

    SAMPLE_METHOD_UNSPECIFIED: CloudStorageOptions.SampleMethod.ValueType = ...  # 0
    TOP: CloudStorageOptions.SampleMethod.ValueType = ...  # 1
    """Scan from the top (default)."""

    RANDOM_START: CloudStorageOptions.SampleMethod.ValueType = ...  # 2
    """For each file larger than bytes_limit_per_file, randomly pick the offset
    to start scanning. The scanned bytes are contiguous.
    """


    class FileSet(google.protobuf.message.Message):
        """Set of files to scan."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        URL_FIELD_NUMBER: builtins.int
        REGEX_FILE_SET_FIELD_NUMBER: builtins.int
        url: typing.Text = ...
        """The Cloud Storage url of the file(s) to scan, in the format
        `gs://<bucket>/<path>`. Trailing wildcard in the path is allowed.

        If the url ends in a trailing slash, the bucket or directory represented
        by the url will be scanned non-recursively (content in sub-directories
        will not be scanned). This means that `gs://mybucket/` is equivalent to
        `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to
        `gs://mybucket/directory/*`.

        Exactly one of `url` or `regex_file_set` must be set.
        """

        @property
        def regex_file_set(self) -> global___CloudStorageRegexFileSet:
            """The regex-filtered set of files to scan. Exactly one of `url` or
            `regex_file_set` must be set.
            """
            pass
        def __init__(self,
            *,
            url : typing.Text = ...,
            regex_file_set : typing.Optional[global___CloudStorageRegexFileSet] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["regex_file_set",b"regex_file_set"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["regex_file_set",b"regex_file_set","url",b"url"]) -> None: ...

    FILE_SET_FIELD_NUMBER: builtins.int
    BYTES_LIMIT_PER_FILE_FIELD_NUMBER: builtins.int
    BYTES_LIMIT_PER_FILE_PERCENT_FIELD_NUMBER: builtins.int
    FILE_TYPES_FIELD_NUMBER: builtins.int
    SAMPLE_METHOD_FIELD_NUMBER: builtins.int
    FILES_LIMIT_PERCENT_FIELD_NUMBER: builtins.int
    @property
    def file_set(self) -> global___CloudStorageOptions.FileSet:
        """The set of one or more files to scan."""
        pass
    bytes_limit_per_file: builtins.int = ...
    """Max number of bytes to scan from a file. If a scanned file's size is bigger
    than this value then the rest of the bytes are omitted. Only one
    of bytes_limit_per_file and bytes_limit_per_file_percent can be specified.
    Cannot be set if de-identification is requested.
    """

    bytes_limit_per_file_percent: builtins.int = ...
    """Max percentage of bytes to scan from a file. The rest are omitted. The
    number of bytes scanned is rounded down. Must be between 0 and 100,
    inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one
    of bytes_limit_per_file and bytes_limit_per_file_percent can be specified.
    Cannot be set if de-identification is requested.
    """

    @property
    def file_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___FileType.ValueType]:
        """List of file type groups to include in the scan.
        If empty, all files are scanned and available data format processors
        are applied. In addition, the binary content of the selected files
        is always scanned as well.
        Images are scanned only as binary if the specified region
        does not support image inspection and no file_types were specified.
        Image inspection is restricted to 'global', 'us', 'asia', and 'europe'.
        """
        pass
    sample_method: global___CloudStorageOptions.SampleMethod.ValueType = ...
    files_limit_percent: builtins.int = ...
    """Limits the number of files to scan to this percentage of the input FileSet.
    Number of files scanned is rounded down. Must be between 0 and 100,
    inclusively. Both 0 and 100 means no limit. Defaults to 0.
    """

    def __init__(self,
        *,
        file_set : typing.Optional[global___CloudStorageOptions.FileSet] = ...,
        bytes_limit_per_file : builtins.int = ...,
        bytes_limit_per_file_percent : builtins.int = ...,
        file_types : typing.Optional[typing.Iterable[global___FileType.ValueType]] = ...,
        sample_method : global___CloudStorageOptions.SampleMethod.ValueType = ...,
        files_limit_percent : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["file_set",b"file_set"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bytes_limit_per_file",b"bytes_limit_per_file","bytes_limit_per_file_percent",b"bytes_limit_per_file_percent","file_set",b"file_set","file_types",b"file_types","files_limit_percent",b"files_limit_percent","sample_method",b"sample_method"]) -> None: ...
global___CloudStorageOptions = CloudStorageOptions

class CloudStorageFileSet(google.protobuf.message.Message):
    """Message representing a set of files in Cloud Storage."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    URL_FIELD_NUMBER: builtins.int
    url: typing.Text = ...
    """The url, in the format `gs://<bucket>/<path>`. Trailing wildcard in the
    path is allowed.
    """

    def __init__(self,
        *,
        url : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["url",b"url"]) -> None: ...
global___CloudStorageFileSet = CloudStorageFileSet

class CloudStoragePath(google.protobuf.message.Message):
    """Message representing a single file or path in Cloud Storage."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PATH_FIELD_NUMBER: builtins.int
    path: typing.Text = ...
    """A url representing a file or path (no wildcards) in Cloud Storage.
    Example: gs://[BUCKET_NAME]/dictionary.txt
    """

    def __init__(self,
        *,
        path : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["path",b"path"]) -> None: ...
global___CloudStoragePath = CloudStoragePath

class BigQueryOptions(google.protobuf.message.Message):
    """Options defining BigQuery table and row identifiers."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _SampleMethod:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _SampleMethodEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SampleMethod.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        SAMPLE_METHOD_UNSPECIFIED: BigQueryOptions.SampleMethod.ValueType = ...  # 0
        TOP: BigQueryOptions.SampleMethod.ValueType = ...  # 1
        """Scan groups of rows in the order BigQuery provides (default). Multiple
        groups of rows may be scanned in parallel, so results may not appear in
        the same order the rows are read.
        """

        RANDOM_START: BigQueryOptions.SampleMethod.ValueType = ...  # 2
        """Randomly pick groups of rows to scan."""

    class SampleMethod(_SampleMethod, metaclass=_SampleMethodEnumTypeWrapper):
        """How to sample rows if not all rows are scanned. Meaningful only when used
        in conjunction with either rows_limit or rows_limit_percent. If not
        specified, rows are scanned in the order BigQuery reads them.
        """
        pass

    SAMPLE_METHOD_UNSPECIFIED: BigQueryOptions.SampleMethod.ValueType = ...  # 0
    TOP: BigQueryOptions.SampleMethod.ValueType = ...  # 1
    """Scan groups of rows in the order BigQuery provides (default). Multiple
    groups of rows may be scanned in parallel, so results may not appear in
    the same order the rows are read.
    """

    RANDOM_START: BigQueryOptions.SampleMethod.ValueType = ...  # 2
    """Randomly pick groups of rows to scan."""


    TABLE_REFERENCE_FIELD_NUMBER: builtins.int
    IDENTIFYING_FIELDS_FIELD_NUMBER: builtins.int
    ROWS_LIMIT_FIELD_NUMBER: builtins.int
    ROWS_LIMIT_PERCENT_FIELD_NUMBER: builtins.int
    SAMPLE_METHOD_FIELD_NUMBER: builtins.int
    EXCLUDED_FIELDS_FIELD_NUMBER: builtins.int
    INCLUDED_FIELDS_FIELD_NUMBER: builtins.int
    @property
    def table_reference(self) -> global___BigQueryTable:
        """Complete BigQuery table reference."""
        pass
    @property
    def identifying_fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FieldId]:
        """Table fields that may uniquely identify a row within the table. When
        `actions.saveFindings.outputConfig.table` is specified, the values of
        columns specified here are available in the output table under
        `location.content_locations.record_location.record_key.id_values`. Nested
        fields such as `person.birthdate.year` are allowed.
        """
        pass
    rows_limit: builtins.int = ...
    """Max number of rows to scan. If the table has more rows than this value, the
    rest of the rows are omitted. If not set, or if set to 0, all rows will be
    scanned. Only one of rows_limit and rows_limit_percent can be specified.
    Cannot be used in conjunction with TimespanConfig.
    """

    rows_limit_percent: builtins.int = ...
    """Max percentage of rows to scan. The rest are omitted. The number of rows
    scanned is rounded down. Must be between 0 and 100, inclusively. Both 0 and
    100 means no limit. Defaults to 0. Only one of rows_limit and
    rows_limit_percent can be specified. Cannot be used in conjunction with
    TimespanConfig.
    """

    sample_method: global___BigQueryOptions.SampleMethod.ValueType = ...
    @property
    def excluded_fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FieldId]:
        """References to fields excluded from scanning. This allows you to skip
        inspection of entire columns which you know have no findings.
        """
        pass
    @property
    def included_fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FieldId]:
        """Limit scanning only to these fields."""
        pass
    def __init__(self,
        *,
        table_reference : typing.Optional[global___BigQueryTable] = ...,
        identifying_fields : typing.Optional[typing.Iterable[global___FieldId]] = ...,
        rows_limit : builtins.int = ...,
        rows_limit_percent : builtins.int = ...,
        sample_method : global___BigQueryOptions.SampleMethod.ValueType = ...,
        excluded_fields : typing.Optional[typing.Iterable[global___FieldId]] = ...,
        included_fields : typing.Optional[typing.Iterable[global___FieldId]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["table_reference",b"table_reference"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["excluded_fields",b"excluded_fields","identifying_fields",b"identifying_fields","included_fields",b"included_fields","rows_limit",b"rows_limit","rows_limit_percent",b"rows_limit_percent","sample_method",b"sample_method","table_reference",b"table_reference"]) -> None: ...
global___BigQueryOptions = BigQueryOptions

class StorageConfig(google.protobuf.message.Message):
    """Shared message indicating Cloud storage type."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class TimespanConfig(google.protobuf.message.Message):
        """Configuration of the timespan of the items to include in scanning.
        Currently only supported when inspecting Google Cloud Storage and BigQuery.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        START_TIME_FIELD_NUMBER: builtins.int
        END_TIME_FIELD_NUMBER: builtins.int
        TIMESTAMP_FIELD_FIELD_NUMBER: builtins.int
        ENABLE_AUTO_POPULATION_OF_TIMESPAN_CONFIG_FIELD_NUMBER: builtins.int
        @property
        def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """Exclude files, tables, or rows older than this value.
            If not set, no lower time limit is applied.
            """
            pass
        @property
        def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """Exclude files, tables, or rows newer than this value.
            If not set, no upper time limit is applied.
            """
            pass
        @property
        def timestamp_field(self) -> global___FieldId:
            """Specification of the field containing the timestamp of scanned items.
            Used for data sources like Datastore and BigQuery.

            For BigQuery:
            If this value is not specified and the table was modified between the
            given start and end times, the entire table will be scanned. If this
            value is specified, then rows are filtered based on the given start and
            end times. Rows with a `NULL` value in the provided BigQuery column are
            skipped.
            Valid data types of the provided BigQuery column are: `INTEGER`, `DATE`,
            `TIMESTAMP`, and `DATETIME`.

            For Datastore:
            If this value is specified, then entities are filtered based on the given
            start and end times. If an entity does not contain the provided timestamp
            property or contains empty or invalid values, then it is included.
            Valid data types of the provided timestamp property are: `TIMESTAMP`.
            """
            pass
        enable_auto_population_of_timespan_config: builtins.bool = ...
        """When the job is started by a JobTrigger we will automatically figure out
        a valid start_time to avoid scanning files that have not been modified
        since the last time the JobTrigger executed. This will be based on the
        time of the execution of the last run of the JobTrigger.
        """

        def __init__(self,
            *,
            start_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            end_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            timestamp_field : typing.Optional[global___FieldId] = ...,
            enable_auto_population_of_timespan_config : builtins.bool = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["end_time",b"end_time","start_time",b"start_time","timestamp_field",b"timestamp_field"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["enable_auto_population_of_timespan_config",b"enable_auto_population_of_timespan_config","end_time",b"end_time","start_time",b"start_time","timestamp_field",b"timestamp_field"]) -> None: ...

    DATASTORE_OPTIONS_FIELD_NUMBER: builtins.int
    CLOUD_STORAGE_OPTIONS_FIELD_NUMBER: builtins.int
    BIG_QUERY_OPTIONS_FIELD_NUMBER: builtins.int
    HYBRID_OPTIONS_FIELD_NUMBER: builtins.int
    TIMESPAN_CONFIG_FIELD_NUMBER: builtins.int
    @property
    def datastore_options(self) -> global___DatastoreOptions:
        """Google Cloud Datastore options."""
        pass
    @property
    def cloud_storage_options(self) -> global___CloudStorageOptions:
        """Google Cloud Storage options."""
        pass
    @property
    def big_query_options(self) -> global___BigQueryOptions:
        """BigQuery options."""
        pass
    @property
    def hybrid_options(self) -> global___HybridOptions:
        """Hybrid inspection options."""
        pass
    @property
    def timespan_config(self) -> global___StorageConfig.TimespanConfig: ...
    def __init__(self,
        *,
        datastore_options : typing.Optional[global___DatastoreOptions] = ...,
        cloud_storage_options : typing.Optional[global___CloudStorageOptions] = ...,
        big_query_options : typing.Optional[global___BigQueryOptions] = ...,
        hybrid_options : typing.Optional[global___HybridOptions] = ...,
        timespan_config : typing.Optional[global___StorageConfig.TimespanConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["big_query_options",b"big_query_options","cloud_storage_options",b"cloud_storage_options","datastore_options",b"datastore_options","hybrid_options",b"hybrid_options","timespan_config",b"timespan_config","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["big_query_options",b"big_query_options","cloud_storage_options",b"cloud_storage_options","datastore_options",b"datastore_options","hybrid_options",b"hybrid_options","timespan_config",b"timespan_config","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["datastore_options","cloud_storage_options","big_query_options","hybrid_options"]]: ...
global___StorageConfig = StorageConfig

class HybridOptions(google.protobuf.message.Message):
    """Configuration to control jobs where the content being inspected is outside
    of Google Cloud Platform.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    DESCRIPTION_FIELD_NUMBER: builtins.int
    REQUIRED_FINDING_LABEL_KEYS_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    TABLE_OPTIONS_FIELD_NUMBER: builtins.int
    description: typing.Text = ...
    """A short description of where the data is coming from. Will be stored once
    in the job. 256 max length.
    """

    @property
    def required_finding_label_keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """These are labels that each inspection request must include within their
        'finding_labels' map. Request may contain others, but any missing one of
        these will be rejected.

        Label keys must be between 1 and 63 characters long and must conform
        to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.

        No more than 10 keys can be required.
        """
        pass
    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """To organize findings, these labels will be added to each finding.

        Label keys must be between 1 and 63 characters long and must conform
        to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.

        Label values must be between 0 and 63 characters long and must conform
        to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.

        No more than 10 labels can be associated with a given finding.

        Examples:
        * `"environment" : "production"`
        * `"pipeline" : "etl"`
        """
        pass
    @property
    def table_options(self) -> global___TableOptions:
        """If the container is a table, additional information to make findings
        meaningful such as the columns that are primary keys.
        """
        pass
    def __init__(self,
        *,
        description : typing.Text = ...,
        required_finding_label_keys : typing.Optional[typing.Iterable[typing.Text]] = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        table_options : typing.Optional[global___TableOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["table_options",b"table_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["description",b"description","labels",b"labels","required_finding_label_keys",b"required_finding_label_keys","table_options",b"table_options"]) -> None: ...
global___HybridOptions = HybridOptions

class BigQueryKey(google.protobuf.message.Message):
    """Row key for identifying a record in BigQuery table."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TABLE_REFERENCE_FIELD_NUMBER: builtins.int
    ROW_NUMBER_FIELD_NUMBER: builtins.int
    @property
    def table_reference(self) -> global___BigQueryTable:
        """Complete BigQuery table reference."""
        pass
    row_number: builtins.int = ...
    """Row number inferred at the time the table was scanned. This value is
    nondeterministic, cannot be queried, and may be null for inspection
    jobs. To locate findings within a table, specify
    `inspect_job.storage_config.big_query_options.identifying_fields` in
    `CreateDlpJobRequest`.
    """

    def __init__(self,
        *,
        table_reference : typing.Optional[global___BigQueryTable] = ...,
        row_number : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["table_reference",b"table_reference"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["row_number",b"row_number","table_reference",b"table_reference"]) -> None: ...
global___BigQueryKey = BigQueryKey

class DatastoreKey(google.protobuf.message.Message):
    """Record key for a finding in Cloud Datastore."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ENTITY_KEY_FIELD_NUMBER: builtins.int
    @property
    def entity_key(self) -> global___Key:
        """Datastore entity key."""
        pass
    def __init__(self,
        *,
        entity_key : typing.Optional[global___Key] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["entity_key",b"entity_key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["entity_key",b"entity_key"]) -> None: ...
global___DatastoreKey = DatastoreKey

class Key(google.protobuf.message.Message):
    """A unique identifier for a Datastore entity.
    If a key's partition ID or any of its path kinds or names are
    reserved/read-only, the key is reserved/read-only.
    A reserved/read-only key is forbidden in certain documented contexts.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class PathElement(google.protobuf.message.Message):
        """A (kind, ID/name) pair used to construct a key path.

        If either name or ID is set, the element is complete.
        If neither is set, the element is incomplete.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KIND_FIELD_NUMBER: builtins.int
        ID_FIELD_NUMBER: builtins.int
        NAME_FIELD_NUMBER: builtins.int
        kind: typing.Text = ...
        """The kind of the entity.
        A kind matching regex `__.*__` is reserved/read-only.
        A kind must not contain more than 1500 bytes when UTF-8 encoded.
        Cannot be `""`.
        """

        id: builtins.int = ...
        """The auto-allocated ID of the entity.
        Never equal to zero. Values less than zero are discouraged and may not
        be supported in the future.
        """

        name: typing.Text = ...
        """The name of the entity.
        A name matching regex `__.*__` is reserved/read-only.
        A name must not be more than 1500 bytes when UTF-8 encoded.
        Cannot be `""`.
        """

        def __init__(self,
            *,
            kind : typing.Text = ...,
            id : builtins.int = ...,
            name : typing.Text = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["id",b"id","id_type",b"id_type","name",b"name"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["id",b"id","id_type",b"id_type","kind",b"kind","name",b"name"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["id_type",b"id_type"]) -> typing.Optional[typing_extensions.Literal["id","name"]]: ...

    PARTITION_ID_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    @property
    def partition_id(self) -> global___PartitionId:
        """Entities are partitioned into subsets, currently identified by a project
        ID and namespace ID.
        Queries are scoped to a single partition.
        """
        pass
    @property
    def path(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Key.PathElement]:
        """The entity path.
        An entity path consists of one or more elements composed of a kind and a
        string or numerical identifier, which identify entities. The first
        element identifies a _root entity_, the second element identifies
        a _child_ of the root entity, the third element identifies a child of the
        second entity, and so forth. The entities identified by all prefixes of
        the path are called the element's _ancestors_.

        A path can never be empty, and a path can have at most 100 elements.
        """
        pass
    def __init__(self,
        *,
        partition_id : typing.Optional[global___PartitionId] = ...,
        path : typing.Optional[typing.Iterable[global___Key.PathElement]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["partition_id",b"partition_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["partition_id",b"partition_id","path",b"path"]) -> None: ...
global___Key = Key

class RecordKey(google.protobuf.message.Message):
    """Message for a unique key indicating a record that contains a finding."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATASTORE_KEY_FIELD_NUMBER: builtins.int
    BIG_QUERY_KEY_FIELD_NUMBER: builtins.int
    ID_VALUES_FIELD_NUMBER: builtins.int
    @property
    def datastore_key(self) -> global___DatastoreKey: ...
    @property
    def big_query_key(self) -> global___BigQueryKey: ...
    @property
    def id_values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Values of identifying columns in the given row. Order of values matches
        the order of `identifying_fields` specified in the scanning request.
        """
        pass
    def __init__(self,
        *,
        datastore_key : typing.Optional[global___DatastoreKey] = ...,
        big_query_key : typing.Optional[global___BigQueryKey] = ...,
        id_values : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["big_query_key",b"big_query_key","datastore_key",b"datastore_key","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["big_query_key",b"big_query_key","datastore_key",b"datastore_key","id_values",b"id_values","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["datastore_key","big_query_key"]]: ...
global___RecordKey = RecordKey

class BigQueryTable(google.protobuf.message.Message):
    """Message defining the location of a BigQuery table. A table is uniquely
    identified  by its project_id, dataset_id, and table_name. Within a query
    a table is often referenced with a string in the format of:
    `<project_id>:<dataset_id>.<table_id>` or
    `<project_id>.<dataset_id>.<table_id>`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_ID_FIELD_NUMBER: builtins.int
    DATASET_ID_FIELD_NUMBER: builtins.int
    TABLE_ID_FIELD_NUMBER: builtins.int
    project_id: typing.Text = ...
    """The Google Cloud Platform project ID of the project containing the table.
    If omitted, project ID is inferred from the API call.
    """

    dataset_id: typing.Text = ...
    """Dataset ID of the table."""

    table_id: typing.Text = ...
    """Name of the table."""

    def __init__(self,
        *,
        project_id : typing.Text = ...,
        dataset_id : typing.Text = ...,
        table_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset_id",b"dataset_id","project_id",b"project_id","table_id",b"table_id"]) -> None: ...
global___BigQueryTable = BigQueryTable

class BigQueryField(google.protobuf.message.Message):
    """Message defining a field of a BigQuery table."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TABLE_FIELD_NUMBER: builtins.int
    FIELD_FIELD_NUMBER: builtins.int
    @property
    def table(self) -> global___BigQueryTable:
        """Source table of the field."""
        pass
    @property
    def field(self) -> global___FieldId:
        """Designated field in the BigQuery table."""
        pass
    def __init__(self,
        *,
        table : typing.Optional[global___BigQueryTable] = ...,
        field : typing.Optional[global___FieldId] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["field",b"field","table",b"table"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["field",b"field","table",b"table"]) -> None: ...
global___BigQueryField = BigQueryField

class EntityId(google.protobuf.message.Message):
    """An entity in a dataset is a field or set of fields that correspond to a
    single person. For example, in medical records the `EntityId` might be a
    patient identifier, or for financial records it might be an account
    identifier. This message is used when generalizations or analysis must take
    into account that multiple rows correspond to the same entity.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FIELD_FIELD_NUMBER: builtins.int
    @property
    def field(self) -> global___FieldId:
        """Composite key indicating which field contains the entity identifier."""
        pass
    def __init__(self,
        *,
        field : typing.Optional[global___FieldId] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["field",b"field"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["field",b"field"]) -> None: ...
global___EntityId = EntityId

class TableOptions(google.protobuf.message.Message):
    """Instructions regarding the table content being inspected."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    IDENTIFYING_FIELDS_FIELD_NUMBER: builtins.int
    @property
    def identifying_fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FieldId]:
        """The columns that are the primary keys for table objects included in
        ContentItem. A copy of this cell's value will stored alongside alongside
        each finding so that the finding can be traced to the specific row it came
        from. No more than 3 may be provided.
        """
        pass
    def __init__(self,
        *,
        identifying_fields : typing.Optional[typing.Iterable[global___FieldId]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["identifying_fields",b"identifying_fields"]) -> None: ...
global___TableOptions = TableOptions
