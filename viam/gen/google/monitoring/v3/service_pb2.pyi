"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.type.calendar_period_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Service(google.protobuf.message.Message):
    """A `Service` is a discrete, autonomous, and network-accessible unit, designed
    to solve an individual concern
    ([Wikipedia](https://en.wikipedia.org/wiki/Service-orientation)). In
    Cloud Monitoring, a `Service` acts as the root resource under which
    operational aspects of the service are accessible.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Custom(google.protobuf.message.Message):
        """Custom view of service telemetry. Currently a place-holder pending final
        design.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    class AppEngine(google.protobuf.message.Message):
        """App Engine service. Learn more at https://cloud.google.com/appengine."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MODULE_ID_FIELD_NUMBER: builtins.int
        module_id: typing.Text = ...
        """The ID of the App Engine module underlying this service. Corresponds to
        the `module_id` resource label in the `gae_app` monitored resource:
        https://cloud.google.com/monitoring/api/resources#tag_gae_app
        """

        def __init__(self,
            *,
            module_id : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["module_id",b"module_id"]) -> None: ...

    class CloudEndpoints(google.protobuf.message.Message):
        """Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SERVICE_FIELD_NUMBER: builtins.int
        service: typing.Text = ...
        """The name of the Cloud Endpoints service underlying this service.
        Corresponds to the `service` resource label in the `api` monitored
        resource: https://cloud.google.com/monitoring/api/resources#tag_api
        """

        def __init__(self,
            *,
            service : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["service",b"service"]) -> None: ...

    class ClusterIstio(google.protobuf.message.Message):
        """Istio service scoped to a single Kubernetes cluster. Learn more at
        https://istio.io. Clusters running OSS Istio will have their services
        ingested as this type.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        LOCATION_FIELD_NUMBER: builtins.int
        CLUSTER_NAME_FIELD_NUMBER: builtins.int
        SERVICE_NAMESPACE_FIELD_NUMBER: builtins.int
        SERVICE_NAME_FIELD_NUMBER: builtins.int
        location: typing.Text = ...
        """The location of the Kubernetes cluster in which this Istio service is
        defined. Corresponds to the `location` resource label in `k8s_cluster`
        resources.
        """

        cluster_name: typing.Text = ...
        """The name of the Kubernetes cluster in which this Istio service is
        defined. Corresponds to the `cluster_name` resource label in
        `k8s_cluster` resources.
        """

        service_namespace: typing.Text = ...
        """The namespace of the Istio service underlying this service. Corresponds
        to the `destination_service_namespace` metric label in Istio metrics.
        """

        service_name: typing.Text = ...
        """The name of the Istio service underlying this service. Corresponds to the
        `destination_service_name` metric label in Istio metrics.
        """

        def __init__(self,
            *,
            location : typing.Text = ...,
            cluster_name : typing.Text = ...,
            service_namespace : typing.Text = ...,
            service_name : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["cluster_name",b"cluster_name","location",b"location","service_name",b"service_name","service_namespace",b"service_namespace"]) -> None: ...

    class MeshIstio(google.protobuf.message.Message):
        """Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8
        will have their services ingested as this type.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MESH_UID_FIELD_NUMBER: builtins.int
        SERVICE_NAMESPACE_FIELD_NUMBER: builtins.int
        SERVICE_NAME_FIELD_NUMBER: builtins.int
        mesh_uid: typing.Text = ...
        """Identifier for the mesh in which this Istio service is defined.
        Corresponds to the `mesh_uid` metric label in Istio metrics.
        """

        service_namespace: typing.Text = ...
        """The namespace of the Istio service underlying this service. Corresponds
        to the `destination_service_namespace` metric label in Istio metrics.
        """

        service_name: typing.Text = ...
        """The name of the Istio service underlying this service. Corresponds to the
        `destination_service_name` metric label in Istio metrics.
        """

        def __init__(self,
            *,
            mesh_uid : typing.Text = ...,
            service_namespace : typing.Text = ...,
            service_name : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["mesh_uid",b"mesh_uid","service_name",b"service_name","service_namespace",b"service_namespace"]) -> None: ...

    class IstioCanonicalService(google.protobuf.message.Message):
        """Canonical service scoped to an Istio mesh. Anthos clusters running ASM >=
        1.6.8 will have their services ingested as this type.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MESH_UID_FIELD_NUMBER: builtins.int
        CANONICAL_SERVICE_NAMESPACE_FIELD_NUMBER: builtins.int
        CANONICAL_SERVICE_FIELD_NUMBER: builtins.int
        mesh_uid: typing.Text = ...
        """Identifier for the Istio mesh in which this canonical service is defined.
        Corresponds to the `mesh_uid` metric label in
        [Istio metrics](https://cloud.google.com/monitoring/api/metrics_istio).
        """

        canonical_service_namespace: typing.Text = ...
        """The namespace of the canonical service underlying this service.
        Corresponds to the `destination_canonical_service_namespace` metric
        label in [Istio
        metrics](https://cloud.google.com/monitoring/api/metrics_istio).
        """

        canonical_service: typing.Text = ...
        """The name of the canonical service underlying this service.
        Corresponds to the `destination_canonical_service_name` metric label in
        label in [Istio
        metrics](https://cloud.google.com/monitoring/api/metrics_istio).
        """

        def __init__(self,
            *,
            mesh_uid : typing.Text = ...,
            canonical_service_namespace : typing.Text = ...,
            canonical_service : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["canonical_service",b"canonical_service","canonical_service_namespace",b"canonical_service_namespace","mesh_uid",b"mesh_uid"]) -> None: ...

    class Telemetry(google.protobuf.message.Message):
        """Configuration for how to query telemetry on a Service."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        RESOURCE_NAME_FIELD_NUMBER: builtins.int
        resource_name: typing.Text = ...
        """The full name of the resource that defines this service. Formatted as
        described in https://cloud.google.com/apis/design/resource_names.
        """

        def __init__(self,
            *,
            resource_name : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["resource_name",b"resource_name"]) -> None: ...

    class UserLabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    CUSTOM_FIELD_NUMBER: builtins.int
    APP_ENGINE_FIELD_NUMBER: builtins.int
    CLOUD_ENDPOINTS_FIELD_NUMBER: builtins.int
    CLUSTER_ISTIO_FIELD_NUMBER: builtins.int
    MESH_ISTIO_FIELD_NUMBER: builtins.int
    ISTIO_CANONICAL_SERVICE_FIELD_NUMBER: builtins.int
    TELEMETRY_FIELD_NUMBER: builtins.int
    USER_LABELS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Resource name for this Service. The format is:

        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
    """

    display_name: typing.Text = ...
    """Name used for UI elements listing this Service."""

    @property
    def custom(self) -> global___Service.Custom:
        """Custom service type."""
        pass
    @property
    def app_engine(self) -> global___Service.AppEngine:
        """Type used for App Engine services."""
        pass
    @property
    def cloud_endpoints(self) -> global___Service.CloudEndpoints:
        """Type used for Cloud Endpoints services."""
        pass
    @property
    def cluster_istio(self) -> global___Service.ClusterIstio:
        """Type used for Istio services that live in a Kubernetes cluster."""
        pass
    @property
    def mesh_istio(self) -> global___Service.MeshIstio:
        """Type used for Istio services scoped to an Istio mesh."""
        pass
    @property
    def istio_canonical_service(self) -> global___Service.IstioCanonicalService:
        """Type used for canonical services scoped to an Istio mesh.
        Metrics for Istio are
        [documented here](https://istio.io/latest/docs/reference/config/metrics/)
        """
        pass
    @property
    def telemetry(self) -> global___Service.Telemetry:
        """Configuration for how to query telemetry on a Service."""
        pass
    @property
    def user_labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Labels which have been used to annotate the service. Label keys must start
        with a letter. Label keys and values may contain lowercase letters,
        numbers, underscores, and dashes. Label keys and values have a maximum
        length of 63 characters, and must be less than 128 bytes in size. Up to 64
        label entries may be stored. For labels which do not have a semantic value,
        the empty string may be supplied for the label value.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        custom : typing.Optional[global___Service.Custom] = ...,
        app_engine : typing.Optional[global___Service.AppEngine] = ...,
        cloud_endpoints : typing.Optional[global___Service.CloudEndpoints] = ...,
        cluster_istio : typing.Optional[global___Service.ClusterIstio] = ...,
        mesh_istio : typing.Optional[global___Service.MeshIstio] = ...,
        istio_canonical_service : typing.Optional[global___Service.IstioCanonicalService] = ...,
        telemetry : typing.Optional[global___Service.Telemetry] = ...,
        user_labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["app_engine",b"app_engine","cloud_endpoints",b"cloud_endpoints","cluster_istio",b"cluster_istio","custom",b"custom","identifier",b"identifier","istio_canonical_service",b"istio_canonical_service","mesh_istio",b"mesh_istio","telemetry",b"telemetry"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["app_engine",b"app_engine","cloud_endpoints",b"cloud_endpoints","cluster_istio",b"cluster_istio","custom",b"custom","display_name",b"display_name","identifier",b"identifier","istio_canonical_service",b"istio_canonical_service","mesh_istio",b"mesh_istio","name",b"name","telemetry",b"telemetry","user_labels",b"user_labels"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["identifier",b"identifier"]) -> typing.Optional[typing_extensions.Literal["custom","app_engine","cloud_endpoints","cluster_istio","mesh_istio","istio_canonical_service"]]: ...
global___Service = Service

class ServiceLevelObjective(google.protobuf.message.Message):
    """A Service-Level Objective (SLO) describes a level of desired good service. It
    consists of a service-level indicator (SLI), a performance goal, and a period
    over which the objective is to be evaluated against that goal. The SLO can
    use SLIs defined in a number of different manners. Typical SLOs might include
    "99% of requests in each rolling week have latency below 200 milliseconds" or
    "99.5% of requests in each calendar month return successfully."
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _View:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ViewEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_View.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        VIEW_UNSPECIFIED: ServiceLevelObjective.View.ValueType = ...  # 0
        """Same as FULL."""

        FULL: ServiceLevelObjective.View.ValueType = ...  # 2
        """Return the embedded `ServiceLevelIndicator` in the form in which it was
        defined. If it was defined using a `BasicSli`, return that `BasicSli`.
        """

        EXPLICIT: ServiceLevelObjective.View.ValueType = ...  # 1
        """For `ServiceLevelIndicator`s using `BasicSli` articulation, instead
        return the `ServiceLevelIndicator` with its mode of computation fully
        spelled out as a `RequestBasedSli`. For `ServiceLevelIndicator`s using
        `RequestBasedSli` or `WindowsBasedSli`, return the
        `ServiceLevelIndicator` as it was provided.
        """

    class View(_View, metaclass=_ViewEnumTypeWrapper):
        """`ServiceLevelObjective.View` determines what form of
        `ServiceLevelObjective` is returned from `GetServiceLevelObjective`,
        `ListServiceLevelObjectives`, and `ListServiceLevelObjectiveVersions` RPCs.
        """
        pass

    VIEW_UNSPECIFIED: ServiceLevelObjective.View.ValueType = ...  # 0
    """Same as FULL."""

    FULL: ServiceLevelObjective.View.ValueType = ...  # 2
    """Return the embedded `ServiceLevelIndicator` in the form in which it was
    defined. If it was defined using a `BasicSli`, return that `BasicSli`.
    """

    EXPLICIT: ServiceLevelObjective.View.ValueType = ...  # 1
    """For `ServiceLevelIndicator`s using `BasicSli` articulation, instead
    return the `ServiceLevelIndicator` with its mode of computation fully
    spelled out as a `RequestBasedSli`. For `ServiceLevelIndicator`s using
    `RequestBasedSli` or `WindowsBasedSli`, return the
    `ServiceLevelIndicator` as it was provided.
    """


    class UserLabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    SERVICE_LEVEL_INDICATOR_FIELD_NUMBER: builtins.int
    GOAL_FIELD_NUMBER: builtins.int
    ROLLING_PERIOD_FIELD_NUMBER: builtins.int
    CALENDAR_PERIOD_FIELD_NUMBER: builtins.int
    USER_LABELS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Resource name for this `ServiceLevelObjective`. The format is:

        projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
    """

    display_name: typing.Text = ...
    """Name used for UI elements listing this SLO."""

    @property
    def service_level_indicator(self) -> global___ServiceLevelIndicator:
        """The definition of good service, used to measure and calculate the quality
        of the `Service`'s performance with respect to a single aspect of service
        quality.
        """
        pass
    goal: builtins.float = ...
    """The fraction of service that must be good in order for this objective to be
    met. `0 < goal <= 0.999`.
    """

    @property
    def rolling_period(self) -> google.protobuf.duration_pb2.Duration:
        """A rolling time period, semantically "in the past `<rolling_period>`".
        Must be an integer multiple of 1 day no larger than 30 days.
        """
        pass
    calendar_period: google.type.calendar_period_pb2.CalendarPeriod.ValueType = ...
    """A calendar period, semantically "since the start of the current
    `<calendar_period>`". At this time, only `DAY`, `WEEK`, `FORTNIGHT`, and
    `MONTH` are supported.
    """

    @property
    def user_labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Labels which have been used to annotate the service-level objective. Label
        keys must start with a letter. Label keys and values may contain lowercase
        letters, numbers, underscores, and dashes. Label keys and values have a
        maximum length of 63 characters, and must be less than 128 bytes in size.
        Up to 64 label entries may be stored. For labels which do not have a
        semantic value, the empty string may be supplied for the label value.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        service_level_indicator : typing.Optional[global___ServiceLevelIndicator] = ...,
        goal : builtins.float = ...,
        rolling_period : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        calendar_period : google.type.calendar_period_pb2.CalendarPeriod.ValueType = ...,
        user_labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["calendar_period",b"calendar_period","period",b"period","rolling_period",b"rolling_period","service_level_indicator",b"service_level_indicator"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["calendar_period",b"calendar_period","display_name",b"display_name","goal",b"goal","name",b"name","period",b"period","rolling_period",b"rolling_period","service_level_indicator",b"service_level_indicator","user_labels",b"user_labels"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["period",b"period"]) -> typing.Optional[typing_extensions.Literal["rolling_period","calendar_period"]]: ...
global___ServiceLevelObjective = ServiceLevelObjective

class ServiceLevelIndicator(google.protobuf.message.Message):
    """A Service-Level Indicator (SLI) describes the "performance" of a service. For
    some services, the SLI is well-defined. In such cases, the SLI can be
    described easily by referencing the well-known SLI and providing the needed
    parameters. Alternatively, a "custom" SLI can be defined with a query to the
    underlying metric store. An SLI is defined to be `good_service /
    total_service` over any queried time interval. The value of performance
    always falls into the range `0 <= performance <= 1`. A custom SLI describes
    how to compute this ratio, whether this is by dividing values from a pair of
    time series, cutting a `Distribution` into good and bad counts, or counting
    time windows in which the service complies with a criterion. For separation
    of concerns, a single Service-Level Indicator measures performance for only
    one aspect of service quality, such as fraction of successful queries or
    fast-enough queries.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    BASIC_SLI_FIELD_NUMBER: builtins.int
    REQUEST_BASED_FIELD_NUMBER: builtins.int
    WINDOWS_BASED_FIELD_NUMBER: builtins.int
    @property
    def basic_sli(self) -> global___BasicSli:
        """Basic SLI on a well-known service type."""
        pass
    @property
    def request_based(self) -> global___RequestBasedSli:
        """Request-based SLIs"""
        pass
    @property
    def windows_based(self) -> global___WindowsBasedSli:
        """Windows-based SLIs"""
        pass
    def __init__(self,
        *,
        basic_sli : typing.Optional[global___BasicSli] = ...,
        request_based : typing.Optional[global___RequestBasedSli] = ...,
        windows_based : typing.Optional[global___WindowsBasedSli] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["basic_sli",b"basic_sli","request_based",b"request_based","type",b"type","windows_based",b"windows_based"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["basic_sli",b"basic_sli","request_based",b"request_based","type",b"type","windows_based",b"windows_based"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["basic_sli","request_based","windows_based"]]: ...
global___ServiceLevelIndicator = ServiceLevelIndicator

class BasicSli(google.protobuf.message.Message):
    """An SLI measuring performance on a well-known service type. Performance will
    be computed on the basis of pre-defined metrics. The type of the
    `service_resource` determines the metrics to use and the
    `service_resource.labels` and `metric_labels` are used to construct a
    monitoring filter to filter that metric down to just the data relevant to
    this service.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class AvailabilityCriteria(google.protobuf.message.Message):
        """Future parameters for the availability SLI."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    class LatencyCriteria(google.protobuf.message.Message):
        """Parameters for a latency threshold SLI."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        THRESHOLD_FIELD_NUMBER: builtins.int
        @property
        def threshold(self) -> google.protobuf.duration_pb2.Duration:
            """Good service is defined to be the count of requests made to this service
            that return in no more than `threshold`.
            """
            pass
        def __init__(self,
            *,
            threshold : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["threshold",b"threshold"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["threshold",b"threshold"]) -> None: ...

    METHOD_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    AVAILABILITY_FIELD_NUMBER: builtins.int
    LATENCY_FIELD_NUMBER: builtins.int
    @property
    def method(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from
        other methods will not be used to calculate performance for this SLI. If
        omitted, this SLI applies to all the Service's methods. For service types
        that don't support breaking down by method, setting this field will result
        in an error.
        """
        pass
    @property
    def location(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """OPTIONAL: The set of locations to which this SLI is relevant. Telemetry
        from other locations will not be used to calculate performance for this
        SLI. If omitted, this SLI applies to all locations in which the Service has
        activity. For service types that don't support breaking down by location,
        setting this field will result in an error.
        """
        pass
    @property
    def version(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry
        from other API versions will not be used to calculate performance for this
        SLI. If omitted, this SLI applies to all API versions. For service types
        that don't support breaking down by version, setting this field will result
        in an error.
        """
        pass
    @property
    def availability(self) -> global___BasicSli.AvailabilityCriteria:
        """Good service is defined to be the count of requests made to this service
        that return successfully.
        """
        pass
    @property
    def latency(self) -> global___BasicSli.LatencyCriteria:
        """Good service is defined to be the count of requests made to this service
        that are fast enough with respect to `latency.threshold`.
        """
        pass
    def __init__(self,
        *,
        method : typing.Optional[typing.Iterable[typing.Text]] = ...,
        location : typing.Optional[typing.Iterable[typing.Text]] = ...,
        version : typing.Optional[typing.Iterable[typing.Text]] = ...,
        availability : typing.Optional[global___BasicSli.AvailabilityCriteria] = ...,
        latency : typing.Optional[global___BasicSli.LatencyCriteria] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["availability",b"availability","latency",b"latency","sli_criteria",b"sli_criteria"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["availability",b"availability","latency",b"latency","location",b"location","method",b"method","sli_criteria",b"sli_criteria","version",b"version"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["sli_criteria",b"sli_criteria"]) -> typing.Optional[typing_extensions.Literal["availability","latency"]]: ...
global___BasicSli = BasicSli

class Range(google.protobuf.message.Message):
    """Range of numerical values within `min` and `max`."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MIN_FIELD_NUMBER: builtins.int
    MAX_FIELD_NUMBER: builtins.int
    min: builtins.float = ...
    """Range minimum."""

    max: builtins.float = ...
    """Range maximum."""

    def __init__(self,
        *,
        min : builtins.float = ...,
        max : builtins.float = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["max",b"max","min",b"min"]) -> None: ...
global___Range = Range

class RequestBasedSli(google.protobuf.message.Message):
    """Service Level Indicators for which atomic units of service are counted
    directly.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GOOD_TOTAL_RATIO_FIELD_NUMBER: builtins.int
    DISTRIBUTION_CUT_FIELD_NUMBER: builtins.int
    @property
    def good_total_ratio(self) -> global___TimeSeriesRatio:
        """`good_total_ratio` is used when the ratio of `good_service` to
        `total_service` is computed from two `TimeSeries`.
        """
        pass
    @property
    def distribution_cut(self) -> global___DistributionCut:
        """`distribution_cut` is used when `good_service` is a count of values
        aggregated in a `Distribution` that fall into a good range. The
        `total_service` is the total count of all values aggregated in the
        `Distribution`.
        """
        pass
    def __init__(self,
        *,
        good_total_ratio : typing.Optional[global___TimeSeriesRatio] = ...,
        distribution_cut : typing.Optional[global___DistributionCut] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["distribution_cut",b"distribution_cut","good_total_ratio",b"good_total_ratio","method",b"method"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["distribution_cut",b"distribution_cut","good_total_ratio",b"good_total_ratio","method",b"method"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["method",b"method"]) -> typing.Optional[typing_extensions.Literal["good_total_ratio","distribution_cut"]]: ...
global___RequestBasedSli = RequestBasedSli

class TimeSeriesRatio(google.protobuf.message.Message):
    """A `TimeSeriesRatio` specifies two `TimeSeries` to use for computing the
    `good_service / total_service` ratio. The specified `TimeSeries` must have
    `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
    DELTA` or `MetricKind = CUMULATIVE`. The `TimeSeriesRatio` must specify
    exactly two of good, bad, and total, and the relationship `good_service +
    bad_service = total_service` will be assumed.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GOOD_SERVICE_FILTER_FIELD_NUMBER: builtins.int
    BAD_SERVICE_FILTER_FIELD_NUMBER: builtins.int
    TOTAL_SERVICE_FILTER_FIELD_NUMBER: builtins.int
    good_service_filter: typing.Text = ...
    """A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    specifying a `TimeSeries` quantifying good service provided. Must have
    `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
    DELTA` or `MetricKind = CUMULATIVE`.
    """

    bad_service_filter: typing.Text = ...
    """A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    specifying a `TimeSeries` quantifying bad service, either demanded service
    that was not provided or demanded service that was of inadequate quality.
    Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have
    `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
    """

    total_service_filter: typing.Text = ...
    """A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    specifying a `TimeSeries` quantifying total demanded service. Must have
    `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
    DELTA` or `MetricKind = CUMULATIVE`.
    """

    def __init__(self,
        *,
        good_service_filter : typing.Text = ...,
        bad_service_filter : typing.Text = ...,
        total_service_filter : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["bad_service_filter",b"bad_service_filter","good_service_filter",b"good_service_filter","total_service_filter",b"total_service_filter"]) -> None: ...
global___TimeSeriesRatio = TimeSeriesRatio

class DistributionCut(google.protobuf.message.Message):
    """A `DistributionCut` defines a `TimeSeries` and thresholds used for measuring
    good service and total service. The `TimeSeries` must have `ValueType =
    DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`. The
    computed `good_service` will be the estimated count of values in the
    `Distribution` that fall within the specified `min` and `max`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DISTRIBUTION_FILTER_FIELD_NUMBER: builtins.int
    RANGE_FIELD_NUMBER: builtins.int
    distribution_filter: typing.Text = ...
    """A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    specifying a `TimeSeries` aggregating values. Must have `ValueType =
    DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
    """

    @property
    def range(self) -> global___Range:
        """Range of values considered "good." For a one-sided range, set one bound to
        an infinite value.
        """
        pass
    def __init__(self,
        *,
        distribution_filter : typing.Text = ...,
        range : typing.Optional[global___Range] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["range",b"range"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["distribution_filter",b"distribution_filter","range",b"range"]) -> None: ...
global___DistributionCut = DistributionCut

class WindowsBasedSli(google.protobuf.message.Message):
    """A `WindowsBasedSli` defines `good_service` as the count of time windows for
    which the provided service was of good quality. Criteria for determining
    if service was good are embedded in the `window_criterion`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class PerformanceThreshold(google.protobuf.message.Message):
        """A `PerformanceThreshold` is used when each window is good when that window
        has a sufficiently high `performance`.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        PERFORMANCE_FIELD_NUMBER: builtins.int
        BASIC_SLI_PERFORMANCE_FIELD_NUMBER: builtins.int
        THRESHOLD_FIELD_NUMBER: builtins.int
        @property
        def performance(self) -> global___RequestBasedSli:
            """`RequestBasedSli` to evaluate to judge window quality."""
            pass
        @property
        def basic_sli_performance(self) -> global___BasicSli:
            """`BasicSli` to evaluate to judge window quality."""
            pass
        threshold: builtins.float = ...
        """If window `performance >= threshold`, the window is counted as good."""

        def __init__(self,
            *,
            performance : typing.Optional[global___RequestBasedSli] = ...,
            basic_sli_performance : typing.Optional[global___BasicSli] = ...,
            threshold : builtins.float = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["basic_sli_performance",b"basic_sli_performance","performance",b"performance","type",b"type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["basic_sli_performance",b"basic_sli_performance","performance",b"performance","threshold",b"threshold","type",b"type"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["performance","basic_sli_performance"]]: ...

    class MetricRange(google.protobuf.message.Message):
        """A `MetricRange` is used when each window is good when the value x of a
        single `TimeSeries` satisfies `range.min <= x <= range.max`. The provided
        `TimeSeries` must have `ValueType = INT64` or `ValueType = DOUBLE` and
        `MetricKind = GAUGE`.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TIME_SERIES_FIELD_NUMBER: builtins.int
        RANGE_FIELD_NUMBER: builtins.int
        time_series: typing.Text = ...
        """A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
        specifying the `TimeSeries` to use for evaluating window quality.
        """

        @property
        def range(self) -> global___Range:
            """Range of values considered "good." For a one-sided range, set one bound
            to an infinite value.
            """
            pass
        def __init__(self,
            *,
            time_series : typing.Text = ...,
            range : typing.Optional[global___Range] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["range",b"range"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["range",b"range","time_series",b"time_series"]) -> None: ...

    GOOD_BAD_METRIC_FILTER_FIELD_NUMBER: builtins.int
    GOOD_TOTAL_RATIO_THRESHOLD_FIELD_NUMBER: builtins.int
    METRIC_MEAN_IN_RANGE_FIELD_NUMBER: builtins.int
    METRIC_SUM_IN_RANGE_FIELD_NUMBER: builtins.int
    WINDOW_PERIOD_FIELD_NUMBER: builtins.int
    good_bad_metric_filter: typing.Text = ...
    """A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    specifying a `TimeSeries` with `ValueType = BOOL`. The window is good if
    any `true` values appear in the window.
    """

    @property
    def good_total_ratio_threshold(self) -> global___WindowsBasedSli.PerformanceThreshold:
        """A window is good if its `performance` is high enough."""
        pass
    @property
    def metric_mean_in_range(self) -> global___WindowsBasedSli.MetricRange:
        """A window is good if the metric's value is in a good range, averaged
        across returned streams.
        """
        pass
    @property
    def metric_sum_in_range(self) -> global___WindowsBasedSli.MetricRange:
        """A window is good if the metric's value is in a good range, summed across
        returned streams.
        """
        pass
    @property
    def window_period(self) -> google.protobuf.duration_pb2.Duration:
        """Duration over which window quality is evaluated. Must be an integer
        fraction of a day and at least `60s`.
        """
        pass
    def __init__(self,
        *,
        good_bad_metric_filter : typing.Text = ...,
        good_total_ratio_threshold : typing.Optional[global___WindowsBasedSli.PerformanceThreshold] = ...,
        metric_mean_in_range : typing.Optional[global___WindowsBasedSli.MetricRange] = ...,
        metric_sum_in_range : typing.Optional[global___WindowsBasedSli.MetricRange] = ...,
        window_period : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["good_bad_metric_filter",b"good_bad_metric_filter","good_total_ratio_threshold",b"good_total_ratio_threshold","metric_mean_in_range",b"metric_mean_in_range","metric_sum_in_range",b"metric_sum_in_range","window_criterion",b"window_criterion","window_period",b"window_period"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["good_bad_metric_filter",b"good_bad_metric_filter","good_total_ratio_threshold",b"good_total_ratio_threshold","metric_mean_in_range",b"metric_mean_in_range","metric_sum_in_range",b"metric_sum_in_range","window_criterion",b"window_criterion","window_period",b"window_period"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["window_criterion",b"window_criterion"]) -> typing.Optional[typing_extensions.Literal["good_bad_metric_filter","good_total_ratio_threshold","metric_mean_in_range","metric_sum_in_range"]]: ...
global___WindowsBasedSli = WindowsBasedSli
