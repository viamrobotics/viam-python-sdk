"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.api.label_pb2
import google.api.metric_pb2
import google.api.monitored_resource_pb2
import google.monitoring.v3.common_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Point(google.protobuf.message.Message):
    """A single data point in a time series."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INTERVAL_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    @property
    def interval(self) -> google.monitoring.v3.common_pb2.TimeInterval:
        """The time interval to which the data point applies.  For `GAUGE` metrics,
        the start time is optional, but if it is supplied, it must equal the
        end time.  For `DELTA` metrics, the start
        and end time should specify a non-zero interval, with subsequent points
        specifying contiguous and non-overlapping intervals.  For `CUMULATIVE`
        metrics, the start and end time should specify a non-zero interval, with
        subsequent points specifying the same start time and increasing end times,
        until an event resets the cumulative value to zero and sets a new start
        time for the following points.
        """
        pass
    @property
    def value(self) -> google.monitoring.v3.common_pb2.TypedValue:
        """The value of the data point."""
        pass
    def __init__(self,
        *,
        interval : typing.Optional[google.monitoring.v3.common_pb2.TimeInterval] = ...,
        value : typing.Optional[google.monitoring.v3.common_pb2.TypedValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["interval",b"interval","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["interval",b"interval","value",b"value"]) -> None: ...
global___Point = Point

class TimeSeries(google.protobuf.message.Message):
    """A collection of data points that describes the time-varying values
    of a metric. A time series is identified by a combination of a
    fully-specified monitored resource and a fully-specified metric.
    This type is used for both listing and creating time series.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    METRIC_FIELD_NUMBER: builtins.int
    RESOURCE_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    METRIC_KIND_FIELD_NUMBER: builtins.int
    VALUE_TYPE_FIELD_NUMBER: builtins.int
    POINTS_FIELD_NUMBER: builtins.int
    UNIT_FIELD_NUMBER: builtins.int
    @property
    def metric(self) -> google.api.metric_pb2.Metric:
        """The associated metric. A fully-specified metric used to identify the time
        series.
        """
        pass
    @property
    def resource(self) -> google.api.monitored_resource_pb2.MonitoredResource:
        """The associated monitored resource.  Custom metrics can use only certain
        monitored resource types in their time series data. For more information,
        see [Monitored resources for custom
        metrics](https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom-metric-resources).
        """
        pass
    @property
    def metadata(self) -> google.api.monitored_resource_pb2.MonitoredResourceMetadata:
        """Output only. The associated monitored resource metadata. When reading a
        time series, this field will include metadata labels that are explicitly
        named in the reduction. When creating a time series, this field is ignored.
        """
        pass
    metric_kind: google.api.metric_pb2.MetricDescriptor.MetricKind.ValueType = ...
    """The metric kind of the time series. When listing time series, this metric
    kind might be different from the metric kind of the associated metric if
    this time series is an alignment or reduction of other time series.

    When creating a time series, this field is optional. If present, it must be
    the same as the metric kind of the associated metric. If the associated
    metric's descriptor must be auto-created, then this field specifies the
    metric kind of the new descriptor and must be either `GAUGE` (the default)
    or `CUMULATIVE`.
    """

    value_type: google.api.metric_pb2.MetricDescriptor.ValueType.ValueType = ...
    """The value type of the time series. When listing time series, this value
    type might be different from the value type of the associated metric if
    this time series is an alignment or reduction of other time series.

    When creating a time series, this field is optional. If present, it must be
    the same as the type of the data in the `points` field.
    """

    @property
    def points(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Point]:
        """The data points of this time series. When listing time series, points are
        returned in reverse time order.

        When creating a time series, this field must contain exactly one point and
        the point's type must be the same as the value type of the associated
        metric. If the associated metric's descriptor must be auto-created, then
        the value type of the descriptor is determined by the point's type, which
        must be `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
        """
        pass
    unit: typing.Text = ...
    """The units in which the metric value is reported. It is only applicable
    if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit`
    defines the representation of the stored metric values.
    """

    def __init__(self,
        *,
        metric : typing.Optional[google.api.metric_pb2.Metric] = ...,
        resource : typing.Optional[google.api.monitored_resource_pb2.MonitoredResource] = ...,
        metadata : typing.Optional[google.api.monitored_resource_pb2.MonitoredResourceMetadata] = ...,
        metric_kind : google.api.metric_pb2.MetricDescriptor.MetricKind.ValueType = ...,
        value_type : google.api.metric_pb2.MetricDescriptor.ValueType.ValueType = ...,
        points : typing.Optional[typing.Iterable[global___Point]] = ...,
        unit : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["metadata",b"metadata","metric",b"metric","resource",b"resource"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["metadata",b"metadata","metric",b"metric","metric_kind",b"metric_kind","points",b"points","resource",b"resource","unit",b"unit","value_type",b"value_type"]) -> None: ...
global___TimeSeries = TimeSeries

class TimeSeriesDescriptor(google.protobuf.message.Message):
    """A descriptor for the labels and points in a time series."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ValueDescriptor(google.protobuf.message.Message):
        """A descriptor for the value columns in a data point."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_TYPE_FIELD_NUMBER: builtins.int
        METRIC_KIND_FIELD_NUMBER: builtins.int
        UNIT_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        """The value key."""

        value_type: google.api.metric_pb2.MetricDescriptor.ValueType.ValueType = ...
        """The value type."""

        metric_kind: google.api.metric_pb2.MetricDescriptor.MetricKind.ValueType = ...
        """The value stream kind."""

        unit: typing.Text = ...
        """The unit in which `time_series` point values are reported. `unit`
        follows the UCUM format for units as seen in
        https://unitsofmeasure.org/ucum.html.
        `unit` is only valid if `value_type` is INTEGER, DOUBLE, DISTRIBUTION.
        """

        def __init__(self,
            *,
            key : typing.Text = ...,
            value_type : google.api.metric_pb2.MetricDescriptor.ValueType.ValueType = ...,
            metric_kind : google.api.metric_pb2.MetricDescriptor.MetricKind.ValueType = ...,
            unit : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","metric_kind",b"metric_kind","unit",b"unit","value_type",b"value_type"]) -> None: ...

    LABEL_DESCRIPTORS_FIELD_NUMBER: builtins.int
    POINT_DESCRIPTORS_FIELD_NUMBER: builtins.int
    @property
    def label_descriptors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.api.label_pb2.LabelDescriptor]:
        """Descriptors for the labels."""
        pass
    @property
    def point_descriptors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TimeSeriesDescriptor.ValueDescriptor]:
        """Descriptors for the point data value columns."""
        pass
    def __init__(self,
        *,
        label_descriptors : typing.Optional[typing.Iterable[google.api.label_pb2.LabelDescriptor]] = ...,
        point_descriptors : typing.Optional[typing.Iterable[global___TimeSeriesDescriptor.ValueDescriptor]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["label_descriptors",b"label_descriptors","point_descriptors",b"point_descriptors"]) -> None: ...
global___TimeSeriesDescriptor = TimeSeriesDescriptor

class TimeSeriesData(google.protobuf.message.Message):
    """Represents the values of a time series associated with a
    TimeSeriesDescriptor.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class PointData(google.protobuf.message.Message):
        """A point's value columns and time interval. Each point has one or more
        point values corresponding to the entries in `point_descriptors` field in
        the TimeSeriesDescriptor associated with this object.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        VALUES_FIELD_NUMBER: builtins.int
        TIME_INTERVAL_FIELD_NUMBER: builtins.int
        @property
        def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.monitoring.v3.common_pb2.TypedValue]:
            """The values that make up the point."""
            pass
        @property
        def time_interval(self) -> google.monitoring.v3.common_pb2.TimeInterval:
            """The time interval associated with the point."""
            pass
        def __init__(self,
            *,
            values : typing.Optional[typing.Iterable[google.monitoring.v3.common_pb2.TypedValue]] = ...,
            time_interval : typing.Optional[google.monitoring.v3.common_pb2.TimeInterval] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["time_interval",b"time_interval"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["time_interval",b"time_interval","values",b"values"]) -> None: ...

    LABEL_VALUES_FIELD_NUMBER: builtins.int
    POINT_DATA_FIELD_NUMBER: builtins.int
    @property
    def label_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LabelValue]:
        """The values of the labels in the time series identifier, given in the same
        order as the `label_descriptors` field of the TimeSeriesDescriptor
        associated with this object. Each value must have a value of the type
        given in the corresponding entry of `label_descriptors`.
        """
        pass
    @property
    def point_data(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TimeSeriesData.PointData]:
        """The points in the time series."""
        pass
    def __init__(self,
        *,
        label_values : typing.Optional[typing.Iterable[global___LabelValue]] = ...,
        point_data : typing.Optional[typing.Iterable[global___TimeSeriesData.PointData]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["label_values",b"label_values","point_data",b"point_data"]) -> None: ...
global___TimeSeriesData = TimeSeriesData

class LabelValue(google.protobuf.message.Message):
    """A label value."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    BOOL_VALUE_FIELD_NUMBER: builtins.int
    INT64_VALUE_FIELD_NUMBER: builtins.int
    STRING_VALUE_FIELD_NUMBER: builtins.int
    bool_value: builtins.bool = ...
    """A bool label value."""

    int64_value: builtins.int = ...
    """An int64 label value."""

    string_value: typing.Text = ...
    """A string label value."""

    def __init__(self,
        *,
        bool_value : builtins.bool = ...,
        int64_value : builtins.int = ...,
        string_value : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bool_value",b"bool_value","int64_value",b"int64_value","string_value",b"string_value","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bool_value",b"bool_value","int64_value",b"int64_value","string_value",b"string_value","value",b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["value",b"value"]) -> typing.Optional[typing_extensions.Literal["bool_value","int64_value","string_value"]]: ...
global___LabelValue = LabelValue

class QueryError(google.protobuf.message.Message):
    """An error associated with a query in the time series query language format."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LOCATOR_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    @property
    def locator(self) -> global___TextLocator:
        """The location of the time series query language text that this error applies
        to.
        """
        pass
    message: typing.Text = ...
    """The error message."""

    def __init__(self,
        *,
        locator : typing.Optional[global___TextLocator] = ...,
        message : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["locator",b"locator"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["locator",b"locator","message",b"message"]) -> None: ...
global___QueryError = QueryError

class TextLocator(google.protobuf.message.Message):
    """A locator for text. Indicates a particular part of the text of a request or
    of an object referenced in the request.

    For example, suppose the request field `text` contains:

      text: "The quick brown fox jumps over the lazy dog."

    Then the locator:

      source: "text"
      start_position {
        line: 1
        column: 17
      }
      end_position {
        line: 1
        column: 19
      }

    refers to the part of the text: "fox".
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Position(google.protobuf.message.Message):
        """The position of a byte within the text."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        LINE_FIELD_NUMBER: builtins.int
        COLUMN_FIELD_NUMBER: builtins.int
        line: builtins.int = ...
        """The line, starting with 1, where the byte is positioned."""

        column: builtins.int = ...
        """The column within the line, starting with 1, where the byte is
        positioned. This is a byte index even though the text is UTF-8.
        """

        def __init__(self,
            *,
            line : builtins.int = ...,
            column : builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["column",b"column","line",b"line"]) -> None: ...

    SOURCE_FIELD_NUMBER: builtins.int
    START_POSITION_FIELD_NUMBER: builtins.int
    END_POSITION_FIELD_NUMBER: builtins.int
    NESTED_LOCATOR_FIELD_NUMBER: builtins.int
    NESTING_REASON_FIELD_NUMBER: builtins.int
    source: typing.Text = ...
    """The source of the text. The source may be a field in the request, in which
    case its format is the format of the
    google.rpc.BadRequest.FieldViolation.field field in
    https://cloud.google.com/apis/design/errors#error_details. It may also be
    be a source other than the request field (e.g. a macro definition
    referenced in the text of the query), in which case this is the name of
    the source (e.g. the macro name).
    """

    @property
    def start_position(self) -> global___TextLocator.Position:
        """The position of the first byte within the text."""
        pass
    @property
    def end_position(self) -> global___TextLocator.Position:
        """The position of the last byte within the text."""
        pass
    @property
    def nested_locator(self) -> global___TextLocator:
        """If `source`, `start_position`, and `end_position` describe a call on
        some object (e.g. a macro in the time series query language text) and a
        location is to be designated in that object's text, `nested_locator`
        identifies the location within that object.
        """
        pass
    nesting_reason: typing.Text = ...
    """When `nested_locator` is set, this field gives the reason for the nesting.
    Usually, the reason is a macro invocation. In that case, the macro name
    (including the leading '@') signals the location of the macro call
    in the text and a macro argument name (including the leading '$') signals
    the location of the macro argument inside the macro body that got
    substituted away.
    """

    def __init__(self,
        *,
        source : typing.Text = ...,
        start_position : typing.Optional[global___TextLocator.Position] = ...,
        end_position : typing.Optional[global___TextLocator.Position] = ...,
        nested_locator : typing.Optional[global___TextLocator] = ...,
        nesting_reason : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_position",b"end_position","nested_locator",b"nested_locator","start_position",b"start_position"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["end_position",b"end_position","nested_locator",b"nested_locator","nesting_reason",b"nesting_reason","source",b"source","start_position",b"start_position"]) -> None: ...
global___TextLocator = TextLocator
