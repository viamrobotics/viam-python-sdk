"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.monitoring.dashboard.v1.common_pb2
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _SparkChartType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _SparkChartTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SparkChartType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    SPARK_CHART_TYPE_UNSPECIFIED: SparkChartType.ValueType = ...  # 0
    """Not allowed in well-formed requests."""

    SPARK_LINE: SparkChartType.ValueType = ...  # 1
    """The sparkline will be rendered as a small line chart."""

    SPARK_BAR: SparkChartType.ValueType = ...  # 2
    """The sparkbar will be rendered as a small bar chart."""

class SparkChartType(_SparkChartType, metaclass=_SparkChartTypeEnumTypeWrapper):
    """Defines the possible types of spark chart supported by the `Scorecard`."""
    pass

SPARK_CHART_TYPE_UNSPECIFIED: SparkChartType.ValueType = ...  # 0
"""Not allowed in well-formed requests."""

SPARK_LINE: SparkChartType.ValueType = ...  # 1
"""The sparkline will be rendered as a small line chart."""

SPARK_BAR: SparkChartType.ValueType = ...  # 2
"""The sparkbar will be rendered as a small bar chart."""

global___SparkChartType = SparkChartType


class TimeSeriesQuery(google.protobuf.message.Message):
    """TimeSeriesQuery collects the set of supported methods for querying time
    series data from the Stackdriver metrics API.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TIME_SERIES_FILTER_FIELD_NUMBER: builtins.int
    TIME_SERIES_FILTER_RATIO_FIELD_NUMBER: builtins.int
    TIME_SERIES_QUERY_LANGUAGE_FIELD_NUMBER: builtins.int
    UNIT_OVERRIDE_FIELD_NUMBER: builtins.int
    @property
    def time_series_filter(self) -> global___TimeSeriesFilter:
        """Filter parameters to fetch time series."""
        pass
    @property
    def time_series_filter_ratio(self) -> global___TimeSeriesFilterRatio:
        """Parameters to fetch a ratio between two time series filters."""
        pass
    time_series_query_language: typing.Text = ...
    """A query used to fetch time series."""

    unit_override: typing.Text = ...
    """The unit of data contained in fetched time series. If non-empty, this
    unit will override any unit that accompanies fetched data. The format is
    the same as the
    [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors)
    field in `MetricDescriptor`.
    """

    def __init__(self,
        *,
        time_series_filter : typing.Optional[global___TimeSeriesFilter] = ...,
        time_series_filter_ratio : typing.Optional[global___TimeSeriesFilterRatio] = ...,
        time_series_query_language : typing.Text = ...,
        unit_override : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["source",b"source","time_series_filter",b"time_series_filter","time_series_filter_ratio",b"time_series_filter_ratio","time_series_query_language",b"time_series_query_language"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["source",b"source","time_series_filter",b"time_series_filter","time_series_filter_ratio",b"time_series_filter_ratio","time_series_query_language",b"time_series_query_language","unit_override",b"unit_override"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["time_series_filter","time_series_filter_ratio","time_series_query_language"]]: ...
global___TimeSeriesQuery = TimeSeriesQuery

class TimeSeriesFilter(google.protobuf.message.Message):
    """A filter that defines a subset of time series data that is displayed in a
    widget. Time series data is fetched using the
    [`ListTimeSeries`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
    method.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FILTER_FIELD_NUMBER: builtins.int
    AGGREGATION_FIELD_NUMBER: builtins.int
    SECONDARY_AGGREGATION_FIELD_NUMBER: builtins.int
    PICK_TIME_SERIES_FILTER_FIELD_NUMBER: builtins.int
    STATISTICAL_TIME_SERIES_FILTER_FIELD_NUMBER: builtins.int
    filter: typing.Text = ...
    """Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    that identifies the metric types, resources, and projects to query.
    """

    @property
    def aggregation(self) -> google.monitoring.dashboard.v1.common_pb2.Aggregation:
        """By default, the raw time series data is returned.
        Use this field to combine multiple time series for different views of the
        data.
        """
        pass
    @property
    def secondary_aggregation(self) -> google.monitoring.dashboard.v1.common_pb2.Aggregation:
        """Apply a second aggregation after `aggregation` is applied."""
        pass
    @property
    def pick_time_series_filter(self) -> google.monitoring.dashboard.v1.common_pb2.PickTimeSeriesFilter:
        """Ranking based time series filter."""
        pass
    @property
    def statistical_time_series_filter(self) -> google.monitoring.dashboard.v1.common_pb2.StatisticalTimeSeriesFilter:
        """Statistics based time series filter.
        Note: This field is deprecated and completely ignored by the API.
        """
        pass
    def __init__(self,
        *,
        filter : typing.Text = ...,
        aggregation : typing.Optional[google.monitoring.dashboard.v1.common_pb2.Aggregation] = ...,
        secondary_aggregation : typing.Optional[google.monitoring.dashboard.v1.common_pb2.Aggregation] = ...,
        pick_time_series_filter : typing.Optional[google.monitoring.dashboard.v1.common_pb2.PickTimeSeriesFilter] = ...,
        statistical_time_series_filter : typing.Optional[google.monitoring.dashboard.v1.common_pb2.StatisticalTimeSeriesFilter] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["aggregation",b"aggregation","output_filter",b"output_filter","pick_time_series_filter",b"pick_time_series_filter","secondary_aggregation",b"secondary_aggregation","statistical_time_series_filter",b"statistical_time_series_filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["aggregation",b"aggregation","filter",b"filter","output_filter",b"output_filter","pick_time_series_filter",b"pick_time_series_filter","secondary_aggregation",b"secondary_aggregation","statistical_time_series_filter",b"statistical_time_series_filter"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["output_filter",b"output_filter"]) -> typing.Optional[typing_extensions.Literal["pick_time_series_filter","statistical_time_series_filter"]]: ...
global___TimeSeriesFilter = TimeSeriesFilter

class TimeSeriesFilterRatio(google.protobuf.message.Message):
    """A pair of time series filters that define a ratio computation. The output
    time series is the pair-wise division of each aligned element from the
    numerator and denominator time series.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class RatioPart(google.protobuf.message.Message):
        """Describes a query to build the numerator or denominator of a
        TimeSeriesFilterRatio.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FILTER_FIELD_NUMBER: builtins.int
        AGGREGATION_FIELD_NUMBER: builtins.int
        filter: typing.Text = ...
        """Required. The [monitoring
        filter](https://cloud.google.com/monitoring/api/v3/filters) that
        identifies the metric types, resources, and projects to query.
        """

        @property
        def aggregation(self) -> google.monitoring.dashboard.v1.common_pb2.Aggregation:
            """By default, the raw time series data is returned.
            Use this field to combine multiple time series for different views of the
            data.
            """
            pass
        def __init__(self,
            *,
            filter : typing.Text = ...,
            aggregation : typing.Optional[google.monitoring.dashboard.v1.common_pb2.Aggregation] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["aggregation",b"aggregation"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["aggregation",b"aggregation","filter",b"filter"]) -> None: ...

    NUMERATOR_FIELD_NUMBER: builtins.int
    DENOMINATOR_FIELD_NUMBER: builtins.int
    SECONDARY_AGGREGATION_FIELD_NUMBER: builtins.int
    PICK_TIME_SERIES_FILTER_FIELD_NUMBER: builtins.int
    STATISTICAL_TIME_SERIES_FILTER_FIELD_NUMBER: builtins.int
    @property
    def numerator(self) -> global___TimeSeriesFilterRatio.RatioPart:
        """The numerator of the ratio."""
        pass
    @property
    def denominator(self) -> global___TimeSeriesFilterRatio.RatioPart:
        """The denominator of the ratio."""
        pass
    @property
    def secondary_aggregation(self) -> google.monitoring.dashboard.v1.common_pb2.Aggregation:
        """Apply a second aggregation after the ratio is computed."""
        pass
    @property
    def pick_time_series_filter(self) -> google.monitoring.dashboard.v1.common_pb2.PickTimeSeriesFilter:
        """Ranking based time series filter."""
        pass
    @property
    def statistical_time_series_filter(self) -> google.monitoring.dashboard.v1.common_pb2.StatisticalTimeSeriesFilter:
        """Statistics based time series filter.
        Note: This field is deprecated and completely ignored by the API.
        """
        pass
    def __init__(self,
        *,
        numerator : typing.Optional[global___TimeSeriesFilterRatio.RatioPart] = ...,
        denominator : typing.Optional[global___TimeSeriesFilterRatio.RatioPart] = ...,
        secondary_aggregation : typing.Optional[google.monitoring.dashboard.v1.common_pb2.Aggregation] = ...,
        pick_time_series_filter : typing.Optional[google.monitoring.dashboard.v1.common_pb2.PickTimeSeriesFilter] = ...,
        statistical_time_series_filter : typing.Optional[google.monitoring.dashboard.v1.common_pb2.StatisticalTimeSeriesFilter] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["denominator",b"denominator","numerator",b"numerator","output_filter",b"output_filter","pick_time_series_filter",b"pick_time_series_filter","secondary_aggregation",b"secondary_aggregation","statistical_time_series_filter",b"statistical_time_series_filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["denominator",b"denominator","numerator",b"numerator","output_filter",b"output_filter","pick_time_series_filter",b"pick_time_series_filter","secondary_aggregation",b"secondary_aggregation","statistical_time_series_filter",b"statistical_time_series_filter"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["output_filter",b"output_filter"]) -> typing.Optional[typing_extensions.Literal["pick_time_series_filter","statistical_time_series_filter"]]: ...
global___TimeSeriesFilterRatio = TimeSeriesFilterRatio

class Threshold(google.protobuf.message.Message):
    """Defines a threshold for categorizing time series values."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Color:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ColorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Color.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        COLOR_UNSPECIFIED: Threshold.Color.ValueType = ...  # 0
        """Color is unspecified. Not allowed in well-formed requests."""

        YELLOW: Threshold.Color.ValueType = ...  # 4
        """Crossing the threshold is "concerning" behavior."""

        RED: Threshold.Color.ValueType = ...  # 6
        """Crossing the threshold is "emergency" behavior."""

    class Color(_Color, metaclass=_ColorEnumTypeWrapper):
        """The color suggests an interpretation to the viewer when actual values cross
        the threshold. Comments on each color provide UX guidance on how users can
        be expected to interpret a given state color.
        """
        pass

    COLOR_UNSPECIFIED: Threshold.Color.ValueType = ...  # 0
    """Color is unspecified. Not allowed in well-formed requests."""

    YELLOW: Threshold.Color.ValueType = ...  # 4
    """Crossing the threshold is "concerning" behavior."""

    RED: Threshold.Color.ValueType = ...  # 6
    """Crossing the threshold is "emergency" behavior."""


    class _Direction:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _DirectionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Direction.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        DIRECTION_UNSPECIFIED: Threshold.Direction.ValueType = ...  # 0
        """Not allowed in well-formed requests."""

        ABOVE: Threshold.Direction.ValueType = ...  # 1
        """The threshold will be considered crossed if the actual value is above
        the threshold value.
        """

        BELOW: Threshold.Direction.ValueType = ...  # 2
        """The threshold will be considered crossed if the actual value is below
        the threshold value.
        """

    class Direction(_Direction, metaclass=_DirectionEnumTypeWrapper):
        """Whether the threshold is considered crossed by an actual value above or
        below its threshold value.
        """
        pass

    DIRECTION_UNSPECIFIED: Threshold.Direction.ValueType = ...  # 0
    """Not allowed in well-formed requests."""

    ABOVE: Threshold.Direction.ValueType = ...  # 1
    """The threshold will be considered crossed if the actual value is above
    the threshold value.
    """

    BELOW: Threshold.Direction.ValueType = ...  # 2
    """The threshold will be considered crossed if the actual value is below
    the threshold value.
    """


    LABEL_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    COLOR_FIELD_NUMBER: builtins.int
    DIRECTION_FIELD_NUMBER: builtins.int
    label: typing.Text = ...
    """A label for the threshold."""

    value: builtins.float = ...
    """The value of the threshold. The value should be defined in the native scale
    of the metric.
    """

    color: global___Threshold.Color.ValueType = ...
    """The state color for this threshold. Color is not allowed in a XyChart."""

    direction: global___Threshold.Direction.ValueType = ...
    """The direction for the current threshold. Direction is not allowed in a
    XyChart.
    """

    def __init__(self,
        *,
        label : typing.Text = ...,
        value : builtins.float = ...,
        color : global___Threshold.Color.ValueType = ...,
        direction : global___Threshold.Direction.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["color",b"color","direction",b"direction","label",b"label","value",b"value"]) -> None: ...
global___Threshold = Threshold
