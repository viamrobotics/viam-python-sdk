"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _TypeCode:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _TypeCodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TypeCode.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    TYPE_CODE_UNSPECIFIED: TypeCode.ValueType = ...  # 0
    """Not specified."""

    BOOL: TypeCode.ValueType = ...  # 1
    """Encoded as JSON `true` or `false`."""

    INT64: TypeCode.ValueType = ...  # 2
    """Encoded as `string`, in decimal format."""

    FLOAT64: TypeCode.ValueType = ...  # 3
    """Encoded as `number`, or the strings `"NaN"`, `"Infinity"`, or
    `"-Infinity"`.
    """

    TIMESTAMP: TypeCode.ValueType = ...  # 4
    """Encoded as `string` in RFC 3339 timestamp format. The time zone
    must be present, and must be `"Z"`.

    If the schema has the column option
    `allow_commit_timestamp=true`, the placeholder string
    `"spanner.commit_timestamp()"` can be used to instruct the system
    to insert the commit timestamp associated with the transaction
    commit.
    """

    DATE: TypeCode.ValueType = ...  # 5
    """Encoded as `string` in RFC 3339 date format."""

    STRING: TypeCode.ValueType = ...  # 6
    """Encoded as `string`."""

    BYTES: TypeCode.ValueType = ...  # 7
    """Encoded as a base64-encoded `string`, as described in RFC 4648,
    section 4.
    """

    ARRAY: TypeCode.ValueType = ...  # 8
    """Encoded as `list`, where the list elements are represented
    according to
    [array_element_type][google.spanner.v1.Type.array_element_type].
    """

    STRUCT: TypeCode.ValueType = ...  # 9
    """Encoded as `list`, where list element `i` is represented according
    to [struct_type.fields[i]][google.spanner.v1.StructType.fields].
    """

    NUMERIC: TypeCode.ValueType = ...  # 10
    """Encoded as `string`, in decimal format or scientific notation format.
    <br>Decimal format:
    <br>`[+-]Digits[.[Digits]]` or
    <br>`[+-][Digits].Digits`

    Scientific notation:
    <br>`[+-]Digits[.[Digits]][ExponentIndicator[+-]Digits]` or
    <br>`[+-][Digits].Digits[ExponentIndicator[+-]Digits]`
    <br>(ExponentIndicator is `"e"` or `"E"`)
    """

    JSON: TypeCode.ValueType = ...  # 11
    """Encoded as a JSON-formatted `string` as described in RFC 7159. The
    following rules are applied when parsing JSON input:

    - Whitespace characters are not preserved.
    - If a JSON object has duplicate keys, only the first key is preserved.
    - Members of a JSON object are not guaranteed to have their order
      preserved.
    - JSON array elements will have their order preserved.
    """

class TypeCode(_TypeCode, metaclass=_TypeCodeEnumTypeWrapper):
    """`TypeCode` is used as part of [Type][google.spanner.v1.Type] to
    indicate the type of a Cloud Spanner value.

    Each legal value of a type can be encoded to or decoded from a JSON
    value, using the encodings described below. All Cloud Spanner values can
    be `null`, regardless of type; `null`s are always encoded as a JSON
    `null`.
    """
    pass

TYPE_CODE_UNSPECIFIED: TypeCode.ValueType = ...  # 0
"""Not specified."""

BOOL: TypeCode.ValueType = ...  # 1
"""Encoded as JSON `true` or `false`."""

INT64: TypeCode.ValueType = ...  # 2
"""Encoded as `string`, in decimal format."""

FLOAT64: TypeCode.ValueType = ...  # 3
"""Encoded as `number`, or the strings `"NaN"`, `"Infinity"`, or
`"-Infinity"`.
"""

TIMESTAMP: TypeCode.ValueType = ...  # 4
"""Encoded as `string` in RFC 3339 timestamp format. The time zone
must be present, and must be `"Z"`.

If the schema has the column option
`allow_commit_timestamp=true`, the placeholder string
`"spanner.commit_timestamp()"` can be used to instruct the system
to insert the commit timestamp associated with the transaction
commit.
"""

DATE: TypeCode.ValueType = ...  # 5
"""Encoded as `string` in RFC 3339 date format."""

STRING: TypeCode.ValueType = ...  # 6
"""Encoded as `string`."""

BYTES: TypeCode.ValueType = ...  # 7
"""Encoded as a base64-encoded `string`, as described in RFC 4648,
section 4.
"""

ARRAY: TypeCode.ValueType = ...  # 8
"""Encoded as `list`, where the list elements are represented
according to
[array_element_type][google.spanner.v1.Type.array_element_type].
"""

STRUCT: TypeCode.ValueType = ...  # 9
"""Encoded as `list`, where list element `i` is represented according
to [struct_type.fields[i]][google.spanner.v1.StructType.fields].
"""

NUMERIC: TypeCode.ValueType = ...  # 10
"""Encoded as `string`, in decimal format or scientific notation format.
<br>Decimal format:
<br>`[+-]Digits[.[Digits]]` or
<br>`[+-][Digits].Digits`

Scientific notation:
<br>`[+-]Digits[.[Digits]][ExponentIndicator[+-]Digits]` or
<br>`[+-][Digits].Digits[ExponentIndicator[+-]Digits]`
<br>(ExponentIndicator is `"e"` or `"E"`)
"""

JSON: TypeCode.ValueType = ...  # 11
"""Encoded as a JSON-formatted `string` as described in RFC 7159. The
following rules are applied when parsing JSON input:

- Whitespace characters are not preserved.
- If a JSON object has duplicate keys, only the first key is preserved.
- Members of a JSON object are not guaranteed to have their order
  preserved.
- JSON array elements will have their order preserved.
"""

global___TypeCode = TypeCode


class _TypeAnnotationCode:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _TypeAnnotationCodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TypeAnnotationCode.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    TYPE_ANNOTATION_CODE_UNSPECIFIED: TypeAnnotationCode.ValueType = ...  # 0
    """Not specified."""

    PG_NUMERIC: TypeAnnotationCode.ValueType = ...  # 2
    """PostgreSQL compatible NUMERIC type. This annotation needs to be applied to
    [Type][google.spanner.v1.Type] instances having [NUMERIC][google.spanner.v1.TypeCode.NUMERIC]
    type code to specify that values of this type should be treated as
    PostgreSQL NUMERIC values. Currently this annotation is always needed for
    [NUMERIC][google.spanner.v1.TypeCode.NUMERIC] when a client interacts with PostgreSQL-enabled
    Spanner databases.
    """

class TypeAnnotationCode(_TypeAnnotationCode, metaclass=_TypeAnnotationCodeEnumTypeWrapper):
    """`TypeAnnotationCode` is used as a part of [Type][google.spanner.v1.Type] to
    disambiguate SQL types that should be used for a given Cloud Spanner value.
    Disambiguation is needed because the same Cloud Spanner type can be mapped to
    different SQL types depending on SQL dialect. TypeAnnotationCode doesn't
    affect the way value is serialized.
    """
    pass

TYPE_ANNOTATION_CODE_UNSPECIFIED: TypeAnnotationCode.ValueType = ...  # 0
"""Not specified."""

PG_NUMERIC: TypeAnnotationCode.ValueType = ...  # 2
"""PostgreSQL compatible NUMERIC type. This annotation needs to be applied to
[Type][google.spanner.v1.Type] instances having [NUMERIC][google.spanner.v1.TypeCode.NUMERIC]
type code to specify that values of this type should be treated as
PostgreSQL NUMERIC values. Currently this annotation is always needed for
[NUMERIC][google.spanner.v1.TypeCode.NUMERIC] when a client interacts with PostgreSQL-enabled
Spanner databases.
"""

global___TypeAnnotationCode = TypeAnnotationCode


class Type(google.protobuf.message.Message):
    """`Type` indicates the type of a Cloud Spanner value, as might be stored in a
    table cell or returned from an SQL query.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CODE_FIELD_NUMBER: builtins.int
    ARRAY_ELEMENT_TYPE_FIELD_NUMBER: builtins.int
    STRUCT_TYPE_FIELD_NUMBER: builtins.int
    TYPE_ANNOTATION_FIELD_NUMBER: builtins.int
    code: global___TypeCode.ValueType = ...
    """Required. The [TypeCode][google.spanner.v1.TypeCode] for this type."""

    @property
    def array_element_type(self) -> global___Type:
        """If [code][google.spanner.v1.Type.code] == [ARRAY][google.spanner.v1.TypeCode.ARRAY], then `array_element_type`
        is the type of the array elements.
        """
        pass
    @property
    def struct_type(self) -> global___StructType:
        """If [code][google.spanner.v1.Type.code] == [STRUCT][google.spanner.v1.TypeCode.STRUCT], then `struct_type`
        provides type information for the struct's fields.
        """
        pass
    type_annotation: global___TypeAnnotationCode.ValueType = ...
    """The [TypeAnnotationCode][google.spanner.v1.TypeAnnotationCode] that disambiguates SQL type that Spanner will
    use to represent values of this type during query processing. This is
    necessary for some type codes because a single [TypeCode][google.spanner.v1.TypeCode] can be mapped
    to different SQL types depending on the SQL dialect. [type_annotation][google.spanner.v1.Type.type_annotation]
    typically is not needed to process the content of a value (it doesn't
    affect serialization) and clients can ignore it on the read path.
    """

    def __init__(self,
        *,
        code : global___TypeCode.ValueType = ...,
        array_element_type : typing.Optional[global___Type] = ...,
        struct_type : typing.Optional[global___StructType] = ...,
        type_annotation : global___TypeAnnotationCode.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["array_element_type",b"array_element_type","struct_type",b"struct_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["array_element_type",b"array_element_type","code",b"code","struct_type",b"struct_type","type_annotation",b"type_annotation"]) -> None: ...
global___Type = Type

class StructType(google.protobuf.message.Message):
    """`StructType` defines the fields of a [STRUCT][google.spanner.v1.TypeCode.STRUCT] type."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Field(google.protobuf.message.Message):
        """Message representing a single field of a struct."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        NAME_FIELD_NUMBER: builtins.int
        TYPE_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        """The name of the field. For reads, this is the column name. For
        SQL queries, it is the column alias (e.g., `"Word"` in the
        query `"SELECT 'hello' AS Word"`), or the column name (e.g.,
        `"ColName"` in the query `"SELECT ColName FROM Table"`). Some
        columns might have an empty name (e.g., `"SELECT
        UPPER(ColName)"`). Note that a query result can contain
        multiple fields with the same name.
        """

        @property
        def type(self) -> global___Type:
            """The type of the field."""
            pass
        def __init__(self,
            *,
            name : typing.Text = ...,
            type : typing.Optional[global___Type] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["type",b"type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["name",b"name","type",b"type"]) -> None: ...

    FIELDS_FIELD_NUMBER: builtins.int
    @property
    def fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StructType.Field]:
        """The list of fields that make up this struct. Order is
        significant, because values of this struct type are represented as
        lists, where the order of field values matches the order of
        fields in the [StructType][google.spanner.v1.StructType]. In turn, the order of fields
        matches the order of columns in a read request, or the order of
        fields in the `SELECT` clause of a query.
        """
        pass
    def __init__(self,
        *,
        fields : typing.Optional[typing.Iterable[global___StructType.Field]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["fields",b"fields"]) -> None: ...
global___StructType = StructType
