"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _NoteKind:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _NoteKindEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_NoteKind.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    NOTE_KIND_UNSPECIFIED: NoteKind.ValueType = ...  # 0
    """Default value. This value is unused."""

    VULNERABILITY: NoteKind.ValueType = ...  # 1
    """The note and occurrence represent a package vulnerability."""

    BUILD: NoteKind.ValueType = ...  # 2
    """The note and occurrence assert build provenance."""

    IMAGE: NoteKind.ValueType = ...  # 3
    """This represents an image basis relationship."""

    PACKAGE: NoteKind.ValueType = ...  # 4
    """This represents a package installed via a package manager."""

    DEPLOYMENT: NoteKind.ValueType = ...  # 5
    """The note and occurrence track deployment events."""

    DISCOVERY: NoteKind.ValueType = ...  # 6
    """The note and occurrence track the initial discovery status of a resource."""

    ATTESTATION: NoteKind.ValueType = ...  # 7
    """This represents a logical "role" that can attest to artifacts."""

    UPGRADE: NoteKind.ValueType = ...  # 8
    """This represents an available package upgrade."""

    COMPLIANCE: NoteKind.ValueType = ...  # 9
    """This represents a Compliance Note"""

    DSSE_ATTESTATION: NoteKind.ValueType = ...  # 10
    """This represents a DSSE attestation Note"""

class NoteKind(_NoteKind, metaclass=_NoteKindEnumTypeWrapper):
    """Kind represents the kinds of notes supported."""
    pass

NOTE_KIND_UNSPECIFIED: NoteKind.ValueType = ...  # 0
"""Default value. This value is unused."""

VULNERABILITY: NoteKind.ValueType = ...  # 1
"""The note and occurrence represent a package vulnerability."""

BUILD: NoteKind.ValueType = ...  # 2
"""The note and occurrence assert build provenance."""

IMAGE: NoteKind.ValueType = ...  # 3
"""This represents an image basis relationship."""

PACKAGE: NoteKind.ValueType = ...  # 4
"""This represents a package installed via a package manager."""

DEPLOYMENT: NoteKind.ValueType = ...  # 5
"""The note and occurrence track deployment events."""

DISCOVERY: NoteKind.ValueType = ...  # 6
"""The note and occurrence track the initial discovery status of a resource."""

ATTESTATION: NoteKind.ValueType = ...  # 7
"""This represents a logical "role" that can attest to artifacts."""

UPGRADE: NoteKind.ValueType = ...  # 8
"""This represents an available package upgrade."""

COMPLIANCE: NoteKind.ValueType = ...  # 9
"""This represents a Compliance Note"""

DSSE_ATTESTATION: NoteKind.ValueType = ...  # 10
"""This represents a DSSE attestation Note"""

global___NoteKind = NoteKind


class RelatedUrl(google.protobuf.message.Message):
    """Metadata for any related URL information."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    URL_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    url: typing.Text = ...
    """Specific URL associated with the resource."""

    label: typing.Text = ...
    """Label to describe usage of the URL."""

    def __init__(self,
        *,
        url : typing.Text = ...,
        label : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["label",b"label","url",b"url"]) -> None: ...
global___RelatedUrl = RelatedUrl

class Signature(google.protobuf.message.Message):
    """Verifiers (e.g. Kritis implementations) MUST verify signatures
    with respect to the trust anchors defined in policy (e.g. a Kritis policy).
    Typically this means that the verifier has been configured with a map from
    `public_key_id` to public key material (and any required parameters, e.g.
    signing algorithm).

    In particular, verification implementations MUST NOT treat the signature
    `public_key_id` as anything more than a key lookup hint. The `public_key_id`
    DOES NOT validate or authenticate a public key; it only provides a mechanism
    for quickly selecting a public key ALREADY CONFIGURED on the verifier through
    a trusted channel. Verification implementations MUST reject signatures in any
    of the following circumstances:
      * The `public_key_id` is not recognized by the verifier.
      * The public key that `public_key_id` refers to does not verify the
        signature with respect to the payload.

    The `signature` contents SHOULD NOT be "attached" (where the payload is
    included with the serialized `signature` bytes). Verifiers MUST ignore any
    "attached" payload and only verify signatures with respect to explicitly
    provided payload (e.g. a `payload` field on the proto message that holds
    this Signature, or the canonical serialization of the proto message that
    holds this signature).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SIGNATURE_FIELD_NUMBER: builtins.int
    PUBLIC_KEY_ID_FIELD_NUMBER: builtins.int
    signature: builtins.bytes = ...
    """The content of the signature, an opaque bytestring.
    The payload that this signature verifies MUST be unambiguously provided
    with the Signature during verification. A wrapper message might provide
    the payload explicitly. Alternatively, a message might have a canonical
    serialization that can always be unambiguously computed to derive the
    payload.
    """

    public_key_id: typing.Text = ...
    """The identifier for the public key that verifies this signature.
      * The `public_key_id` is required.
      * The `public_key_id` SHOULD be an RFC3986 conformant URI.
      * When possible, the `public_key_id` SHOULD be an immutable reference,
        such as a cryptographic digest.

    Examples of valid `public_key_id`s:

    OpenPGP V4 public key fingerprint:
      * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA"
    See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
    details on this scheme.

    RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
    serialization):
      * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU"
      * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
    """

    def __init__(self,
        *,
        signature : builtins.bytes = ...,
        public_key_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["public_key_id",b"public_key_id","signature",b"signature"]) -> None: ...
global___Signature = Signature

class Envelope(google.protobuf.message.Message):
    """MUST match
    https://github.com/secure-systems-lab/dsse/blob/master/envelope.proto. An
    authenticated message of arbitrary type.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PAYLOAD_FIELD_NUMBER: builtins.int
    PAYLOAD_TYPE_FIELD_NUMBER: builtins.int
    SIGNATURES_FIELD_NUMBER: builtins.int
    payload: builtins.bytes = ...
    payload_type: typing.Text = ...
    @property
    def signatures(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EnvelopeSignature]: ...
    def __init__(self,
        *,
        payload : builtins.bytes = ...,
        payload_type : typing.Text = ...,
        signatures : typing.Optional[typing.Iterable[global___EnvelopeSignature]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["payload",b"payload","payload_type",b"payload_type","signatures",b"signatures"]) -> None: ...
global___Envelope = Envelope

class EnvelopeSignature(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SIG_FIELD_NUMBER: builtins.int
    KEYID_FIELD_NUMBER: builtins.int
    sig: builtins.bytes = ...
    keyid: typing.Text = ...
    def __init__(self,
        *,
        sig : builtins.bytes = ...,
        keyid : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["keyid",b"keyid","sig",b"sig"]) -> None: ...
global___EnvelopeSignature = EnvelopeSignature
