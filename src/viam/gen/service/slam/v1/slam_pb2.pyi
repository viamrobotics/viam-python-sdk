"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
from .... import common
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import sys
import typing
if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions
DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _MappingMode:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _MappingModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_MappingMode.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    MAPPING_MODE_UNSPECIFIED: _MappingMode.ValueType
    MAPPING_MODE_CREATE_NEW_MAP: _MappingMode.ValueType
    MAPPING_MODE_LOCALIZE_ONLY: _MappingMode.ValueType
    MAPPING_MODE_UPDATE_EXISTING_MAP: _MappingMode.ValueType

class MappingMode(_MappingMode, metaclass=_MappingModeEnumTypeWrapper):
    """MappingMode represnts the various form of mapping and localizing SLAM can perform.
    These include, creating a new map, localizing on an existiing map and updating an
    exisiting map.
    """
MAPPING_MODE_UNSPECIFIED: MappingMode.ValueType
MAPPING_MODE_CREATE_NEW_MAP: MappingMode.ValueType
MAPPING_MODE_LOCALIZE_ONLY: MappingMode.ValueType
MAPPING_MODE_UPDATE_EXISTING_MAP: MappingMode.ValueType
global___MappingMode = MappingMode

class _SensorType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SensorTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SensorType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SENSOR_TYPE_UNSPECIFIED: _SensorType.ValueType
    SENSOR_TYPE_CAMERA: _SensorType.ValueType
    SENSOR_TYPE_MOVEMENT_SENSOR: _SensorType.ValueType

class SensorType(_SensorType, metaclass=_SensorTypeEnumTypeWrapper):
    ...
SENSOR_TYPE_UNSPECIFIED: SensorType.ValueType
SENSOR_TYPE_CAMERA: SensorType.ValueType
SENSOR_TYPE_MOVEMENT_SENSOR: SensorType.ValueType
global___SensorType = SensorType

@typing.final
class GetPositionRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    name: builtins.str
    'Name of slam service'

    def __init__(self, *, name: builtins.str=...) -> None:
        ...

    def ClearField(self, field_name: typing.Literal['name', b'name']) -> None:
        ...
global___GetPositionRequest = GetPositionRequest

@typing.final
class GetPositionResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    POSE_FIELD_NUMBER: builtins.int
    COMPONENT_REFERENCE_FIELD_NUMBER: builtins.int
    EXTRA_FIELD_NUMBER: builtins.int
    component_reference: builtins.str
    'This is usually the name of the camera that is in the SLAM config'

    @property
    def pose(self) -> common.v1.common_pb2.Pose:
        """Current position of the specified component in the SLAM Map"""

    @property
    def extra(self) -> google.protobuf.struct_pb2.Struct:
        """Additional information in the response"""

    def __init__(self, *, pose: common.v1.common_pb2.Pose | None=..., component_reference: builtins.str=..., extra: google.protobuf.struct_pb2.Struct | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['extra', b'extra', 'pose', b'pose']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['component_reference', b'component_reference', 'extra', b'extra', 'pose', b'pose']) -> None:
        ...
global___GetPositionResponse = GetPositionResponse

@typing.final
class GetPointCloudMapRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    RETURN_EDITED_MAP_FIELD_NUMBER: builtins.int
    name: builtins.str
    'Name of slam service'
    return_edited_map: builtins.bool
    'For SLAM services that implement handling an edited map, this boolean\n    should indicate whether to return that edited map. If the SLAM service\n    does not handle edited maps, the unedited map will be returned instead.\n    '

    def __init__(self, *, name: builtins.str=..., return_edited_map: builtins.bool | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['_return_edited_map', b'_return_edited_map', 'return_edited_map', b'return_edited_map']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['_return_edited_map', b'_return_edited_map', 'name', b'name', 'return_edited_map', b'return_edited_map']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['_return_edited_map', b'_return_edited_map']) -> typing.Literal['return_edited_map'] | None:
        ...
global___GetPointCloudMapRequest = GetPointCloudMapRequest

@typing.final
class GetPointCloudMapResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    POINT_CLOUD_PCD_CHUNK_FIELD_NUMBER: builtins.int
    point_cloud_pcd_chunk: builtins.bytes
    'One chunk of the PointCloud.\n    For a given GetPointCloudMap request, concatenating all\n    GetPointCloudMapResponse.point_cloud_pcd_chunk values in the\n    order received result in the complete pointcloud in standard PCD\n    format where XY is the ground plane and positive Z is up, following\n    the Right Hand Rule.\n\n    Read more about the pointcloud format here:\n    https://pointclouds.org/documentation/tutorials/pcd_file_format.html\n\n    Viam expects pointcloud data with fields "x y z" or "x y z rgb", and for\n    this to be specified in the pointcloud header in the FIELDS entry. If color\n    data is included in the pointcloud, Viam\'s services assume that the color\n    value encodes a confidence score for that data point. Viam expects the\n    confidence score to be encoded in the blue parameter of the RGB value, on a\n    scale from 1-100.\n\n    Pointclouds are little endian encoded.\n    '

    def __init__(self, *, point_cloud_pcd_chunk: builtins.bytes=...) -> None:
        ...

    def ClearField(self, field_name: typing.Literal['point_cloud_pcd_chunk', b'point_cloud_pcd_chunk']) -> None:
        ...
global___GetPointCloudMapResponse = GetPointCloudMapResponse

@typing.final
class GetInternalStateRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    name: builtins.str
    'Name of slam service'

    def __init__(self, *, name: builtins.str=...) -> None:
        ...

    def ClearField(self, field_name: typing.Literal['name', b'name']) -> None:
        ...
global___GetInternalStateRequest = GetInternalStateRequest

@typing.final
class GetInternalStateResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    INTERNAL_STATE_CHUNK_FIELD_NUMBER: builtins.int
    internal_state_chunk: builtins.bytes
    'Chunk of the internal state of the SLAM algorithm required to continue\n    mapping/localization\n    '

    def __init__(self, *, internal_state_chunk: builtins.bytes=...) -> None:
        ...

    def ClearField(self, field_name: typing.Literal['internal_state_chunk', b'internal_state_chunk']) -> None:
        ...
global___GetInternalStateResponse = GetInternalStateResponse

@typing.final
class GetPropertiesRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    name: builtins.str
    'Name of the slam service'

    def __init__(self, *, name: builtins.str=...) -> None:
        ...

    def ClearField(self, field_name: typing.Literal['name', b'name']) -> None:
        ...
global___GetPropertiesRequest = GetPropertiesRequest

@typing.final
class GetPropertiesResponse(google.protobuf.message.Message):
    """Returns properties information for the named slam service"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    CLOUD_SLAM_FIELD_NUMBER: builtins.int
    MAPPING_MODE_FIELD_NUMBER: builtins.int
    INTERNAL_STATE_FILE_TYPE_FIELD_NUMBER: builtins.int
    SENSOR_INFO_FIELD_NUMBER: builtins.int
    cloud_slam: builtins.bool
    mapping_mode: global___MappingMode.ValueType
    internal_state_file_type: builtins.str

    @property
    def sensor_info(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SensorInfo]:
        ...

    def __init__(self, *, cloud_slam: builtins.bool=..., mapping_mode: global___MappingMode.ValueType=..., internal_state_file_type: builtins.str | None=..., sensor_info: collections.abc.Iterable[global___SensorInfo] | None=...) -> None:
        ...

    def HasField(self, field_name: typing.Literal['_internal_state_file_type', b'_internal_state_file_type', 'internal_state_file_type', b'internal_state_file_type']) -> builtins.bool:
        ...

    def ClearField(self, field_name: typing.Literal['_internal_state_file_type', b'_internal_state_file_type', 'cloud_slam', b'cloud_slam', 'internal_state_file_type', b'internal_state_file_type', 'mapping_mode', b'mapping_mode', 'sensor_info', b'sensor_info']) -> None:
        ...

    def WhichOneof(self, oneof_group: typing.Literal['_internal_state_file_type', b'_internal_state_file_type']) -> typing.Literal['internal_state_file_type'] | None:
        ...
global___GetPropertiesResponse = GetPropertiesResponse

@typing.final
class SensorInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    name: builtins.str
    type: global___SensorType.ValueType

    def __init__(self, *, name: builtins.str=..., type: global___SensorType.ValueType=...) -> None:
        ...

    def ClearField(self, field_name: typing.Literal['name', b'name', 'type', b'type']) -> None:
        ...
global___SensorInfo = SensorInfo