"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.cloud.integrations.v1alpha.event_parameter_pb2
import google.cloud.integrations.v1alpha.json_validation_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class TaskConfig(google.protobuf.message.Message):
    """The task configuration details. This is not the implementation of Task.
    There might be multiple TaskConfigs for the same Task.
    Next available id: 12
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _NextTasksExecutionPolicy:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _NextTasksExecutionPolicyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_NextTasksExecutionPolicy.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED: TaskConfig.NextTasksExecutionPolicy.ValueType = ...  # 0
        """Default."""

        RUN_ALL_MATCH: TaskConfig.NextTasksExecutionPolicy.ValueType = ...  # 1
        """Execute all the tasks that satisfy their associated condition."""

        RUN_FIRST_MATCH: TaskConfig.NextTasksExecutionPolicy.ValueType = ...  # 2
        """Execute the first task that satisfies the associated condition."""

    class NextTasksExecutionPolicy(_NextTasksExecutionPolicy, metaclass=_NextTasksExecutionPolicyEnumTypeWrapper):
        """Various policies for executing the next set of tasks."""
        pass

    NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED: TaskConfig.NextTasksExecutionPolicy.ValueType = ...  # 0
    """Default."""

    RUN_ALL_MATCH: TaskConfig.NextTasksExecutionPolicy.ValueType = ...  # 1
    """Execute all the tasks that satisfy their associated condition."""

    RUN_FIRST_MATCH: TaskConfig.NextTasksExecutionPolicy.ValueType = ...  # 2
    """Execute the first task that satisfies the associated condition."""


    class _TaskExecutionStrategy:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TaskExecutionStrategyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TaskExecutionStrategy.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        TASK_EXECUTION_STRATEGY_UNSPECIFIED: TaskConfig.TaskExecutionStrategy.ValueType = ...  # 0
        """Default. If the strategy is not set explicitly, it will default to
        `WHEN_ALL_SUCCEED`.
        """

        WHEN_ALL_SUCCEED: TaskConfig.TaskExecutionStrategy.ValueType = ...  # 1
        """Wait until all of its previous tasks finished execution, then verify at
        least one of the edge conditions is met, and execute if possible. This
        should be considered as WHEN_ALL_TASKS_SUCCEED.
        """

        WHEN_ANY_SUCCEED: TaskConfig.TaskExecutionStrategy.ValueType = ...  # 2
        """Start execution as long as any of its previous tasks finished execution
        and the corresponding edge condition is met (since we will execute if
        only that succeeding edge condition is met).
        """

        WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED: TaskConfig.TaskExecutionStrategy.ValueType = ...  # 3
        """Wait until all of its previous tasks finished execution, then verify
        the all edge conditions are met and execute if possible.
        """

    class TaskExecutionStrategy(_TaskExecutionStrategy, metaclass=_TaskExecutionStrategyEnumTypeWrapper):
        """Various policies to trigger the execution of this task."""
        pass

    TASK_EXECUTION_STRATEGY_UNSPECIFIED: TaskConfig.TaskExecutionStrategy.ValueType = ...  # 0
    """Default. If the strategy is not set explicitly, it will default to
    `WHEN_ALL_SUCCEED`.
    """

    WHEN_ALL_SUCCEED: TaskConfig.TaskExecutionStrategy.ValueType = ...  # 1
    """Wait until all of its previous tasks finished execution, then verify at
    least one of the edge conditions is met, and execute if possible. This
    should be considered as WHEN_ALL_TASKS_SUCCEED.
    """

    WHEN_ANY_SUCCEED: TaskConfig.TaskExecutionStrategy.ValueType = ...  # 2
    """Start execution as long as any of its previous tasks finished execution
    and the corresponding edge condition is met (since we will execute if
    only that succeeding edge condition is met).
    """

    WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED: TaskConfig.TaskExecutionStrategy.ValueType = ...  # 3
    """Wait until all of its previous tasks finished execution, then verify
    the all edge conditions are met and execute if possible.
    """


    class ParametersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> google.cloud.integrations.v1alpha.event_parameter_pb2.EventParameter: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[google.cloud.integrations.v1alpha.event_parameter_pb2.EventParameter] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    TASK_FIELD_NUMBER: builtins.int
    TASK_ID_FIELD_NUMBER: builtins.int
    PARAMETERS_FIELD_NUMBER: builtins.int
    FAILURE_POLICY_FIELD_NUMBER: builtins.int
    SYNCHRONOUS_CALL_FAILURE_POLICY_FIELD_NUMBER: builtins.int
    NEXT_TASKS_FIELD_NUMBER: builtins.int
    NEXT_TASKS_EXECUTION_POLICY_FIELD_NUMBER: builtins.int
    TASK_EXECUTION_STRATEGY_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    SUCCESS_POLICY_FIELD_NUMBER: builtins.int
    JSON_VALIDATION_OPTION_FIELD_NUMBER: builtins.int
    task: typing.Text = ...
    """Optional. The name for the task."""

    task_id: typing.Text = ...
    """Required. The identifier of this task within its parent event config,
    specified by the client. This should be unique among all the tasks belong
    to the same event config. We use this field as the identifier to
    find next tasks (via field `next_tasks.task_id`).
    """

    @property
    def parameters(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.cloud.integrations.v1alpha.event_parameter_pb2.EventParameter]:
        """Optional. The customized parameters the user can pass to this task."""
        pass
    @property
    def failure_policy(self) -> global___FailurePolicy:
        """Optional. Determines the number of times the
        task will be retried on failure and with what retry strategy.
        This is applicable for asynchronous calls to Eventbus alone (Post To
        Queue, Schedule etc.).
        """
        pass
    @property
    def synchronous_call_failure_policy(self) -> global___FailurePolicy:
        """Optional. Determines the number of times the
        task will be retried on failure and with what retry strategy.
        This is applicable for synchronous calls to Eventbus alone (Post).
        """
        pass
    @property
    def next_tasks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___NextTask]:
        """Optional. The set of tasks that are next in line to be executed as per the
        execution graph defined for the parent event, specified by
        `event_config_id`. Each of these next tasks are executed
        only if the condition associated with them evaluates to true.
        """
        pass
    next_tasks_execution_policy: global___TaskConfig.NextTasksExecutionPolicy.ValueType = ...
    """Optional. The policy dictating the execution of the next set of tasks for the current
    task.
    """

    task_execution_strategy: global___TaskConfig.TaskExecutionStrategy.ValueType = ...
    """Optional. The policy dictating the execution strategy of this task."""

    display_name: typing.Text = ...
    """Optional. User-provided label that is attached to this TaskConfig in the UI."""

    @property
    def success_policy(self) -> global___SuccessPolicy:
        """Optional. Determines what action to take upon successful task completion."""
        pass
    json_validation_option: google.cloud.integrations.v1alpha.json_validation_pb2.JsonValidationOption.ValueType = ...
    """Optional. If set, overrides the option configured in the Task implementation class."""

    def __init__(self,
        *,
        task : typing.Text = ...,
        task_id : typing.Text = ...,
        parameters : typing.Optional[typing.Mapping[typing.Text, google.cloud.integrations.v1alpha.event_parameter_pb2.EventParameter]] = ...,
        failure_policy : typing.Optional[global___FailurePolicy] = ...,
        synchronous_call_failure_policy : typing.Optional[global___FailurePolicy] = ...,
        next_tasks : typing.Optional[typing.Iterable[global___NextTask]] = ...,
        next_tasks_execution_policy : global___TaskConfig.NextTasksExecutionPolicy.ValueType = ...,
        task_execution_strategy : global___TaskConfig.TaskExecutionStrategy.ValueType = ...,
        display_name : typing.Text = ...,
        success_policy : typing.Optional[global___SuccessPolicy] = ...,
        json_validation_option : google.cloud.integrations.v1alpha.json_validation_pb2.JsonValidationOption.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["failure_policy",b"failure_policy","success_policy",b"success_policy","synchronous_call_failure_policy",b"synchronous_call_failure_policy"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["display_name",b"display_name","failure_policy",b"failure_policy","json_validation_option",b"json_validation_option","next_tasks",b"next_tasks","next_tasks_execution_policy",b"next_tasks_execution_policy","parameters",b"parameters","success_policy",b"success_policy","synchronous_call_failure_policy",b"synchronous_call_failure_policy","task",b"task","task_execution_strategy",b"task_execution_strategy","task_id",b"task_id"]) -> None: ...
global___TaskConfig = TaskConfig

class SuccessPolicy(google.protobuf.message.Message):
    """Policy that dictates the behavior for the task after it completes
    successfully.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _FinalState:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _FinalStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_FinalState.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        FINAL_STATE_UNSPECIFIED: SuccessPolicy.FinalState.ValueType = ...  # 0
        """UNSPECIFIED."""

        SUCCEEDED: SuccessPolicy.FinalState.ValueType = ...  # 1
        """The default behavior, where successful tasks will be marked as SUCCEEDED."""

        SUSPENDED: SuccessPolicy.FinalState.ValueType = ...  # 2
        """Sets the state to SUSPENDED after executing.  This is required for
        SuspensionTask; event execution will continue once the user calls
        ResolveSuspensions with the event_execution_info_id and the task number.
        """

    class FinalState(_FinalState, metaclass=_FinalStateEnumTypeWrapper):
        """The state of execution."""
        pass

    FINAL_STATE_UNSPECIFIED: SuccessPolicy.FinalState.ValueType = ...  # 0
    """UNSPECIFIED."""

    SUCCEEDED: SuccessPolicy.FinalState.ValueType = ...  # 1
    """The default behavior, where successful tasks will be marked as SUCCEEDED."""

    SUSPENDED: SuccessPolicy.FinalState.ValueType = ...  # 2
    """Sets the state to SUSPENDED after executing.  This is required for
    SuspensionTask; event execution will continue once the user calls
    ResolveSuspensions with the event_execution_info_id and the task number.
    """


    FINAL_STATE_FIELD_NUMBER: builtins.int
    final_state: global___SuccessPolicy.FinalState.ValueType = ...
    """State to which the execution snapshot status will be set if the task
    succeeds.
    """

    def __init__(self,
        *,
        final_state : global___SuccessPolicy.FinalState.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["final_state",b"final_state"]) -> None: ...
global___SuccessPolicy = SuccessPolicy

class FailurePolicy(google.protobuf.message.Message):
    """Policy that defines the task retry logic and failure type. If no
    FailurePolicy is defined for a task, all its dependent tasks will not be
    executed (i.e, a `retry_strategy` of NONE will be applied).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _RetryStrategy:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _RetryStrategyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RetryStrategy.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        RETRY_STRATEGY_UNSPECIFIED: FailurePolicy.RetryStrategy.ValueType = ...  # 0
        """UNSPECIFIED."""

        IGNORE: FailurePolicy.RetryStrategy.ValueType = ...  # 1
        """Ignores the failure of this task. The rest of the integration will be
        executed Assuming this task succeeded.
        """

        NONE: FailurePolicy.RetryStrategy.ValueType = ...  # 2
        """Causes a permanent failure of the task. However, if the last task(s)
        of event was successfully completed despite the failure of this task,
        it has no impact on the integration.
        """

        FATAL: FailurePolicy.RetryStrategy.ValueType = ...  # 3
        """Causes a permanent failure of the event. It is different from NONE
        because this will mark the event as FAILED by shutting down the
        event execution.
        """

        FIXED_INTERVAL: FailurePolicy.RetryStrategy.ValueType = ...  # 4
        """The task will be retried from the failed task onwards after a fixed
        delay. A max-retry count is required to be specified with this
        strategy. A jitter is added to each exponential interval so that
        concurrently failing tasks of the same type do not end up retrying
        after the exact same exponential interval. max_retries and
        interval_in_seconds must be specified.
        """

        LINEAR_BACKOFF: FailurePolicy.RetryStrategy.ValueType = ...  # 5
        """The task will be retried from the failed task onwards after a fixed
        delay that linearly increases with each retry attempt. A jitter is
        added to each exponential interval so that concurrently failing tasks
        of the same type do not end up retrying after the exact same
        exponential interval. A max-retry count is required to be specified
        with this strategy. max_retries and interval_in_seconds must be
        specified.
        """

        EXPONENTIAL_BACKOFF: FailurePolicy.RetryStrategy.ValueType = ...  # 6
        """The task will be retried after an exponentially increasing period of
        time with each failure. A jitter is added to each exponential interval
        so that concurrently failing tasks of the same type do not end up
        retrying after the exact same exponential interval. A max-retry count
        is required to be specified with this strategy. `max_retries` and
        `interval_in_seconds` must be specified.
        """

        RESTART_INTEGRATION_WITH_BACKOFF: FailurePolicy.RetryStrategy.ValueType = ...  # 7
        """The entire integration will be restarted with the initial parameters that
        were set when the event was fired. A max-retry count is required to be
        specified with this strategy. `max_retries` and `interval_in_seconds`
        must be specified.
        """

    class RetryStrategy(_RetryStrategy, metaclass=_RetryStrategyEnumTypeWrapper):
        """The behavior when the taks failed."""
        pass

    RETRY_STRATEGY_UNSPECIFIED: FailurePolicy.RetryStrategy.ValueType = ...  # 0
    """UNSPECIFIED."""

    IGNORE: FailurePolicy.RetryStrategy.ValueType = ...  # 1
    """Ignores the failure of this task. The rest of the integration will be
    executed Assuming this task succeeded.
    """

    NONE: FailurePolicy.RetryStrategy.ValueType = ...  # 2
    """Causes a permanent failure of the task. However, if the last task(s)
    of event was successfully completed despite the failure of this task,
    it has no impact on the integration.
    """

    FATAL: FailurePolicy.RetryStrategy.ValueType = ...  # 3
    """Causes a permanent failure of the event. It is different from NONE
    because this will mark the event as FAILED by shutting down the
    event execution.
    """

    FIXED_INTERVAL: FailurePolicy.RetryStrategy.ValueType = ...  # 4
    """The task will be retried from the failed task onwards after a fixed
    delay. A max-retry count is required to be specified with this
    strategy. A jitter is added to each exponential interval so that
    concurrently failing tasks of the same type do not end up retrying
    after the exact same exponential interval. max_retries and
    interval_in_seconds must be specified.
    """

    LINEAR_BACKOFF: FailurePolicy.RetryStrategy.ValueType = ...  # 5
    """The task will be retried from the failed task onwards after a fixed
    delay that linearly increases with each retry attempt. A jitter is
    added to each exponential interval so that concurrently failing tasks
    of the same type do not end up retrying after the exact same
    exponential interval. A max-retry count is required to be specified
    with this strategy. max_retries and interval_in_seconds must be
    specified.
    """

    EXPONENTIAL_BACKOFF: FailurePolicy.RetryStrategy.ValueType = ...  # 6
    """The task will be retried after an exponentially increasing period of
    time with each failure. A jitter is added to each exponential interval
    so that concurrently failing tasks of the same type do not end up
    retrying after the exact same exponential interval. A max-retry count
    is required to be specified with this strategy. `max_retries` and
    `interval_in_seconds` must be specified.
    """

    RESTART_INTEGRATION_WITH_BACKOFF: FailurePolicy.RetryStrategy.ValueType = ...  # 7
    """The entire integration will be restarted with the initial parameters that
    were set when the event was fired. A max-retry count is required to be
    specified with this strategy. `max_retries` and `interval_in_seconds`
    must be specified.
    """


    RETRY_STRATEGY_FIELD_NUMBER: builtins.int
    MAX_RETRIES_FIELD_NUMBER: builtins.int
    INTERVAL_TIME_FIELD_NUMBER: builtins.int
    retry_strategy: global___FailurePolicy.RetryStrategy.ValueType = ...
    """Defines what happens to the task upon failure."""

    max_retries: builtins.int = ...
    """Required if retry_strategy is FIXED_INTERVAL or
    LINEAR/EXPONENTIAL_BACKOFF/RESTART_INTEGRATION_WITH_BACKOFF. Defines the
    number of times the task will be retried if failed.
    """

    @property
    def interval_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Required if retry_strategy is FIXED_INTERVAL or
        LINEAR/EXPONENTIAL_BACKOFF/RESTART_INTEGRATION_WITH_BACKOFF. Defines the
        initial interval in seconds for backoff.
        """
        pass
    def __init__(self,
        *,
        retry_strategy : global___FailurePolicy.RetryStrategy.ValueType = ...,
        max_retries : builtins.int = ...,
        interval_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["interval_time",b"interval_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["interval_time",b"interval_time","max_retries",b"max_retries","retry_strategy",b"retry_strategy"]) -> None: ...
global___FailurePolicy = FailurePolicy

class NextTask(google.protobuf.message.Message):
    """The task that is next in line to be executed, if the
    condition specified evaluated to true.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TASK_CONFIG_ID_FIELD_NUMBER: builtins.int
    TASK_ID_FIELD_NUMBER: builtins.int
    CONDITION_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    task_config_id: typing.Text = ...
    """ID of the next task."""

    task_id: typing.Text = ...
    """Task number of the next task."""

    condition: typing.Text = ...
    """Standard filter expression for this task to become an eligible next task."""

    display_name: typing.Text = ...
    """User-provided label that is attached to this edge in the UI."""

    def __init__(self,
        *,
        task_config_id : typing.Text = ...,
        task_id : typing.Text = ...,
        condition : typing.Text = ...,
        display_name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["condition",b"condition","display_name",b"display_name","task_config_id",b"task_config_id","task_id",b"task_id"]) -> None: ...
global___NextTask = NextTask
