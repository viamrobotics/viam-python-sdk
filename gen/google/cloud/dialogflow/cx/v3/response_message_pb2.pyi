"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import google.protobuf.struct_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class ResponseMessage(google.protobuf.message.Message):
    """Represents a response message that can be returned by a conversational agent.

    Response messages are also used for output audio synthesis. The approach is
    as follows:

    * If at least one OutputAudioText response is present, then all
      OutputAudioText responses are linearly concatenated, and the result is used
      for output audio synthesis.
    * If the OutputAudioText responses are a mixture of text and SSML, then the
      concatenated result is treated as SSML; otherwise, the result is treated as
      either text or SSML as appropriate. The agent designer should ideally use
      either text or SSML consistently throughout the bot design.
    * Otherwise, all Text responses are linearly concatenated, and the result is
      used for output audio synthesis.

    This approach allows for more sophisticated user experience scenarios, where
    the text displayed to the user may differ from what is heard.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Text(google.protobuf.message.Message):
        """The text response message."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TEXT_FIELD_NUMBER: builtins.int
        ALLOW_PLAYBACK_INTERRUPTION_FIELD_NUMBER: builtins.int
        @property
        def text(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """Required. A collection of text responses."""
            pass
        allow_playback_interruption: builtins.bool = ...
        """Output only. Whether the playback of this message can be interrupted by the end
        user's speech and the client can then starts the next Dialogflow
        request.
        """

        def __init__(self,
            *,
            text : typing.Optional[typing.Iterable[typing.Text]] = ...,
            allow_playback_interruption : builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["allow_playback_interruption",b"allow_playback_interruption","text",b"text"]) -> None: ...

    class LiveAgentHandoff(google.protobuf.message.Message):
        """Indicates that the conversation should be handed off to a live agent.

        Dialogflow only uses this to determine which conversations were handed off
        to a human agent for measurement purposes. What else to do with this signal
        is up to you and your handoff procedures.

        You may set this, for example:
        * In the [entry_fulfillment][google.cloud.dialogflow.cx.v3.Page.entry_fulfillment] of a [Page][google.cloud.dialogflow.cx.v3.Page] if
          entering the page indicates something went extremely wrong in the
          conversation.
        * In a webhook response when you determine that the customer issue can only
          be handled by a human.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        METADATA_FIELD_NUMBER: builtins.int
        @property
        def metadata(self) -> google.protobuf.struct_pb2.Struct:
            """Custom metadata for your handoff procedure. Dialogflow doesn't impose
            any structure on this.
            """
            pass
        def __init__(self,
            *,
            metadata : typing.Optional[google.protobuf.struct_pb2.Struct] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["metadata",b"metadata"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["metadata",b"metadata"]) -> None: ...

    class ConversationSuccess(google.protobuf.message.Message):
        """Indicates that the conversation succeeded, i.e., the bot handled the issue
        that the customer talked to it about.

        Dialogflow only uses this to determine which conversations should be
        counted as successful and doesn't process the metadata in this message in
        any way. Note that Dialogflow also considers conversations that get to the
        conversation end page as successful even if they don't return
        [ConversationSuccess][google.cloud.dialogflow.cx.v3.ResponseMessage.ConversationSuccess].

        You may set this, for example:
        * In the [entry_fulfillment][google.cloud.dialogflow.cx.v3.Page.entry_fulfillment] of a [Page][google.cloud.dialogflow.cx.v3.Page] if
          entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer
          issue.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        METADATA_FIELD_NUMBER: builtins.int
        @property
        def metadata(self) -> google.protobuf.struct_pb2.Struct:
            """Custom metadata. Dialogflow doesn't impose any structure on this."""
            pass
        def __init__(self,
            *,
            metadata : typing.Optional[google.protobuf.struct_pb2.Struct] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["metadata",b"metadata"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["metadata",b"metadata"]) -> None: ...

    class OutputAudioText(google.protobuf.message.Message):
        """A text or ssml response that is preferentially used for TTS output audio
        synthesis, as described in the comment on the ResponseMessage message.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TEXT_FIELD_NUMBER: builtins.int
        SSML_FIELD_NUMBER: builtins.int
        ALLOW_PLAYBACK_INTERRUPTION_FIELD_NUMBER: builtins.int
        text: typing.Text = ...
        """The raw text to be synthesized."""

        ssml: typing.Text = ...
        """The SSML text to be synthesized. For more information, see
        [SSML](/speech/text-to-speech/docs/ssml).
        """

        allow_playback_interruption: builtins.bool = ...
        """Output only. Whether the playback of this message can be interrupted by the end
        user's speech and the client can then starts the next Dialogflow
        request.
        """

        def __init__(self,
            *,
            text : typing.Text = ...,
            ssml : typing.Text = ...,
            allow_playback_interruption : builtins.bool = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["source",b"source","ssml",b"ssml","text",b"text"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["allow_playback_interruption",b"allow_playback_interruption","source",b"source","ssml",b"ssml","text",b"text"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["text","ssml"]]: ...

    class EndInteraction(google.protobuf.message.Message):
        """Indicates that interaction with the Dialogflow agent has ended.
        This message is generated by Dialogflow only and not supposed to be
        defined by the user.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    class PlayAudio(google.protobuf.message.Message):
        """Specifies an audio clip to be played by the client as part of the response."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        AUDIO_URI_FIELD_NUMBER: builtins.int
        ALLOW_PLAYBACK_INTERRUPTION_FIELD_NUMBER: builtins.int
        audio_uri: typing.Text = ...
        """Required. URI of the audio clip. Dialogflow does not impose any validation on this
        value. It is specific to the client that reads it.
        """

        allow_playback_interruption: builtins.bool = ...
        """Output only. Whether the playback of this message can be interrupted by the end
        user's speech and the client can then starts the next Dialogflow
        request.
        """

        def __init__(self,
            *,
            audio_uri : typing.Text = ...,
            allow_playback_interruption : builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["allow_playback_interruption",b"allow_playback_interruption","audio_uri",b"audio_uri"]) -> None: ...

    class MixedAudio(google.protobuf.message.Message):
        """Represents an audio message that is composed of both segments
        synthesized from the Dialogflow agent prompts and ones hosted externally
        at the specified URIs.
        The external URIs are specified via
        [play_audio][google.cloud.dialogflow.cx.v3.ResponseMessage.play_audio].
        This message is generated by Dialogflow only and not supposed to be
        defined by the user.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Segment(google.protobuf.message.Message):
            """Represents one segment of audio."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AUDIO_FIELD_NUMBER: builtins.int
            URI_FIELD_NUMBER: builtins.int
            ALLOW_PLAYBACK_INTERRUPTION_FIELD_NUMBER: builtins.int
            audio: builtins.bytes = ...
            """Raw audio synthesized from the Dialogflow agent's response using
            the output config specified in the request.
            """

            uri: typing.Text = ...
            """Client-specific URI that points to an audio clip accessible to the
            client. Dialogflow does not impose any validation on it.
            """

            allow_playback_interruption: builtins.bool = ...
            """Output only. Whether the playback of this segment can be interrupted by the end
            user's speech and the client should then start the next Dialogflow
            request.
            """

            def __init__(self,
                *,
                audio : builtins.bytes = ...,
                uri : typing.Text = ...,
                allow_playback_interruption : builtins.bool = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["audio",b"audio","content",b"content","uri",b"uri"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["allow_playback_interruption",b"allow_playback_interruption","audio",b"audio","content",b"content","uri",b"uri"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["content",b"content"]) -> typing.Optional[typing_extensions.Literal["audio","uri"]]: ...

        SEGMENTS_FIELD_NUMBER: builtins.int
        @property
        def segments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ResponseMessage.MixedAudio.Segment]:
            """Segments this audio response is composed of."""
            pass
        def __init__(self,
            *,
            segments : typing.Optional[typing.Iterable[global___ResponseMessage.MixedAudio.Segment]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["segments",b"segments"]) -> None: ...

    class TelephonyTransferCall(google.protobuf.message.Message):
        """Represents the signal that telles the client to transfer the phone call
        connected to the agent to a third-party endpoint.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        PHONE_NUMBER_FIELD_NUMBER: builtins.int
        phone_number: typing.Text = ...
        """Transfer the call to a phone number
        in [E.164 format](https://en.wikipedia.org/wiki/E.164).
        """

        def __init__(self,
            *,
            phone_number : typing.Text = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["endpoint",b"endpoint","phone_number",b"phone_number"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["endpoint",b"endpoint","phone_number",b"phone_number"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["endpoint",b"endpoint"]) -> typing.Optional[typing_extensions.Literal["phone_number"]]: ...

    TEXT_FIELD_NUMBER: builtins.int
    PAYLOAD_FIELD_NUMBER: builtins.int
    CONVERSATION_SUCCESS_FIELD_NUMBER: builtins.int
    OUTPUT_AUDIO_TEXT_FIELD_NUMBER: builtins.int
    LIVE_AGENT_HANDOFF_FIELD_NUMBER: builtins.int
    END_INTERACTION_FIELD_NUMBER: builtins.int
    PLAY_AUDIO_FIELD_NUMBER: builtins.int
    MIXED_AUDIO_FIELD_NUMBER: builtins.int
    TELEPHONY_TRANSFER_CALL_FIELD_NUMBER: builtins.int
    @property
    def text(self) -> global___ResponseMessage.Text:
        """Returns a text response."""
        pass
    @property
    def payload(self) -> google.protobuf.struct_pb2.Struct:
        """Returns a response containing a custom, platform-specific payload."""
        pass
    @property
    def conversation_success(self) -> global___ResponseMessage.ConversationSuccess:
        """Indicates that the conversation succeeded."""
        pass
    @property
    def output_audio_text(self) -> global___ResponseMessage.OutputAudioText:
        """A text or ssml response that is preferentially used for TTS output audio
        synthesis, as described in the comment on the ResponseMessage message.
        """
        pass
    @property
    def live_agent_handoff(self) -> global___ResponseMessage.LiveAgentHandoff:
        """Hands off conversation to a human agent."""
        pass
    @property
    def end_interaction(self) -> global___ResponseMessage.EndInteraction:
        """Output only. A signal that indicates the interaction with the Dialogflow agent has
        ended.
        This message is generated by Dialogflow only when the conversation
        reaches `END_SESSION` page. It is not supposed to be defined by the user.

        It's guaranteed that there is at most one such message in each response.
        """
        pass
    @property
    def play_audio(self) -> global___ResponseMessage.PlayAudio:
        """Signal that the client should play an audio clip hosted at a
        client-specific URI. Dialogflow uses this to construct
        [mixed_audio][google.cloud.dialogflow.cx.v3.ResponseMessage.mixed_audio]. However, Dialogflow itself
        does not try to read or process the URI in any way.
        """
        pass
    @property
    def mixed_audio(self) -> global___ResponseMessage.MixedAudio:
        """Output only. An audio response message composed of both the synthesized Dialogflow
        agent responses and responses defined via
        [play_audio][google.cloud.dialogflow.cx.v3.ResponseMessage.play_audio].
        This message is generated by Dialogflow only and not supposed to be
        defined by the user.
        """
        pass
    @property
    def telephony_transfer_call(self) -> global___ResponseMessage.TelephonyTransferCall:
        """A signal that the client should transfer the phone call connected to
        this agent to a third-party endpoint.
        """
        pass
    def __init__(self,
        *,
        text : typing.Optional[global___ResponseMessage.Text] = ...,
        payload : typing.Optional[google.protobuf.struct_pb2.Struct] = ...,
        conversation_success : typing.Optional[global___ResponseMessage.ConversationSuccess] = ...,
        output_audio_text : typing.Optional[global___ResponseMessage.OutputAudioText] = ...,
        live_agent_handoff : typing.Optional[global___ResponseMessage.LiveAgentHandoff] = ...,
        end_interaction : typing.Optional[global___ResponseMessage.EndInteraction] = ...,
        play_audio : typing.Optional[global___ResponseMessage.PlayAudio] = ...,
        mixed_audio : typing.Optional[global___ResponseMessage.MixedAudio] = ...,
        telephony_transfer_call : typing.Optional[global___ResponseMessage.TelephonyTransferCall] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["conversation_success",b"conversation_success","end_interaction",b"end_interaction","live_agent_handoff",b"live_agent_handoff","message",b"message","mixed_audio",b"mixed_audio","output_audio_text",b"output_audio_text","payload",b"payload","play_audio",b"play_audio","telephony_transfer_call",b"telephony_transfer_call","text",b"text"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["conversation_success",b"conversation_success","end_interaction",b"end_interaction","live_agent_handoff",b"live_agent_handoff","message",b"message","mixed_audio",b"mixed_audio","output_audio_text",b"output_audio_text","payload",b"payload","play_audio",b"play_audio","telephony_transfer_call",b"telephony_transfer_call","text",b"text"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["message",b"message"]) -> typing.Optional[typing_extensions.Literal["text","payload","conversation_success","output_audio_text","live_agent_handoff","end_interaction","play_audio","mixed_audio","telephony_transfer_call"]]: ...
global___ResponseMessage = ResponseMessage
