"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.cloud.dialogflow.v2.gcs_pb2
import google.protobuf.descriptor
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.rpc.status_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Document(google.protobuf.message.Message):
    """A knowledge document to be used by a [KnowledgeBase][google.cloud.dialogflow.v2.KnowledgeBase].

    For more information, see the [knowledge base
    guide](https://cloud.google.com/dialogflow/docs/how/knowledge-bases).

    Note: The `projects.agent.knowledgeBases.documents` resource is deprecated;
    only use `projects.knowledgeBases.documents`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _KnowledgeType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _KnowledgeTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_KnowledgeType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        KNOWLEDGE_TYPE_UNSPECIFIED: Document.KnowledgeType.ValueType = ...  # 0
        """The type is unspecified or arbitrary."""

        FAQ: Document.KnowledgeType.ValueType = ...  # 1
        """The document content contains question and answer pairs as either HTML or
        CSV. Typical FAQ HTML formats are parsed accurately, but unusual formats
        may fail to be parsed.

        CSV must have questions in the first column and answers in the second,
        with no header. Because of this explicit format, they are always parsed
        accurately.
        """

        EXTRACTIVE_QA: Document.KnowledgeType.ValueType = ...  # 2
        """Documents for which unstructured text is extracted and used for
        question answering.
        """

        ARTICLE_SUGGESTION: Document.KnowledgeType.ValueType = ...  # 3
        """The entire document content as a whole can be used for query results.
        Only for Contact Center Solutions on Dialogflow.
        """

    class KnowledgeType(_KnowledgeType, metaclass=_KnowledgeTypeEnumTypeWrapper):
        """The knowledge type of document content."""
        pass

    KNOWLEDGE_TYPE_UNSPECIFIED: Document.KnowledgeType.ValueType = ...  # 0
    """The type is unspecified or arbitrary."""

    FAQ: Document.KnowledgeType.ValueType = ...  # 1
    """The document content contains question and answer pairs as either HTML or
    CSV. Typical FAQ HTML formats are parsed accurately, but unusual formats
    may fail to be parsed.

    CSV must have questions in the first column and answers in the second,
    with no header. Because of this explicit format, they are always parsed
    accurately.
    """

    EXTRACTIVE_QA: Document.KnowledgeType.ValueType = ...  # 2
    """Documents for which unstructured text is extracted and used for
    question answering.
    """

    ARTICLE_SUGGESTION: Document.KnowledgeType.ValueType = ...  # 3
    """The entire document content as a whole can be used for query results.
    Only for Contact Center Solutions on Dialogflow.
    """


    class ReloadStatus(google.protobuf.message.Message):
        """The status of a reload attempt."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TIME_FIELD_NUMBER: builtins.int
        STATUS_FIELD_NUMBER: builtins.int
        @property
        def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The time of a reload attempt.
            This reload may have been triggered automatically or manually and may
            not have succeeded.
            """
            pass
        @property
        def status(self) -> google.rpc.status_pb2.Status:
            """The status of a reload attempt or the initial load."""
            pass
        def __init__(self,
            *,
            time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            status : typing.Optional[google.rpc.status_pb2.Status] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["status",b"status","time",b"time"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["status",b"status","time",b"time"]) -> None: ...

    class MetadataEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    MIME_TYPE_FIELD_NUMBER: builtins.int
    KNOWLEDGE_TYPES_FIELD_NUMBER: builtins.int
    CONTENT_URI_FIELD_NUMBER: builtins.int
    RAW_CONTENT_FIELD_NUMBER: builtins.int
    ENABLE_AUTO_RELOAD_FIELD_NUMBER: builtins.int
    LATEST_RELOAD_STATUS_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Optional. The document resource name.
    The name must be empty when creating a document.
    Format: `projects/<Project ID>/locations/<Location
    ID>/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
    """

    display_name: typing.Text = ...
    """Required. The display name of the document. The name must be 1024 bytes or
    less; otherwise, the creation request fails.
    """

    mime_type: typing.Text = ...
    """Required. The MIME type of this document."""

    @property
    def knowledge_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___Document.KnowledgeType.ValueType]:
        """Required. The knowledge type of document content."""
        pass
    content_uri: typing.Text = ...
    """The URI where the file content is located.

    For documents stored in Google Cloud Storage, these URIs must have
    the form `gs://<bucket-name>/<object-name>`.

    NOTE: External URLs must correspond to public webpages, i.e., they must
    be indexed by Google Search. In particular, URLs for showing documents in
    Google Cloud Storage (i.e. the URL in your browser) are not supported.
    Instead use the `gs://` format URI described above.
    """

    raw_content: builtins.bytes = ...
    """The raw content of the document. This field is only permitted for
    EXTRACTIVE_QA and FAQ knowledge types.
    """

    enable_auto_reload: builtins.bool = ...
    """Optional. If true, we try to automatically reload the document every day
    (at a time picked by the system). If false or unspecified, we don't try
    to automatically reload the document.

    Currently you can only enable automatic reload for documents sourced from
    a public url, see `source` field for the source types.

    Reload status can be tracked in `latest_reload_status`. If a reload
    fails, we will keep the document unchanged.

    If a reload fails with internal errors, the system will try to reload the
    document on the next day.
    If a reload fails with non-retriable errors (e.g. PERMISION_DENIED), the
    system will not try to reload the document anymore. You need to manually
    reload the document successfully by calling `ReloadDocument` and clear the
    errors.
    """

    @property
    def latest_reload_status(self) -> global___Document.ReloadStatus:
        """Output only. The time and status of the latest reload.
        This reload may have been triggered automatically or manually
        and may not have succeeded.
        """
        pass
    @property
    def metadata(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Optional. Metadata for the document. The metadata supports arbitrary
        key-value pairs. Suggested use cases include storing a document's title,
        an external URL distinct from the document's content_uri, etc.
        The max size of a `key` or a `value` of the metadata is 1024 bytes.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        mime_type : typing.Text = ...,
        knowledge_types : typing.Optional[typing.Iterable[global___Document.KnowledgeType.ValueType]] = ...,
        content_uri : typing.Text = ...,
        raw_content : builtins.bytes = ...,
        enable_auto_reload : builtins.bool = ...,
        latest_reload_status : typing.Optional[global___Document.ReloadStatus] = ...,
        metadata : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["content_uri",b"content_uri","latest_reload_status",b"latest_reload_status","raw_content",b"raw_content","source",b"source"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["content_uri",b"content_uri","display_name",b"display_name","enable_auto_reload",b"enable_auto_reload","knowledge_types",b"knowledge_types","latest_reload_status",b"latest_reload_status","metadata",b"metadata","mime_type",b"mime_type","name",b"name","raw_content",b"raw_content","source",b"source"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["content_uri","raw_content"]]: ...
global___Document = Document

class GetDocumentRequest(google.protobuf.message.Message):
    """Request message for [Documents.GetDocument][google.cloud.dialogflow.v2.Documents.GetDocument]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the document to retrieve.
    Format `projects/<Project ID>/locations/<Location
    ID>/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetDocumentRequest = GetDocumentRequest

class ListDocumentsRequest(google.protobuf.message.Message):
    """Request message for [Documents.ListDocuments][google.cloud.dialogflow.v2.Documents.ListDocuments]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The knowledge base to list all documents for.
    Format: `projects/<Project ID>/locations/<Location
    ID>/knowledgeBases/<Knowledge Base ID>`.
    """

    page_size: builtins.int = ...
    """The maximum number of items to return in a single page. By
    default 10 and at most 100.
    """

    page_token: typing.Text = ...
    """The next_page_token value returned from a previous list request."""

    filter: typing.Text = ...
    """The filter expression used to filter documents returned by the list method.
    The expression has the following syntax:

      <field> <operator> <value> [AND <field> <operator> <value>] ...

    The following fields and operators are supported:

    * knowledge_types with has(:) operator
    * display_name with has(:) operator
    * state with equals(=) operator

    Examples:

    * "knowledge_types:FAQ" matches documents with FAQ knowledge type.
    * "display_name:customer" matches documents whose display name contains
      "customer".
    * "state=ACTIVE" matches documents with ACTIVE state.
    * "knowledge_types:FAQ AND state=ACTIVE" matches all active FAQ documents.

    For more information about filtering, see
    [API Filtering](https://aip.dev/160).
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        filter : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","page_size",b"page_size","page_token",b"page_token","parent",b"parent"]) -> None: ...
global___ListDocumentsRequest = ListDocumentsRequest

class ListDocumentsResponse(google.protobuf.message.Message):
    """Response message for [Documents.ListDocuments][google.cloud.dialogflow.v2.Documents.ListDocuments]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DOCUMENTS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def documents(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Document]:
        """The list of documents."""
        pass
    next_page_token: typing.Text = ...
    """Token to retrieve the next page of results, or empty if there are no
    more results in the list.
    """

    def __init__(self,
        *,
        documents : typing.Optional[typing.Iterable[global___Document]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["documents",b"documents","next_page_token",b"next_page_token"]) -> None: ...
global___ListDocumentsResponse = ListDocumentsResponse

class CreateDocumentRequest(google.protobuf.message.Message):
    """Request message for [Documents.CreateDocument][google.cloud.dialogflow.v2.Documents.CreateDocument]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    DOCUMENT_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The knowledge base to create a document for.
    Format: `projects/<Project ID>/locations/<Location
    ID>/knowledgeBases/<Knowledge Base ID>`.
    """

    @property
    def document(self) -> global___Document:
        """Required. The document to create."""
        pass
    def __init__(self,
        *,
        parent : typing.Text = ...,
        document : typing.Optional[global___Document] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["document",b"document"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["document",b"document","parent",b"parent"]) -> None: ...
global___CreateDocumentRequest = CreateDocumentRequest

class ImportDocumentsRequest(google.protobuf.message.Message):
    """Request message for [Documents.ImportDocuments][google.cloud.dialogflow.v2.Documents.ImportDocuments]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    GCS_SOURCE_FIELD_NUMBER: builtins.int
    DOCUMENT_TEMPLATE_FIELD_NUMBER: builtins.int
    IMPORT_GCS_CUSTOM_METADATA_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. The knowledge base to import documents into.
    Format: `projects/<Project ID>/locations/<Location
    ID>/knowledgeBases/<Knowledge Base ID>`.
    """

    @property
    def gcs_source(self) -> google.cloud.dialogflow.v2.gcs_pb2.GcsSources:
        """The Google Cloud Storage location for the documents.
        The path can include a wildcard.

        These URIs may have the forms
        `gs://<bucket-name>/<object-name>`.
        `gs://<bucket-name>/<object-path>/*.<extension>`.
        """
        pass
    @property
    def document_template(self) -> global___ImportDocumentTemplate:
        """Required. Document template used for importing all the documents."""
        pass
    import_gcs_custom_metadata: builtins.bool = ...
    """Whether to import custom metadata from Google Cloud Storage.
    Only valid when the document source is Google Cloud Storage URI.
    """

    def __init__(self,
        *,
        parent : typing.Text = ...,
        gcs_source : typing.Optional[google.cloud.dialogflow.v2.gcs_pb2.GcsSources] = ...,
        document_template : typing.Optional[global___ImportDocumentTemplate] = ...,
        import_gcs_custom_metadata : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["document_template",b"document_template","gcs_source",b"gcs_source","source",b"source"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["document_template",b"document_template","gcs_source",b"gcs_source","import_gcs_custom_metadata",b"import_gcs_custom_metadata","parent",b"parent","source",b"source"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["gcs_source"]]: ...
global___ImportDocumentsRequest = ImportDocumentsRequest

class ImportDocumentTemplate(google.protobuf.message.Message):
    """The template used for importing documents."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class MetadataEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    MIME_TYPE_FIELD_NUMBER: builtins.int
    KNOWLEDGE_TYPES_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    mime_type: typing.Text = ...
    """Required. The MIME type of the document."""

    @property
    def knowledge_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___Document.KnowledgeType.ValueType]:
        """Required. The knowledge type of document content."""
        pass
    @property
    def metadata(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Metadata for the document. The metadata supports arbitrary
        key-value pairs. Suggested use cases include storing a document's title,
        an external URL distinct from the document's content_uri, etc.
        The max size of a `key` or a `value` of the metadata is 1024 bytes.
        """
        pass
    def __init__(self,
        *,
        mime_type : typing.Text = ...,
        knowledge_types : typing.Optional[typing.Iterable[global___Document.KnowledgeType.ValueType]] = ...,
        metadata : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["knowledge_types",b"knowledge_types","metadata",b"metadata","mime_type",b"mime_type"]) -> None: ...
global___ImportDocumentTemplate = ImportDocumentTemplate

class ImportDocumentsResponse(google.protobuf.message.Message):
    """Response message for [Documents.ImportDocuments][google.cloud.dialogflow.v2.Documents.ImportDocuments]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    WARNINGS_FIELD_NUMBER: builtins.int
    @property
    def warnings(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.rpc.status_pb2.Status]:
        """Includes details about skipped documents or any other warnings."""
        pass
    def __init__(self,
        *,
        warnings : typing.Optional[typing.Iterable[google.rpc.status_pb2.Status]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["warnings",b"warnings"]) -> None: ...
global___ImportDocumentsResponse = ImportDocumentsResponse

class DeleteDocumentRequest(google.protobuf.message.Message):
    """Request message for [Documents.DeleteDocument][google.cloud.dialogflow.v2.Documents.DeleteDocument]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the document to delete.
    Format: `projects/<Project ID>/locations/<Location
    ID>/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___DeleteDocumentRequest = DeleteDocumentRequest

class UpdateDocumentRequest(google.protobuf.message.Message):
    """Request message for [Documents.UpdateDocument][google.cloud.dialogflow.v2.Documents.UpdateDocument]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DOCUMENT_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    @property
    def document(self) -> global___Document:
        """Required. The document to update."""
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Optional. Not specified means `update all`.
        Currently, only `display_name` can be updated, an InvalidArgument will be
        returned for attempting to update other fields.
        """
        pass
    def __init__(self,
        *,
        document : typing.Optional[global___Document] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["document",b"document","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["document",b"document","update_mask",b"update_mask"]) -> None: ...
global___UpdateDocumentRequest = UpdateDocumentRequest

class ReloadDocumentRequest(google.protobuf.message.Message):
    """Request message for [Documents.ReloadDocument][google.cloud.dialogflow.v2.Documents.ReloadDocument]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    CONTENT_URI_FIELD_NUMBER: builtins.int
    IMPORT_GCS_CUSTOM_METADATA_FIELD_NUMBER: builtins.int
    SMART_MESSAGING_PARTIAL_UPDATE_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the document to reload.
    Format: `projects/<Project ID>/locations/<Location
    ID>/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`
    """

    content_uri: typing.Text = ...
    """Optional. The path of gcs source file for reloading document content. For now,
    only gcs uri is supported.

    For documents stored in Google Cloud Storage, these URIs must have
    the form `gs://<bucket-name>/<object-name>`.
    """

    import_gcs_custom_metadata: builtins.bool = ...
    """Optional. Whether to import custom metadata from Google Cloud Storage.
    Only valid when the document source is Google Cloud Storage URI.
    """

    smart_messaging_partial_update: builtins.bool = ...
    """Optional. When enabled, the reload request is to apply partial update to the smart
    messaging allowlist.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        content_uri : typing.Text = ...,
        import_gcs_custom_metadata : builtins.bool = ...,
        smart_messaging_partial_update : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["content_uri",b"content_uri","source",b"source"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["content_uri",b"content_uri","import_gcs_custom_metadata",b"import_gcs_custom_metadata","name",b"name","smart_messaging_partial_update",b"smart_messaging_partial_update","source",b"source"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["content_uri"]]: ...
global___ReloadDocumentRequest = ReloadDocumentRequest

class ExportDocumentRequest(google.protobuf.message.Message):
    """Request message for [Documents.ExportDocument][google.cloud.dialogflow.v2.Documents.ExportDocument]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    GCS_DESTINATION_FIELD_NUMBER: builtins.int
    EXPORT_FULL_CONTENT_FIELD_NUMBER: builtins.int
    SMART_MESSAGING_PARTIAL_UPDATE_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the document to export.
    Format: `projects/<Project ID>/locations/<Location
    ID>/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
    """

    @property
    def gcs_destination(self) -> google.cloud.dialogflow.v2.gcs_pb2.GcsDestination:
        """Cloud Storage file path to export the document."""
        pass
    export_full_content: builtins.bool = ...
    """When enabled, export the full content of the document including empirical
    probability.
    """

    smart_messaging_partial_update: builtins.bool = ...
    """When enabled, export the smart messaging allowlist document for partial
    update.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        gcs_destination : typing.Optional[google.cloud.dialogflow.v2.gcs_pb2.GcsDestination] = ...,
        export_full_content : builtins.bool = ...,
        smart_messaging_partial_update : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["destination",b"destination","gcs_destination",b"gcs_destination"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["destination",b"destination","export_full_content",b"export_full_content","gcs_destination",b"gcs_destination","name",b"name","smart_messaging_partial_update",b"smart_messaging_partial_update"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["destination",b"destination"]) -> typing.Optional[typing_extensions.Literal["gcs_destination"]]: ...
global___ExportDocumentRequest = ExportDocumentRequest

class KnowledgeOperationMetadata(google.protobuf.message.Message):
    """Metadata in google::longrunning::Operation for Knowledge operations."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _State:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_State.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        STATE_UNSPECIFIED: KnowledgeOperationMetadata.State.ValueType = ...  # 0
        """State unspecified."""

        PENDING: KnowledgeOperationMetadata.State.ValueType = ...  # 1
        """The operation has been created."""

        RUNNING: KnowledgeOperationMetadata.State.ValueType = ...  # 2
        """The operation is currently running."""

        DONE: KnowledgeOperationMetadata.State.ValueType = ...  # 3
        """The operation is done, either cancelled or completed."""

    class State(_State, metaclass=_StateEnumTypeWrapper):
        """States of the operation."""
        pass

    STATE_UNSPECIFIED: KnowledgeOperationMetadata.State.ValueType = ...  # 0
    """State unspecified."""

    PENDING: KnowledgeOperationMetadata.State.ValueType = ...  # 1
    """The operation has been created."""

    RUNNING: KnowledgeOperationMetadata.State.ValueType = ...  # 2
    """The operation is currently running."""

    DONE: KnowledgeOperationMetadata.State.ValueType = ...  # 3
    """The operation is done, either cancelled or completed."""


    STATE_FIELD_NUMBER: builtins.int
    KNOWLEDGE_BASE_FIELD_NUMBER: builtins.int
    state: global___KnowledgeOperationMetadata.State.ValueType = ...
    """Output only. The current state of this operation."""

    knowledge_base: typing.Text = ...
    """The name of the knowledge base interacted with during the operation."""

    def __init__(self,
        *,
        state : global___KnowledgeOperationMetadata.State.ValueType = ...,
        knowledge_base : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["knowledge_base",b"knowledge_base","state",b"state"]) -> None: ...
global___KnowledgeOperationMetadata = KnowledgeOperationMetadata
