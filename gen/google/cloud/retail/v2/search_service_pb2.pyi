"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.cloud.retail.v2.common_pb2
import google.cloud.retail.v2.product_pb2
import google.protobuf.descriptor
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class SearchRequest(google.protobuf.message.Message):
    """Request message for
    [SearchService.Search][google.cloud.retail.v2.SearchService.Search] method.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _SearchMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _SearchModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SearchMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        SEARCH_MODE_UNSPECIFIED: SearchRequest.SearchMode.ValueType = ...  # 0
        """Default value. In this case both product search and faceted search will
        be performed. Both [SearchResponse.SearchResult] and
        [SearchResponse.Facet] will be returned.
        """

        PRODUCT_SEARCH_ONLY: SearchRequest.SearchMode.ValueType = ...  # 1
        """Only product search will be performed. The faceted search will be
        disabled.

        Only [SearchResponse.SearchResult] will be returned.
        [SearchResponse.Facet] will not be returned, even if
        [SearchRequest.facet_specs][google.cloud.retail.v2.SearchRequest.facet_specs]
        or
        [SearchRequest.dynamic_facet_spec][google.cloud.retail.v2.SearchRequest.dynamic_facet_spec]
        is set.
        """

        FACETED_SEARCH_ONLY: SearchRequest.SearchMode.ValueType = ...  # 2
        """Only faceted search will be performed. The product search will be
        disabled.

        When in this mode, one or both of [SearchRequest.facet_spec][] and
        [SearchRequest.dynamic_facet_spec][google.cloud.retail.v2.SearchRequest.dynamic_facet_spec]
        should be set. Otherwise, an INVALID_ARGUMENT error is returned. Only
        [SearchResponse.Facet] will be returned. [SearchResponse.SearchResult]
        will not be returned.
        """

    class SearchMode(_SearchMode, metaclass=_SearchModeEnumTypeWrapper):
        """The search mode of each search request."""
        pass

    SEARCH_MODE_UNSPECIFIED: SearchRequest.SearchMode.ValueType = ...  # 0
    """Default value. In this case both product search and faceted search will
    be performed. Both [SearchResponse.SearchResult] and
    [SearchResponse.Facet] will be returned.
    """

    PRODUCT_SEARCH_ONLY: SearchRequest.SearchMode.ValueType = ...  # 1
    """Only product search will be performed. The faceted search will be
    disabled.

    Only [SearchResponse.SearchResult] will be returned.
    [SearchResponse.Facet] will not be returned, even if
    [SearchRequest.facet_specs][google.cloud.retail.v2.SearchRequest.facet_specs]
    or
    [SearchRequest.dynamic_facet_spec][google.cloud.retail.v2.SearchRequest.dynamic_facet_spec]
    is set.
    """

    FACETED_SEARCH_ONLY: SearchRequest.SearchMode.ValueType = ...  # 2
    """Only faceted search will be performed. The product search will be
    disabled.

    When in this mode, one or both of [SearchRequest.facet_spec][] and
    [SearchRequest.dynamic_facet_spec][google.cloud.retail.v2.SearchRequest.dynamic_facet_spec]
    should be set. Otherwise, an INVALID_ARGUMENT error is returned. Only
    [SearchResponse.Facet] will be returned. [SearchResponse.SearchResult]
    will not be returned.
    """


    class FacetSpec(google.protobuf.message.Message):
        """A facet specification to perform faceted search."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class FacetKey(google.protobuf.message.Message):
            """Specifies how a facet is computed."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            INTERVALS_FIELD_NUMBER: builtins.int
            RESTRICTED_VALUES_FIELD_NUMBER: builtins.int
            PREFIXES_FIELD_NUMBER: builtins.int
            CONTAINS_FIELD_NUMBER: builtins.int
            ORDER_BY_FIELD_NUMBER: builtins.int
            QUERY_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            """Required. Supported textual and numerical facet keys in
            [Product][google.cloud.retail.v2.Product] object, over which the facet
            values are computed. Facet key is case-sensitive.

            Allowed facet keys when
            [FacetKey.query][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.query]
            is not specified:

            * textual_field =
                * "brands"
                * "categories"
                * "genders"
                * "ageGroups"
                * "availability"
                * "colorFamilies"
                * "colors"
                * "sizes"
                * "materials"
                * "patterns"
                * "conditions"
                * "attributes.key"
                * "pickupInStore"
                * "shipToStore"
                * "sameDayDelivery"
                * "nextDayDelivery"
                * "customFulfillment1"
                * "customFulfillment2"
                * "customFulfillment3"
                * "customFulfillment4"
                * "customFulfillment5"
                * "inventory(place_id,attributes.key)"

            * numerical_field =
                * "price"
                * "discount"
                * "rating"
                * "ratingCount"
                * "attributes.key"
                * "inventory(place_id,price)"
                * "inventory(place_id,attributes.key)"
            """

            @property
            def intervals(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.cloud.retail.v2.common_pb2.Interval]:
                """Set only if values should be bucketized into intervals. Must be set
                for facets with numerical values. Must not be set for facet with text
                values. Maximum number of intervals is 30.
                """
                pass
            @property
            def restricted_values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """Only get facet for the given restricted values. For example, when using
                "pickupInStore" as key and set restricted values to
                ["store123", "store456"], only facets for "store123" and "store456" are
                returned. Only supported on textual fields and fulfillments.
                Maximum is 20.

                Must be set for the fulfillment facet keys:

                * pickupInStore

                * shipToStore

                * sameDayDelivery

                * nextDayDelivery

                * customFulfillment1

                * customFulfillment2

                * customFulfillment3

                * customFulfillment4

                * customFulfillment5
                """
                pass
            @property
            def prefixes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """Only get facet values that start with the given string prefix. For
                example, suppose "categories" has three values "Women > Shoe",
                "Women > Dress" and "Men > Shoe". If set "prefixes" to "Women", the
                "categories" facet will give only "Women > Shoe" and "Women > Dress".
                Only supported on textual fields. Maximum is 10.
                """
                pass
            @property
            def contains(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """Only get facet values that contains the given strings. For example,
                suppose "categories" has three values "Women > Shoe",
                "Women > Dress" and "Men > Shoe". If set "contains" to "Shoe", the
                "categories" facet will give only "Women > Shoe" and "Men > Shoe".
                Only supported on textual fields. Maximum is 10.
                """
                pass
            order_by: typing.Text = ...
            """The order in which [Facet.values][] are returned.

            Allowed values are:

            * "count desc", which means order by [Facet.FacetValue.count][]
            descending.

            * "value desc", which means order by [Facet.FacetValue.value][]
            descending.
              Only applies to textual facets.

            If not set, textual values are sorted in [natural
            order](https://en.wikipedia.org/wiki/Natural_sort_order); numerical
            intervals are sorted in the order given by
            [FacetSpec.FacetKey.intervals][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.intervals];
            [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
            are sorted in the order given by
            [FacetSpec.FacetKey.restricted_values][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.restricted_values].
            """

            query: typing.Text = ...
            """The query that is used to compute facet for the given facet key.
            When provided, it will override the default behavior of facet
            computation. The query syntax is the same as a filter expression. See
            [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter] for
            detail syntax and limitations. Notice that there is no limitation on
            [FacetKey.key][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.key]
            when query is specified.

            In the response, [FacetValue.value][] will be always "1" and
            [FacetValue.count][] will be the number of results that matches the
            query.

            For example, you can set a customized facet for "shipToStore",
            where
            [FacetKey.key][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.key]
            is "customizedShipToStore", and
            [FacetKey.query][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.query]
            is "availability: ANY(\\"IN_STOCK\\") AND shipToStore: ANY(\\"123\\")".
            Then the facet will count the products that are both in stock and ship
            to store "123".
            """

            def __init__(self,
                *,
                key : typing.Text = ...,
                intervals : typing.Optional[typing.Iterable[google.cloud.retail.v2.common_pb2.Interval]] = ...,
                restricted_values : typing.Optional[typing.Iterable[typing.Text]] = ...,
                prefixes : typing.Optional[typing.Iterable[typing.Text]] = ...,
                contains : typing.Optional[typing.Iterable[typing.Text]] = ...,
                order_by : typing.Text = ...,
                query : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["contains",b"contains","intervals",b"intervals","key",b"key","order_by",b"order_by","prefixes",b"prefixes","query",b"query","restricted_values",b"restricted_values"]) -> None: ...

        FACET_KEY_FIELD_NUMBER: builtins.int
        LIMIT_FIELD_NUMBER: builtins.int
        EXCLUDED_FILTER_KEYS_FIELD_NUMBER: builtins.int
        ENABLE_DYNAMIC_POSITION_FIELD_NUMBER: builtins.int
        @property
        def facet_key(self) -> global___SearchRequest.FacetSpec.FacetKey:
            """Required. The facet key specification."""
            pass
        limit: builtins.int = ...
        """Maximum of facet values that should be returned for this facet. If
        unspecified, defaults to 20. The maximum allowed value is 300. Values
        above 300 will be coerced to 300.

        If this field is negative, an INVALID_ARGUMENT is returned.
        """

        @property
        def excluded_filter_keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """List of keys to exclude when faceting.

            By default,
            [FacetKey.key][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.key]
            is not excluded from the filter unless it is listed in this field.

            For example, suppose there are 100 products with color facet "Red" and
            200 products with color facet "Blue". A query containing the filter
            "colorFamilies:ANY("Red")" and have "colorFamilies" as
            [FacetKey.key][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.key]
            will by default return the "Red" with count 100.

            If this field contains "colorFamilies", then the query returns both the
            "Red" with count 100 and "Blue" with count 200, because the
            "colorFamilies" key is now excluded from the filter.

            A maximum of 100 values are allowed. Otherwise, an INVALID_ARGUMENT error
            is returned.
            """
            pass
        enable_dynamic_position: builtins.bool = ...
        """Enables dynamic position for this facet. If set to true, the position of
        this facet among all facets in the response is determined by Google
        Retail Search. It will be ordered together with dynamic facets if dynamic
        facets is enabled. If set to false, the position of this facet in the
        response will be the same as in the request, and it will be ranked before
        the facets with dynamic position enable and all dynamic facets.

        For example, you may always want to have rating facet returned in
        the response, but it's not necessarily to always display the rating facet
        at the top. In that case, you can set enable_dynamic_position to true so
        that the position of rating facet in response will be determined by
        Google Retail Search.

        Another example, assuming you have the following facets in the request:

        * "rating", enable_dynamic_position = true

        * "price", enable_dynamic_position = false

        * "brands", enable_dynamic_position = false

        And also you have a dynamic facets enable, which will generate a facet
        'gender'. Then the final order of the facets in the response can be
        ("price", "brands", "rating", "gender") or ("price", "brands", "gender",
        "rating") depends on how Google Retail Search orders "gender" and
        "rating" facets. However, notice that "price" and "brands" will always be
        ranked at 1st and 2nd position since their enable_dynamic_position are
        false.
        """

        def __init__(self,
            *,
            facet_key : typing.Optional[global___SearchRequest.FacetSpec.FacetKey] = ...,
            limit : builtins.int = ...,
            excluded_filter_keys : typing.Optional[typing.Iterable[typing.Text]] = ...,
            enable_dynamic_position : builtins.bool = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["facet_key",b"facet_key"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["enable_dynamic_position",b"enable_dynamic_position","excluded_filter_keys",b"excluded_filter_keys","facet_key",b"facet_key","limit",b"limit"]) -> None: ...

    class DynamicFacetSpec(google.protobuf.message.Message):
        """The specifications of dynamically generated facets."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _Mode:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _ModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Mode.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            MODE_UNSPECIFIED: SearchRequest.DynamicFacetSpec.Mode.ValueType = ...  # 0
            """Default value."""

            DISABLED: SearchRequest.DynamicFacetSpec.Mode.ValueType = ...  # 1
            """Disable Dynamic Facet."""

            ENABLED: SearchRequest.DynamicFacetSpec.Mode.ValueType = ...  # 2
            """Automatic mode built by Google Retail Search."""

        class Mode(_Mode, metaclass=_ModeEnumTypeWrapper):
            """Enum to control DynamicFacet mode"""
            pass

        MODE_UNSPECIFIED: SearchRequest.DynamicFacetSpec.Mode.ValueType = ...  # 0
        """Default value."""

        DISABLED: SearchRequest.DynamicFacetSpec.Mode.ValueType = ...  # 1
        """Disable Dynamic Facet."""

        ENABLED: SearchRequest.DynamicFacetSpec.Mode.ValueType = ...  # 2
        """Automatic mode built by Google Retail Search."""


        MODE_FIELD_NUMBER: builtins.int
        mode: global___SearchRequest.DynamicFacetSpec.Mode.ValueType = ...
        """Mode of the DynamicFacet feature.
        Defaults to
        [Mode.DISABLED][google.cloud.retail.v2.SearchRequest.DynamicFacetSpec.Mode.DISABLED]
        if it's unset.
        """

        def __init__(self,
            *,
            mode : global___SearchRequest.DynamicFacetSpec.Mode.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["mode",b"mode"]) -> None: ...

    class BoostSpec(google.protobuf.message.Message):
        """Boost specification to boost certain items."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class ConditionBoostSpec(google.protobuf.message.Message):
            """Boost applies to products which match a condition."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            CONDITION_FIELD_NUMBER: builtins.int
            BOOST_FIELD_NUMBER: builtins.int
            condition: typing.Text = ...
            """An expression which specifies a boost condition. The syntax and
            supported fields are the same as a filter expression. See
            [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter] for
            detail syntax and limitations.

            Examples:

            * To boost products with product ID "product_1" or "product_2", and
            color
              "Red" or "Blue":
                * (id: ANY("product_1", "product_2")) AND (colorFamilies:
                ANY("Red","Blue"))
            """

            boost: builtins.float = ...
            """Strength of the condition boost, which should be in [-1, 1]. Negative
            boost means demotion. Default is 0.0.

            Setting to 1.0 gives the item a big promotion. However, it does not
            necessarily mean that the boosted item will be the top result at all
            times, nor that other items will be excluded. Results could still be
            shown even when none of them matches the condition. And results that
            are significantly more relevant to the search query can still trump
            your heavily favored but irrelevant items.

            Setting to -1.0 gives the item a big demotion. However, results that
            are deeply relevant might still be shown. The item will have an
            upstream battle to get a fairly high ranking, but it is not blocked out
            completely.

            Setting to 0.0 means no boost applied. The boosting condition is
            ignored.
            """

            def __init__(self,
                *,
                condition : typing.Text = ...,
                boost : builtins.float = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["boost",b"boost","condition",b"condition"]) -> None: ...

        CONDITION_BOOST_SPECS_FIELD_NUMBER: builtins.int
        @property
        def condition_boost_specs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SearchRequest.BoostSpec.ConditionBoostSpec]:
            """Condition boost specifications. If a product matches multiple conditions
            in the specifictions, boost scores from these specifications are all
            applied and combined in a non-linear way. Maximum number of
            specifications is 10.
            """
            pass
        def __init__(self,
            *,
            condition_boost_specs : typing.Optional[typing.Iterable[global___SearchRequest.BoostSpec.ConditionBoostSpec]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["condition_boost_specs",b"condition_boost_specs"]) -> None: ...

    class QueryExpansionSpec(google.protobuf.message.Message):
        """Specification to determine under which conditions query expansion should
        occur.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _Condition:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _ConditionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Condition.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            CONDITION_UNSPECIFIED: SearchRequest.QueryExpansionSpec.Condition.ValueType = ...  # 0
            """Unspecified query expansion condition. This defaults to
            [Condition.DISABLED][google.cloud.retail.v2.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
            """

            DISABLED: SearchRequest.QueryExpansionSpec.Condition.ValueType = ...  # 1
            """Disabled query expansion. Only the exact search query is used, even if
            [SearchResponse.total_size][google.cloud.retail.v2.SearchResponse.total_size]
            is zero.
            """

            AUTO: SearchRequest.QueryExpansionSpec.Condition.ValueType = ...  # 3
            """Automatic query expansion built by Google Retail Search."""

        class Condition(_Condition, metaclass=_ConditionEnumTypeWrapper):
            """Enum describing under which condition query expansion should occur."""
            pass

        CONDITION_UNSPECIFIED: SearchRequest.QueryExpansionSpec.Condition.ValueType = ...  # 0
        """Unspecified query expansion condition. This defaults to
        [Condition.DISABLED][google.cloud.retail.v2.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
        """

        DISABLED: SearchRequest.QueryExpansionSpec.Condition.ValueType = ...  # 1
        """Disabled query expansion. Only the exact search query is used, even if
        [SearchResponse.total_size][google.cloud.retail.v2.SearchResponse.total_size]
        is zero.
        """

        AUTO: SearchRequest.QueryExpansionSpec.Condition.ValueType = ...  # 3
        """Automatic query expansion built by Google Retail Search."""


        CONDITION_FIELD_NUMBER: builtins.int
        PIN_UNEXPANDED_RESULTS_FIELD_NUMBER: builtins.int
        condition: global___SearchRequest.QueryExpansionSpec.Condition.ValueType = ...
        """The condition under which query expansion should occur. Default to
        [Condition.DISABLED][google.cloud.retail.v2.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
        """

        pin_unexpanded_results: builtins.bool = ...
        """Whether to pin unexpanded results. If this field is set to true,
        unexpanded products are always at the top of the search results, followed
        by the expanded results.
        """

        def __init__(self,
            *,
            condition : global___SearchRequest.QueryExpansionSpec.Condition.ValueType = ...,
            pin_unexpanded_results : builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["condition",b"condition","pin_unexpanded_results",b"pin_unexpanded_results"]) -> None: ...

    PLACEMENT_FIELD_NUMBER: builtins.int
    BRANCH_FIELD_NUMBER: builtins.int
    QUERY_FIELD_NUMBER: builtins.int
    VISITOR_ID_FIELD_NUMBER: builtins.int
    USER_INFO_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    CANONICAL_FILTER_FIELD_NUMBER: builtins.int
    ORDER_BY_FIELD_NUMBER: builtins.int
    FACET_SPECS_FIELD_NUMBER: builtins.int
    DYNAMIC_FACET_SPEC_FIELD_NUMBER: builtins.int
    BOOST_SPEC_FIELD_NUMBER: builtins.int
    QUERY_EXPANSION_SPEC_FIELD_NUMBER: builtins.int
    VARIANT_ROLLUP_KEYS_FIELD_NUMBER: builtins.int
    PAGE_CATEGORIES_FIELD_NUMBER: builtins.int
    SEARCH_MODE_FIELD_NUMBER: builtins.int
    placement: typing.Text = ...
    """Required. The resource name of the search engine placement, such as
    `projects/*/locations/global/catalogs/default_catalog/placements/default_search`.
    This field is used to identify the serving configuration name and the set
    of models that will be used to make the search.
    """

    branch: typing.Text = ...
    """The branch resource name, such as
    `projects/*/locations/global/catalogs/default_catalog/branches/0`.

    Use "default_branch" as the branch ID or leave this field empty, to search
    products under the default branch.
    """

    query: typing.Text = ...
    """Raw search query."""

    visitor_id: typing.Text = ...
    """Required. A unique identifier for tracking visitors. For example, this
    could be implemented with an HTTP cookie, which should be able to uniquely
    identify a visitor on a single device. This unique identifier should not
    change if the visitor logs in or out of the website.

    The field must be a UTF-8 encoded string with a length limit of 128
    characters. Otherwise, an INVALID_ARGUMENT error is returned.
    """

    @property
    def user_info(self) -> google.cloud.retail.v2.common_pb2.UserInfo:
        """User information."""
        pass
    page_size: builtins.int = ...
    """Maximum number of [Product][google.cloud.retail.v2.Product]s to return. If
    unspecified, defaults to a reasonable value. The maximum allowed value is
    120. Values above 120 will be coerced to 120.

    If this field is negative, an INVALID_ARGUMENT is returned.
    """

    page_token: typing.Text = ...
    """A page token
    [SearchResponse.next_page_token][google.cloud.retail.v2.SearchResponse.next_page_token],
    received from a previous
    [SearchService.Search][google.cloud.retail.v2.SearchService.Search] call.
    Provide this to retrieve the subsequent page.

    When paginating, all other parameters provided to
    [SearchService.Search][google.cloud.retail.v2.SearchService.Search] must
    match the call that provided the page token. Otherwise, an INVALID_ARGUMENT
    error is returned.
    """

    offset: builtins.int = ...
    """A 0-indexed integer that specifies the current offset (that is, starting
    result location, amongst the [Product][google.cloud.retail.v2.Product]s
    deemed by the API as relevant) in search results. This field is only
    considered if [page_token][google.cloud.retail.v2.SearchRequest.page_token]
    is unset.

    If this field is negative, an INVALID_ARGUMENT is returned.
    """

    filter: typing.Text = ...
    """The filter syntax consists of an expression language for constructing a
    predicate from one or more fields of the products being filtered. Filter
    expression is case-sensitive. See more details at this [user
    guide](https://cloud.google.com/retail/docs/filter-and-order#filter).

    If this field is unrecognizable, an INVALID_ARGUMENT is returned.
    """

    canonical_filter: typing.Text = ...
    """The filter applied to every search request when quality improvement such as
    query expansion is needed. For example, if a query does not have enough
    results, an expanded query with
    [SearchRequest.canonical_filter][google.cloud.retail.v2.SearchRequest.canonical_filter]
    will be returned as a supplement of the original query. This field is
    strongly recommended to achieve high search quality.

    See [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter] for
    more details about filter syntax.
    """

    order_by: typing.Text = ...
    """The order in which products are returned. Products can be ordered by
    a field in an [Product][google.cloud.retail.v2.Product] object. Leave it
    unset if ordered by relevance. OrderBy expression is case-sensitive. See
    more details at this [user
    guide](https://cloud.google.com/retail/docs/filter-and-order#order).

    If this field is unrecognizable, an INVALID_ARGUMENT is returned.
    """

    @property
    def facet_specs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SearchRequest.FacetSpec]:
        """Facet specifications for faceted search. If empty, no facets are returned.

        A maximum of 100 values are allowed. Otherwise, an INVALID_ARGUMENT error
        is returned.
        """
        pass
    @property
    def dynamic_facet_spec(self) -> global___SearchRequest.DynamicFacetSpec:
        """The specification for dynamically generated facets. Notice that only
        textual facets can be dynamically generated.

        This feature requires additional allowlisting. Contact Retail Search
        support team if you are interested in using dynamic facet feature.
        """
        pass
    @property
    def boost_spec(self) -> global___SearchRequest.BoostSpec:
        """Boost specification to boost certain products. See more details at this
        [user guide](https://cloud.google.com/retail/docs/boosting).

        Notice that if both [ServingConfig.boost_control_ids][] and
        [SearchRequest.boost_spec] are set, the boost conditions from both places
        are evaluated. If a search request matches multiple boost conditions,
        the final boost score is equal to the sum of the boost scores from all
        matched boost conditions.
        """
        pass
    @property
    def query_expansion_spec(self) -> global___SearchRequest.QueryExpansionSpec:
        """The query expansion specification that specifies the conditions under which
        query expansion will occur. See more details at this [user
        guide](https://cloud.google.com/retail/docs/result-size#query_expansion).
        """
        pass
    @property
    def variant_rollup_keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The keys to fetch and rollup the matching
        [variant][google.cloud.retail.v2.Product.Type.VARIANT]
        [Product][google.cloud.retail.v2.Product]s attributes. The attributes from
        all the matching [variant][google.cloud.retail.v2.Product.Type.VARIANT]
        [Product][google.cloud.retail.v2.Product]s are merged and de-duplicated.
        Notice that rollup [variant][google.cloud.retail.v2.Product.Type.VARIANT]
        [Product][google.cloud.retail.v2.Product]s attributes will lead to extra
        query latency. Maximum number of keys is 10.

        For [FulfillmentInfo][google.cloud.retail.v2.FulfillmentInfo], a
        fulfillment type and a fulfillment ID must be provided in the format of
        "fulfillmentType.fulfillmentId". E.g., in "pickupInStore.store123",
        "pickupInStore" is fulfillment type and "store123" is the store ID.

        Supported keys are:

        * colorFamilies
        * price
        * originalPrice
        * discount
        * variantId
        * inventory(place_id,price)
        * inventory(place_id,attributes.key), where key is any key in the
          [Product.inventories.attributes][] map.
        * attributes.key, where key is any key in the
          [Product.attributes][google.cloud.retail.v2.Product.attributes] map.
        * pickupInStore.id, where id is any
        [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
        for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
          "pickup-in-store".
        * shipToStore.id, where id is any
        [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
        for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
          "ship-to-store".
        * sameDayDelivery.id, where id is any
        [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
        for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
          "same-day-delivery".
        * nextDayDelivery.id, where id is any
        [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
        for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
          "next-day-delivery".
        * customFulfillment1.id, where id is any
        [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
        for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
          "custom-type-1".
        * customFulfillment2.id, where id is any
        [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
        for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
          "custom-type-2".
        * customFulfillment3.id, where id is any
        [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
        for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
          "custom-type-3".
        * customFulfillment4.id, where id is any
        [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
        for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
          "custom-type-4".
        * customFulfillment5.id, where id is any
        [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
        for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
          "custom-type-5".

        If this field is set to an invalid value other than these, an
        INVALID_ARGUMENT error is returned.
        """
        pass
    @property
    def page_categories(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The categories associated with a category page. Required for category
        navigation queries to achieve good search quality. The format should be
        the same as
        [UserEvent.page_categories][google.cloud.retail.v2.UserEvent.page_categories];

        To represent full path of category, use '>' sign to separate different
        hierarchies. If '>' is part of the category name, please replace it with
        other character(s).

        Category pages include special pages such as sales or promotions. For
        instance, a special sale page may have the category hierarchy:
        "pageCategories" : ["Sales > 2017 Black Friday Deals"].
        """
        pass
    search_mode: global___SearchRequest.SearchMode.ValueType = ...
    """The search mode of the search request. If not specified, a single search
    request triggers both product search and faceted search.
    """

    def __init__(self,
        *,
        placement : typing.Text = ...,
        branch : typing.Text = ...,
        query : typing.Text = ...,
        visitor_id : typing.Text = ...,
        user_info : typing.Optional[google.cloud.retail.v2.common_pb2.UserInfo] = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        offset : builtins.int = ...,
        filter : typing.Text = ...,
        canonical_filter : typing.Text = ...,
        order_by : typing.Text = ...,
        facet_specs : typing.Optional[typing.Iterable[global___SearchRequest.FacetSpec]] = ...,
        dynamic_facet_spec : typing.Optional[global___SearchRequest.DynamicFacetSpec] = ...,
        boost_spec : typing.Optional[global___SearchRequest.BoostSpec] = ...,
        query_expansion_spec : typing.Optional[global___SearchRequest.QueryExpansionSpec] = ...,
        variant_rollup_keys : typing.Optional[typing.Iterable[typing.Text]] = ...,
        page_categories : typing.Optional[typing.Iterable[typing.Text]] = ...,
        search_mode : global___SearchRequest.SearchMode.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["boost_spec",b"boost_spec","dynamic_facet_spec",b"dynamic_facet_spec","query_expansion_spec",b"query_expansion_spec","user_info",b"user_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["boost_spec",b"boost_spec","branch",b"branch","canonical_filter",b"canonical_filter","dynamic_facet_spec",b"dynamic_facet_spec","facet_specs",b"facet_specs","filter",b"filter","offset",b"offset","order_by",b"order_by","page_categories",b"page_categories","page_size",b"page_size","page_token",b"page_token","placement",b"placement","query",b"query","query_expansion_spec",b"query_expansion_spec","search_mode",b"search_mode","user_info",b"user_info","variant_rollup_keys",b"variant_rollup_keys","visitor_id",b"visitor_id"]) -> None: ...
global___SearchRequest = SearchRequest

class SearchResponse(google.protobuf.message.Message):
    """Response message for
    [SearchService.Search][google.cloud.retail.v2.SearchService.Search] method.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SearchResult(google.protobuf.message.Message):
        """Represents the search results."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class MatchingVariantFieldsEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            @property
            def value(self) -> google.protobuf.field_mask_pb2.FieldMask: ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        class VariantRollupValuesEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            @property
            def value(self) -> google.protobuf.struct_pb2.Value: ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Optional[google.protobuf.struct_pb2.Value] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        ID_FIELD_NUMBER: builtins.int
        PRODUCT_FIELD_NUMBER: builtins.int
        MATCHING_VARIANT_COUNT_FIELD_NUMBER: builtins.int
        MATCHING_VARIANT_FIELDS_FIELD_NUMBER: builtins.int
        VARIANT_ROLLUP_VALUES_FIELD_NUMBER: builtins.int
        id: typing.Text = ...
        """[Product.id][google.cloud.retail.v2.Product.id] of the searched
        [Product][google.cloud.retail.v2.Product].
        """

        @property
        def product(self) -> google.cloud.retail.v2.product_pb2.Product:
            """The product data snippet in the search response. Only
            [Product.name][google.cloud.retail.v2.Product.name] is guaranteed to be
            populated.

            [Product.variants][google.cloud.retail.v2.Product.variants] contains the
            product variants that match the search query. If there are multiple
            product variants matching the query, top 5 most relevant product variants
            are returned and ordered by relevancy.

            If relevancy can be deternmined, use
            [matching_variant_fields][google.cloud.retail.v2.SearchResponse.SearchResult.matching_variant_fields]
            to look up matched product variants fields. If relevancy cannot be
            determined, e.g. when searching "shoe" all products in a shoe product can
            be a match, 5 product variants are returned but order is meaningless.
            """
            pass
        matching_variant_count: builtins.int = ...
        """The count of matched
        [variant][google.cloud.retail.v2.Product.Type.VARIANT]
        [Product][google.cloud.retail.v2.Product]s.
        """

        @property
        def matching_variant_fields(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.protobuf.field_mask_pb2.FieldMask]:
            """If a [variant][google.cloud.retail.v2.Product.Type.VARIANT]
            [Product][google.cloud.retail.v2.Product] matches the search query, this
            map indicates which [Product][google.cloud.retail.v2.Product] fields are
            matched. The key is the
            [Product.name][google.cloud.retail.v2.Product.name], the value is a field
            mask of the matched [Product][google.cloud.retail.v2.Product] fields. If
            matched attributes cannot be determined, this map will be empty.

            For example, a key "sku1" with field mask
            "products.color_info" indicates there is a match between
            "sku1" [ColorInfo][google.cloud.retail.v2.ColorInfo] and the query.
            """
            pass
        @property
        def variant_rollup_values(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.protobuf.struct_pb2.Value]:
            """The rollup matching
            [variant][google.cloud.retail.v2.Product.Type.VARIANT]
            [Product][google.cloud.retail.v2.Product] attributes. The key is one of
            the
            [SearchRequest.variant_rollup_keys][google.cloud.retail.v2.SearchRequest.variant_rollup_keys].
            The values are the merged and de-duplicated
            [Product][google.cloud.retail.v2.Product] attributes. Notice that the
            rollup values are respect filter. For example, when filtering by
            "colorFamilies:ANY(\\"red\\")" and rollup "colorFamilies", only "red" is
            returned.

            For textual and numerical attributes, the rollup values is a list of
            string or double values with type
            [google.protobuf.ListValue][google.protobuf.ListValue]. For example, if
            there are two variants with colors "red" and "blue", the rollup values
            are

                { key: "colorFamilies"
                  value {
                    list_value {
                      values { string_value: "red" }
                      values { string_value: "blue" }
                     }
                  }
                }

            For [FulfillmentInfo][google.cloud.retail.v2.FulfillmentInfo], the rollup
            values is a double value with type
            [google.protobuf.Value][google.protobuf.Value]. For example,
            `{key: "pickupInStore.store1" value { number_value: 10 }}` means a there
            are 10 variants in this product are available in the store "store1".
            """
            pass
        def __init__(self,
            *,
            id : typing.Text = ...,
            product : typing.Optional[google.cloud.retail.v2.product_pb2.Product] = ...,
            matching_variant_count : builtins.int = ...,
            matching_variant_fields : typing.Optional[typing.Mapping[typing.Text, google.protobuf.field_mask_pb2.FieldMask]] = ...,
            variant_rollup_values : typing.Optional[typing.Mapping[typing.Text, google.protobuf.struct_pb2.Value]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["product",b"product"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["id",b"id","matching_variant_count",b"matching_variant_count","matching_variant_fields",b"matching_variant_fields","product",b"product","variant_rollup_values",b"variant_rollup_values"]) -> None: ...

    class Facet(google.protobuf.message.Message):
        """A facet result."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class FacetValue(google.protobuf.message.Message):
            """A facet value which contains value names and their count."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            VALUE_FIELD_NUMBER: builtins.int
            INTERVAL_FIELD_NUMBER: builtins.int
            COUNT_FIELD_NUMBER: builtins.int
            value: typing.Text = ...
            """Text value of a facet, such as "Black" for facet "colorFamilies"."""

            @property
            def interval(self) -> google.cloud.retail.v2.common_pb2.Interval:
                """Interval value for a facet, such as [10, 20) for facet "price"."""
                pass
            count: builtins.int = ...
            """Number of items that have this facet value."""

            def __init__(self,
                *,
                value : typing.Text = ...,
                interval : typing.Optional[google.cloud.retail.v2.common_pb2.Interval] = ...,
                count : builtins.int = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["facet_value",b"facet_value","interval",b"interval","value",b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["count",b"count","facet_value",b"facet_value","interval",b"interval","value",b"value"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["facet_value",b"facet_value"]) -> typing.Optional[typing_extensions.Literal["value","interval"]]: ...

        KEY_FIELD_NUMBER: builtins.int
        VALUES_FIELD_NUMBER: builtins.int
        DYNAMIC_FACET_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        """The key for this facet. E.g., "colorFamilies" or "price" or
        "attributes.attr1".
        """

        @property
        def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SearchResponse.Facet.FacetValue]:
            """The facet values for this field."""
            pass
        dynamic_facet: builtins.bool = ...
        """Whether the facet is dynamically generated."""

        def __init__(self,
            *,
            key : typing.Text = ...,
            values : typing.Optional[typing.Iterable[global___SearchResponse.Facet.FacetValue]] = ...,
            dynamic_facet : builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["dynamic_facet",b"dynamic_facet","key",b"key","values",b"values"]) -> None: ...

    class QueryExpansionInfo(google.protobuf.message.Message):
        """Information describing query expansion including whether expansion has
        occurred.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        EXPANDED_QUERY_FIELD_NUMBER: builtins.int
        PINNED_RESULT_COUNT_FIELD_NUMBER: builtins.int
        expanded_query: builtins.bool = ...
        """Bool describing whether query expansion has occurred."""

        pinned_result_count: builtins.int = ...
        """Number of pinned results. This field will only be set when expansion
        happens and
        [SearchRequest.QueryExpansionSpec.pin_unexpanded_results][google.cloud.retail.v2.SearchRequest.QueryExpansionSpec.pin_unexpanded_results]
        is set to true.
        """

        def __init__(self,
            *,
            expanded_query : builtins.bool = ...,
            pinned_result_count : builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["expanded_query",b"expanded_query","pinned_result_count",b"pinned_result_count"]) -> None: ...

    RESULTS_FIELD_NUMBER: builtins.int
    FACETS_FIELD_NUMBER: builtins.int
    TOTAL_SIZE_FIELD_NUMBER: builtins.int
    CORRECTED_QUERY_FIELD_NUMBER: builtins.int
    ATTRIBUTION_TOKEN_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    QUERY_EXPANSION_INFO_FIELD_NUMBER: builtins.int
    REDIRECT_URI_FIELD_NUMBER: builtins.int
    @property
    def results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SearchResponse.SearchResult]:
        """A list of matched items. The order represents the ranking."""
        pass
    @property
    def facets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SearchResponse.Facet]:
        """Results of facets requested by user."""
        pass
    total_size: builtins.int = ...
    """The estimated total count of matched items irrespective of pagination. The
    count of [results][google.cloud.retail.v2.SearchResponse.results] returned
    by pagination may be less than the
    [total_size][google.cloud.retail.v2.SearchResponse.total_size] that
    matches.
    """

    corrected_query: typing.Text = ...
    """If spell correction applies, the corrected query. Otherwise, empty."""

    attribution_token: typing.Text = ...
    """A unique search token. This should be included in the
    [UserEvent][google.cloud.retail.v2.UserEvent] logs resulting from this
    search, which enables accurate attribution of search model performance.
    """

    next_page_token: typing.Text = ...
    """A token that can be sent as
    [SearchRequest.page_token][google.cloud.retail.v2.SearchRequest.page_token]
    to retrieve the next page. If this field is omitted, there are no
    subsequent pages.
    """

    @property
    def query_expansion_info(self) -> global___SearchResponse.QueryExpansionInfo:
        """Query expansion information for the returned results."""
        pass
    redirect_uri: typing.Text = ...
    """The URI of a customer-defined redirect page. If redirect action is
    triggered, no search will be performed, and only
    [redirect_uri][google.cloud.retail.v2.SearchResponse.redirect_uri] and
    [attribution_token][google.cloud.retail.v2.SearchResponse.attribution_token]
    will be set in the response.
    """

    def __init__(self,
        *,
        results : typing.Optional[typing.Iterable[global___SearchResponse.SearchResult]] = ...,
        facets : typing.Optional[typing.Iterable[global___SearchResponse.Facet]] = ...,
        total_size : builtins.int = ...,
        corrected_query : typing.Text = ...,
        attribution_token : typing.Text = ...,
        next_page_token : typing.Text = ...,
        query_expansion_info : typing.Optional[global___SearchResponse.QueryExpansionInfo] = ...,
        redirect_uri : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["query_expansion_info",b"query_expansion_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["attribution_token",b"attribution_token","corrected_query",b"corrected_query","facets",b"facets","next_page_token",b"next_page_token","query_expansion_info",b"query_expansion_info","redirect_uri",b"redirect_uri","results",b"results","total_size",b"total_size"]) -> None: ...
global___SearchResponse = SearchResponse
