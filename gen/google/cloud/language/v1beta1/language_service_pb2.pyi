"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _EncodingType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _EncodingTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EncodingType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    NONE: EncodingType.ValueType = ...  # 0
    """If `EncodingType` is not specified, encoding-dependent information (such as
    `begin_offset`) will be set at `-1`.
    """

    UTF8: EncodingType.ValueType = ...  # 1
    """Encoding-dependent information (such as `begin_offset`) is calculated based
    on the UTF-8 encoding of the input. C++ and Go are examples of languages
    that use this encoding natively.
    """

    UTF16: EncodingType.ValueType = ...  # 2
    """Encoding-dependent information (such as `begin_offset`) is calculated based
    on the UTF-16 encoding of the input. Java and Javascript are examples of
    languages that use this encoding natively.
    """

    UTF32: EncodingType.ValueType = ...  # 3
    """Encoding-dependent information (such as `begin_offset`) is calculated based
    on the UTF-32 encoding of the input. Python is an example of a language
    that uses this encoding natively.
    """

class EncodingType(_EncodingType, metaclass=_EncodingTypeEnumTypeWrapper):
    """Represents the text encoding that the caller uses to process the output.
    Providing an `EncodingType` is recommended because the API provides the
    beginning offsets for various outputs, such as tokens and mentions, and
    languages that natively use different text encodings may access offsets
    differently.
    """
    pass

NONE: EncodingType.ValueType = ...  # 0
"""If `EncodingType` is not specified, encoding-dependent information (such as
`begin_offset`) will be set at `-1`.
"""

UTF8: EncodingType.ValueType = ...  # 1
"""Encoding-dependent information (such as `begin_offset`) is calculated based
on the UTF-8 encoding of the input. C++ and Go are examples of languages
that use this encoding natively.
"""

UTF16: EncodingType.ValueType = ...  # 2
"""Encoding-dependent information (such as `begin_offset`) is calculated based
on the UTF-16 encoding of the input. Java and Javascript are examples of
languages that use this encoding natively.
"""

UTF32: EncodingType.ValueType = ...  # 3
"""Encoding-dependent information (such as `begin_offset`) is calculated based
on the UTF-32 encoding of the input. Python is an example of a language
that uses this encoding natively.
"""

global___EncodingType = EncodingType


class Document(google.protobuf.message.Message):
    """
    Represents the input to API methods.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        TYPE_UNSPECIFIED: Document.Type.ValueType = ...  # 0
        """The content type is not specified."""

        PLAIN_TEXT: Document.Type.ValueType = ...  # 1
        """Plain text"""

        HTML: Document.Type.ValueType = ...  # 2
        """HTML"""

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """The document types enum."""
        pass

    TYPE_UNSPECIFIED: Document.Type.ValueType = ...  # 0
    """The content type is not specified."""

    PLAIN_TEXT: Document.Type.ValueType = ...  # 1
    """Plain text"""

    HTML: Document.Type.ValueType = ...  # 2
    """HTML"""


    TYPE_FIELD_NUMBER: builtins.int
    CONTENT_FIELD_NUMBER: builtins.int
    GCS_CONTENT_URI_FIELD_NUMBER: builtins.int
    LANGUAGE_FIELD_NUMBER: builtins.int
    type: global___Document.Type.ValueType = ...
    """Required. If the type is not set or is `TYPE_UNSPECIFIED`,
    returns an `INVALID_ARGUMENT` error.
    """

    content: typing.Text = ...
    """The content of the input in string format."""

    gcs_content_uri: typing.Text = ...
    """The Google Cloud Storage URI where the file content is located.
    This URI must be of the form: gs://bucket_name/object_name. For more
    details, see https://cloud.google.com/storage/docs/reference-uris.
    NOTE: Cloud Storage object versioning is not supported.
    """

    language: typing.Text = ...
    """The language of the document (if not specified, the language is
    automatically detected). Both ISO and BCP-47 language codes are
    accepted.<br>
    [Language
    Support](https://cloud.google.com/natural-language/docs/languages) lists
    currently supported languages for each API method. If the language (either
    specified by the caller or automatically detected) is not supported by the
    called API method, an `INVALID_ARGUMENT` error is returned.
    """

    def __init__(self,
        *,
        type : global___Document.Type.ValueType = ...,
        content : typing.Text = ...,
        gcs_content_uri : typing.Text = ...,
        language : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["content",b"content","gcs_content_uri",b"gcs_content_uri","source",b"source"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["content",b"content","gcs_content_uri",b"gcs_content_uri","language",b"language","source",b"source","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["content","gcs_content_uri"]]: ...
global___Document = Document

class Sentence(google.protobuf.message.Message):
    """Represents a sentence in the input document."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TEXT_FIELD_NUMBER: builtins.int
    SENTIMENT_FIELD_NUMBER: builtins.int
    @property
    def text(self) -> global___TextSpan:
        """The sentence text."""
        pass
    @property
    def sentiment(self) -> global___Sentiment:
        """For calls to [AnalyzeSentiment][] or if
        [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_document_sentiment]
        is set to true, this field will contain the sentiment for the sentence.
        """
        pass
    def __init__(self,
        *,
        text : typing.Optional[global___TextSpan] = ...,
        sentiment : typing.Optional[global___Sentiment] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["sentiment",b"sentiment","text",b"text"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["sentiment",b"sentiment","text",b"text"]) -> None: ...
global___Sentence = Sentence

class Entity(google.protobuf.message.Message):
    """Represents a phrase in the text that is a known entity, such as
    a person, an organization, or location. The API associates information, such
    as salience and mentions, with entities.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNKNOWN: Entity.Type.ValueType = ...  # 0
        """Unknown"""

        PERSON: Entity.Type.ValueType = ...  # 1
        """Person"""

        LOCATION: Entity.Type.ValueType = ...  # 2
        """Location"""

        ORGANIZATION: Entity.Type.ValueType = ...  # 3
        """Organization"""

        EVENT: Entity.Type.ValueType = ...  # 4
        """Event"""

        WORK_OF_ART: Entity.Type.ValueType = ...  # 5
        """Work of art"""

        CONSUMER_GOOD: Entity.Type.ValueType = ...  # 6
        """Consumer goods"""

        OTHER: Entity.Type.ValueType = ...  # 7
        """Other types"""

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """The type of the entity."""
        pass

    UNKNOWN: Entity.Type.ValueType = ...  # 0
    """Unknown"""

    PERSON: Entity.Type.ValueType = ...  # 1
    """Person"""

    LOCATION: Entity.Type.ValueType = ...  # 2
    """Location"""

    ORGANIZATION: Entity.Type.ValueType = ...  # 3
    """Organization"""

    EVENT: Entity.Type.ValueType = ...  # 4
    """Event"""

    WORK_OF_ART: Entity.Type.ValueType = ...  # 5
    """Work of art"""

    CONSUMER_GOOD: Entity.Type.ValueType = ...  # 6
    """Consumer goods"""

    OTHER: Entity.Type.ValueType = ...  # 7
    """Other types"""


    class MetadataEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    SALIENCE_FIELD_NUMBER: builtins.int
    MENTIONS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The representative name for the entity."""

    type: global___Entity.Type.ValueType = ...
    """The entity type."""

    @property
    def metadata(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Metadata associated with the entity.

        Currently, Wikipedia URLs and Knowledge Graph MIDs are provided, if
        available. The associated keys are "wikipedia_url" and "mid", respectively.
        """
        pass
    salience: builtins.float = ...
    """The salience score associated with the entity in the [0, 1.0] range.

    The salience score for an entity provides information about the
    importance or centrality of that entity to the entire document text.
    Scores closer to 0 are less salient, while scores closer to 1.0 are highly
    salient.
    """

    @property
    def mentions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EntityMention]:
        """The mentions of this entity in the input document. The API currently
        supports proper noun mentions.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        type : global___Entity.Type.ValueType = ...,
        metadata : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        salience : builtins.float = ...,
        mentions : typing.Optional[typing.Iterable[global___EntityMention]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["mentions",b"mentions","metadata",b"metadata","name",b"name","salience",b"salience","type",b"type"]) -> None: ...
global___Entity = Entity

class Token(google.protobuf.message.Message):
    """Represents the smallest syntactic building block of the text."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TEXT_FIELD_NUMBER: builtins.int
    PART_OF_SPEECH_FIELD_NUMBER: builtins.int
    DEPENDENCY_EDGE_FIELD_NUMBER: builtins.int
    LEMMA_FIELD_NUMBER: builtins.int
    @property
    def text(self) -> global___TextSpan:
        """The token text."""
        pass
    @property
    def part_of_speech(self) -> global___PartOfSpeech:
        """Parts of speech tag for this token."""
        pass
    @property
    def dependency_edge(self) -> global___DependencyEdge:
        """Dependency tree parse for this token."""
        pass
    lemma: typing.Text = ...
    """[Lemma](https://en.wikipedia.org/wiki/Lemma_%28morphology%29) of the token."""

    def __init__(self,
        *,
        text : typing.Optional[global___TextSpan] = ...,
        part_of_speech : typing.Optional[global___PartOfSpeech] = ...,
        dependency_edge : typing.Optional[global___DependencyEdge] = ...,
        lemma : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dependency_edge",b"dependency_edge","part_of_speech",b"part_of_speech","text",b"text"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dependency_edge",b"dependency_edge","lemma",b"lemma","part_of_speech",b"part_of_speech","text",b"text"]) -> None: ...
global___Token = Token

class Sentiment(google.protobuf.message.Message):
    """Represents the feeling associated with the entire text or entities in
    the text.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    POLARITY_FIELD_NUMBER: builtins.int
    MAGNITUDE_FIELD_NUMBER: builtins.int
    SCORE_FIELD_NUMBER: builtins.int
    polarity: builtins.float = ...
    """DEPRECATED FIELD - This field is being deprecated in
    favor of score. Please refer to our documentation at
    https://cloud.google.com/natural-language/docs for more information.
    """

    magnitude: builtins.float = ...
    """A non-negative number in the [0, +inf) range, which represents
    the absolute magnitude of sentiment regardless of score (positive or
    negative).
    """

    score: builtins.float = ...
    """Sentiment score between -1.0 (negative sentiment) and 1.0
    (positive sentiment).
    """

    def __init__(self,
        *,
        polarity : builtins.float = ...,
        magnitude : builtins.float = ...,
        score : builtins.float = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["magnitude",b"magnitude","polarity",b"polarity","score",b"score"]) -> None: ...
global___Sentiment = Sentiment

class PartOfSpeech(google.protobuf.message.Message):
    """Represents part of speech information for a token."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Tag:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TagEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Tag.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNKNOWN: PartOfSpeech.Tag.ValueType = ...  # 0
        """Unknown"""

        ADJ: PartOfSpeech.Tag.ValueType = ...  # 1
        """Adjective"""

        ADP: PartOfSpeech.Tag.ValueType = ...  # 2
        """Adposition (preposition and postposition)"""

        ADV: PartOfSpeech.Tag.ValueType = ...  # 3
        """Adverb"""

        CONJ: PartOfSpeech.Tag.ValueType = ...  # 4
        """Conjunction"""

        DET: PartOfSpeech.Tag.ValueType = ...  # 5
        """Determiner"""

        NOUN: PartOfSpeech.Tag.ValueType = ...  # 6
        """Noun (common and proper)"""

        NUM: PartOfSpeech.Tag.ValueType = ...  # 7
        """Cardinal number"""

        PRON: PartOfSpeech.Tag.ValueType = ...  # 8
        """Pronoun"""

        PRT: PartOfSpeech.Tag.ValueType = ...  # 9
        """Particle or other function word"""

        PUNCT: PartOfSpeech.Tag.ValueType = ...  # 10
        """Punctuation"""

        VERB: PartOfSpeech.Tag.ValueType = ...  # 11
        """Verb (all tenses and modes)"""

        X: PartOfSpeech.Tag.ValueType = ...  # 12
        """Other: foreign words, typos, abbreviations"""

        AFFIX: PartOfSpeech.Tag.ValueType = ...  # 13
        """Affix"""

    class Tag(_Tag, metaclass=_TagEnumTypeWrapper):
        """The part of speech tags enum."""
        pass

    UNKNOWN: PartOfSpeech.Tag.ValueType = ...  # 0
    """Unknown"""

    ADJ: PartOfSpeech.Tag.ValueType = ...  # 1
    """Adjective"""

    ADP: PartOfSpeech.Tag.ValueType = ...  # 2
    """Adposition (preposition and postposition)"""

    ADV: PartOfSpeech.Tag.ValueType = ...  # 3
    """Adverb"""

    CONJ: PartOfSpeech.Tag.ValueType = ...  # 4
    """Conjunction"""

    DET: PartOfSpeech.Tag.ValueType = ...  # 5
    """Determiner"""

    NOUN: PartOfSpeech.Tag.ValueType = ...  # 6
    """Noun (common and proper)"""

    NUM: PartOfSpeech.Tag.ValueType = ...  # 7
    """Cardinal number"""

    PRON: PartOfSpeech.Tag.ValueType = ...  # 8
    """Pronoun"""

    PRT: PartOfSpeech.Tag.ValueType = ...  # 9
    """Particle or other function word"""

    PUNCT: PartOfSpeech.Tag.ValueType = ...  # 10
    """Punctuation"""

    VERB: PartOfSpeech.Tag.ValueType = ...  # 11
    """Verb (all tenses and modes)"""

    X: PartOfSpeech.Tag.ValueType = ...  # 12
    """Other: foreign words, typos, abbreviations"""

    AFFIX: PartOfSpeech.Tag.ValueType = ...  # 13
    """Affix"""


    class _Aspect:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _AspectEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Aspect.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        ASPECT_UNKNOWN: PartOfSpeech.Aspect.ValueType = ...  # 0
        """Aspect is not applicable in the analyzed language or is not predicted."""

        PERFECTIVE: PartOfSpeech.Aspect.ValueType = ...  # 1
        """Perfective"""

        IMPERFECTIVE: PartOfSpeech.Aspect.ValueType = ...  # 2
        """Imperfective"""

        PROGRESSIVE: PartOfSpeech.Aspect.ValueType = ...  # 3
        """Progressive"""

    class Aspect(_Aspect, metaclass=_AspectEnumTypeWrapper):
        """The characteristic of a verb that expresses time flow during an event."""
        pass

    ASPECT_UNKNOWN: PartOfSpeech.Aspect.ValueType = ...  # 0
    """Aspect is not applicable in the analyzed language or is not predicted."""

    PERFECTIVE: PartOfSpeech.Aspect.ValueType = ...  # 1
    """Perfective"""

    IMPERFECTIVE: PartOfSpeech.Aspect.ValueType = ...  # 2
    """Imperfective"""

    PROGRESSIVE: PartOfSpeech.Aspect.ValueType = ...  # 3
    """Progressive"""


    class _Case:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _CaseEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Case.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        CASE_UNKNOWN: PartOfSpeech.Case.ValueType = ...  # 0
        """Case is not applicable in the analyzed language or is not predicted."""

        ACCUSATIVE: PartOfSpeech.Case.ValueType = ...  # 1
        """Accusative"""

        ADVERBIAL: PartOfSpeech.Case.ValueType = ...  # 2
        """Adverbial"""

        COMPLEMENTIVE: PartOfSpeech.Case.ValueType = ...  # 3
        """Complementive"""

        DATIVE: PartOfSpeech.Case.ValueType = ...  # 4
        """Dative"""

        GENITIVE: PartOfSpeech.Case.ValueType = ...  # 5
        """Genitive"""

        INSTRUMENTAL: PartOfSpeech.Case.ValueType = ...  # 6
        """Instrumental"""

        LOCATIVE: PartOfSpeech.Case.ValueType = ...  # 7
        """Locative"""

        NOMINATIVE: PartOfSpeech.Case.ValueType = ...  # 8
        """Nominative"""

        OBLIQUE: PartOfSpeech.Case.ValueType = ...  # 9
        """Oblique"""

        PARTITIVE: PartOfSpeech.Case.ValueType = ...  # 10
        """Partitive"""

        PREPOSITIONAL: PartOfSpeech.Case.ValueType = ...  # 11
        """Prepositional"""

        REFLEXIVE_CASE: PartOfSpeech.Case.ValueType = ...  # 12
        """Reflexive"""

        RELATIVE_CASE: PartOfSpeech.Case.ValueType = ...  # 13
        """Relative"""

        VOCATIVE: PartOfSpeech.Case.ValueType = ...  # 14
        """Vocative"""

    class Case(_Case, metaclass=_CaseEnumTypeWrapper):
        """The grammatical function performed by a noun or pronoun in a phrase,
        clause, or sentence. In some languages, other parts of speech, such as
        adjective and determiner, take case inflection in agreement with the noun.
        """
        pass

    CASE_UNKNOWN: PartOfSpeech.Case.ValueType = ...  # 0
    """Case is not applicable in the analyzed language or is not predicted."""

    ACCUSATIVE: PartOfSpeech.Case.ValueType = ...  # 1
    """Accusative"""

    ADVERBIAL: PartOfSpeech.Case.ValueType = ...  # 2
    """Adverbial"""

    COMPLEMENTIVE: PartOfSpeech.Case.ValueType = ...  # 3
    """Complementive"""

    DATIVE: PartOfSpeech.Case.ValueType = ...  # 4
    """Dative"""

    GENITIVE: PartOfSpeech.Case.ValueType = ...  # 5
    """Genitive"""

    INSTRUMENTAL: PartOfSpeech.Case.ValueType = ...  # 6
    """Instrumental"""

    LOCATIVE: PartOfSpeech.Case.ValueType = ...  # 7
    """Locative"""

    NOMINATIVE: PartOfSpeech.Case.ValueType = ...  # 8
    """Nominative"""

    OBLIQUE: PartOfSpeech.Case.ValueType = ...  # 9
    """Oblique"""

    PARTITIVE: PartOfSpeech.Case.ValueType = ...  # 10
    """Partitive"""

    PREPOSITIONAL: PartOfSpeech.Case.ValueType = ...  # 11
    """Prepositional"""

    REFLEXIVE_CASE: PartOfSpeech.Case.ValueType = ...  # 12
    """Reflexive"""

    RELATIVE_CASE: PartOfSpeech.Case.ValueType = ...  # 13
    """Relative"""

    VOCATIVE: PartOfSpeech.Case.ValueType = ...  # 14
    """Vocative"""


    class _Form:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _FormEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Form.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        FORM_UNKNOWN: PartOfSpeech.Form.ValueType = ...  # 0
        """Form is not applicable in the analyzed language or is not predicted."""

        ADNOMIAL: PartOfSpeech.Form.ValueType = ...  # 1
        """Adnomial"""

        AUXILIARY: PartOfSpeech.Form.ValueType = ...  # 2
        """Auxiliary"""

        COMPLEMENTIZER: PartOfSpeech.Form.ValueType = ...  # 3
        """Complementizer"""

        FINAL_ENDING: PartOfSpeech.Form.ValueType = ...  # 4
        """Final ending"""

        GERUND: PartOfSpeech.Form.ValueType = ...  # 5
        """Gerund"""

        REALIS: PartOfSpeech.Form.ValueType = ...  # 6
        """Realis"""

        IRREALIS: PartOfSpeech.Form.ValueType = ...  # 7
        """Irrealis"""

        SHORT: PartOfSpeech.Form.ValueType = ...  # 8
        """Short form"""

        LONG: PartOfSpeech.Form.ValueType = ...  # 9
        """Long form"""

        ORDER: PartOfSpeech.Form.ValueType = ...  # 10
        """Order form"""

        SPECIFIC: PartOfSpeech.Form.ValueType = ...  # 11
        """Specific form"""

    class Form(_Form, metaclass=_FormEnumTypeWrapper):
        """Depending on the language, Form can be categorizing different forms of
        verbs, adjectives, adverbs, etc. For example, categorizing inflected
        endings of verbs and adjectives or distinguishing between short and long
        forms of adjectives and participles
        """
        pass

    FORM_UNKNOWN: PartOfSpeech.Form.ValueType = ...  # 0
    """Form is not applicable in the analyzed language or is not predicted."""

    ADNOMIAL: PartOfSpeech.Form.ValueType = ...  # 1
    """Adnomial"""

    AUXILIARY: PartOfSpeech.Form.ValueType = ...  # 2
    """Auxiliary"""

    COMPLEMENTIZER: PartOfSpeech.Form.ValueType = ...  # 3
    """Complementizer"""

    FINAL_ENDING: PartOfSpeech.Form.ValueType = ...  # 4
    """Final ending"""

    GERUND: PartOfSpeech.Form.ValueType = ...  # 5
    """Gerund"""

    REALIS: PartOfSpeech.Form.ValueType = ...  # 6
    """Realis"""

    IRREALIS: PartOfSpeech.Form.ValueType = ...  # 7
    """Irrealis"""

    SHORT: PartOfSpeech.Form.ValueType = ...  # 8
    """Short form"""

    LONG: PartOfSpeech.Form.ValueType = ...  # 9
    """Long form"""

    ORDER: PartOfSpeech.Form.ValueType = ...  # 10
    """Order form"""

    SPECIFIC: PartOfSpeech.Form.ValueType = ...  # 11
    """Specific form"""


    class _Gender:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _GenderEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Gender.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        GENDER_UNKNOWN: PartOfSpeech.Gender.ValueType = ...  # 0
        """Gender is not applicable in the analyzed language or is not predicted."""

        FEMININE: PartOfSpeech.Gender.ValueType = ...  # 1
        """Feminine"""

        MASCULINE: PartOfSpeech.Gender.ValueType = ...  # 2
        """Masculine"""

        NEUTER: PartOfSpeech.Gender.ValueType = ...  # 3
        """Neuter"""

    class Gender(_Gender, metaclass=_GenderEnumTypeWrapper):
        """Gender classes of nouns reflected in the behaviour of associated words."""
        pass

    GENDER_UNKNOWN: PartOfSpeech.Gender.ValueType = ...  # 0
    """Gender is not applicable in the analyzed language or is not predicted."""

    FEMININE: PartOfSpeech.Gender.ValueType = ...  # 1
    """Feminine"""

    MASCULINE: PartOfSpeech.Gender.ValueType = ...  # 2
    """Masculine"""

    NEUTER: PartOfSpeech.Gender.ValueType = ...  # 3
    """Neuter"""


    class _Mood:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _MoodEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Mood.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        MOOD_UNKNOWN: PartOfSpeech.Mood.ValueType = ...  # 0
        """Mood is not applicable in the analyzed language or is not predicted."""

        CONDITIONAL_MOOD: PartOfSpeech.Mood.ValueType = ...  # 1
        """Conditional"""

        IMPERATIVE: PartOfSpeech.Mood.ValueType = ...  # 2
        """Imperative"""

        INDICATIVE: PartOfSpeech.Mood.ValueType = ...  # 3
        """Indicative"""

        INTERROGATIVE: PartOfSpeech.Mood.ValueType = ...  # 4
        """Interrogative"""

        JUSSIVE: PartOfSpeech.Mood.ValueType = ...  # 5
        """Jussive"""

        SUBJUNCTIVE: PartOfSpeech.Mood.ValueType = ...  # 6
        """Subjunctive"""

    class Mood(_Mood, metaclass=_MoodEnumTypeWrapper):
        """The grammatical feature of verbs, used for showing modality and attitude."""
        pass

    MOOD_UNKNOWN: PartOfSpeech.Mood.ValueType = ...  # 0
    """Mood is not applicable in the analyzed language or is not predicted."""

    CONDITIONAL_MOOD: PartOfSpeech.Mood.ValueType = ...  # 1
    """Conditional"""

    IMPERATIVE: PartOfSpeech.Mood.ValueType = ...  # 2
    """Imperative"""

    INDICATIVE: PartOfSpeech.Mood.ValueType = ...  # 3
    """Indicative"""

    INTERROGATIVE: PartOfSpeech.Mood.ValueType = ...  # 4
    """Interrogative"""

    JUSSIVE: PartOfSpeech.Mood.ValueType = ...  # 5
    """Jussive"""

    SUBJUNCTIVE: PartOfSpeech.Mood.ValueType = ...  # 6
    """Subjunctive"""


    class _Number:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _NumberEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Number.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        NUMBER_UNKNOWN: PartOfSpeech.Number.ValueType = ...  # 0
        """Number is not applicable in the analyzed language or is not predicted."""

        SINGULAR: PartOfSpeech.Number.ValueType = ...  # 1
        """Singular"""

        PLURAL: PartOfSpeech.Number.ValueType = ...  # 2
        """Plural"""

        DUAL: PartOfSpeech.Number.ValueType = ...  # 3
        """Dual"""

    class Number(_Number, metaclass=_NumberEnumTypeWrapper):
        """Count distinctions."""
        pass

    NUMBER_UNKNOWN: PartOfSpeech.Number.ValueType = ...  # 0
    """Number is not applicable in the analyzed language or is not predicted."""

    SINGULAR: PartOfSpeech.Number.ValueType = ...  # 1
    """Singular"""

    PLURAL: PartOfSpeech.Number.ValueType = ...  # 2
    """Plural"""

    DUAL: PartOfSpeech.Number.ValueType = ...  # 3
    """Dual"""


    class _Person:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _PersonEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Person.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        PERSON_UNKNOWN: PartOfSpeech.Person.ValueType = ...  # 0
        """Person is not applicable in the analyzed language or is not predicted."""

        FIRST: PartOfSpeech.Person.ValueType = ...  # 1
        """First"""

        SECOND: PartOfSpeech.Person.ValueType = ...  # 2
        """Second"""

        THIRD: PartOfSpeech.Person.ValueType = ...  # 3
        """Third"""

        REFLEXIVE_PERSON: PartOfSpeech.Person.ValueType = ...  # 4
        """Reflexive"""

    class Person(_Person, metaclass=_PersonEnumTypeWrapper):
        """The distinction between the speaker, second person, third person, etc."""
        pass

    PERSON_UNKNOWN: PartOfSpeech.Person.ValueType = ...  # 0
    """Person is not applicable in the analyzed language or is not predicted."""

    FIRST: PartOfSpeech.Person.ValueType = ...  # 1
    """First"""

    SECOND: PartOfSpeech.Person.ValueType = ...  # 2
    """Second"""

    THIRD: PartOfSpeech.Person.ValueType = ...  # 3
    """Third"""

    REFLEXIVE_PERSON: PartOfSpeech.Person.ValueType = ...  # 4
    """Reflexive"""


    class _Proper:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ProperEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Proper.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        PROPER_UNKNOWN: PartOfSpeech.Proper.ValueType = ...  # 0
        """Proper is not applicable in the analyzed language or is not predicted."""

        PROPER: PartOfSpeech.Proper.ValueType = ...  # 1
        """Proper"""

        NOT_PROPER: PartOfSpeech.Proper.ValueType = ...  # 2
        """Not proper"""

    class Proper(_Proper, metaclass=_ProperEnumTypeWrapper):
        """This category shows if the token is part of a proper name."""
        pass

    PROPER_UNKNOWN: PartOfSpeech.Proper.ValueType = ...  # 0
    """Proper is not applicable in the analyzed language or is not predicted."""

    PROPER: PartOfSpeech.Proper.ValueType = ...  # 1
    """Proper"""

    NOT_PROPER: PartOfSpeech.Proper.ValueType = ...  # 2
    """Not proper"""


    class _Reciprocity:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ReciprocityEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Reciprocity.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        RECIPROCITY_UNKNOWN: PartOfSpeech.Reciprocity.ValueType = ...  # 0
        """Reciprocity is not applicable in the analyzed language or is not
        predicted.
        """

        RECIPROCAL: PartOfSpeech.Reciprocity.ValueType = ...  # 1
        """Reciprocal"""

        NON_RECIPROCAL: PartOfSpeech.Reciprocity.ValueType = ...  # 2
        """Non-reciprocal"""

    class Reciprocity(_Reciprocity, metaclass=_ReciprocityEnumTypeWrapper):
        """Reciprocal features of a pronoun."""
        pass

    RECIPROCITY_UNKNOWN: PartOfSpeech.Reciprocity.ValueType = ...  # 0
    """Reciprocity is not applicable in the analyzed language or is not
    predicted.
    """

    RECIPROCAL: PartOfSpeech.Reciprocity.ValueType = ...  # 1
    """Reciprocal"""

    NON_RECIPROCAL: PartOfSpeech.Reciprocity.ValueType = ...  # 2
    """Non-reciprocal"""


    class _Tense:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TenseEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Tense.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        TENSE_UNKNOWN: PartOfSpeech.Tense.ValueType = ...  # 0
        """Tense is not applicable in the analyzed language or is not predicted."""

        CONDITIONAL_TENSE: PartOfSpeech.Tense.ValueType = ...  # 1
        """Conditional"""

        FUTURE: PartOfSpeech.Tense.ValueType = ...  # 2
        """Future"""

        PAST: PartOfSpeech.Tense.ValueType = ...  # 3
        """Past"""

        PRESENT: PartOfSpeech.Tense.ValueType = ...  # 4
        """Present"""

        IMPERFECT: PartOfSpeech.Tense.ValueType = ...  # 5
        """Imperfect"""

        PLUPERFECT: PartOfSpeech.Tense.ValueType = ...  # 6
        """Pluperfect"""

    class Tense(_Tense, metaclass=_TenseEnumTypeWrapper):
        """Time reference."""
        pass

    TENSE_UNKNOWN: PartOfSpeech.Tense.ValueType = ...  # 0
    """Tense is not applicable in the analyzed language or is not predicted."""

    CONDITIONAL_TENSE: PartOfSpeech.Tense.ValueType = ...  # 1
    """Conditional"""

    FUTURE: PartOfSpeech.Tense.ValueType = ...  # 2
    """Future"""

    PAST: PartOfSpeech.Tense.ValueType = ...  # 3
    """Past"""

    PRESENT: PartOfSpeech.Tense.ValueType = ...  # 4
    """Present"""

    IMPERFECT: PartOfSpeech.Tense.ValueType = ...  # 5
    """Imperfect"""

    PLUPERFECT: PartOfSpeech.Tense.ValueType = ...  # 6
    """Pluperfect"""


    class _Voice:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _VoiceEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Voice.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        VOICE_UNKNOWN: PartOfSpeech.Voice.ValueType = ...  # 0
        """Voice is not applicable in the analyzed language or is not predicted."""

        ACTIVE: PartOfSpeech.Voice.ValueType = ...  # 1
        """Active"""

        CAUSATIVE: PartOfSpeech.Voice.ValueType = ...  # 2
        """Causative"""

        PASSIVE: PartOfSpeech.Voice.ValueType = ...  # 3
        """Passive"""

    class Voice(_Voice, metaclass=_VoiceEnumTypeWrapper):
        """The relationship between the action that a verb expresses and the
        participants identified by its arguments.
        """
        pass

    VOICE_UNKNOWN: PartOfSpeech.Voice.ValueType = ...  # 0
    """Voice is not applicable in the analyzed language or is not predicted."""

    ACTIVE: PartOfSpeech.Voice.ValueType = ...  # 1
    """Active"""

    CAUSATIVE: PartOfSpeech.Voice.ValueType = ...  # 2
    """Causative"""

    PASSIVE: PartOfSpeech.Voice.ValueType = ...  # 3
    """Passive"""


    TAG_FIELD_NUMBER: builtins.int
    ASPECT_FIELD_NUMBER: builtins.int
    CASE_FIELD_NUMBER: builtins.int
    FORM_FIELD_NUMBER: builtins.int
    GENDER_FIELD_NUMBER: builtins.int
    MOOD_FIELD_NUMBER: builtins.int
    NUMBER_FIELD_NUMBER: builtins.int
    PERSON_FIELD_NUMBER: builtins.int
    PROPER_FIELD_NUMBER: builtins.int
    RECIPROCITY_FIELD_NUMBER: builtins.int
    TENSE_FIELD_NUMBER: builtins.int
    VOICE_FIELD_NUMBER: builtins.int
    tag: global___PartOfSpeech.Tag.ValueType = ...
    """The part of speech tag."""

    aspect: global___PartOfSpeech.Aspect.ValueType = ...
    """The grammatical aspect."""

    case: global___PartOfSpeech.Case.ValueType = ...
    """The grammatical case."""

    form: global___PartOfSpeech.Form.ValueType = ...
    """The grammatical form."""

    gender: global___PartOfSpeech.Gender.ValueType = ...
    """The grammatical gender."""

    mood: global___PartOfSpeech.Mood.ValueType = ...
    """The grammatical mood."""

    number: global___PartOfSpeech.Number.ValueType = ...
    """The grammatical number."""

    person: global___PartOfSpeech.Person.ValueType = ...
    """The grammatical person."""

    proper: global___PartOfSpeech.Proper.ValueType = ...
    """The grammatical properness."""

    reciprocity: global___PartOfSpeech.Reciprocity.ValueType = ...
    """The grammatical reciprocity."""

    tense: global___PartOfSpeech.Tense.ValueType = ...
    """The grammatical tense."""

    voice: global___PartOfSpeech.Voice.ValueType = ...
    """The grammatical voice."""

    def __init__(self,
        *,
        tag : global___PartOfSpeech.Tag.ValueType = ...,
        aspect : global___PartOfSpeech.Aspect.ValueType = ...,
        case : global___PartOfSpeech.Case.ValueType = ...,
        form : global___PartOfSpeech.Form.ValueType = ...,
        gender : global___PartOfSpeech.Gender.ValueType = ...,
        mood : global___PartOfSpeech.Mood.ValueType = ...,
        number : global___PartOfSpeech.Number.ValueType = ...,
        person : global___PartOfSpeech.Person.ValueType = ...,
        proper : global___PartOfSpeech.Proper.ValueType = ...,
        reciprocity : global___PartOfSpeech.Reciprocity.ValueType = ...,
        tense : global___PartOfSpeech.Tense.ValueType = ...,
        voice : global___PartOfSpeech.Voice.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["aspect",b"aspect","case",b"case","form",b"form","gender",b"gender","mood",b"mood","number",b"number","person",b"person","proper",b"proper","reciprocity",b"reciprocity","tag",b"tag","tense",b"tense","voice",b"voice"]) -> None: ...
global___PartOfSpeech = PartOfSpeech

class DependencyEdge(google.protobuf.message.Message):
    """Represents dependency parse tree information for a token."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Label:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _LabelEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Label.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNKNOWN: DependencyEdge.Label.ValueType = ...  # 0
        """Unknown"""

        ABBREV: DependencyEdge.Label.ValueType = ...  # 1
        """Abbreviation modifier"""

        ACOMP: DependencyEdge.Label.ValueType = ...  # 2
        """Adjectival complement"""

        ADVCL: DependencyEdge.Label.ValueType = ...  # 3
        """Adverbial clause modifier"""

        ADVMOD: DependencyEdge.Label.ValueType = ...  # 4
        """Adverbial modifier"""

        AMOD: DependencyEdge.Label.ValueType = ...  # 5
        """Adjectival modifier of an NP"""

        APPOS: DependencyEdge.Label.ValueType = ...  # 6
        """Appositional modifier of an NP"""

        ATTR: DependencyEdge.Label.ValueType = ...  # 7
        """Attribute dependent of a copular verb"""

        AUX: DependencyEdge.Label.ValueType = ...  # 8
        """Auxiliary (non-main) verb"""

        AUXPASS: DependencyEdge.Label.ValueType = ...  # 9
        """Passive auxiliary"""

        CC: DependencyEdge.Label.ValueType = ...  # 10
        """Coordinating conjunction"""

        CCOMP: DependencyEdge.Label.ValueType = ...  # 11
        """Clausal complement of a verb or adjective"""

        CONJ: DependencyEdge.Label.ValueType = ...  # 12
        """Conjunct"""

        CSUBJ: DependencyEdge.Label.ValueType = ...  # 13
        """Clausal subject"""

        CSUBJPASS: DependencyEdge.Label.ValueType = ...  # 14
        """Clausal passive subject"""

        DEP: DependencyEdge.Label.ValueType = ...  # 15
        """Dependency (unable to determine)"""

        DET: DependencyEdge.Label.ValueType = ...  # 16
        """Determiner"""

        DISCOURSE: DependencyEdge.Label.ValueType = ...  # 17
        """Discourse"""

        DOBJ: DependencyEdge.Label.ValueType = ...  # 18
        """Direct object"""

        EXPL: DependencyEdge.Label.ValueType = ...  # 19
        """Expletive"""

        GOESWITH: DependencyEdge.Label.ValueType = ...  # 20
        """Goes with (part of a word in a text not well edited)"""

        IOBJ: DependencyEdge.Label.ValueType = ...  # 21
        """Indirect object"""

        MARK: DependencyEdge.Label.ValueType = ...  # 22
        """Marker (word introducing a subordinate clause)"""

        MWE: DependencyEdge.Label.ValueType = ...  # 23
        """Multi-word expression"""

        MWV: DependencyEdge.Label.ValueType = ...  # 24
        """Multi-word verbal expression"""

        NEG: DependencyEdge.Label.ValueType = ...  # 25
        """Negation modifier"""

        NN: DependencyEdge.Label.ValueType = ...  # 26
        """Noun compound modifier"""

        NPADVMOD: DependencyEdge.Label.ValueType = ...  # 27
        """Noun phrase used as an adverbial modifier"""

        NSUBJ: DependencyEdge.Label.ValueType = ...  # 28
        """Nominal subject"""

        NSUBJPASS: DependencyEdge.Label.ValueType = ...  # 29
        """Passive nominal subject"""

        NUM: DependencyEdge.Label.ValueType = ...  # 30
        """Numeric modifier of a noun"""

        NUMBER: DependencyEdge.Label.ValueType = ...  # 31
        """Element of compound number"""

        P: DependencyEdge.Label.ValueType = ...  # 32
        """Punctuation mark"""

        PARATAXIS: DependencyEdge.Label.ValueType = ...  # 33
        """Parataxis relation"""

        PARTMOD: DependencyEdge.Label.ValueType = ...  # 34
        """Participial modifier"""

        PCOMP: DependencyEdge.Label.ValueType = ...  # 35
        """The complement of a preposition is a clause"""

        POBJ: DependencyEdge.Label.ValueType = ...  # 36
        """Object of a preposition"""

        POSS: DependencyEdge.Label.ValueType = ...  # 37
        """Possession modifier"""

        POSTNEG: DependencyEdge.Label.ValueType = ...  # 38
        """Postverbal negative particle"""

        PRECOMP: DependencyEdge.Label.ValueType = ...  # 39
        """Predicate complement"""

        PRECONJ: DependencyEdge.Label.ValueType = ...  # 40
        """Preconjunt"""

        PREDET: DependencyEdge.Label.ValueType = ...  # 41
        """Predeterminer"""

        PREF: DependencyEdge.Label.ValueType = ...  # 42
        """Prefix"""

        PREP: DependencyEdge.Label.ValueType = ...  # 43
        """Prepositional modifier"""

        PRONL: DependencyEdge.Label.ValueType = ...  # 44
        """The relationship between a verb and verbal morpheme"""

        PRT: DependencyEdge.Label.ValueType = ...  # 45
        """Particle"""

        PS: DependencyEdge.Label.ValueType = ...  # 46
        """Associative or possessive marker"""

        QUANTMOD: DependencyEdge.Label.ValueType = ...  # 47
        """Quantifier phrase modifier"""

        RCMOD: DependencyEdge.Label.ValueType = ...  # 48
        """Relative clause modifier"""

        RCMODREL: DependencyEdge.Label.ValueType = ...  # 49
        """Complementizer in relative clause"""

        RDROP: DependencyEdge.Label.ValueType = ...  # 50
        """Ellipsis without a preceding predicate"""

        REF: DependencyEdge.Label.ValueType = ...  # 51
        """Referent"""

        REMNANT: DependencyEdge.Label.ValueType = ...  # 52
        """Remnant"""

        REPARANDUM: DependencyEdge.Label.ValueType = ...  # 53
        """Reparandum"""

        ROOT: DependencyEdge.Label.ValueType = ...  # 54
        """Root"""

        SNUM: DependencyEdge.Label.ValueType = ...  # 55
        """Suffix specifying a unit of number"""

        SUFF: DependencyEdge.Label.ValueType = ...  # 56
        """Suffix"""

        TMOD: DependencyEdge.Label.ValueType = ...  # 57
        """Temporal modifier"""

        TOPIC: DependencyEdge.Label.ValueType = ...  # 58
        """Topic marker"""

        VMOD: DependencyEdge.Label.ValueType = ...  # 59
        """Clause headed by an infinite form of the verb that modifies a noun"""

        VOCATIVE: DependencyEdge.Label.ValueType = ...  # 60
        """Vocative"""

        XCOMP: DependencyEdge.Label.ValueType = ...  # 61
        """Open clausal complement"""

        SUFFIX: DependencyEdge.Label.ValueType = ...  # 62
        """Name suffix"""

        TITLE: DependencyEdge.Label.ValueType = ...  # 63
        """Name title"""

        ADVPHMOD: DependencyEdge.Label.ValueType = ...  # 64
        """Adverbial phrase modifier"""

        AUXCAUS: DependencyEdge.Label.ValueType = ...  # 65
        """Causative auxiliary"""

        AUXVV: DependencyEdge.Label.ValueType = ...  # 66
        """Helper auxiliary"""

        DTMOD: DependencyEdge.Label.ValueType = ...  # 67
        """Rentaishi (Prenominal modifier)"""

        FOREIGN: DependencyEdge.Label.ValueType = ...  # 68
        """Foreign words"""

        KW: DependencyEdge.Label.ValueType = ...  # 69
        """Keyword"""

        LIST: DependencyEdge.Label.ValueType = ...  # 70
        """List for chains of comparable items"""

        NOMC: DependencyEdge.Label.ValueType = ...  # 71
        """Nominalized clause"""

        NOMCSUBJ: DependencyEdge.Label.ValueType = ...  # 72
        """Nominalized clausal subject"""

        NOMCSUBJPASS: DependencyEdge.Label.ValueType = ...  # 73
        """Nominalized clausal passive"""

        NUMC: DependencyEdge.Label.ValueType = ...  # 74
        """Compound of numeric modifier"""

        COP: DependencyEdge.Label.ValueType = ...  # 75
        """Copula"""

        DISLOCATED: DependencyEdge.Label.ValueType = ...  # 76
        """Dislocated relation (for fronted/topicalized elements)"""

    class Label(_Label, metaclass=_LabelEnumTypeWrapper):
        """The parse label enum for the token."""
        pass

    UNKNOWN: DependencyEdge.Label.ValueType = ...  # 0
    """Unknown"""

    ABBREV: DependencyEdge.Label.ValueType = ...  # 1
    """Abbreviation modifier"""

    ACOMP: DependencyEdge.Label.ValueType = ...  # 2
    """Adjectival complement"""

    ADVCL: DependencyEdge.Label.ValueType = ...  # 3
    """Adverbial clause modifier"""

    ADVMOD: DependencyEdge.Label.ValueType = ...  # 4
    """Adverbial modifier"""

    AMOD: DependencyEdge.Label.ValueType = ...  # 5
    """Adjectival modifier of an NP"""

    APPOS: DependencyEdge.Label.ValueType = ...  # 6
    """Appositional modifier of an NP"""

    ATTR: DependencyEdge.Label.ValueType = ...  # 7
    """Attribute dependent of a copular verb"""

    AUX: DependencyEdge.Label.ValueType = ...  # 8
    """Auxiliary (non-main) verb"""

    AUXPASS: DependencyEdge.Label.ValueType = ...  # 9
    """Passive auxiliary"""

    CC: DependencyEdge.Label.ValueType = ...  # 10
    """Coordinating conjunction"""

    CCOMP: DependencyEdge.Label.ValueType = ...  # 11
    """Clausal complement of a verb or adjective"""

    CONJ: DependencyEdge.Label.ValueType = ...  # 12
    """Conjunct"""

    CSUBJ: DependencyEdge.Label.ValueType = ...  # 13
    """Clausal subject"""

    CSUBJPASS: DependencyEdge.Label.ValueType = ...  # 14
    """Clausal passive subject"""

    DEP: DependencyEdge.Label.ValueType = ...  # 15
    """Dependency (unable to determine)"""

    DET: DependencyEdge.Label.ValueType = ...  # 16
    """Determiner"""

    DISCOURSE: DependencyEdge.Label.ValueType = ...  # 17
    """Discourse"""

    DOBJ: DependencyEdge.Label.ValueType = ...  # 18
    """Direct object"""

    EXPL: DependencyEdge.Label.ValueType = ...  # 19
    """Expletive"""

    GOESWITH: DependencyEdge.Label.ValueType = ...  # 20
    """Goes with (part of a word in a text not well edited)"""

    IOBJ: DependencyEdge.Label.ValueType = ...  # 21
    """Indirect object"""

    MARK: DependencyEdge.Label.ValueType = ...  # 22
    """Marker (word introducing a subordinate clause)"""

    MWE: DependencyEdge.Label.ValueType = ...  # 23
    """Multi-word expression"""

    MWV: DependencyEdge.Label.ValueType = ...  # 24
    """Multi-word verbal expression"""

    NEG: DependencyEdge.Label.ValueType = ...  # 25
    """Negation modifier"""

    NN: DependencyEdge.Label.ValueType = ...  # 26
    """Noun compound modifier"""

    NPADVMOD: DependencyEdge.Label.ValueType = ...  # 27
    """Noun phrase used as an adverbial modifier"""

    NSUBJ: DependencyEdge.Label.ValueType = ...  # 28
    """Nominal subject"""

    NSUBJPASS: DependencyEdge.Label.ValueType = ...  # 29
    """Passive nominal subject"""

    NUM: DependencyEdge.Label.ValueType = ...  # 30
    """Numeric modifier of a noun"""

    NUMBER: DependencyEdge.Label.ValueType = ...  # 31
    """Element of compound number"""

    P: DependencyEdge.Label.ValueType = ...  # 32
    """Punctuation mark"""

    PARATAXIS: DependencyEdge.Label.ValueType = ...  # 33
    """Parataxis relation"""

    PARTMOD: DependencyEdge.Label.ValueType = ...  # 34
    """Participial modifier"""

    PCOMP: DependencyEdge.Label.ValueType = ...  # 35
    """The complement of a preposition is a clause"""

    POBJ: DependencyEdge.Label.ValueType = ...  # 36
    """Object of a preposition"""

    POSS: DependencyEdge.Label.ValueType = ...  # 37
    """Possession modifier"""

    POSTNEG: DependencyEdge.Label.ValueType = ...  # 38
    """Postverbal negative particle"""

    PRECOMP: DependencyEdge.Label.ValueType = ...  # 39
    """Predicate complement"""

    PRECONJ: DependencyEdge.Label.ValueType = ...  # 40
    """Preconjunt"""

    PREDET: DependencyEdge.Label.ValueType = ...  # 41
    """Predeterminer"""

    PREF: DependencyEdge.Label.ValueType = ...  # 42
    """Prefix"""

    PREP: DependencyEdge.Label.ValueType = ...  # 43
    """Prepositional modifier"""

    PRONL: DependencyEdge.Label.ValueType = ...  # 44
    """The relationship between a verb and verbal morpheme"""

    PRT: DependencyEdge.Label.ValueType = ...  # 45
    """Particle"""

    PS: DependencyEdge.Label.ValueType = ...  # 46
    """Associative or possessive marker"""

    QUANTMOD: DependencyEdge.Label.ValueType = ...  # 47
    """Quantifier phrase modifier"""

    RCMOD: DependencyEdge.Label.ValueType = ...  # 48
    """Relative clause modifier"""

    RCMODREL: DependencyEdge.Label.ValueType = ...  # 49
    """Complementizer in relative clause"""

    RDROP: DependencyEdge.Label.ValueType = ...  # 50
    """Ellipsis without a preceding predicate"""

    REF: DependencyEdge.Label.ValueType = ...  # 51
    """Referent"""

    REMNANT: DependencyEdge.Label.ValueType = ...  # 52
    """Remnant"""

    REPARANDUM: DependencyEdge.Label.ValueType = ...  # 53
    """Reparandum"""

    ROOT: DependencyEdge.Label.ValueType = ...  # 54
    """Root"""

    SNUM: DependencyEdge.Label.ValueType = ...  # 55
    """Suffix specifying a unit of number"""

    SUFF: DependencyEdge.Label.ValueType = ...  # 56
    """Suffix"""

    TMOD: DependencyEdge.Label.ValueType = ...  # 57
    """Temporal modifier"""

    TOPIC: DependencyEdge.Label.ValueType = ...  # 58
    """Topic marker"""

    VMOD: DependencyEdge.Label.ValueType = ...  # 59
    """Clause headed by an infinite form of the verb that modifies a noun"""

    VOCATIVE: DependencyEdge.Label.ValueType = ...  # 60
    """Vocative"""

    XCOMP: DependencyEdge.Label.ValueType = ...  # 61
    """Open clausal complement"""

    SUFFIX: DependencyEdge.Label.ValueType = ...  # 62
    """Name suffix"""

    TITLE: DependencyEdge.Label.ValueType = ...  # 63
    """Name title"""

    ADVPHMOD: DependencyEdge.Label.ValueType = ...  # 64
    """Adverbial phrase modifier"""

    AUXCAUS: DependencyEdge.Label.ValueType = ...  # 65
    """Causative auxiliary"""

    AUXVV: DependencyEdge.Label.ValueType = ...  # 66
    """Helper auxiliary"""

    DTMOD: DependencyEdge.Label.ValueType = ...  # 67
    """Rentaishi (Prenominal modifier)"""

    FOREIGN: DependencyEdge.Label.ValueType = ...  # 68
    """Foreign words"""

    KW: DependencyEdge.Label.ValueType = ...  # 69
    """Keyword"""

    LIST: DependencyEdge.Label.ValueType = ...  # 70
    """List for chains of comparable items"""

    NOMC: DependencyEdge.Label.ValueType = ...  # 71
    """Nominalized clause"""

    NOMCSUBJ: DependencyEdge.Label.ValueType = ...  # 72
    """Nominalized clausal subject"""

    NOMCSUBJPASS: DependencyEdge.Label.ValueType = ...  # 73
    """Nominalized clausal passive"""

    NUMC: DependencyEdge.Label.ValueType = ...  # 74
    """Compound of numeric modifier"""

    COP: DependencyEdge.Label.ValueType = ...  # 75
    """Copula"""

    DISLOCATED: DependencyEdge.Label.ValueType = ...  # 76
    """Dislocated relation (for fronted/topicalized elements)"""


    HEAD_TOKEN_INDEX_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    head_token_index: builtins.int = ...
    """Represents the head of this token in the dependency tree.
    This is the index of the token which has an arc going to this token.
    The index is the position of the token in the array of tokens returned
    by the API method. If this token is a root token, then the
    `head_token_index` is its own index.
    """

    label: global___DependencyEdge.Label.ValueType = ...
    """The parse label for the token."""

    def __init__(self,
        *,
        head_token_index : builtins.int = ...,
        label : global___DependencyEdge.Label.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["head_token_index",b"head_token_index","label",b"label"]) -> None: ...
global___DependencyEdge = DependencyEdge

class EntityMention(google.protobuf.message.Message):
    """Represents a mention for an entity in the text. Currently, proper noun
    mentions are supported.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Type:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        TYPE_UNKNOWN: EntityMention.Type.ValueType = ...  # 0
        """Unknown"""

        PROPER: EntityMention.Type.ValueType = ...  # 1
        """Proper name"""

        COMMON: EntityMention.Type.ValueType = ...  # 2
        """Common noun (or noun compound)"""

    class Type(_Type, metaclass=_TypeEnumTypeWrapper):
        """The supported types of mentions."""
        pass

    TYPE_UNKNOWN: EntityMention.Type.ValueType = ...  # 0
    """Unknown"""

    PROPER: EntityMention.Type.ValueType = ...  # 1
    """Proper name"""

    COMMON: EntityMention.Type.ValueType = ...  # 2
    """Common noun (or noun compound)"""


    TEXT_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    @property
    def text(self) -> global___TextSpan:
        """The mention text."""
        pass
    type: global___EntityMention.Type.ValueType = ...
    """The type of the entity mention."""

    def __init__(self,
        *,
        text : typing.Optional[global___TextSpan] = ...,
        type : global___EntityMention.Type.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["text",b"text"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["text",b"text","type",b"type"]) -> None: ...
global___EntityMention = EntityMention

class TextSpan(google.protobuf.message.Message):
    """Represents an output piece of text."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONTENT_FIELD_NUMBER: builtins.int
    BEGIN_OFFSET_FIELD_NUMBER: builtins.int
    content: typing.Text = ...
    """The content of the output text."""

    begin_offset: builtins.int = ...
    """The API calculates the beginning offset of the content in the original
    document according to the
    [EncodingType][google.cloud.language.v1beta1.EncodingType] specified in the
    API request.
    """

    def __init__(self,
        *,
        content : typing.Text = ...,
        begin_offset : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["begin_offset",b"begin_offset","content",b"content"]) -> None: ...
global___TextSpan = TextSpan

class AnalyzeSentimentRequest(google.protobuf.message.Message):
    """The sentiment analysis request message."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DOCUMENT_FIELD_NUMBER: builtins.int
    ENCODING_TYPE_FIELD_NUMBER: builtins.int
    @property
    def document(self) -> global___Document:
        """Input document."""
        pass
    encoding_type: global___EncodingType.ValueType = ...
    """The encoding type used by the API to calculate sentence offsets for the
    sentence sentiment.
    """

    def __init__(self,
        *,
        document : typing.Optional[global___Document] = ...,
        encoding_type : global___EncodingType.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["document",b"document"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["document",b"document","encoding_type",b"encoding_type"]) -> None: ...
global___AnalyzeSentimentRequest = AnalyzeSentimentRequest

class AnalyzeSentimentResponse(google.protobuf.message.Message):
    """The sentiment analysis response message."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DOCUMENT_SENTIMENT_FIELD_NUMBER: builtins.int
    LANGUAGE_FIELD_NUMBER: builtins.int
    SENTENCES_FIELD_NUMBER: builtins.int
    @property
    def document_sentiment(self) -> global___Sentiment:
        """The overall sentiment of the input document."""
        pass
    language: typing.Text = ...
    """The language of the text, which will be the same as the language specified
    in the request or, if not specified, the automatically-detected language.
    See [Document.language][google.cloud.language.v1beta1.Document.language]
    field for more details.
    """

    @property
    def sentences(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Sentence]:
        """The sentiment for all the sentences in the document."""
        pass
    def __init__(self,
        *,
        document_sentiment : typing.Optional[global___Sentiment] = ...,
        language : typing.Text = ...,
        sentences : typing.Optional[typing.Iterable[global___Sentence]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["document_sentiment",b"document_sentiment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["document_sentiment",b"document_sentiment","language",b"language","sentences",b"sentences"]) -> None: ...
global___AnalyzeSentimentResponse = AnalyzeSentimentResponse

class AnalyzeEntitiesRequest(google.protobuf.message.Message):
    """The entity analysis request message."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DOCUMENT_FIELD_NUMBER: builtins.int
    ENCODING_TYPE_FIELD_NUMBER: builtins.int
    @property
    def document(self) -> global___Document:
        """Input document."""
        pass
    encoding_type: global___EncodingType.ValueType = ...
    """The encoding type used by the API to calculate offsets."""

    def __init__(self,
        *,
        document : typing.Optional[global___Document] = ...,
        encoding_type : global___EncodingType.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["document",b"document"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["document",b"document","encoding_type",b"encoding_type"]) -> None: ...
global___AnalyzeEntitiesRequest = AnalyzeEntitiesRequest

class AnalyzeEntitiesResponse(google.protobuf.message.Message):
    """The entity analysis response message."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ENTITIES_FIELD_NUMBER: builtins.int
    LANGUAGE_FIELD_NUMBER: builtins.int
    @property
    def entities(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Entity]:
        """The recognized entities in the input document."""
        pass
    language: typing.Text = ...
    """The language of the text, which will be the same as the language specified
    in the request or, if not specified, the automatically-detected language.
    See [Document.language][google.cloud.language.v1beta1.Document.language]
    field for more details.
    """

    def __init__(self,
        *,
        entities : typing.Optional[typing.Iterable[global___Entity]] = ...,
        language : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["entities",b"entities","language",b"language"]) -> None: ...
global___AnalyzeEntitiesResponse = AnalyzeEntitiesResponse

class AnalyzeSyntaxRequest(google.protobuf.message.Message):
    """The syntax analysis request message."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DOCUMENT_FIELD_NUMBER: builtins.int
    ENCODING_TYPE_FIELD_NUMBER: builtins.int
    @property
    def document(self) -> global___Document:
        """Input document."""
        pass
    encoding_type: global___EncodingType.ValueType = ...
    """The encoding type used by the API to calculate offsets."""

    def __init__(self,
        *,
        document : typing.Optional[global___Document] = ...,
        encoding_type : global___EncodingType.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["document",b"document"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["document",b"document","encoding_type",b"encoding_type"]) -> None: ...
global___AnalyzeSyntaxRequest = AnalyzeSyntaxRequest

class AnalyzeSyntaxResponse(google.protobuf.message.Message):
    """The syntax analysis response message."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SENTENCES_FIELD_NUMBER: builtins.int
    TOKENS_FIELD_NUMBER: builtins.int
    LANGUAGE_FIELD_NUMBER: builtins.int
    @property
    def sentences(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Sentence]:
        """Sentences in the input document."""
        pass
    @property
    def tokens(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Token]:
        """Tokens, along with their syntactic information, in the input document."""
        pass
    language: typing.Text = ...
    """The language of the text, which will be the same as the language specified
    in the request or, if not specified, the automatically-detected language.
    See [Document.language][google.cloud.language.v1beta1.Document.language]
    field for more details.
    """

    def __init__(self,
        *,
        sentences : typing.Optional[typing.Iterable[global___Sentence]] = ...,
        tokens : typing.Optional[typing.Iterable[global___Token]] = ...,
        language : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["language",b"language","sentences",b"sentences","tokens",b"tokens"]) -> None: ...
global___AnalyzeSyntaxResponse = AnalyzeSyntaxResponse

class AnnotateTextRequest(google.protobuf.message.Message):
    """The request message for the text annotation API, which can perform multiple
    analysis types (sentiment, entities, and syntax) in one call.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Features(google.protobuf.message.Message):
        """All available features for sentiment, syntax, and semantic analysis.
        Setting each one to true will enable that specific analysis for the input.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        EXTRACT_SYNTAX_FIELD_NUMBER: builtins.int
        EXTRACT_ENTITIES_FIELD_NUMBER: builtins.int
        EXTRACT_DOCUMENT_SENTIMENT_FIELD_NUMBER: builtins.int
        extract_syntax: builtins.bool = ...
        """Extract syntax information."""

        extract_entities: builtins.bool = ...
        """Extract entities."""

        extract_document_sentiment: builtins.bool = ...
        """Extract document-level sentiment."""

        def __init__(self,
            *,
            extract_syntax : builtins.bool = ...,
            extract_entities : builtins.bool = ...,
            extract_document_sentiment : builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["extract_document_sentiment",b"extract_document_sentiment","extract_entities",b"extract_entities","extract_syntax",b"extract_syntax"]) -> None: ...

    DOCUMENT_FIELD_NUMBER: builtins.int
    FEATURES_FIELD_NUMBER: builtins.int
    ENCODING_TYPE_FIELD_NUMBER: builtins.int
    @property
    def document(self) -> global___Document:
        """Input document."""
        pass
    @property
    def features(self) -> global___AnnotateTextRequest.Features:
        """The enabled features."""
        pass
    encoding_type: global___EncodingType.ValueType = ...
    """The encoding type used by the API to calculate offsets."""

    def __init__(self,
        *,
        document : typing.Optional[global___Document] = ...,
        features : typing.Optional[global___AnnotateTextRequest.Features] = ...,
        encoding_type : global___EncodingType.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["document",b"document","features",b"features"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["document",b"document","encoding_type",b"encoding_type","features",b"features"]) -> None: ...
global___AnnotateTextRequest = AnnotateTextRequest

class AnnotateTextResponse(google.protobuf.message.Message):
    """The text annotations response message."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SENTENCES_FIELD_NUMBER: builtins.int
    TOKENS_FIELD_NUMBER: builtins.int
    ENTITIES_FIELD_NUMBER: builtins.int
    DOCUMENT_SENTIMENT_FIELD_NUMBER: builtins.int
    LANGUAGE_FIELD_NUMBER: builtins.int
    @property
    def sentences(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Sentence]:
        """Sentences in the input document. Populated if the user enables
        [AnnotateTextRequest.Features.extract_syntax][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_syntax].
        """
        pass
    @property
    def tokens(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Token]:
        """Tokens, along with their syntactic information, in the input document.
        Populated if the user enables
        [AnnotateTextRequest.Features.extract_syntax][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_syntax].
        """
        pass
    @property
    def entities(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Entity]:
        """Entities, along with their semantic information, in the input document.
        Populated if the user enables
        [AnnotateTextRequest.Features.extract_entities][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_entities].
        """
        pass
    @property
    def document_sentiment(self) -> global___Sentiment:
        """The overall sentiment for the document. Populated if the user enables
        [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_document_sentiment].
        """
        pass
    language: typing.Text = ...
    """The language of the text, which will be the same as the language specified
    in the request or, if not specified, the automatically-detected language.
    See [Document.language][google.cloud.language.v1beta1.Document.language]
    field for more details.
    """

    def __init__(self,
        *,
        sentences : typing.Optional[typing.Iterable[global___Sentence]] = ...,
        tokens : typing.Optional[typing.Iterable[global___Token]] = ...,
        entities : typing.Optional[typing.Iterable[global___Entity]] = ...,
        document_sentiment : typing.Optional[global___Sentiment] = ...,
        language : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["document_sentiment",b"document_sentiment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["document_sentiment",b"document_sentiment","entities",b"entities","language",b"language","sentences",b"sentences","tokens",b"tokens"]) -> None: ...
global___AnnotateTextResponse = AnnotateTextResponse
