"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.cloud.notebooks.v1.environment_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Runtime(google.protobuf.message.Message):
    """The definition of a Runtime for a managed notebook instance."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _State:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_State.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        STATE_UNSPECIFIED: Runtime.State.ValueType = ...  # 0
        """State is not specified."""

        STARTING: Runtime.State.ValueType = ...  # 1
        """The compute layer is starting the runtime. It is not ready for use."""

        PROVISIONING: Runtime.State.ValueType = ...  # 2
        """The compute layer is installing required frameworks and registering the
        runtime with notebook proxy. It cannot be used.
        """

        ACTIVE: Runtime.State.ValueType = ...  # 3
        """The runtime is currently running. It is ready for use."""

        STOPPING: Runtime.State.ValueType = ...  # 4
        """The control logic is stopping the runtime. It cannot be used."""

        STOPPED: Runtime.State.ValueType = ...  # 5
        """The runtime is stopped. It cannot be used."""

        DELETING: Runtime.State.ValueType = ...  # 6
        """The runtime is being deleted. It cannot be used."""

        UPGRADING: Runtime.State.ValueType = ...  # 7
        """The runtime is upgrading. It cannot be used."""

        INITIALIZING: Runtime.State.ValueType = ...  # 8
        """The runtime is being created and set up. It is not ready for use."""

    class State(_State, metaclass=_StateEnumTypeWrapper):
        """The definition of the states of this runtime."""
        pass

    STATE_UNSPECIFIED: Runtime.State.ValueType = ...  # 0
    """State is not specified."""

    STARTING: Runtime.State.ValueType = ...  # 1
    """The compute layer is starting the runtime. It is not ready for use."""

    PROVISIONING: Runtime.State.ValueType = ...  # 2
    """The compute layer is installing required frameworks and registering the
    runtime with notebook proxy. It cannot be used.
    """

    ACTIVE: Runtime.State.ValueType = ...  # 3
    """The runtime is currently running. It is ready for use."""

    STOPPING: Runtime.State.ValueType = ...  # 4
    """The control logic is stopping the runtime. It cannot be used."""

    STOPPED: Runtime.State.ValueType = ...  # 5
    """The runtime is stopped. It cannot be used."""

    DELETING: Runtime.State.ValueType = ...  # 6
    """The runtime is being deleted. It cannot be used."""

    UPGRADING: Runtime.State.ValueType = ...  # 7
    """The runtime is upgrading. It cannot be used."""

    INITIALIZING: Runtime.State.ValueType = ...  # 8
    """The runtime is being created and set up. It is not ready for use."""


    class _HealthState:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _HealthStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_HealthState.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        HEALTH_STATE_UNSPECIFIED: Runtime.HealthState.ValueType = ...  # 0
        """The runtime substate is unknown."""

        HEALTHY: Runtime.HealthState.ValueType = ...  # 1
        """The runtime is known to be in an healthy state
        (for example, critical daemons are running)
        Applies to ACTIVE state.
        """

        UNHEALTHY: Runtime.HealthState.ValueType = ...  # 2
        """The runtime is known to be in an unhealthy state
        (for example, critical daemons are not running)
        Applies to ACTIVE state.
        """

    class HealthState(_HealthState, metaclass=_HealthStateEnumTypeWrapper):
        """The runtime substate."""
        pass

    HEALTH_STATE_UNSPECIFIED: Runtime.HealthState.ValueType = ...  # 0
    """The runtime substate is unknown."""

    HEALTHY: Runtime.HealthState.ValueType = ...  # 1
    """The runtime is known to be in an healthy state
    (for example, critical daemons are running)
    Applies to ACTIVE state.
    """

    UNHEALTHY: Runtime.HealthState.ValueType = ...  # 2
    """The runtime is known to be in an unhealthy state
    (for example, critical daemons are not running)
    Applies to ACTIVE state.
    """


    NAME_FIELD_NUMBER: builtins.int
    VIRTUAL_MACHINE_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    HEALTH_STATE_FIELD_NUMBER: builtins.int
    ACCESS_CONFIG_FIELD_NUMBER: builtins.int
    SOFTWARE_CONFIG_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Output only. The resource name of the runtime.
    Format:
    `projects/{project}/locations/{location}/runtimes/{runtimeId}`
    """

    @property
    def virtual_machine(self) -> global___VirtualMachine:
        """Use a Compute Engine VM image to start the managed notebook instance."""
        pass
    state: global___Runtime.State.ValueType = ...
    """Output only. Runtime state."""

    health_state: global___Runtime.HealthState.ValueType = ...
    """Output only. Runtime health_state."""

    @property
    def access_config(self) -> global___RuntimeAccessConfig:
        """The config settings for accessing runtime."""
        pass
    @property
    def software_config(self) -> global___RuntimeSoftwareConfig:
        """The config settings for software inside the runtime."""
        pass
    @property
    def metrics(self) -> global___RuntimeMetrics:
        """Output only. Contains Runtime daemon metrics such as Service status and JupyterLab
        stats.
        """
        pass
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Runtime creation time."""
        pass
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Runtime update time."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        virtual_machine : typing.Optional[global___VirtualMachine] = ...,
        state : global___Runtime.State.ValueType = ...,
        health_state : global___Runtime.HealthState.ValueType = ...,
        access_config : typing.Optional[global___RuntimeAccessConfig] = ...,
        software_config : typing.Optional[global___RuntimeSoftwareConfig] = ...,
        metrics : typing.Optional[global___RuntimeMetrics] = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        update_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["access_config",b"access_config","create_time",b"create_time","metrics",b"metrics","runtime_type",b"runtime_type","software_config",b"software_config","update_time",b"update_time","virtual_machine",b"virtual_machine"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["access_config",b"access_config","create_time",b"create_time","health_state",b"health_state","metrics",b"metrics","name",b"name","runtime_type",b"runtime_type","software_config",b"software_config","state",b"state","update_time",b"update_time","virtual_machine",b"virtual_machine"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["runtime_type",b"runtime_type"]) -> typing.Optional[typing_extensions.Literal["virtual_machine"]]: ...
global___Runtime = Runtime

class RuntimeAcceleratorConfig(google.protobuf.message.Message):
    """Definition of the types of hardware accelerators that can be used.
    Definition of the types of hardware accelerators that can be used.
    See [Compute Engine
    AcceleratorTypes](https://cloud.google.com/compute/docs/reference/beta/acceleratorTypes).
    Examples:

    * `nvidia-tesla-k80`
    * `nvidia-tesla-p100`
    * `nvidia-tesla-v100`
    * `nvidia-tesla-t4`
    * `nvidia-tesla-a100`
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _AcceleratorType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _AcceleratorTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_AcceleratorType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        ACCELERATOR_TYPE_UNSPECIFIED: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 0
        """Accelerator type is not specified."""

        NVIDIA_TESLA_K80: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 1
        """Accelerator type is Nvidia Tesla K80."""

        NVIDIA_TESLA_P100: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 2
        """Accelerator type is Nvidia Tesla P100."""

        NVIDIA_TESLA_V100: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 3
        """Accelerator type is Nvidia Tesla V100."""

        NVIDIA_TESLA_P4: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 4
        """Accelerator type is Nvidia Tesla P4 GPU."""

        NVIDIA_TESLA_T4: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 5
        """Accelerator type is Nvidia Tesla T4."""

        NVIDIA_TESLA_A100: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 6
        """Accelerator type is Nvidia Tesla A100."""

        TPU_V2: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 7
        """(Coming soon) Accelerator type is TPU V2."""

        TPU_V3: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 8
        """(Coming soon) Accelerator type is TPU V3."""

        NVIDIA_TESLA_T4_VWS: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 9
        """Accelerator type is NVIDIA Tesla T4 Virtual Workstations."""

        NVIDIA_TESLA_P100_VWS: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 10
        """Accelerator type is NVIDIA Tesla P100 Virtual Workstations."""

        NVIDIA_TESLA_P4_VWS: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 11
        """Accelerator type is Nvidia Tesla P.4 GPU Virtual Workstations."""

    class AcceleratorType(_AcceleratorType, metaclass=_AcceleratorTypeEnumTypeWrapper):
        """Type of this accelerator."""
        pass

    ACCELERATOR_TYPE_UNSPECIFIED: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 0
    """Accelerator type is not specified."""

    NVIDIA_TESLA_K80: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 1
    """Accelerator type is Nvidia Tesla K80."""

    NVIDIA_TESLA_P100: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 2
    """Accelerator type is Nvidia Tesla P100."""

    NVIDIA_TESLA_V100: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 3
    """Accelerator type is Nvidia Tesla V100."""

    NVIDIA_TESLA_P4: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 4
    """Accelerator type is Nvidia Tesla P4 GPU."""

    NVIDIA_TESLA_T4: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 5
    """Accelerator type is Nvidia Tesla T4."""

    NVIDIA_TESLA_A100: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 6
    """Accelerator type is Nvidia Tesla A100."""

    TPU_V2: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 7
    """(Coming soon) Accelerator type is TPU V2."""

    TPU_V3: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 8
    """(Coming soon) Accelerator type is TPU V3."""

    NVIDIA_TESLA_T4_VWS: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 9
    """Accelerator type is NVIDIA Tesla T4 Virtual Workstations."""

    NVIDIA_TESLA_P100_VWS: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 10
    """Accelerator type is NVIDIA Tesla P100 Virtual Workstations."""

    NVIDIA_TESLA_P4_VWS: RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...  # 11
    """Accelerator type is Nvidia Tesla P.4 GPU Virtual Workstations."""


    TYPE_FIELD_NUMBER: builtins.int
    CORE_COUNT_FIELD_NUMBER: builtins.int
    type: global___RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...
    """Accelerator model."""

    core_count: builtins.int = ...
    """Count of cores of this accelerator."""

    def __init__(self,
        *,
        type : global___RuntimeAcceleratorConfig.AcceleratorType.ValueType = ...,
        core_count : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["core_count",b"core_count","type",b"type"]) -> None: ...
global___RuntimeAcceleratorConfig = RuntimeAcceleratorConfig

class EncryptionConfig(google.protobuf.message.Message):
    """Represents a custom encryption key configuration that can be applied to
    a resource. This will encrypt all disks in Virtual Machine.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KMS_KEY_FIELD_NUMBER: builtins.int
    kms_key: typing.Text = ...
    """The Cloud KMS resource identifier of the customer-managed encryption key
    used to protect a resource, such as a disks. It has the following
    format:
    `projects/{PROJECT_ID}/locations/{REGION}/keyRings/{KEY_RING_NAME}/cryptoKeys/{KEY_NAME}`
    """

    def __init__(self,
        *,
        kms_key : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["kms_key",b"kms_key"]) -> None: ...
global___EncryptionConfig = EncryptionConfig

class LocalDisk(google.protobuf.message.Message):
    """A Local attached disk resource."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class RuntimeGuestOsFeature(google.protobuf.message.Message):
        """Optional. A list of features to enable on the guest operating system.
        Applicable only for bootable images.
        Read [Enabling guest operating system
        features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features)
        to see a list of available options.
        Guest OS features for boot disk.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TYPE_FIELD_NUMBER: builtins.int
        type: typing.Text = ...
        """The ID of a supported feature. Read [Enabling guest operating system
        features](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images#guest-os-features)
        to see a list of available options.

        Valid values:

        * FEATURE_TYPE_UNSPECIFIED
        * MULTI_IP_SUBNET
        * SECURE_BOOT
        * UEFI_COMPATIBLE
        * VIRTIO_SCSI_MULTIQUEUE
        * WINDOWS
        """

        def __init__(self,
            *,
            type : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["type",b"type"]) -> None: ...

    AUTO_DELETE_FIELD_NUMBER: builtins.int
    BOOT_FIELD_NUMBER: builtins.int
    DEVICE_NAME_FIELD_NUMBER: builtins.int
    GUEST_OS_FEATURES_FIELD_NUMBER: builtins.int
    INDEX_FIELD_NUMBER: builtins.int
    INITIALIZE_PARAMS_FIELD_NUMBER: builtins.int
    INTERFACE_FIELD_NUMBER: builtins.int
    KIND_FIELD_NUMBER: builtins.int
    LICENSES_FIELD_NUMBER: builtins.int
    MODE_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    auto_delete: builtins.bool = ...
    """Optional. Output only. Specifies whether the disk will be auto-deleted when the
    instance is deleted (but not when the disk is detached from the instance).
    """

    boot: builtins.bool = ...
    """Optional. Output only. Indicates that this is a boot disk. The virtual machine
    will use the first partition of the disk for its root filesystem.
    """

    device_name: typing.Text = ...
    """Optional. Output only. Specifies a unique device name
    of your choice that is reflected into the
    /dev/disk/by-id/google-* tree of a Linux operating system running within
    the instance. This name can be used to reference the device for mounting,
    resizing, and so on, from within the instance.

    If not specified, the server chooses a default device name to apply to this
    disk, in the form persistent-disk-x, where x is a number assigned by Google
    Compute Engine. This field is only applicable for persistent disks.
    """

    @property
    def guest_os_features(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LocalDisk.RuntimeGuestOsFeature]:
        """Output only. Indicates a list of features to enable on the guest operating system.
        Applicable only for bootable images. Read  Enabling guest operating
        system features to see a list of available options.
        """
        pass
    index: builtins.int = ...
    """Output only. A zero-based index to this disk, where 0 is reserved for the
    boot disk. If you have many disks attached to an instance, each disk would
    have a unique index number.
    """

    @property
    def initialize_params(self) -> global___LocalDiskInitializeParams:
        """Input only. Specifies the parameters for a new disk that will be created
        alongside the new instance. Use initialization parameters to create boot
        disks or local SSDs attached to the new instance.

        This property is mutually exclusive with the source property; you can only
        define one or the other, but not both.
        """
        pass
    interface: typing.Text = ...
    """Specifies the disk interface to use for attaching this disk, which is
    either SCSI or NVME. The default is SCSI. Persistent disks must always use
    SCSI and the request will fail if you attempt to attach a persistent disk
    in any other format than SCSI. Local SSDs can use either NVME or SCSI. For
    performance characteristics of SCSI over NVMe, see Local SSD performance.
    Valid values:

    * NVME
    * SCSI
    """

    kind: typing.Text = ...
    """Output only. Type of the resource. Always compute#attachedDisk for attached disks."""

    @property
    def licenses(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Output only. Any valid publicly visible licenses."""
        pass
    mode: typing.Text = ...
    """The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If
    not specified, the default is to attach the disk in READ_WRITE mode.
    Valid values:

    * READ_ONLY
    * READ_WRITE
    """

    source: typing.Text = ...
    """Specifies a valid partial or full URL to an existing Persistent Disk
    resource.
    """

    type: typing.Text = ...
    """Specifies the type of the disk, either SCRATCH or PERSISTENT. If not
    specified, the default is PERSISTENT.
    Valid values:

    * PERSISTENT
    * SCRATCH
    """

    def __init__(self,
        *,
        auto_delete : builtins.bool = ...,
        boot : builtins.bool = ...,
        device_name : typing.Text = ...,
        guest_os_features : typing.Optional[typing.Iterable[global___LocalDisk.RuntimeGuestOsFeature]] = ...,
        index : builtins.int = ...,
        initialize_params : typing.Optional[global___LocalDiskInitializeParams] = ...,
        interface : typing.Text = ...,
        kind : typing.Text = ...,
        licenses : typing.Optional[typing.Iterable[typing.Text]] = ...,
        mode : typing.Text = ...,
        source : typing.Text = ...,
        type : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["initialize_params",b"initialize_params"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["auto_delete",b"auto_delete","boot",b"boot","device_name",b"device_name","guest_os_features",b"guest_os_features","index",b"index","initialize_params",b"initialize_params","interface",b"interface","kind",b"kind","licenses",b"licenses","mode",b"mode","source",b"source","type",b"type"]) -> None: ...
global___LocalDisk = LocalDisk

class LocalDiskInitializeParams(google.protobuf.message.Message):
    """Input only. Specifies the parameters for a new disk that will be created
    alongside the new instance. Use initialization parameters to create boot
    disks or local SSDs attached to the new runtime.
    This property is mutually exclusive with the source property; you can only
    define one or the other, but not both.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _DiskType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _DiskTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DiskType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        DISK_TYPE_UNSPECIFIED: LocalDiskInitializeParams.DiskType.ValueType = ...  # 0
        """Disk type not set."""

        PD_STANDARD: LocalDiskInitializeParams.DiskType.ValueType = ...  # 1
        """Standard persistent disk type."""

        PD_SSD: LocalDiskInitializeParams.DiskType.ValueType = ...  # 2
        """SSD persistent disk type."""

        PD_BALANCED: LocalDiskInitializeParams.DiskType.ValueType = ...  # 3
        """Balanced persistent disk type."""

    class DiskType(_DiskType, metaclass=_DiskTypeEnumTypeWrapper):
        """Possible disk types."""
        pass

    DISK_TYPE_UNSPECIFIED: LocalDiskInitializeParams.DiskType.ValueType = ...  # 0
    """Disk type not set."""

    PD_STANDARD: LocalDiskInitializeParams.DiskType.ValueType = ...  # 1
    """Standard persistent disk type."""

    PD_SSD: LocalDiskInitializeParams.DiskType.ValueType = ...  # 2
    """SSD persistent disk type."""

    PD_BALANCED: LocalDiskInitializeParams.DiskType.ValueType = ...  # 3
    """Balanced persistent disk type."""


    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    DESCRIPTION_FIELD_NUMBER: builtins.int
    DISK_NAME_FIELD_NUMBER: builtins.int
    DISK_SIZE_GB_FIELD_NUMBER: builtins.int
    DISK_TYPE_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    description: typing.Text = ...
    """Optional. Provide this property when creating the disk."""

    disk_name: typing.Text = ...
    """Optional. Specifies the disk name. If not specified, the default is to use the name
    of the instance. If the disk with the instance name exists already in the
    given zone/region, a new name will be automatically generated.
    """

    disk_size_gb: builtins.int = ...
    """Optional. Specifies the size of the disk in base-2 GB. If not specified, the disk
    will be the same size as the image (usually 10GB). If specified, the size
    must be equal to or larger than 10GB. Default 100 GB.
    """

    disk_type: global___LocalDiskInitializeParams.DiskType.ValueType = ...
    """Input only. The type of the boot disk attached to this instance, defaults to
    standard persistent disk (`PD_STANDARD`).
    """

    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Optional. Labels to apply to this disk. These can be later modified by the
        disks.setLabels method. This field is only applicable for persistent disks.
        """
        pass
    def __init__(self,
        *,
        description : typing.Text = ...,
        disk_name : typing.Text = ...,
        disk_size_gb : builtins.int = ...,
        disk_type : global___LocalDiskInitializeParams.DiskType.ValueType = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["description",b"description","disk_name",b"disk_name","disk_size_gb",b"disk_size_gb","disk_type",b"disk_type","labels",b"labels"]) -> None: ...
global___LocalDiskInitializeParams = LocalDiskInitializeParams

class RuntimeAccessConfig(google.protobuf.message.Message):
    """Specifies the login configuration for Runtime"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _RuntimeAccessType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _RuntimeAccessTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RuntimeAccessType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        RUNTIME_ACCESS_TYPE_UNSPECIFIED: RuntimeAccessConfig.RuntimeAccessType.ValueType = ...  # 0
        """Unspecified access."""

        SINGLE_USER: RuntimeAccessConfig.RuntimeAccessType.ValueType = ...  # 1
        """Single user login."""

    class RuntimeAccessType(_RuntimeAccessType, metaclass=_RuntimeAccessTypeEnumTypeWrapper):
        """Possible ways to access runtime. Authentication mode.
        Currently supports: Single User only.
        """
        pass

    RUNTIME_ACCESS_TYPE_UNSPECIFIED: RuntimeAccessConfig.RuntimeAccessType.ValueType = ...  # 0
    """Unspecified access."""

    SINGLE_USER: RuntimeAccessConfig.RuntimeAccessType.ValueType = ...  # 1
    """Single user login."""


    ACCESS_TYPE_FIELD_NUMBER: builtins.int
    RUNTIME_OWNER_FIELD_NUMBER: builtins.int
    PROXY_URI_FIELD_NUMBER: builtins.int
    access_type: global___RuntimeAccessConfig.RuntimeAccessType.ValueType = ...
    """The type of access mode this instance."""

    runtime_owner: typing.Text = ...
    """The owner of this runtime after creation. Format: `alias@example.com`
    Currently supports one owner only.
    """

    proxy_uri: typing.Text = ...
    """Output only. The proxy endpoint that is used to access the runtime."""

    def __init__(self,
        *,
        access_type : global___RuntimeAccessConfig.RuntimeAccessType.ValueType = ...,
        runtime_owner : typing.Text = ...,
        proxy_uri : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["access_type",b"access_type","proxy_uri",b"proxy_uri","runtime_owner",b"runtime_owner"]) -> None: ...
global___RuntimeAccessConfig = RuntimeAccessConfig

class RuntimeSoftwareConfig(google.protobuf.message.Message):
    """Specifies the selection and configuration of software inside the runtime.
    The properties to set on runtime.
    Properties keys are specified in `key:value` format, for example:

    * `idle_shutdown: true`
    * `idle_shutdown_timeout: 180`
    * `report-system-health: true`
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NOTEBOOK_UPGRADE_SCHEDULE_FIELD_NUMBER: builtins.int
    ENABLE_HEALTH_MONITORING_FIELD_NUMBER: builtins.int
    IDLE_SHUTDOWN_FIELD_NUMBER: builtins.int
    IDLE_SHUTDOWN_TIMEOUT_FIELD_NUMBER: builtins.int
    INSTALL_GPU_DRIVER_FIELD_NUMBER: builtins.int
    CUSTOM_GPU_DRIVER_PATH_FIELD_NUMBER: builtins.int
    POST_STARTUP_SCRIPT_FIELD_NUMBER: builtins.int
    notebook_upgrade_schedule: typing.Text = ...
    """Cron expression in UTC timezone, used to schedule instance auto upgrade.
    Please follow the [cron format](https://en.wikipedia.org/wiki/Cron).
    """

    enable_health_monitoring: builtins.bool = ...
    """Verifies core internal services are running.
    Default: True
    """

    idle_shutdown: builtins.bool = ...
    """Runtime will automatically shutdown after idle_shutdown_time.
    Default: True
    """

    idle_shutdown_timeout: builtins.int = ...
    """Time in minutes to wait before shutting down runtime. Default: 180 minutes"""

    install_gpu_driver: builtins.bool = ...
    """Install Nvidia Driver automatically."""

    custom_gpu_driver_path: typing.Text = ...
    """Specify a custom Cloud Storage path where the GPU driver is stored.
    If not specified, we'll automatically choose from official GPU drivers.
    """

    post_startup_script: typing.Text = ...
    """Path to a Bash script that automatically runs after a notebook instance
    fully boots up. The path must be a URL or
    Cloud Storage path (`gs://path-to-file/file-name`).
    """

    def __init__(self,
        *,
        notebook_upgrade_schedule : typing.Text = ...,
        enable_health_monitoring : typing.Optional[builtins.bool] = ...,
        idle_shutdown : typing.Optional[builtins.bool] = ...,
        idle_shutdown_timeout : builtins.int = ...,
        install_gpu_driver : builtins.bool = ...,
        custom_gpu_driver_path : typing.Text = ...,
        post_startup_script : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_enable_health_monitoring",b"_enable_health_monitoring","_idle_shutdown",b"_idle_shutdown","enable_health_monitoring",b"enable_health_monitoring","idle_shutdown",b"idle_shutdown"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_enable_health_monitoring",b"_enable_health_monitoring","_idle_shutdown",b"_idle_shutdown","custom_gpu_driver_path",b"custom_gpu_driver_path","enable_health_monitoring",b"enable_health_monitoring","idle_shutdown",b"idle_shutdown","idle_shutdown_timeout",b"idle_shutdown_timeout","install_gpu_driver",b"install_gpu_driver","notebook_upgrade_schedule",b"notebook_upgrade_schedule","post_startup_script",b"post_startup_script"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_enable_health_monitoring",b"_enable_health_monitoring"]) -> typing.Optional[typing_extensions.Literal["enable_health_monitoring"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_idle_shutdown",b"_idle_shutdown"]) -> typing.Optional[typing_extensions.Literal["idle_shutdown"]]: ...
global___RuntimeSoftwareConfig = RuntimeSoftwareConfig

class RuntimeMetrics(google.protobuf.message.Message):
    """Contains runtime daemon metrics, such as OS and kernels and sessions stats."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SystemMetricsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    SYSTEM_METRICS_FIELD_NUMBER: builtins.int
    @property
    def system_metrics(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Output only. The system metrics."""
        pass
    def __init__(self,
        *,
        system_metrics : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["system_metrics",b"system_metrics"]) -> None: ...
global___RuntimeMetrics = RuntimeMetrics

class RuntimeShieldedInstanceConfig(google.protobuf.message.Message):
    """A set of Shielded Instance options.
    Check [Images using supported Shielded VM
    features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
    Not all combinations are valid.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ENABLE_SECURE_BOOT_FIELD_NUMBER: builtins.int
    ENABLE_VTPM_FIELD_NUMBER: builtins.int
    ENABLE_INTEGRITY_MONITORING_FIELD_NUMBER: builtins.int
    enable_secure_boot: builtins.bool = ...
    """Defines whether the instance has Secure Boot enabled.

    Secure Boot helps ensure that the system only runs authentic software by
    verifying the digital signature of all boot components, and halting the
    boot process if signature verification fails. Disabled by default.
    """

    enable_vtpm: builtins.bool = ...
    """Defines whether the instance has the vTPM enabled. Enabled by default."""

    enable_integrity_monitoring: builtins.bool = ...
    """Defines whether the instance has integrity monitoring enabled.

    Enables monitoring and attestation of the boot integrity of the instance.
    The attestation is performed against the integrity policy baseline. This
    baseline is initially derived from the implicitly trusted boot image when
    the instance is created. Enabled by default.
    """

    def __init__(self,
        *,
        enable_secure_boot : builtins.bool = ...,
        enable_vtpm : builtins.bool = ...,
        enable_integrity_monitoring : builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["enable_integrity_monitoring",b"enable_integrity_monitoring","enable_secure_boot",b"enable_secure_boot","enable_vtpm",b"enable_vtpm"]) -> None: ...
global___RuntimeShieldedInstanceConfig = RuntimeShieldedInstanceConfig

class VirtualMachine(google.protobuf.message.Message):
    """Runtime using Virtual Machine for computing."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INSTANCE_NAME_FIELD_NUMBER: builtins.int
    INSTANCE_ID_FIELD_NUMBER: builtins.int
    VIRTUAL_MACHINE_CONFIG_FIELD_NUMBER: builtins.int
    instance_name: typing.Text = ...
    """Output only. The user-friendly name of the Managed Compute Engine instance."""

    instance_id: typing.Text = ...
    """Output only. The unique identifier of the Managed Compute Engine instance."""

    @property
    def virtual_machine_config(self) -> global___VirtualMachineConfig:
        """Virtual Machine configuration settings."""
        pass
    def __init__(self,
        *,
        instance_name : typing.Text = ...,
        instance_id : typing.Text = ...,
        virtual_machine_config : typing.Optional[global___VirtualMachineConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["virtual_machine_config",b"virtual_machine_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["instance_id",b"instance_id","instance_name",b"instance_name","virtual_machine_config",b"virtual_machine_config"]) -> None: ...
global___VirtualMachine = VirtualMachine

class VirtualMachineConfig(google.protobuf.message.Message):
    """The config settings for virtual machine."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _NicType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _NicTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_NicType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNSPECIFIED_NIC_TYPE: VirtualMachineConfig.NicType.ValueType = ...  # 0
        """No type specified."""

        VIRTIO_NET: VirtualMachineConfig.NicType.ValueType = ...  # 1
        """VIRTIO"""

        GVNIC: VirtualMachineConfig.NicType.ValueType = ...  # 2
        """GVNIC"""

    class NicType(_NicType, metaclass=_NicTypeEnumTypeWrapper):
        """The type of vNIC driver.
        Default should be UNSPECIFIED_NIC_TYPE.
        """
        pass

    UNSPECIFIED_NIC_TYPE: VirtualMachineConfig.NicType.ValueType = ...  # 0
    """No type specified."""

    VIRTIO_NET: VirtualMachineConfig.NicType.ValueType = ...  # 1
    """VIRTIO"""

    GVNIC: VirtualMachineConfig.NicType.ValueType = ...  # 2
    """GVNIC"""


    class GuestAttributesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class MetadataEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    ZONE_FIELD_NUMBER: builtins.int
    MACHINE_TYPE_FIELD_NUMBER: builtins.int
    CONTAINER_IMAGES_FIELD_NUMBER: builtins.int
    DATA_DISK_FIELD_NUMBER: builtins.int
    ENCRYPTION_CONFIG_FIELD_NUMBER: builtins.int
    SHIELDED_INSTANCE_CONFIG_FIELD_NUMBER: builtins.int
    ACCELERATOR_CONFIG_FIELD_NUMBER: builtins.int
    NETWORK_FIELD_NUMBER: builtins.int
    SUBNET_FIELD_NUMBER: builtins.int
    INTERNAL_IP_ONLY_FIELD_NUMBER: builtins.int
    TAGS_FIELD_NUMBER: builtins.int
    GUEST_ATTRIBUTES_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    NIC_TYPE_FIELD_NUMBER: builtins.int
    zone: typing.Text = ...
    """Output only. The zone where the virtual machine is located.
    If using regional request, the notebooks service will pick a location
    in the corresponding runtime region.
    On a get request, zone will always be present. Example:
    * `us-central1-b`
    """

    machine_type: typing.Text = ...
    """Required. The Compute Engine machine type used for runtimes.
    Short name is valid. Examples:
    * `n1-standard-2`
    * `e2-standard-8`
    """

    @property
    def container_images(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.cloud.notebooks.v1.environment_pb2.ContainerImage]:
        """Optional. Use a list of container images to start the notebook instance."""
        pass
    @property
    def data_disk(self) -> global___LocalDisk:
        """Required. Data disk option configuration settings."""
        pass
    @property
    def encryption_config(self) -> global___EncryptionConfig:
        """Optional. Encryption settings for virtual machine data disk."""
        pass
    @property
    def shielded_instance_config(self) -> global___RuntimeShieldedInstanceConfig:
        """Optional. Shielded VM Instance configuration settings."""
        pass
    @property
    def accelerator_config(self) -> global___RuntimeAcceleratorConfig:
        """Optional. The Compute Engine accelerator configuration for this runtime."""
        pass
    network: typing.Text = ...
    """Optional. The Compute Engine network to be used for machine
    communications. Cannot be specified with subnetwork. If neither
    `network` nor `subnet` is specified, the "default" network of
    the project is used, if it exists.

    A full URL or partial URI. Examples:

    * `https://www.googleapis.com/compute/v1/projects/[project_id]/regions/global/default`
    * `projects/[project_id]/regions/global/default`

    Runtimes are managed resources inside Google Infrastructure.
    Runtimes support the following network configurations:

    * Google Managed Network (Network & subnet are empty)
    * Consumer Project VPC (network & subnet are required). Requires
    configuring Private Service Access.
    * Shared VPC (network & subnet are required). Requires configuring Private
    Service Access.
    """

    subnet: typing.Text = ...
    """Optional. The Compute Engine subnetwork to be used for machine
    communications. Cannot be specified with network.

    A full URL or partial URI are valid. Examples:

    * `https://www.googleapis.com/compute/v1/projects/[project_id]/regions/us-east1/subnetworks/sub0`
    * `projects/[project_id]/regions/us-east1/subnetworks/sub0`
    """

    internal_ip_only: builtins.bool = ...
    """Optional. If true, runtime will only have internal IP
    addresses. By default, runtimes are not restricted to internal IP
    addresses, and will have ephemeral external IP addresses assigned to each
    vm. This `internal_ip_only` restriction can only be enabled for
    subnetwork enabled networks, and all dependencies must be
    configured to be accessible without external IP addresses.
    """

    @property
    def tags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Optional. The Compute Engine tags to add to runtime (see [Tagging
        instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).
        """
        pass
    @property
    def guest_attributes(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Output only. The Compute Engine guest attributes. (see
        [Project and instance
        guest
        attributes](https://cloud.google.com/compute/docs/storing-retrieving-metadata#guest_attributes)).
        """
        pass
    @property
    def metadata(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Optional. The Compute Engine metadata entries to add to virtual machine. (see
        [Project and instance
        metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#project_and_instance_metadata)).
        """
        pass
    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Optional. The labels to associate with this runtime.
        Label **keys** must contain 1 to 63 characters, and must conform to
        [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
        Label **values** may be empty, but, if present, must contain 1 to 63
        characters, and must conform to [RFC
        1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
        associated with a cluster.
        """
        pass
    nic_type: global___VirtualMachineConfig.NicType.ValueType = ...
    """Optional. The type of vNIC to be used on this interface. This may be gVNIC or
    VirtioNet.
    """

    def __init__(self,
        *,
        zone : typing.Text = ...,
        machine_type : typing.Text = ...,
        container_images : typing.Optional[typing.Iterable[google.cloud.notebooks.v1.environment_pb2.ContainerImage]] = ...,
        data_disk : typing.Optional[global___LocalDisk] = ...,
        encryption_config : typing.Optional[global___EncryptionConfig] = ...,
        shielded_instance_config : typing.Optional[global___RuntimeShieldedInstanceConfig] = ...,
        accelerator_config : typing.Optional[global___RuntimeAcceleratorConfig] = ...,
        network : typing.Text = ...,
        subnet : typing.Text = ...,
        internal_ip_only : builtins.bool = ...,
        tags : typing.Optional[typing.Iterable[typing.Text]] = ...,
        guest_attributes : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        metadata : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        nic_type : global___VirtualMachineConfig.NicType.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["accelerator_config",b"accelerator_config","data_disk",b"data_disk","encryption_config",b"encryption_config","shielded_instance_config",b"shielded_instance_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["accelerator_config",b"accelerator_config","container_images",b"container_images","data_disk",b"data_disk","encryption_config",b"encryption_config","guest_attributes",b"guest_attributes","internal_ip_only",b"internal_ip_only","labels",b"labels","machine_type",b"machine_type","metadata",b"metadata","network",b"network","nic_type",b"nic_type","shielded_instance_config",b"shielded_instance_config","subnet",b"subnet","tags",b"tags","zone",b"zone"]) -> None: ...
global___VirtualMachineConfig = VirtualMachineConfig
