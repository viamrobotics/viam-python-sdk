"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.cloud.bigquery.v2.encryption_config_pb2
import google.cloud.bigquery.v2.model_reference_pb2
import google.cloud.bigquery.v2.standard_sql_pb2
import google.cloud.bigquery.v2.table_reference_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.protobuf.wrappers_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Model(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _ModelType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ModelTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ModelType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        MODEL_TYPE_UNSPECIFIED: Model.ModelType.ValueType = ...  # 0
        LINEAR_REGRESSION: Model.ModelType.ValueType = ...  # 1
        """Linear regression model."""

        LOGISTIC_REGRESSION: Model.ModelType.ValueType = ...  # 2
        """Logistic regression based classification model."""

        KMEANS: Model.ModelType.ValueType = ...  # 3
        """K-means clustering model."""

        MATRIX_FACTORIZATION: Model.ModelType.ValueType = ...  # 4
        """Matrix factorization model."""

        DNN_CLASSIFIER: Model.ModelType.ValueType = ...  # 5
        """DNN classifier model."""

        TENSORFLOW: Model.ModelType.ValueType = ...  # 6
        """An imported TensorFlow model."""

        DNN_REGRESSOR: Model.ModelType.ValueType = ...  # 7
        """DNN regressor model."""

        BOOSTED_TREE_REGRESSOR: Model.ModelType.ValueType = ...  # 9
        """Boosted tree regressor model."""

        BOOSTED_TREE_CLASSIFIER: Model.ModelType.ValueType = ...  # 10
        """Boosted tree classifier model."""

        ARIMA: Model.ModelType.ValueType = ...  # 11
        """ARIMA model."""

        AUTOML_REGRESSOR: Model.ModelType.ValueType = ...  # 12
        """[Beta] AutoML Tables regression model."""

        AUTOML_CLASSIFIER: Model.ModelType.ValueType = ...  # 13
        """[Beta] AutoML Tables classification model."""

        ARIMA_PLUS: Model.ModelType.ValueType = ...  # 19
        """New name for the ARIMA model."""

    class ModelType(_ModelType, metaclass=_ModelTypeEnumTypeWrapper):
        """Indicates the type of the Model."""
        pass

    MODEL_TYPE_UNSPECIFIED: Model.ModelType.ValueType = ...  # 0
    LINEAR_REGRESSION: Model.ModelType.ValueType = ...  # 1
    """Linear regression model."""

    LOGISTIC_REGRESSION: Model.ModelType.ValueType = ...  # 2
    """Logistic regression based classification model."""

    KMEANS: Model.ModelType.ValueType = ...  # 3
    """K-means clustering model."""

    MATRIX_FACTORIZATION: Model.ModelType.ValueType = ...  # 4
    """Matrix factorization model."""

    DNN_CLASSIFIER: Model.ModelType.ValueType = ...  # 5
    """DNN classifier model."""

    TENSORFLOW: Model.ModelType.ValueType = ...  # 6
    """An imported TensorFlow model."""

    DNN_REGRESSOR: Model.ModelType.ValueType = ...  # 7
    """DNN regressor model."""

    BOOSTED_TREE_REGRESSOR: Model.ModelType.ValueType = ...  # 9
    """Boosted tree regressor model."""

    BOOSTED_TREE_CLASSIFIER: Model.ModelType.ValueType = ...  # 10
    """Boosted tree classifier model."""

    ARIMA: Model.ModelType.ValueType = ...  # 11
    """ARIMA model."""

    AUTOML_REGRESSOR: Model.ModelType.ValueType = ...  # 12
    """[Beta] AutoML Tables regression model."""

    AUTOML_CLASSIFIER: Model.ModelType.ValueType = ...  # 13
    """[Beta] AutoML Tables classification model."""

    ARIMA_PLUS: Model.ModelType.ValueType = ...  # 19
    """New name for the ARIMA model."""


    class _LossType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _LossTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_LossType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        LOSS_TYPE_UNSPECIFIED: Model.LossType.ValueType = ...  # 0
        MEAN_SQUARED_LOSS: Model.LossType.ValueType = ...  # 1
        """Mean squared loss, used for linear regression."""

        MEAN_LOG_LOSS: Model.LossType.ValueType = ...  # 2
        """Mean log loss, used for logistic regression."""

    class LossType(_LossType, metaclass=_LossTypeEnumTypeWrapper):
        """Loss metric to evaluate model training performance."""
        pass

    LOSS_TYPE_UNSPECIFIED: Model.LossType.ValueType = ...  # 0
    MEAN_SQUARED_LOSS: Model.LossType.ValueType = ...  # 1
    """Mean squared loss, used for linear regression."""

    MEAN_LOG_LOSS: Model.LossType.ValueType = ...  # 2
    """Mean log loss, used for logistic regression."""


    class _DistanceType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _DistanceTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DistanceType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        DISTANCE_TYPE_UNSPECIFIED: Model.DistanceType.ValueType = ...  # 0
        EUCLIDEAN: Model.DistanceType.ValueType = ...  # 1
        """Eculidean distance."""

        COSINE: Model.DistanceType.ValueType = ...  # 2
        """Cosine distance."""

    class DistanceType(_DistanceType, metaclass=_DistanceTypeEnumTypeWrapper):
        """Distance metric used to compute the distance between two points."""
        pass

    DISTANCE_TYPE_UNSPECIFIED: Model.DistanceType.ValueType = ...  # 0
    EUCLIDEAN: Model.DistanceType.ValueType = ...  # 1
    """Eculidean distance."""

    COSINE: Model.DistanceType.ValueType = ...  # 2
    """Cosine distance."""


    class _DataSplitMethod:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _DataSplitMethodEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DataSplitMethod.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        DATA_SPLIT_METHOD_UNSPECIFIED: Model.DataSplitMethod.ValueType = ...  # 0
        RANDOM: Model.DataSplitMethod.ValueType = ...  # 1
        """Splits data randomly."""

        CUSTOM: Model.DataSplitMethod.ValueType = ...  # 2
        """Splits data with the user provided tags."""

        SEQUENTIAL: Model.DataSplitMethod.ValueType = ...  # 3
        """Splits data sequentially."""

        NO_SPLIT: Model.DataSplitMethod.ValueType = ...  # 4
        """Data split will be skipped."""

        AUTO_SPLIT: Model.DataSplitMethod.ValueType = ...  # 5
        """Splits data automatically: Uses NO_SPLIT if the data size is small.
        Otherwise uses RANDOM.
        """

    class DataSplitMethod(_DataSplitMethod, metaclass=_DataSplitMethodEnumTypeWrapper):
        """Indicates the method to split input data into multiple tables."""
        pass

    DATA_SPLIT_METHOD_UNSPECIFIED: Model.DataSplitMethod.ValueType = ...  # 0
    RANDOM: Model.DataSplitMethod.ValueType = ...  # 1
    """Splits data randomly."""

    CUSTOM: Model.DataSplitMethod.ValueType = ...  # 2
    """Splits data with the user provided tags."""

    SEQUENTIAL: Model.DataSplitMethod.ValueType = ...  # 3
    """Splits data sequentially."""

    NO_SPLIT: Model.DataSplitMethod.ValueType = ...  # 4
    """Data split will be skipped."""

    AUTO_SPLIT: Model.DataSplitMethod.ValueType = ...  # 5
    """Splits data automatically: Uses NO_SPLIT if the data size is small.
    Otherwise uses RANDOM.
    """


    class _DataFrequency:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _DataFrequencyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DataFrequency.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        DATA_FREQUENCY_UNSPECIFIED: Model.DataFrequency.ValueType = ...  # 0
        AUTO_FREQUENCY: Model.DataFrequency.ValueType = ...  # 1
        """Automatically inferred from timestamps."""

        YEARLY: Model.DataFrequency.ValueType = ...  # 2
        """Yearly data."""

        QUARTERLY: Model.DataFrequency.ValueType = ...  # 3
        """Quarterly data."""

        MONTHLY: Model.DataFrequency.ValueType = ...  # 4
        """Monthly data."""

        WEEKLY: Model.DataFrequency.ValueType = ...  # 5
        """Weekly data."""

        DAILY: Model.DataFrequency.ValueType = ...  # 6
        """Daily data."""

        HOURLY: Model.DataFrequency.ValueType = ...  # 7
        """Hourly data."""

        PER_MINUTE: Model.DataFrequency.ValueType = ...  # 8
        """Per-minute data."""

    class DataFrequency(_DataFrequency, metaclass=_DataFrequencyEnumTypeWrapper):
        """Type of supported data frequency for time series forecasting models."""
        pass

    DATA_FREQUENCY_UNSPECIFIED: Model.DataFrequency.ValueType = ...  # 0
    AUTO_FREQUENCY: Model.DataFrequency.ValueType = ...  # 1
    """Automatically inferred from timestamps."""

    YEARLY: Model.DataFrequency.ValueType = ...  # 2
    """Yearly data."""

    QUARTERLY: Model.DataFrequency.ValueType = ...  # 3
    """Quarterly data."""

    MONTHLY: Model.DataFrequency.ValueType = ...  # 4
    """Monthly data."""

    WEEKLY: Model.DataFrequency.ValueType = ...  # 5
    """Weekly data."""

    DAILY: Model.DataFrequency.ValueType = ...  # 6
    """Daily data."""

    HOURLY: Model.DataFrequency.ValueType = ...  # 7
    """Hourly data."""

    PER_MINUTE: Model.DataFrequency.ValueType = ...  # 8
    """Per-minute data."""


    class _HolidayRegion:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _HolidayRegionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_HolidayRegion.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        HOLIDAY_REGION_UNSPECIFIED: Model.HolidayRegion.ValueType = ...  # 0
        """Holiday region unspecified."""

        GLOBAL: Model.HolidayRegion.ValueType = ...  # 1
        """Global."""

        NA: Model.HolidayRegion.ValueType = ...  # 2
        """North America."""

        JAPAC: Model.HolidayRegion.ValueType = ...  # 3
        """Japan and Asia Pacific: Korea, Greater China, India, Australia, and New
        Zealand.
        """

        EMEA: Model.HolidayRegion.ValueType = ...  # 4
        """Europe, the Middle East and Africa."""

        LAC: Model.HolidayRegion.ValueType = ...  # 5
        """Latin America and the Caribbean."""

        AE: Model.HolidayRegion.ValueType = ...  # 6
        """United Arab Emirates"""

        AR: Model.HolidayRegion.ValueType = ...  # 7
        """Argentina"""

        AT: Model.HolidayRegion.ValueType = ...  # 8
        """Austria"""

        AU: Model.HolidayRegion.ValueType = ...  # 9
        """Australia"""

        BE: Model.HolidayRegion.ValueType = ...  # 10
        """Belgium"""

        BR: Model.HolidayRegion.ValueType = ...  # 11
        """Brazil"""

        CA: Model.HolidayRegion.ValueType = ...  # 12
        """Canada"""

        CH: Model.HolidayRegion.ValueType = ...  # 13
        """Switzerland"""

        CL: Model.HolidayRegion.ValueType = ...  # 14
        """Chile"""

        CN: Model.HolidayRegion.ValueType = ...  # 15
        """China"""

        CO: Model.HolidayRegion.ValueType = ...  # 16
        """Colombia"""

        CS: Model.HolidayRegion.ValueType = ...  # 17
        """Czechoslovakia"""

        CZ: Model.HolidayRegion.ValueType = ...  # 18
        """Czech Republic"""

        DE: Model.HolidayRegion.ValueType = ...  # 19
        """Germany"""

        DK: Model.HolidayRegion.ValueType = ...  # 20
        """Denmark"""

        DZ: Model.HolidayRegion.ValueType = ...  # 21
        """Algeria"""

        EC: Model.HolidayRegion.ValueType = ...  # 22
        """Ecuador"""

        EE: Model.HolidayRegion.ValueType = ...  # 23
        """Estonia"""

        EG: Model.HolidayRegion.ValueType = ...  # 24
        """Egypt"""

        ES: Model.HolidayRegion.ValueType = ...  # 25
        """Spain"""

        FI: Model.HolidayRegion.ValueType = ...  # 26
        """Finland"""

        FR: Model.HolidayRegion.ValueType = ...  # 27
        """France"""

        GB: Model.HolidayRegion.ValueType = ...  # 28
        """Great Britain (United Kingdom)"""

        GR: Model.HolidayRegion.ValueType = ...  # 29
        """Greece"""

        HK: Model.HolidayRegion.ValueType = ...  # 30
        """Hong Kong"""

        HU: Model.HolidayRegion.ValueType = ...  # 31
        """Hungary"""

        ID: Model.HolidayRegion.ValueType = ...  # 32
        """Indonesia"""

        IE: Model.HolidayRegion.ValueType = ...  # 33
        """Ireland"""

        IL: Model.HolidayRegion.ValueType = ...  # 34
        """Israel"""

        IN: Model.HolidayRegion.ValueType = ...  # 35
        """India"""

        IR: Model.HolidayRegion.ValueType = ...  # 36
        """Iran"""

        IT: Model.HolidayRegion.ValueType = ...  # 37
        """Italy"""

        JP: Model.HolidayRegion.ValueType = ...  # 38
        """Japan"""

        KR: Model.HolidayRegion.ValueType = ...  # 39
        """Korea (South)"""

        LV: Model.HolidayRegion.ValueType = ...  # 40
        """Latvia"""

        MA: Model.HolidayRegion.ValueType = ...  # 41
        """Morocco"""

        MX: Model.HolidayRegion.ValueType = ...  # 42
        """Mexico"""

        MY: Model.HolidayRegion.ValueType = ...  # 43
        """Malaysia"""

        NG: Model.HolidayRegion.ValueType = ...  # 44
        """Nigeria"""

        NL: Model.HolidayRegion.ValueType = ...  # 45
        """Netherlands"""

        NO: Model.HolidayRegion.ValueType = ...  # 46
        """Norway"""

        NZ: Model.HolidayRegion.ValueType = ...  # 47
        """New Zealand"""

        PE: Model.HolidayRegion.ValueType = ...  # 48
        """Peru"""

        PH: Model.HolidayRegion.ValueType = ...  # 49
        """Philippines"""

        PK: Model.HolidayRegion.ValueType = ...  # 50
        """Pakistan"""

        PL: Model.HolidayRegion.ValueType = ...  # 51
        """Poland"""

        PT: Model.HolidayRegion.ValueType = ...  # 52
        """Portugal"""

        RO: Model.HolidayRegion.ValueType = ...  # 53
        """Romania"""

        RS: Model.HolidayRegion.ValueType = ...  # 54
        """Serbia"""

        RU: Model.HolidayRegion.ValueType = ...  # 55
        """Russian Federation"""

        SA: Model.HolidayRegion.ValueType = ...  # 56
        """Saudi Arabia"""

        SE: Model.HolidayRegion.ValueType = ...  # 57
        """Sweden"""

        SG: Model.HolidayRegion.ValueType = ...  # 58
        """Singapore"""

        SI: Model.HolidayRegion.ValueType = ...  # 59
        """Slovenia"""

        SK: Model.HolidayRegion.ValueType = ...  # 60
        """Slovakia"""

        TH: Model.HolidayRegion.ValueType = ...  # 61
        """Thailand"""

        TR: Model.HolidayRegion.ValueType = ...  # 62
        """Turkey"""

        TW: Model.HolidayRegion.ValueType = ...  # 63
        """Taiwan"""

        UA: Model.HolidayRegion.ValueType = ...  # 64
        """Ukraine"""

        US: Model.HolidayRegion.ValueType = ...  # 65
        """United States"""

        VE: Model.HolidayRegion.ValueType = ...  # 66
        """Venezuela"""

        VN: Model.HolidayRegion.ValueType = ...  # 67
        """Viet Nam"""

        ZA: Model.HolidayRegion.ValueType = ...  # 68
        """South Africa"""

    class HolidayRegion(_HolidayRegion, metaclass=_HolidayRegionEnumTypeWrapper):
        """Type of supported holiday regions for time series forecasting models."""
        pass

    HOLIDAY_REGION_UNSPECIFIED: Model.HolidayRegion.ValueType = ...  # 0
    """Holiday region unspecified."""

    GLOBAL: Model.HolidayRegion.ValueType = ...  # 1
    """Global."""

    NA: Model.HolidayRegion.ValueType = ...  # 2
    """North America."""

    JAPAC: Model.HolidayRegion.ValueType = ...  # 3
    """Japan and Asia Pacific: Korea, Greater China, India, Australia, and New
    Zealand.
    """

    EMEA: Model.HolidayRegion.ValueType = ...  # 4
    """Europe, the Middle East and Africa."""

    LAC: Model.HolidayRegion.ValueType = ...  # 5
    """Latin America and the Caribbean."""

    AE: Model.HolidayRegion.ValueType = ...  # 6
    """United Arab Emirates"""

    AR: Model.HolidayRegion.ValueType = ...  # 7
    """Argentina"""

    AT: Model.HolidayRegion.ValueType = ...  # 8
    """Austria"""

    AU: Model.HolidayRegion.ValueType = ...  # 9
    """Australia"""

    BE: Model.HolidayRegion.ValueType = ...  # 10
    """Belgium"""

    BR: Model.HolidayRegion.ValueType = ...  # 11
    """Brazil"""

    CA: Model.HolidayRegion.ValueType = ...  # 12
    """Canada"""

    CH: Model.HolidayRegion.ValueType = ...  # 13
    """Switzerland"""

    CL: Model.HolidayRegion.ValueType = ...  # 14
    """Chile"""

    CN: Model.HolidayRegion.ValueType = ...  # 15
    """China"""

    CO: Model.HolidayRegion.ValueType = ...  # 16
    """Colombia"""

    CS: Model.HolidayRegion.ValueType = ...  # 17
    """Czechoslovakia"""

    CZ: Model.HolidayRegion.ValueType = ...  # 18
    """Czech Republic"""

    DE: Model.HolidayRegion.ValueType = ...  # 19
    """Germany"""

    DK: Model.HolidayRegion.ValueType = ...  # 20
    """Denmark"""

    DZ: Model.HolidayRegion.ValueType = ...  # 21
    """Algeria"""

    EC: Model.HolidayRegion.ValueType = ...  # 22
    """Ecuador"""

    EE: Model.HolidayRegion.ValueType = ...  # 23
    """Estonia"""

    EG: Model.HolidayRegion.ValueType = ...  # 24
    """Egypt"""

    ES: Model.HolidayRegion.ValueType = ...  # 25
    """Spain"""

    FI: Model.HolidayRegion.ValueType = ...  # 26
    """Finland"""

    FR: Model.HolidayRegion.ValueType = ...  # 27
    """France"""

    GB: Model.HolidayRegion.ValueType = ...  # 28
    """Great Britain (United Kingdom)"""

    GR: Model.HolidayRegion.ValueType = ...  # 29
    """Greece"""

    HK: Model.HolidayRegion.ValueType = ...  # 30
    """Hong Kong"""

    HU: Model.HolidayRegion.ValueType = ...  # 31
    """Hungary"""

    ID: Model.HolidayRegion.ValueType = ...  # 32
    """Indonesia"""

    IE: Model.HolidayRegion.ValueType = ...  # 33
    """Ireland"""

    IL: Model.HolidayRegion.ValueType = ...  # 34
    """Israel"""

    IN: Model.HolidayRegion.ValueType = ...  # 35
    """India"""

    IR: Model.HolidayRegion.ValueType = ...  # 36
    """Iran"""

    IT: Model.HolidayRegion.ValueType = ...  # 37
    """Italy"""

    JP: Model.HolidayRegion.ValueType = ...  # 38
    """Japan"""

    KR: Model.HolidayRegion.ValueType = ...  # 39
    """Korea (South)"""

    LV: Model.HolidayRegion.ValueType = ...  # 40
    """Latvia"""

    MA: Model.HolidayRegion.ValueType = ...  # 41
    """Morocco"""

    MX: Model.HolidayRegion.ValueType = ...  # 42
    """Mexico"""

    MY: Model.HolidayRegion.ValueType = ...  # 43
    """Malaysia"""

    NG: Model.HolidayRegion.ValueType = ...  # 44
    """Nigeria"""

    NL: Model.HolidayRegion.ValueType = ...  # 45
    """Netherlands"""

    NO: Model.HolidayRegion.ValueType = ...  # 46
    """Norway"""

    NZ: Model.HolidayRegion.ValueType = ...  # 47
    """New Zealand"""

    PE: Model.HolidayRegion.ValueType = ...  # 48
    """Peru"""

    PH: Model.HolidayRegion.ValueType = ...  # 49
    """Philippines"""

    PK: Model.HolidayRegion.ValueType = ...  # 50
    """Pakistan"""

    PL: Model.HolidayRegion.ValueType = ...  # 51
    """Poland"""

    PT: Model.HolidayRegion.ValueType = ...  # 52
    """Portugal"""

    RO: Model.HolidayRegion.ValueType = ...  # 53
    """Romania"""

    RS: Model.HolidayRegion.ValueType = ...  # 54
    """Serbia"""

    RU: Model.HolidayRegion.ValueType = ...  # 55
    """Russian Federation"""

    SA: Model.HolidayRegion.ValueType = ...  # 56
    """Saudi Arabia"""

    SE: Model.HolidayRegion.ValueType = ...  # 57
    """Sweden"""

    SG: Model.HolidayRegion.ValueType = ...  # 58
    """Singapore"""

    SI: Model.HolidayRegion.ValueType = ...  # 59
    """Slovenia"""

    SK: Model.HolidayRegion.ValueType = ...  # 60
    """Slovakia"""

    TH: Model.HolidayRegion.ValueType = ...  # 61
    """Thailand"""

    TR: Model.HolidayRegion.ValueType = ...  # 62
    """Turkey"""

    TW: Model.HolidayRegion.ValueType = ...  # 63
    """Taiwan"""

    UA: Model.HolidayRegion.ValueType = ...  # 64
    """Ukraine"""

    US: Model.HolidayRegion.ValueType = ...  # 65
    """United States"""

    VE: Model.HolidayRegion.ValueType = ...  # 66
    """Venezuela"""

    VN: Model.HolidayRegion.ValueType = ...  # 67
    """Viet Nam"""

    ZA: Model.HolidayRegion.ValueType = ...  # 68
    """South Africa"""


    class _LearnRateStrategy:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _LearnRateStrategyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_LearnRateStrategy.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        LEARN_RATE_STRATEGY_UNSPECIFIED: Model.LearnRateStrategy.ValueType = ...  # 0
        LINE_SEARCH: Model.LearnRateStrategy.ValueType = ...  # 1
        """Use line search to determine learning rate."""

        CONSTANT: Model.LearnRateStrategy.ValueType = ...  # 2
        """Use a constant learning rate."""

    class LearnRateStrategy(_LearnRateStrategy, metaclass=_LearnRateStrategyEnumTypeWrapper):
        """Indicates the learning rate optimization strategy to use."""
        pass

    LEARN_RATE_STRATEGY_UNSPECIFIED: Model.LearnRateStrategy.ValueType = ...  # 0
    LINE_SEARCH: Model.LearnRateStrategy.ValueType = ...  # 1
    """Use line search to determine learning rate."""

    CONSTANT: Model.LearnRateStrategy.ValueType = ...  # 2
    """Use a constant learning rate."""


    class _OptimizationStrategy:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _OptimizationStrategyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_OptimizationStrategy.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        OPTIMIZATION_STRATEGY_UNSPECIFIED: Model.OptimizationStrategy.ValueType = ...  # 0
        BATCH_GRADIENT_DESCENT: Model.OptimizationStrategy.ValueType = ...  # 1
        """Uses an iterative batch gradient descent algorithm."""

        NORMAL_EQUATION: Model.OptimizationStrategy.ValueType = ...  # 2
        """Uses a normal equation to solve linear regression problem."""

    class OptimizationStrategy(_OptimizationStrategy, metaclass=_OptimizationStrategyEnumTypeWrapper):
        """Indicates the optimization strategy used for training."""
        pass

    OPTIMIZATION_STRATEGY_UNSPECIFIED: Model.OptimizationStrategy.ValueType = ...  # 0
    BATCH_GRADIENT_DESCENT: Model.OptimizationStrategy.ValueType = ...  # 1
    """Uses an iterative batch gradient descent algorithm."""

    NORMAL_EQUATION: Model.OptimizationStrategy.ValueType = ...  # 2
    """Uses a normal equation to solve linear regression problem."""


    class _FeedbackType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _FeedbackTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_FeedbackType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        FEEDBACK_TYPE_UNSPECIFIED: Model.FeedbackType.ValueType = ...  # 0
        IMPLICIT: Model.FeedbackType.ValueType = ...  # 1
        """Use weighted-als for implicit feedback problems."""

        EXPLICIT: Model.FeedbackType.ValueType = ...  # 2
        """Use nonweighted-als for explicit feedback problems."""

    class FeedbackType(_FeedbackType, metaclass=_FeedbackTypeEnumTypeWrapper):
        """Indicates the training algorithm to use for matrix factorization models."""
        pass

    FEEDBACK_TYPE_UNSPECIFIED: Model.FeedbackType.ValueType = ...  # 0
    IMPLICIT: Model.FeedbackType.ValueType = ...  # 1
    """Use weighted-als for implicit feedback problems."""

    EXPLICIT: Model.FeedbackType.ValueType = ...  # 2
    """Use nonweighted-als for explicit feedback problems."""


    class SeasonalPeriod(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _SeasonalPeriodType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _SeasonalPeriodTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SeasonalPeriodType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            SEASONAL_PERIOD_TYPE_UNSPECIFIED: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 0
            NO_SEASONALITY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 1
            """No seasonality"""

            DAILY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 2
            """Daily period, 24 hours."""

            WEEKLY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 3
            """Weekly period, 7 days."""

            MONTHLY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 4
            """Monthly period, 30 days or irregular."""

            QUARTERLY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 5
            """Quarterly period, 90 days or irregular."""

            YEARLY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 6
            """Yearly period, 365 days or irregular."""

        class SeasonalPeriodType(_SeasonalPeriodType, metaclass=_SeasonalPeriodTypeEnumTypeWrapper):
            pass

        SEASONAL_PERIOD_TYPE_UNSPECIFIED: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 0
        NO_SEASONALITY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 1
        """No seasonality"""

        DAILY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 2
        """Daily period, 24 hours."""

        WEEKLY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 3
        """Weekly period, 7 days."""

        MONTHLY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 4
        """Monthly period, 30 days or irregular."""

        QUARTERLY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 5
        """Quarterly period, 90 days or irregular."""

        YEARLY: Model.SeasonalPeriod.SeasonalPeriodType.ValueType = ...  # 6
        """Yearly period, 365 days or irregular."""


        def __init__(self,
            ) -> None: ...

    class KmeansEnums(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _KmeansInitializationMethod:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _KmeansInitializationMethodEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_KmeansInitializationMethod.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            KMEANS_INITIALIZATION_METHOD_UNSPECIFIED: Model.KmeansEnums.KmeansInitializationMethod.ValueType = ...  # 0
            """Unspecified initialization method."""

            RANDOM: Model.KmeansEnums.KmeansInitializationMethod.ValueType = ...  # 1
            """Initializes the centroids randomly."""

            CUSTOM: Model.KmeansEnums.KmeansInitializationMethod.ValueType = ...  # 2
            """Initializes the centroids using data specified in
            kmeans_initialization_column.
            """

            KMEANS_PLUS_PLUS: Model.KmeansEnums.KmeansInitializationMethod.ValueType = ...  # 3
            """Initializes with kmeans++."""

        class KmeansInitializationMethod(_KmeansInitializationMethod, metaclass=_KmeansInitializationMethodEnumTypeWrapper):
            """Indicates the method used to initialize the centroids for KMeans
            clustering algorithm.
            """
            pass

        KMEANS_INITIALIZATION_METHOD_UNSPECIFIED: Model.KmeansEnums.KmeansInitializationMethod.ValueType = ...  # 0
        """Unspecified initialization method."""

        RANDOM: Model.KmeansEnums.KmeansInitializationMethod.ValueType = ...  # 1
        """Initializes the centroids randomly."""

        CUSTOM: Model.KmeansEnums.KmeansInitializationMethod.ValueType = ...  # 2
        """Initializes the centroids using data specified in
        kmeans_initialization_column.
        """

        KMEANS_PLUS_PLUS: Model.KmeansEnums.KmeansInitializationMethod.ValueType = ...  # 3
        """Initializes with kmeans++."""


        def __init__(self,
            ) -> None: ...

    class RegressionMetrics(google.protobuf.message.Message):
        """Evaluation metrics for regression and explicit feedback type matrix
        factorization models.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MEAN_ABSOLUTE_ERROR_FIELD_NUMBER: builtins.int
        MEAN_SQUARED_ERROR_FIELD_NUMBER: builtins.int
        MEAN_SQUARED_LOG_ERROR_FIELD_NUMBER: builtins.int
        MEDIAN_ABSOLUTE_ERROR_FIELD_NUMBER: builtins.int
        R_SQUARED_FIELD_NUMBER: builtins.int
        @property
        def mean_absolute_error(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Mean absolute error."""
            pass
        @property
        def mean_squared_error(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Mean squared error."""
            pass
        @property
        def mean_squared_log_error(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Mean squared log error."""
            pass
        @property
        def median_absolute_error(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Median absolute error."""
            pass
        @property
        def r_squared(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """R^2 score. This corresponds to r2_score in ML.EVALUATE."""
            pass
        def __init__(self,
            *,
            mean_absolute_error : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            mean_squared_error : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            mean_squared_log_error : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            median_absolute_error : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            r_squared : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["mean_absolute_error",b"mean_absolute_error","mean_squared_error",b"mean_squared_error","mean_squared_log_error",b"mean_squared_log_error","median_absolute_error",b"median_absolute_error","r_squared",b"r_squared"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["mean_absolute_error",b"mean_absolute_error","mean_squared_error",b"mean_squared_error","mean_squared_log_error",b"mean_squared_log_error","median_absolute_error",b"median_absolute_error","r_squared",b"r_squared"]) -> None: ...

    class AggregateClassificationMetrics(google.protobuf.message.Message):
        """Aggregate metrics for classification/classifier models. For multi-class
        models, the metrics are either macro-averaged or micro-averaged. When
        macro-averaged, the metrics are calculated for each label and then an
        unweighted average is taken of those values. When micro-averaged, the
        metric is calculated globally by counting the total number of correctly
        predicted rows.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        PRECISION_FIELD_NUMBER: builtins.int
        RECALL_FIELD_NUMBER: builtins.int
        ACCURACY_FIELD_NUMBER: builtins.int
        THRESHOLD_FIELD_NUMBER: builtins.int
        F1_SCORE_FIELD_NUMBER: builtins.int
        LOG_LOSS_FIELD_NUMBER: builtins.int
        ROC_AUC_FIELD_NUMBER: builtins.int
        @property
        def precision(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Precision is the fraction of actual positive predictions that had
            positive actual labels. For multiclass this is a macro-averaged
            metric treating each class as a binary classifier.
            """
            pass
        @property
        def recall(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Recall is the fraction of actual positive labels that were given a
            positive prediction. For multiclass this is a macro-averaged metric.
            """
            pass
        @property
        def accuracy(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Accuracy is the fraction of predictions given the correct label. For
            multiclass this is a micro-averaged metric.
            """
            pass
        @property
        def threshold(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Threshold at which the metrics are computed. For binary
            classification models this is the positive class threshold.
            For multi-class classfication models this is the confidence
            threshold.
            """
            pass
        @property
        def f1_score(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """The F1 score is an average of recall and precision. For multiclass
            this is a macro-averaged metric.
            """
            pass
        @property
        def log_loss(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Logarithmic Loss. For multiclass this is a macro-averaged metric."""
            pass
        @property
        def roc_auc(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Area Under a ROC Curve. For multiclass this is a macro-averaged
            metric.
            """
            pass
        def __init__(self,
            *,
            precision : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            recall : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            accuracy : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            threshold : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            f1_score : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            log_loss : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            roc_auc : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["accuracy",b"accuracy","f1_score",b"f1_score","log_loss",b"log_loss","precision",b"precision","recall",b"recall","roc_auc",b"roc_auc","threshold",b"threshold"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["accuracy",b"accuracy","f1_score",b"f1_score","log_loss",b"log_loss","precision",b"precision","recall",b"recall","roc_auc",b"roc_auc","threshold",b"threshold"]) -> None: ...

    class BinaryClassificationMetrics(google.protobuf.message.Message):
        """Evaluation metrics for binary classification/classifier models."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class BinaryConfusionMatrix(google.protobuf.message.Message):
            """Confusion matrix for binary classification models."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            POSITIVE_CLASS_THRESHOLD_FIELD_NUMBER: builtins.int
            TRUE_POSITIVES_FIELD_NUMBER: builtins.int
            FALSE_POSITIVES_FIELD_NUMBER: builtins.int
            TRUE_NEGATIVES_FIELD_NUMBER: builtins.int
            FALSE_NEGATIVES_FIELD_NUMBER: builtins.int
            PRECISION_FIELD_NUMBER: builtins.int
            RECALL_FIELD_NUMBER: builtins.int
            F1_SCORE_FIELD_NUMBER: builtins.int
            ACCURACY_FIELD_NUMBER: builtins.int
            @property
            def positive_class_threshold(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """Threshold value used when computing each of the following metric."""
                pass
            @property
            def true_positives(self) -> google.protobuf.wrappers_pb2.Int64Value:
                """Number of true samples predicted as true."""
                pass
            @property
            def false_positives(self) -> google.protobuf.wrappers_pb2.Int64Value:
                """Number of false samples predicted as true."""
                pass
            @property
            def true_negatives(self) -> google.protobuf.wrappers_pb2.Int64Value:
                """Number of true samples predicted as false."""
                pass
            @property
            def false_negatives(self) -> google.protobuf.wrappers_pb2.Int64Value:
                """Number of false samples predicted as false."""
                pass
            @property
            def precision(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """The fraction of actual positive predictions that had positive actual
                labels.
                """
                pass
            @property
            def recall(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """The fraction of actual positive labels that were given a positive
                prediction.
                """
                pass
            @property
            def f1_score(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """The equally weighted average of recall and precision."""
                pass
            @property
            def accuracy(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """The fraction of predictions given the correct label."""
                pass
            def __init__(self,
                *,
                positive_class_threshold : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                true_positives : typing.Optional[google.protobuf.wrappers_pb2.Int64Value] = ...,
                false_positives : typing.Optional[google.protobuf.wrappers_pb2.Int64Value] = ...,
                true_negatives : typing.Optional[google.protobuf.wrappers_pb2.Int64Value] = ...,
                false_negatives : typing.Optional[google.protobuf.wrappers_pb2.Int64Value] = ...,
                precision : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                recall : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                f1_score : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                accuracy : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["accuracy",b"accuracy","f1_score",b"f1_score","false_negatives",b"false_negatives","false_positives",b"false_positives","positive_class_threshold",b"positive_class_threshold","precision",b"precision","recall",b"recall","true_negatives",b"true_negatives","true_positives",b"true_positives"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["accuracy",b"accuracy","f1_score",b"f1_score","false_negatives",b"false_negatives","false_positives",b"false_positives","positive_class_threshold",b"positive_class_threshold","precision",b"precision","recall",b"recall","true_negatives",b"true_negatives","true_positives",b"true_positives"]) -> None: ...

        AGGREGATE_CLASSIFICATION_METRICS_FIELD_NUMBER: builtins.int
        BINARY_CONFUSION_MATRIX_LIST_FIELD_NUMBER: builtins.int
        POSITIVE_LABEL_FIELD_NUMBER: builtins.int
        NEGATIVE_LABEL_FIELD_NUMBER: builtins.int
        @property
        def aggregate_classification_metrics(self) -> global___Model.AggregateClassificationMetrics:
            """Aggregate classification metrics."""
            pass
        @property
        def binary_confusion_matrix_list(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.BinaryClassificationMetrics.BinaryConfusionMatrix]:
            """Binary confusion matrix at multiple thresholds."""
            pass
        positive_label: typing.Text = ...
        """Label representing the positive class."""

        negative_label: typing.Text = ...
        """Label representing the negative class."""

        def __init__(self,
            *,
            aggregate_classification_metrics : typing.Optional[global___Model.AggregateClassificationMetrics] = ...,
            binary_confusion_matrix_list : typing.Optional[typing.Iterable[global___Model.BinaryClassificationMetrics.BinaryConfusionMatrix]] = ...,
            positive_label : typing.Text = ...,
            negative_label : typing.Text = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["aggregate_classification_metrics",b"aggregate_classification_metrics"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["aggregate_classification_metrics",b"aggregate_classification_metrics","binary_confusion_matrix_list",b"binary_confusion_matrix_list","negative_label",b"negative_label","positive_label",b"positive_label"]) -> None: ...

    class MultiClassClassificationMetrics(google.protobuf.message.Message):
        """Evaluation metrics for multi-class classification/classifier models."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class ConfusionMatrix(google.protobuf.message.Message):
            """Confusion matrix for multi-class classification models."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class Entry(google.protobuf.message.Message):
                """A single entry in the confusion matrix."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                PREDICTED_LABEL_FIELD_NUMBER: builtins.int
                ITEM_COUNT_FIELD_NUMBER: builtins.int
                predicted_label: typing.Text = ...
                """The predicted label. For confidence_threshold > 0, we will
                also add an entry indicating the number of items under the
                confidence threshold.
                """

                @property
                def item_count(self) -> google.protobuf.wrappers_pb2.Int64Value:
                    """Number of items being predicted as this label."""
                    pass
                def __init__(self,
                    *,
                    predicted_label : typing.Text = ...,
                    item_count : typing.Optional[google.protobuf.wrappers_pb2.Int64Value] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["item_count",b"item_count"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["item_count",b"item_count","predicted_label",b"predicted_label"]) -> None: ...

            class Row(google.protobuf.message.Message):
                """A single row in the confusion matrix."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                ACTUAL_LABEL_FIELD_NUMBER: builtins.int
                ENTRIES_FIELD_NUMBER: builtins.int
                actual_label: typing.Text = ...
                """The original label of this row."""

                @property
                def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.MultiClassClassificationMetrics.ConfusionMatrix.Entry]:
                    """Info describing predicted label distribution."""
                    pass
                def __init__(self,
                    *,
                    actual_label : typing.Text = ...,
                    entries : typing.Optional[typing.Iterable[global___Model.MultiClassClassificationMetrics.ConfusionMatrix.Entry]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["actual_label",b"actual_label","entries",b"entries"]) -> None: ...

            CONFIDENCE_THRESHOLD_FIELD_NUMBER: builtins.int
            ROWS_FIELD_NUMBER: builtins.int
            @property
            def confidence_threshold(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """Confidence threshold used when computing the entries of the
                confusion matrix.
                """
                pass
            @property
            def rows(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.MultiClassClassificationMetrics.ConfusionMatrix.Row]:
                """One row per actual label."""
                pass
            def __init__(self,
                *,
                confidence_threshold : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                rows : typing.Optional[typing.Iterable[global___Model.MultiClassClassificationMetrics.ConfusionMatrix.Row]] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["confidence_threshold",b"confidence_threshold"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["confidence_threshold",b"confidence_threshold","rows",b"rows"]) -> None: ...

        AGGREGATE_CLASSIFICATION_METRICS_FIELD_NUMBER: builtins.int
        CONFUSION_MATRIX_LIST_FIELD_NUMBER: builtins.int
        @property
        def aggregate_classification_metrics(self) -> global___Model.AggregateClassificationMetrics:
            """Aggregate classification metrics."""
            pass
        @property
        def confusion_matrix_list(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.MultiClassClassificationMetrics.ConfusionMatrix]:
            """Confusion matrix at different thresholds."""
            pass
        def __init__(self,
            *,
            aggregate_classification_metrics : typing.Optional[global___Model.AggregateClassificationMetrics] = ...,
            confusion_matrix_list : typing.Optional[typing.Iterable[global___Model.MultiClassClassificationMetrics.ConfusionMatrix]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["aggregate_classification_metrics",b"aggregate_classification_metrics"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["aggregate_classification_metrics",b"aggregate_classification_metrics","confusion_matrix_list",b"confusion_matrix_list"]) -> None: ...

    class ClusteringMetrics(google.protobuf.message.Message):
        """Evaluation metrics for clustering models."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Cluster(google.protobuf.message.Message):
            """Message containing the information about one cluster."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class FeatureValue(google.protobuf.message.Message):
                """Representative value of a single feature within the cluster."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                class CategoricalValue(google.protobuf.message.Message):
                    """Representative value of a categorical feature."""
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    class CategoryCount(google.protobuf.message.Message):
                        """Represents the count of a single category within the cluster."""
                        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                        CATEGORY_FIELD_NUMBER: builtins.int
                        COUNT_FIELD_NUMBER: builtins.int
                        category: typing.Text = ...
                        """The name of category."""

                        @property
                        def count(self) -> google.protobuf.wrappers_pb2.Int64Value:
                            """The count of training samples matching the category within the
                            cluster.
                            """
                            pass
                        def __init__(self,
                            *,
                            category : typing.Text = ...,
                            count : typing.Optional[google.protobuf.wrappers_pb2.Int64Value] = ...,
                            ) -> None: ...
                        def HasField(self, field_name: typing_extensions.Literal["count",b"count"]) -> builtins.bool: ...
                        def ClearField(self, field_name: typing_extensions.Literal["category",b"category","count",b"count"]) -> None: ...

                    CATEGORY_COUNTS_FIELD_NUMBER: builtins.int
                    @property
                    def category_counts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.ClusteringMetrics.Cluster.FeatureValue.CategoricalValue.CategoryCount]:
                        """Counts of all categories for the categorical feature. If there are
                        more than ten categories, we return top ten (by count) and return
                        one more CategoryCount with category "_OTHER_" and count as
                        aggregate counts of remaining categories.
                        """
                        pass
                    def __init__(self,
                        *,
                        category_counts : typing.Optional[typing.Iterable[global___Model.ClusteringMetrics.Cluster.FeatureValue.CategoricalValue.CategoryCount]] = ...,
                        ) -> None: ...
                    def ClearField(self, field_name: typing_extensions.Literal["category_counts",b"category_counts"]) -> None: ...

                FEATURE_COLUMN_FIELD_NUMBER: builtins.int
                NUMERICAL_VALUE_FIELD_NUMBER: builtins.int
                CATEGORICAL_VALUE_FIELD_NUMBER: builtins.int
                feature_column: typing.Text = ...
                """The feature column name."""

                @property
                def numerical_value(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                    """The numerical feature value. This is the centroid value for this
                    feature.
                    """
                    pass
                @property
                def categorical_value(self) -> global___Model.ClusteringMetrics.Cluster.FeatureValue.CategoricalValue:
                    """The categorical feature value."""
                    pass
                def __init__(self,
                    *,
                    feature_column : typing.Text = ...,
                    numerical_value : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                    categorical_value : typing.Optional[global___Model.ClusteringMetrics.Cluster.FeatureValue.CategoricalValue] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["categorical_value",b"categorical_value","numerical_value",b"numerical_value","value",b"value"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["categorical_value",b"categorical_value","feature_column",b"feature_column","numerical_value",b"numerical_value","value",b"value"]) -> None: ...
                def WhichOneof(self, oneof_group: typing_extensions.Literal["value",b"value"]) -> typing.Optional[typing_extensions.Literal["numerical_value","categorical_value"]]: ...

            CENTROID_ID_FIELD_NUMBER: builtins.int
            FEATURE_VALUES_FIELD_NUMBER: builtins.int
            COUNT_FIELD_NUMBER: builtins.int
            centroid_id: builtins.int = ...
            """Centroid id."""

            @property
            def feature_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.ClusteringMetrics.Cluster.FeatureValue]:
                """Values of highly variant features for this cluster."""
                pass
            @property
            def count(self) -> google.protobuf.wrappers_pb2.Int64Value:
                """Count of training data rows that were assigned to this cluster."""
                pass
            def __init__(self,
                *,
                centroid_id : builtins.int = ...,
                feature_values : typing.Optional[typing.Iterable[global___Model.ClusteringMetrics.Cluster.FeatureValue]] = ...,
                count : typing.Optional[google.protobuf.wrappers_pb2.Int64Value] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["count",b"count"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["centroid_id",b"centroid_id","count",b"count","feature_values",b"feature_values"]) -> None: ...

        DAVIES_BOULDIN_INDEX_FIELD_NUMBER: builtins.int
        MEAN_SQUARED_DISTANCE_FIELD_NUMBER: builtins.int
        CLUSTERS_FIELD_NUMBER: builtins.int
        @property
        def davies_bouldin_index(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Davies-Bouldin index."""
            pass
        @property
        def mean_squared_distance(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Mean of squared distances between each sample to its cluster centroid."""
            pass
        @property
        def clusters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.ClusteringMetrics.Cluster]:
            """Information for all clusters."""
            pass
        def __init__(self,
            *,
            davies_bouldin_index : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            mean_squared_distance : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            clusters : typing.Optional[typing.Iterable[global___Model.ClusteringMetrics.Cluster]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["davies_bouldin_index",b"davies_bouldin_index","mean_squared_distance",b"mean_squared_distance"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["clusters",b"clusters","davies_bouldin_index",b"davies_bouldin_index","mean_squared_distance",b"mean_squared_distance"]) -> None: ...

    class RankingMetrics(google.protobuf.message.Message):
        """Evaluation metrics used by weighted-ALS models specified by
        feedback_type=implicit.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MEAN_AVERAGE_PRECISION_FIELD_NUMBER: builtins.int
        MEAN_SQUARED_ERROR_FIELD_NUMBER: builtins.int
        NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN_FIELD_NUMBER: builtins.int
        AVERAGE_RANK_FIELD_NUMBER: builtins.int
        @property
        def mean_average_precision(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Calculates a precision per user for all the items by ranking them and
            then averages all the precisions across all the users.
            """
            pass
        @property
        def mean_squared_error(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Similar to the mean squared error computed in regression and explicit
            recommendation models except instead of computing the rating directly,
            the output from evaluate is computed against a preference which is 1 or 0
            depending on if the rating exists or not.
            """
            pass
        @property
        def normalized_discounted_cumulative_gain(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """A metric to determine the goodness of a ranking calculated from the
            predicted confidence by comparing it to an ideal rank measured by the
            original ratings.
            """
            pass
        @property
        def average_rank(self) -> google.protobuf.wrappers_pb2.DoubleValue:
            """Determines the goodness of a ranking by computing the percentile rank
            from the predicted confidence and dividing it by the original rank.
            """
            pass
        def __init__(self,
            *,
            mean_average_precision : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            mean_squared_error : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            normalized_discounted_cumulative_gain : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            average_rank : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["average_rank",b"average_rank","mean_average_precision",b"mean_average_precision","mean_squared_error",b"mean_squared_error","normalized_discounted_cumulative_gain",b"normalized_discounted_cumulative_gain"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["average_rank",b"average_rank","mean_average_precision",b"mean_average_precision","mean_squared_error",b"mean_squared_error","normalized_discounted_cumulative_gain",b"normalized_discounted_cumulative_gain"]) -> None: ...

    class ArimaForecastingMetrics(google.protobuf.message.Message):
        """Model evaluation metrics for ARIMA forecasting models."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class ArimaSingleModelForecastingMetrics(google.protobuf.message.Message):
            """Model evaluation metrics for a single ARIMA forecasting model."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            NON_SEASONAL_ORDER_FIELD_NUMBER: builtins.int
            ARIMA_FITTING_METRICS_FIELD_NUMBER: builtins.int
            HAS_DRIFT_FIELD_NUMBER: builtins.int
            TIME_SERIES_ID_FIELD_NUMBER: builtins.int
            TIME_SERIES_IDS_FIELD_NUMBER: builtins.int
            SEASONAL_PERIODS_FIELD_NUMBER: builtins.int
            HAS_HOLIDAY_EFFECT_FIELD_NUMBER: builtins.int
            HAS_SPIKES_AND_DIPS_FIELD_NUMBER: builtins.int
            HAS_STEP_CHANGES_FIELD_NUMBER: builtins.int
            @property
            def non_seasonal_order(self) -> global___Model.ArimaOrder:
                """Non-seasonal order."""
                pass
            @property
            def arima_fitting_metrics(self) -> global___Model.ArimaFittingMetrics:
                """Arima fitting metrics."""
                pass
            has_drift: builtins.bool = ...
            """Is arima model fitted with drift or not. It is always false when d
            is not 1.
            """

            time_series_id: typing.Text = ...
            """The time_series_id value for this time series. It will be one of
            the unique values from the time_series_id_column specified during
            ARIMA model training. Only present when time_series_id_column
            training option was used.
            """

            @property
            def time_series_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """The tuple of time_series_ids identifying this time series. It will
                be one of the unique tuples of values present in the
                time_series_id_columns specified during ARIMA model training. Only
                present when time_series_id_columns training option was used and
                the order of values here are same as the order of
                time_series_id_columns.
                """
                pass
            @property
            def seasonal_periods(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___Model.SeasonalPeriod.SeasonalPeriodType.ValueType]:
                """Seasonal periods. Repeated because multiple periods are supported
                for one time series.
                """
                pass
            @property
            def has_holiday_effect(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If true, holiday_effect is a part of time series decomposition result."""
                pass
            @property
            def has_spikes_and_dips(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If true, spikes_and_dips is a part of time series decomposition result."""
                pass
            @property
            def has_step_changes(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If true, step_changes is a part of time series decomposition result."""
                pass
            def __init__(self,
                *,
                non_seasonal_order : typing.Optional[global___Model.ArimaOrder] = ...,
                arima_fitting_metrics : typing.Optional[global___Model.ArimaFittingMetrics] = ...,
                has_drift : builtins.bool = ...,
                time_series_id : typing.Text = ...,
                time_series_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
                seasonal_periods : typing.Optional[typing.Iterable[global___Model.SeasonalPeriod.SeasonalPeriodType.ValueType]] = ...,
                has_holiday_effect : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                has_spikes_and_dips : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                has_step_changes : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["arima_fitting_metrics",b"arima_fitting_metrics","has_holiday_effect",b"has_holiday_effect","has_spikes_and_dips",b"has_spikes_and_dips","has_step_changes",b"has_step_changes","non_seasonal_order",b"non_seasonal_order"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["arima_fitting_metrics",b"arima_fitting_metrics","has_drift",b"has_drift","has_holiday_effect",b"has_holiday_effect","has_spikes_and_dips",b"has_spikes_and_dips","has_step_changes",b"has_step_changes","non_seasonal_order",b"non_seasonal_order","seasonal_periods",b"seasonal_periods","time_series_id",b"time_series_id","time_series_ids",b"time_series_ids"]) -> None: ...

        NON_SEASONAL_ORDER_FIELD_NUMBER: builtins.int
        ARIMA_FITTING_METRICS_FIELD_NUMBER: builtins.int
        SEASONAL_PERIODS_FIELD_NUMBER: builtins.int
        HAS_DRIFT_FIELD_NUMBER: builtins.int
        TIME_SERIES_ID_FIELD_NUMBER: builtins.int
        ARIMA_SINGLE_MODEL_FORECASTING_METRICS_FIELD_NUMBER: builtins.int
        @property
        def non_seasonal_order(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.ArimaOrder]:
            """Non-seasonal order."""
            pass
        @property
        def arima_fitting_metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.ArimaFittingMetrics]:
            """Arima model fitting metrics."""
            pass
        @property
        def seasonal_periods(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___Model.SeasonalPeriod.SeasonalPeriodType.ValueType]:
            """Seasonal periods. Repeated because multiple periods are supported for one
            time series.
            """
            pass
        @property
        def has_drift(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bool]:
            """Whether Arima model fitted with drift or not. It is always false when d
            is not 1.
            """
            pass
        @property
        def time_series_id(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """Id to differentiate different time series for the large-scale case."""
            pass
        @property
        def arima_single_model_forecasting_metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.ArimaForecastingMetrics.ArimaSingleModelForecastingMetrics]:
            """Repeated as there can be many metric sets (one for each model) in
            auto-arima and the large-scale case.
            """
            pass
        def __init__(self,
            *,
            non_seasonal_order : typing.Optional[typing.Iterable[global___Model.ArimaOrder]] = ...,
            arima_fitting_metrics : typing.Optional[typing.Iterable[global___Model.ArimaFittingMetrics]] = ...,
            seasonal_periods : typing.Optional[typing.Iterable[global___Model.SeasonalPeriod.SeasonalPeriodType.ValueType]] = ...,
            has_drift : typing.Optional[typing.Iterable[builtins.bool]] = ...,
            time_series_id : typing.Optional[typing.Iterable[typing.Text]] = ...,
            arima_single_model_forecasting_metrics : typing.Optional[typing.Iterable[global___Model.ArimaForecastingMetrics.ArimaSingleModelForecastingMetrics]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["arima_fitting_metrics",b"arima_fitting_metrics","arima_single_model_forecasting_metrics",b"arima_single_model_forecasting_metrics","has_drift",b"has_drift","non_seasonal_order",b"non_seasonal_order","seasonal_periods",b"seasonal_periods","time_series_id",b"time_series_id"]) -> None: ...

    class EvaluationMetrics(google.protobuf.message.Message):
        """Evaluation metrics of a model. These are either computed on all training
        data or just the eval data based on whether eval data was used during
        training. These are not present for imported models.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        REGRESSION_METRICS_FIELD_NUMBER: builtins.int
        BINARY_CLASSIFICATION_METRICS_FIELD_NUMBER: builtins.int
        MULTI_CLASS_CLASSIFICATION_METRICS_FIELD_NUMBER: builtins.int
        CLUSTERING_METRICS_FIELD_NUMBER: builtins.int
        RANKING_METRICS_FIELD_NUMBER: builtins.int
        ARIMA_FORECASTING_METRICS_FIELD_NUMBER: builtins.int
        @property
        def regression_metrics(self) -> global___Model.RegressionMetrics:
            """Populated for regression models and explicit feedback type matrix
            factorization models.
            """
            pass
        @property
        def binary_classification_metrics(self) -> global___Model.BinaryClassificationMetrics:
            """Populated for binary classification/classifier models."""
            pass
        @property
        def multi_class_classification_metrics(self) -> global___Model.MultiClassClassificationMetrics:
            """Populated for multi-class classification/classifier models."""
            pass
        @property
        def clustering_metrics(self) -> global___Model.ClusteringMetrics:
            """Populated for clustering models."""
            pass
        @property
        def ranking_metrics(self) -> global___Model.RankingMetrics:
            """Populated for implicit feedback type matrix factorization models."""
            pass
        @property
        def arima_forecasting_metrics(self) -> global___Model.ArimaForecastingMetrics:
            """Populated for ARIMA models."""
            pass
        def __init__(self,
            *,
            regression_metrics : typing.Optional[global___Model.RegressionMetrics] = ...,
            binary_classification_metrics : typing.Optional[global___Model.BinaryClassificationMetrics] = ...,
            multi_class_classification_metrics : typing.Optional[global___Model.MultiClassClassificationMetrics] = ...,
            clustering_metrics : typing.Optional[global___Model.ClusteringMetrics] = ...,
            ranking_metrics : typing.Optional[global___Model.RankingMetrics] = ...,
            arima_forecasting_metrics : typing.Optional[global___Model.ArimaForecastingMetrics] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["arima_forecasting_metrics",b"arima_forecasting_metrics","binary_classification_metrics",b"binary_classification_metrics","clustering_metrics",b"clustering_metrics","metrics",b"metrics","multi_class_classification_metrics",b"multi_class_classification_metrics","ranking_metrics",b"ranking_metrics","regression_metrics",b"regression_metrics"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["arima_forecasting_metrics",b"arima_forecasting_metrics","binary_classification_metrics",b"binary_classification_metrics","clustering_metrics",b"clustering_metrics","metrics",b"metrics","multi_class_classification_metrics",b"multi_class_classification_metrics","ranking_metrics",b"ranking_metrics","regression_metrics",b"regression_metrics"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["metrics",b"metrics"]) -> typing.Optional[typing_extensions.Literal["regression_metrics","binary_classification_metrics","multi_class_classification_metrics","clustering_metrics","ranking_metrics","arima_forecasting_metrics"]]: ...

    class DataSplitResult(google.protobuf.message.Message):
        """Data split result. This contains references to the training and evaluation
        data tables that were used to train the model.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TRAINING_TABLE_FIELD_NUMBER: builtins.int
        EVALUATION_TABLE_FIELD_NUMBER: builtins.int
        @property
        def training_table(self) -> google.cloud.bigquery.v2.table_reference_pb2.TableReference:
            """Table reference of the training data after split."""
            pass
        @property
        def evaluation_table(self) -> google.cloud.bigquery.v2.table_reference_pb2.TableReference:
            """Table reference of the evaluation data after split."""
            pass
        def __init__(self,
            *,
            training_table : typing.Optional[google.cloud.bigquery.v2.table_reference_pb2.TableReference] = ...,
            evaluation_table : typing.Optional[google.cloud.bigquery.v2.table_reference_pb2.TableReference] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["evaluation_table",b"evaluation_table","training_table",b"training_table"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["evaluation_table",b"evaluation_table","training_table",b"training_table"]) -> None: ...

    class ArimaOrder(google.protobuf.message.Message):
        """Arima order, can be used for both non-seasonal and seasonal parts."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        P_FIELD_NUMBER: builtins.int
        D_FIELD_NUMBER: builtins.int
        Q_FIELD_NUMBER: builtins.int
        p: builtins.int = ...
        """Order of the autoregressive part."""

        d: builtins.int = ...
        """Order of the differencing part."""

        q: builtins.int = ...
        """Order of the moving-average part."""

        def __init__(self,
            *,
            p : builtins.int = ...,
            d : builtins.int = ...,
            q : builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["d",b"d","p",b"p","q",b"q"]) -> None: ...

    class ArimaFittingMetrics(google.protobuf.message.Message):
        """ARIMA model fitting metrics."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        LOG_LIKELIHOOD_FIELD_NUMBER: builtins.int
        AIC_FIELD_NUMBER: builtins.int
        VARIANCE_FIELD_NUMBER: builtins.int
        log_likelihood: builtins.float = ...
        """Log-likelihood."""

        aic: builtins.float = ...
        """AIC."""

        variance: builtins.float = ...
        """Variance."""

        def __init__(self,
            *,
            log_likelihood : builtins.float = ...,
            aic : builtins.float = ...,
            variance : builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["aic",b"aic","log_likelihood",b"log_likelihood","variance",b"variance"]) -> None: ...

    class GlobalExplanation(google.protobuf.message.Message):
        """Global explanations containing the top most important features
        after training.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Explanation(google.protobuf.message.Message):
            """Explanation for a single feature."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            FEATURE_NAME_FIELD_NUMBER: builtins.int
            ATTRIBUTION_FIELD_NUMBER: builtins.int
            feature_name: typing.Text = ...
            """Full name of the feature. For non-numerical features, will be
            formatted like <column_name>.<encoded_feature_name>. Overall size of
            feature name will always be truncated to first 120 characters.
            """

            @property
            def attribution(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """Attribution of feature."""
                pass
            def __init__(self,
                *,
                feature_name : typing.Text = ...,
                attribution : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["attribution",b"attribution"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["attribution",b"attribution","feature_name",b"feature_name"]) -> None: ...

        EXPLANATIONS_FIELD_NUMBER: builtins.int
        CLASS_LABEL_FIELD_NUMBER: builtins.int
        @property
        def explanations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.GlobalExplanation.Explanation]:
            """A list of the top global explanations. Sorted by absolute value of
            attribution in descending order.
            """
            pass
        class_label: typing.Text = ...
        """Class label for this set of global explanations. Will be empty/null for
        binary logistic and linear regression models. Sorted alphabetically in
        descending order.
        """

        def __init__(self,
            *,
            explanations : typing.Optional[typing.Iterable[global___Model.GlobalExplanation.Explanation]] = ...,
            class_label : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["class_label",b"class_label","explanations",b"explanations"]) -> None: ...

    class TrainingRun(google.protobuf.message.Message):
        """Information about a single training query run for the model."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class TrainingOptions(google.protobuf.message.Message):
            """Options used in model training."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class LabelClassWeightsEntry(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                KEY_FIELD_NUMBER: builtins.int
                VALUE_FIELD_NUMBER: builtins.int
                key: typing.Text = ...
                value: builtins.float = ...
                def __init__(self,
                    *,
                    key : typing.Text = ...,
                    value : builtins.float = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

            MAX_ITERATIONS_FIELD_NUMBER: builtins.int
            LOSS_TYPE_FIELD_NUMBER: builtins.int
            LEARN_RATE_FIELD_NUMBER: builtins.int
            L1_REGULARIZATION_FIELD_NUMBER: builtins.int
            L2_REGULARIZATION_FIELD_NUMBER: builtins.int
            MIN_RELATIVE_PROGRESS_FIELD_NUMBER: builtins.int
            WARM_START_FIELD_NUMBER: builtins.int
            EARLY_STOP_FIELD_NUMBER: builtins.int
            INPUT_LABEL_COLUMNS_FIELD_NUMBER: builtins.int
            DATA_SPLIT_METHOD_FIELD_NUMBER: builtins.int
            DATA_SPLIT_EVAL_FRACTION_FIELD_NUMBER: builtins.int
            DATA_SPLIT_COLUMN_FIELD_NUMBER: builtins.int
            LEARN_RATE_STRATEGY_FIELD_NUMBER: builtins.int
            INITIAL_LEARN_RATE_FIELD_NUMBER: builtins.int
            LABEL_CLASS_WEIGHTS_FIELD_NUMBER: builtins.int
            USER_COLUMN_FIELD_NUMBER: builtins.int
            ITEM_COLUMN_FIELD_NUMBER: builtins.int
            DISTANCE_TYPE_FIELD_NUMBER: builtins.int
            NUM_CLUSTERS_FIELD_NUMBER: builtins.int
            MODEL_URI_FIELD_NUMBER: builtins.int
            OPTIMIZATION_STRATEGY_FIELD_NUMBER: builtins.int
            HIDDEN_UNITS_FIELD_NUMBER: builtins.int
            BATCH_SIZE_FIELD_NUMBER: builtins.int
            DROPOUT_FIELD_NUMBER: builtins.int
            MAX_TREE_DEPTH_FIELD_NUMBER: builtins.int
            SUBSAMPLE_FIELD_NUMBER: builtins.int
            MIN_SPLIT_LOSS_FIELD_NUMBER: builtins.int
            NUM_FACTORS_FIELD_NUMBER: builtins.int
            FEEDBACK_TYPE_FIELD_NUMBER: builtins.int
            WALS_ALPHA_FIELD_NUMBER: builtins.int
            KMEANS_INITIALIZATION_METHOD_FIELD_NUMBER: builtins.int
            KMEANS_INITIALIZATION_COLUMN_FIELD_NUMBER: builtins.int
            TIME_SERIES_TIMESTAMP_COLUMN_FIELD_NUMBER: builtins.int
            TIME_SERIES_DATA_COLUMN_FIELD_NUMBER: builtins.int
            AUTO_ARIMA_FIELD_NUMBER: builtins.int
            NON_SEASONAL_ORDER_FIELD_NUMBER: builtins.int
            DATA_FREQUENCY_FIELD_NUMBER: builtins.int
            INCLUDE_DRIFT_FIELD_NUMBER: builtins.int
            HOLIDAY_REGION_FIELD_NUMBER: builtins.int
            TIME_SERIES_ID_COLUMN_FIELD_NUMBER: builtins.int
            TIME_SERIES_ID_COLUMNS_FIELD_NUMBER: builtins.int
            HORIZON_FIELD_NUMBER: builtins.int
            PRESERVE_INPUT_STRUCTS_FIELD_NUMBER: builtins.int
            AUTO_ARIMA_MAX_ORDER_FIELD_NUMBER: builtins.int
            DECOMPOSE_TIME_SERIES_FIELD_NUMBER: builtins.int
            CLEAN_SPIKES_AND_DIPS_FIELD_NUMBER: builtins.int
            ADJUST_STEP_CHANGES_FIELD_NUMBER: builtins.int
            max_iterations: builtins.int = ...
            """The maximum number of iterations in training. Used only for iterative
            training algorithms.
            """

            loss_type: global___Model.LossType.ValueType = ...
            """Type of loss function used during training run."""

            learn_rate: builtins.float = ...
            """Learning rate in training. Used only for iterative training algorithms."""

            @property
            def l1_regularization(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """L1 regularization coefficient."""
                pass
            @property
            def l2_regularization(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """L2 regularization coefficient."""
                pass
            @property
            def min_relative_progress(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """When early_stop is true, stops training when accuracy improvement is
                less than 'min_relative_progress'. Used only for iterative training
                algorithms.
                """
                pass
            @property
            def warm_start(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """Whether to train a model from the last checkpoint."""
                pass
            @property
            def early_stop(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """Whether to stop early when the loss doesn't improve significantly
                any more (compared to min_relative_progress). Used only for iterative
                training algorithms.
                """
                pass
            @property
            def input_label_columns(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """Name of input label columns in training data."""
                pass
            data_split_method: global___Model.DataSplitMethod.ValueType = ...
            """The data split type for training and evaluation, e.g. RANDOM."""

            data_split_eval_fraction: builtins.float = ...
            """The fraction of evaluation data over the whole input data. The rest
            of data will be used as training data. The format should be double.
            Accurate to two decimal places.
            Default value is 0.2.
            """

            data_split_column: typing.Text = ...
            """The column to split data with. This column won't be used as a
            feature.
            1. When data_split_method is CUSTOM, the corresponding column should
            be boolean. The rows with true value tag are eval data, and the false
            are training data.
            2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION
            rows (from smallest to largest) in the corresponding column are used
            as training data, and the rest are eval data. It respects the order
            in Orderable data types:
            https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties
            """

            learn_rate_strategy: global___Model.LearnRateStrategy.ValueType = ...
            """The strategy to determine learn rate for the current iteration."""

            initial_learn_rate: builtins.float = ...
            """Specifies the initial learning rate for the line search learn rate
            strategy.
            """

            @property
            def label_class_weights(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, builtins.float]:
                """Weights associated with each label class, for rebalancing the
                training data. Only applicable for classification models.
                """
                pass
            user_column: typing.Text = ...
            """User column specified for matrix factorization models."""

            item_column: typing.Text = ...
            """Item column specified for matrix factorization models."""

            distance_type: global___Model.DistanceType.ValueType = ...
            """Distance type for clustering models."""

            num_clusters: builtins.int = ...
            """Number of clusters for clustering models."""

            model_uri: typing.Text = ...
            """Google Cloud Storage URI from which the model was imported. Only
            applicable for imported models.
            """

            optimization_strategy: global___Model.OptimizationStrategy.ValueType = ...
            """Optimization strategy for training linear regression models."""

            @property
            def hidden_units(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """Hidden units for dnn models."""
                pass
            batch_size: builtins.int = ...
            """Batch size for dnn models."""

            @property
            def dropout(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """Dropout probability for dnn models."""
                pass
            max_tree_depth: builtins.int = ...
            """Maximum depth of a tree for boosted tree models."""

            subsample: builtins.float = ...
            """Subsample fraction of the training data to grow tree to prevent
            overfitting for boosted tree models.
            """

            @property
            def min_split_loss(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """Minimum split loss for boosted tree models."""
                pass
            num_factors: builtins.int = ...
            """Num factors specified for matrix factorization models."""

            feedback_type: global___Model.FeedbackType.ValueType = ...
            """Feedback type that specifies which algorithm to run for matrix
            factorization.
            """

            @property
            def wals_alpha(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """Hyperparameter for matrix factoration when implicit feedback type is
                specified.
                """
                pass
            kmeans_initialization_method: global___Model.KmeansEnums.KmeansInitializationMethod.ValueType = ...
            """The method used to initialize the centroids for kmeans algorithm."""

            kmeans_initialization_column: typing.Text = ...
            """The column used to provide the initial centroids for kmeans algorithm
            when kmeans_initialization_method is CUSTOM.
            """

            time_series_timestamp_column: typing.Text = ...
            """Column to be designated as time series timestamp for ARIMA model."""

            time_series_data_column: typing.Text = ...
            """Column to be designated as time series data for ARIMA model."""

            auto_arima: builtins.bool = ...
            """Whether to enable auto ARIMA or not."""

            @property
            def non_seasonal_order(self) -> global___Model.ArimaOrder:
                """A specification of the non-seasonal part of the ARIMA model: the three
                components (p, d, q) are the AR order, the degree of differencing, and
                the MA order.
                """
                pass
            data_frequency: global___Model.DataFrequency.ValueType = ...
            """The data frequency of a time series."""

            include_drift: builtins.bool = ...
            """Include drift when fitting an ARIMA model."""

            holiday_region: global___Model.HolidayRegion.ValueType = ...
            """The geographical region based on which the holidays are considered in
            time series modeling. If a valid value is specified, then holiday
            effects modeling is enabled.
            """

            time_series_id_column: typing.Text = ...
            """The time series id column that was used during ARIMA model training."""

            @property
            def time_series_id_columns(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """The time series id columns that were used during ARIMA model training."""
                pass
            horizon: builtins.int = ...
            """The number of periods ahead that need to be forecasted."""

            preserve_input_structs: builtins.bool = ...
            """Whether to preserve the input structs in output feature names.
            Suppose there is a struct A with field b.
            When false (default), the output feature name is A_b.
            When true, the output feature name is A.b.
            """

            auto_arima_max_order: builtins.int = ...
            """The max value of non-seasonal p and q."""

            @property
            def decompose_time_series(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If true, perform decompose time series and save the results."""
                pass
            @property
            def clean_spikes_and_dips(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If true, clean spikes and dips in the input time series."""
                pass
            @property
            def adjust_step_changes(self) -> google.protobuf.wrappers_pb2.BoolValue:
                """If true, detect step changes and make data adjustment in the input time
                series.
                """
                pass
            def __init__(self,
                *,
                max_iterations : builtins.int = ...,
                loss_type : global___Model.LossType.ValueType = ...,
                learn_rate : builtins.float = ...,
                l1_regularization : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                l2_regularization : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                min_relative_progress : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                warm_start : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                early_stop : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                input_label_columns : typing.Optional[typing.Iterable[typing.Text]] = ...,
                data_split_method : global___Model.DataSplitMethod.ValueType = ...,
                data_split_eval_fraction : builtins.float = ...,
                data_split_column : typing.Text = ...,
                learn_rate_strategy : global___Model.LearnRateStrategy.ValueType = ...,
                initial_learn_rate : builtins.float = ...,
                label_class_weights : typing.Optional[typing.Mapping[typing.Text, builtins.float]] = ...,
                user_column : typing.Text = ...,
                item_column : typing.Text = ...,
                distance_type : global___Model.DistanceType.ValueType = ...,
                num_clusters : builtins.int = ...,
                model_uri : typing.Text = ...,
                optimization_strategy : global___Model.OptimizationStrategy.ValueType = ...,
                hidden_units : typing.Optional[typing.Iterable[builtins.int]] = ...,
                batch_size : builtins.int = ...,
                dropout : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                max_tree_depth : builtins.int = ...,
                subsample : builtins.float = ...,
                min_split_loss : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                num_factors : builtins.int = ...,
                feedback_type : global___Model.FeedbackType.ValueType = ...,
                wals_alpha : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                kmeans_initialization_method : global___Model.KmeansEnums.KmeansInitializationMethod.ValueType = ...,
                kmeans_initialization_column : typing.Text = ...,
                time_series_timestamp_column : typing.Text = ...,
                time_series_data_column : typing.Text = ...,
                auto_arima : builtins.bool = ...,
                non_seasonal_order : typing.Optional[global___Model.ArimaOrder] = ...,
                data_frequency : global___Model.DataFrequency.ValueType = ...,
                include_drift : builtins.bool = ...,
                holiday_region : global___Model.HolidayRegion.ValueType = ...,
                time_series_id_column : typing.Text = ...,
                time_series_id_columns : typing.Optional[typing.Iterable[typing.Text]] = ...,
                horizon : builtins.int = ...,
                preserve_input_structs : builtins.bool = ...,
                auto_arima_max_order : builtins.int = ...,
                decompose_time_series : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                clean_spikes_and_dips : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                adjust_step_changes : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["adjust_step_changes",b"adjust_step_changes","clean_spikes_and_dips",b"clean_spikes_and_dips","decompose_time_series",b"decompose_time_series","dropout",b"dropout","early_stop",b"early_stop","l1_regularization",b"l1_regularization","l2_regularization",b"l2_regularization","min_relative_progress",b"min_relative_progress","min_split_loss",b"min_split_loss","non_seasonal_order",b"non_seasonal_order","wals_alpha",b"wals_alpha","warm_start",b"warm_start"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["adjust_step_changes",b"adjust_step_changes","auto_arima",b"auto_arima","auto_arima_max_order",b"auto_arima_max_order","batch_size",b"batch_size","clean_spikes_and_dips",b"clean_spikes_and_dips","data_frequency",b"data_frequency","data_split_column",b"data_split_column","data_split_eval_fraction",b"data_split_eval_fraction","data_split_method",b"data_split_method","decompose_time_series",b"decompose_time_series","distance_type",b"distance_type","dropout",b"dropout","early_stop",b"early_stop","feedback_type",b"feedback_type","hidden_units",b"hidden_units","holiday_region",b"holiday_region","horizon",b"horizon","include_drift",b"include_drift","initial_learn_rate",b"initial_learn_rate","input_label_columns",b"input_label_columns","item_column",b"item_column","kmeans_initialization_column",b"kmeans_initialization_column","kmeans_initialization_method",b"kmeans_initialization_method","l1_regularization",b"l1_regularization","l2_regularization",b"l2_regularization","label_class_weights",b"label_class_weights","learn_rate",b"learn_rate","learn_rate_strategy",b"learn_rate_strategy","loss_type",b"loss_type","max_iterations",b"max_iterations","max_tree_depth",b"max_tree_depth","min_relative_progress",b"min_relative_progress","min_split_loss",b"min_split_loss","model_uri",b"model_uri","non_seasonal_order",b"non_seasonal_order","num_clusters",b"num_clusters","num_factors",b"num_factors","optimization_strategy",b"optimization_strategy","preserve_input_structs",b"preserve_input_structs","subsample",b"subsample","time_series_data_column",b"time_series_data_column","time_series_id_column",b"time_series_id_column","time_series_id_columns",b"time_series_id_columns","time_series_timestamp_column",b"time_series_timestamp_column","user_column",b"user_column","wals_alpha",b"wals_alpha","warm_start",b"warm_start"]) -> None: ...

        class IterationResult(google.protobuf.message.Message):
            """Information about a single iteration of the training run."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class ClusterInfo(google.protobuf.message.Message):
                """Information about a single cluster for clustering model."""
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                CENTROID_ID_FIELD_NUMBER: builtins.int
                CLUSTER_RADIUS_FIELD_NUMBER: builtins.int
                CLUSTER_SIZE_FIELD_NUMBER: builtins.int
                centroid_id: builtins.int = ...
                """Centroid id."""

                @property
                def cluster_radius(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                    """Cluster radius, the average distance from centroid
                    to each point assigned to the cluster.
                    """
                    pass
                @property
                def cluster_size(self) -> google.protobuf.wrappers_pb2.Int64Value:
                    """Cluster size, the total number of points assigned to the cluster."""
                    pass
                def __init__(self,
                    *,
                    centroid_id : builtins.int = ...,
                    cluster_radius : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                    cluster_size : typing.Optional[google.protobuf.wrappers_pb2.Int64Value] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["cluster_radius",b"cluster_radius","cluster_size",b"cluster_size"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["centroid_id",b"centroid_id","cluster_radius",b"cluster_radius","cluster_size",b"cluster_size"]) -> None: ...

            class ArimaResult(google.protobuf.message.Message):
                """(Auto-)arima fitting result. Wrap everything in ArimaResult for easier
                refactoring if we want to use model-specific iteration results.
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                class ArimaCoefficients(google.protobuf.message.Message):
                    """Arima coefficients."""
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    AUTO_REGRESSIVE_COEFFICIENTS_FIELD_NUMBER: builtins.int
                    MOVING_AVERAGE_COEFFICIENTS_FIELD_NUMBER: builtins.int
                    INTERCEPT_COEFFICIENT_FIELD_NUMBER: builtins.int
                    @property
                    def auto_regressive_coefficients(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                        """Auto-regressive coefficients, an array of double."""
                        pass
                    @property
                    def moving_average_coefficients(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                        """Moving-average coefficients, an array of double."""
                        pass
                    intercept_coefficient: builtins.float = ...
                    """Intercept coefficient, just a double not an array."""

                    def __init__(self,
                        *,
                        auto_regressive_coefficients : typing.Optional[typing.Iterable[builtins.float]] = ...,
                        moving_average_coefficients : typing.Optional[typing.Iterable[builtins.float]] = ...,
                        intercept_coefficient : builtins.float = ...,
                        ) -> None: ...
                    def ClearField(self, field_name: typing_extensions.Literal["auto_regressive_coefficients",b"auto_regressive_coefficients","intercept_coefficient",b"intercept_coefficient","moving_average_coefficients",b"moving_average_coefficients"]) -> None: ...

                class ArimaModelInfo(google.protobuf.message.Message):
                    """Arima model information."""
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    NON_SEASONAL_ORDER_FIELD_NUMBER: builtins.int
                    ARIMA_COEFFICIENTS_FIELD_NUMBER: builtins.int
                    ARIMA_FITTING_METRICS_FIELD_NUMBER: builtins.int
                    HAS_DRIFT_FIELD_NUMBER: builtins.int
                    TIME_SERIES_ID_FIELD_NUMBER: builtins.int
                    TIME_SERIES_IDS_FIELD_NUMBER: builtins.int
                    SEASONAL_PERIODS_FIELD_NUMBER: builtins.int
                    HAS_HOLIDAY_EFFECT_FIELD_NUMBER: builtins.int
                    HAS_SPIKES_AND_DIPS_FIELD_NUMBER: builtins.int
                    HAS_STEP_CHANGES_FIELD_NUMBER: builtins.int
                    @property
                    def non_seasonal_order(self) -> global___Model.ArimaOrder:
                        """Non-seasonal order."""
                        pass
                    @property
                    def arima_coefficients(self) -> global___Model.TrainingRun.IterationResult.ArimaResult.ArimaCoefficients:
                        """Arima coefficients."""
                        pass
                    @property
                    def arima_fitting_metrics(self) -> global___Model.ArimaFittingMetrics:
                        """Arima fitting metrics."""
                        pass
                    has_drift: builtins.bool = ...
                    """Whether Arima model fitted with drift or not. It is always false
                    when d is not 1.
                    """

                    time_series_id: typing.Text = ...
                    """The time_series_id value for this time series. It will be one of
                    the unique values from the time_series_id_column specified during
                    ARIMA model training. Only present when time_series_id_column
                    training option was used.
                    """

                    @property
                    def time_series_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                        """The tuple of time_series_ids identifying this time series. It will
                        be one of the unique tuples of values present in the
                        time_series_id_columns specified during ARIMA model training. Only
                        present when time_series_id_columns training option was used and
                        the order of values here are same as the order of
                        time_series_id_columns.
                        """
                        pass
                    @property
                    def seasonal_periods(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___Model.SeasonalPeriod.SeasonalPeriodType.ValueType]:
                        """Seasonal periods. Repeated because multiple periods are supported
                        for one time series.
                        """
                        pass
                    @property
                    def has_holiday_effect(self) -> google.protobuf.wrappers_pb2.BoolValue:
                        """If true, holiday_effect is a part of time series decomposition
                        result.
                        """
                        pass
                    @property
                    def has_spikes_and_dips(self) -> google.protobuf.wrappers_pb2.BoolValue:
                        """If true, spikes_and_dips is a part of time series decomposition
                        result.
                        """
                        pass
                    @property
                    def has_step_changes(self) -> google.protobuf.wrappers_pb2.BoolValue:
                        """If true, step_changes is a part of time series decomposition
                        result.
                        """
                        pass
                    def __init__(self,
                        *,
                        non_seasonal_order : typing.Optional[global___Model.ArimaOrder] = ...,
                        arima_coefficients : typing.Optional[global___Model.TrainingRun.IterationResult.ArimaResult.ArimaCoefficients] = ...,
                        arima_fitting_metrics : typing.Optional[global___Model.ArimaFittingMetrics] = ...,
                        has_drift : builtins.bool = ...,
                        time_series_id : typing.Text = ...,
                        time_series_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
                        seasonal_periods : typing.Optional[typing.Iterable[global___Model.SeasonalPeriod.SeasonalPeriodType.ValueType]] = ...,
                        has_holiday_effect : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                        has_spikes_and_dips : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                        has_step_changes : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
                        ) -> None: ...
                    def HasField(self, field_name: typing_extensions.Literal["arima_coefficients",b"arima_coefficients","arima_fitting_metrics",b"arima_fitting_metrics","has_holiday_effect",b"has_holiday_effect","has_spikes_and_dips",b"has_spikes_and_dips","has_step_changes",b"has_step_changes","non_seasonal_order",b"non_seasonal_order"]) -> builtins.bool: ...
                    def ClearField(self, field_name: typing_extensions.Literal["arima_coefficients",b"arima_coefficients","arima_fitting_metrics",b"arima_fitting_metrics","has_drift",b"has_drift","has_holiday_effect",b"has_holiday_effect","has_spikes_and_dips",b"has_spikes_and_dips","has_step_changes",b"has_step_changes","non_seasonal_order",b"non_seasonal_order","seasonal_periods",b"seasonal_periods","time_series_id",b"time_series_id","time_series_ids",b"time_series_ids"]) -> None: ...

                ARIMA_MODEL_INFO_FIELD_NUMBER: builtins.int
                SEASONAL_PERIODS_FIELD_NUMBER: builtins.int
                @property
                def arima_model_info(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.TrainingRun.IterationResult.ArimaResult.ArimaModelInfo]:
                    """This message is repeated because there are multiple arima models
                    fitted in auto-arima. For non-auto-arima model, its size is one.
                    """
                    pass
                @property
                def seasonal_periods(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___Model.SeasonalPeriod.SeasonalPeriodType.ValueType]:
                    """Seasonal periods. Repeated because multiple periods are supported for
                    one time series.
                    """
                    pass
                def __init__(self,
                    *,
                    arima_model_info : typing.Optional[typing.Iterable[global___Model.TrainingRun.IterationResult.ArimaResult.ArimaModelInfo]] = ...,
                    seasonal_periods : typing.Optional[typing.Iterable[global___Model.SeasonalPeriod.SeasonalPeriodType.ValueType]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["arima_model_info",b"arima_model_info","seasonal_periods",b"seasonal_periods"]) -> None: ...

            INDEX_FIELD_NUMBER: builtins.int
            DURATION_MS_FIELD_NUMBER: builtins.int
            TRAINING_LOSS_FIELD_NUMBER: builtins.int
            EVAL_LOSS_FIELD_NUMBER: builtins.int
            LEARN_RATE_FIELD_NUMBER: builtins.int
            CLUSTER_INFOS_FIELD_NUMBER: builtins.int
            ARIMA_RESULT_FIELD_NUMBER: builtins.int
            @property
            def index(self) -> google.protobuf.wrappers_pb2.Int32Value:
                """Index of the iteration, 0 based."""
                pass
            @property
            def duration_ms(self) -> google.protobuf.wrappers_pb2.Int64Value:
                """Time taken to run the iteration in milliseconds."""
                pass
            @property
            def training_loss(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """Loss computed on the training data at the end of iteration."""
                pass
            @property
            def eval_loss(self) -> google.protobuf.wrappers_pb2.DoubleValue:
                """Loss computed on the eval data at the end of iteration."""
                pass
            learn_rate: builtins.float = ...
            """Learn rate used for this iteration."""

            @property
            def cluster_infos(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.TrainingRun.IterationResult.ClusterInfo]:
                """Information about top clusters for clustering models."""
                pass
            @property
            def arima_result(self) -> global___Model.TrainingRun.IterationResult.ArimaResult: ...
            def __init__(self,
                *,
                index : typing.Optional[google.protobuf.wrappers_pb2.Int32Value] = ...,
                duration_ms : typing.Optional[google.protobuf.wrappers_pb2.Int64Value] = ...,
                training_loss : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                eval_loss : typing.Optional[google.protobuf.wrappers_pb2.DoubleValue] = ...,
                learn_rate : builtins.float = ...,
                cluster_infos : typing.Optional[typing.Iterable[global___Model.TrainingRun.IterationResult.ClusterInfo]] = ...,
                arima_result : typing.Optional[global___Model.TrainingRun.IterationResult.ArimaResult] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["arima_result",b"arima_result","duration_ms",b"duration_ms","eval_loss",b"eval_loss","index",b"index","training_loss",b"training_loss"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["arima_result",b"arima_result","cluster_infos",b"cluster_infos","duration_ms",b"duration_ms","eval_loss",b"eval_loss","index",b"index","learn_rate",b"learn_rate","training_loss",b"training_loss"]) -> None: ...

        TRAINING_OPTIONS_FIELD_NUMBER: builtins.int
        START_TIME_FIELD_NUMBER: builtins.int
        RESULTS_FIELD_NUMBER: builtins.int
        EVALUATION_METRICS_FIELD_NUMBER: builtins.int
        DATA_SPLIT_RESULT_FIELD_NUMBER: builtins.int
        GLOBAL_EXPLANATIONS_FIELD_NUMBER: builtins.int
        @property
        def training_options(self) -> global___Model.TrainingRun.TrainingOptions:
            """Options that were used for this training run, includes
            user specified and default options that were used.
            """
            pass
        @property
        def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The start time of this training run."""
            pass
        @property
        def results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.TrainingRun.IterationResult]:
            """Output of each iteration run, results.size() <= max_iterations."""
            pass
        @property
        def evaluation_metrics(self) -> global___Model.EvaluationMetrics:
            """The evaluation metrics over training/eval data that were computed at the
            end of training.
            """
            pass
        @property
        def data_split_result(self) -> global___Model.DataSplitResult:
            """Data split result of the training run. Only set when the input data is
            actually split.
            """
            pass
        @property
        def global_explanations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.GlobalExplanation]:
            """Global explanations for important features of the model. For multi-class
            models, there is one entry for each label class. For other models, there
            is only one entry in the list.
            """
            pass
        def __init__(self,
            *,
            training_options : typing.Optional[global___Model.TrainingRun.TrainingOptions] = ...,
            start_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
            results : typing.Optional[typing.Iterable[global___Model.TrainingRun.IterationResult]] = ...,
            evaluation_metrics : typing.Optional[global___Model.EvaluationMetrics] = ...,
            data_split_result : typing.Optional[global___Model.DataSplitResult] = ...,
            global_explanations : typing.Optional[typing.Iterable[global___Model.GlobalExplanation]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["data_split_result",b"data_split_result","evaluation_metrics",b"evaluation_metrics","start_time",b"start_time","training_options",b"training_options"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["data_split_result",b"data_split_result","evaluation_metrics",b"evaluation_metrics","global_explanations",b"global_explanations","results",b"results","start_time",b"start_time","training_options",b"training_options"]) -> None: ...

    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    ETAG_FIELD_NUMBER: builtins.int
    MODEL_REFERENCE_FIELD_NUMBER: builtins.int
    CREATION_TIME_FIELD_NUMBER: builtins.int
    LAST_MODIFIED_TIME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    FRIENDLY_NAME_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    EXPIRATION_TIME_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    ENCRYPTION_CONFIGURATION_FIELD_NUMBER: builtins.int
    MODEL_TYPE_FIELD_NUMBER: builtins.int
    TRAINING_RUNS_FIELD_NUMBER: builtins.int
    FEATURE_COLUMNS_FIELD_NUMBER: builtins.int
    LABEL_COLUMNS_FIELD_NUMBER: builtins.int
    BEST_TRIAL_ID_FIELD_NUMBER: builtins.int
    etag: typing.Text = ...
    """Output only. A hash of this resource."""

    @property
    def model_reference(self) -> google.cloud.bigquery.v2.model_reference_pb2.ModelReference:
        """Required. Unique identifier for this model."""
        pass
    creation_time: builtins.int = ...
    """Output only. The time when this model was created, in millisecs since the epoch."""

    last_modified_time: builtins.int = ...
    """Output only. The time when this model was last modified, in millisecs since the epoch."""

    description: typing.Text = ...
    """Optional. A user-friendly description of this model."""

    friendly_name: typing.Text = ...
    """Optional. A descriptive name for this model."""

    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """The labels associated with this model. You can use these to organize
        and group your models. Label keys and values can be no longer
        than 63 characters, can only contain lowercase letters, numeric
        characters, underscores and dashes. International characters are allowed.
        Label values are optional. Label keys must start with a letter and each
        label in the list must have a different key.
        """
        pass
    expiration_time: builtins.int = ...
    """Optional. The time when this model expires, in milliseconds since the epoch.
    If not present, the model will persist indefinitely. Expired models
    will be deleted and their storage reclaimed.  The defaultTableExpirationMs
    property of the encapsulating dataset can be used to set a default
    expirationTime on newly created models.
    """

    location: typing.Text = ...
    """Output only. The geographic location where the model resides. This value
    is inherited from the dataset.
    """

    @property
    def encryption_configuration(self) -> google.cloud.bigquery.v2.encryption_config_pb2.EncryptionConfiguration:
        """Custom encryption configuration (e.g., Cloud KMS keys). This shows the
        encryption configuration of the model data while stored in BigQuery
        storage. This field can be used with PatchModel to update encryption key
        for an already encrypted model.
        """
        pass
    model_type: global___Model.ModelType.ValueType = ...
    """Output only. Type of the model resource."""

    @property
    def training_runs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model.TrainingRun]:
        """Output only. Information for all training runs in increasing order of start_time."""
        pass
    @property
    def feature_columns(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.cloud.bigquery.v2.standard_sql_pb2.StandardSqlField]:
        """Output only. Input feature columns that were used to train this model."""
        pass
    @property
    def label_columns(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.cloud.bigquery.v2.standard_sql_pb2.StandardSqlField]:
        """Output only. Label columns that were used to train this model.
        The output of the model will have a "predicted_" prefix to these columns.
        """
        pass
    best_trial_id: builtins.int = ...
    """The best trial_id across all training runs."""

    def __init__(self,
        *,
        etag : typing.Text = ...,
        model_reference : typing.Optional[google.cloud.bigquery.v2.model_reference_pb2.ModelReference] = ...,
        creation_time : builtins.int = ...,
        last_modified_time : builtins.int = ...,
        description : typing.Text = ...,
        friendly_name : typing.Text = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        expiration_time : builtins.int = ...,
        location : typing.Text = ...,
        encryption_configuration : typing.Optional[google.cloud.bigquery.v2.encryption_config_pb2.EncryptionConfiguration] = ...,
        model_type : global___Model.ModelType.ValueType = ...,
        training_runs : typing.Optional[typing.Iterable[global___Model.TrainingRun]] = ...,
        feature_columns : typing.Optional[typing.Iterable[google.cloud.bigquery.v2.standard_sql_pb2.StandardSqlField]] = ...,
        label_columns : typing.Optional[typing.Iterable[google.cloud.bigquery.v2.standard_sql_pb2.StandardSqlField]] = ...,
        best_trial_id : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["encryption_configuration",b"encryption_configuration","model_reference",b"model_reference"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["best_trial_id",b"best_trial_id","creation_time",b"creation_time","description",b"description","encryption_configuration",b"encryption_configuration","etag",b"etag","expiration_time",b"expiration_time","feature_columns",b"feature_columns","friendly_name",b"friendly_name","label_columns",b"label_columns","labels",b"labels","last_modified_time",b"last_modified_time","location",b"location","model_reference",b"model_reference","model_type",b"model_type","training_runs",b"training_runs"]) -> None: ...
global___Model = Model

class GetModelRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_ID_FIELD_NUMBER: builtins.int
    DATASET_ID_FIELD_NUMBER: builtins.int
    MODEL_ID_FIELD_NUMBER: builtins.int
    project_id: typing.Text = ...
    """Required. Project ID of the requested model."""

    dataset_id: typing.Text = ...
    """Required. Dataset ID of the requested model."""

    model_id: typing.Text = ...
    """Required. Model ID of the requested model."""

    def __init__(self,
        *,
        project_id : typing.Text = ...,
        dataset_id : typing.Text = ...,
        model_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset_id",b"dataset_id","model_id",b"model_id","project_id",b"project_id"]) -> None: ...
global___GetModelRequest = GetModelRequest

class PatchModelRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_ID_FIELD_NUMBER: builtins.int
    DATASET_ID_FIELD_NUMBER: builtins.int
    MODEL_ID_FIELD_NUMBER: builtins.int
    MODEL_FIELD_NUMBER: builtins.int
    project_id: typing.Text = ...
    """Required. Project ID of the model to patch."""

    dataset_id: typing.Text = ...
    """Required. Dataset ID of the model to patch."""

    model_id: typing.Text = ...
    """Required. Model ID of the model to patch."""

    @property
    def model(self) -> global___Model:
        """Required. Patched model.
        Follows RFC5789 patch semantics. Missing fields are not updated.
        To clear a field, explicitly set to default value.
        """
        pass
    def __init__(self,
        *,
        project_id : typing.Text = ...,
        dataset_id : typing.Text = ...,
        model_id : typing.Text = ...,
        model : typing.Optional[global___Model] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["model",b"model"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset_id",b"dataset_id","model",b"model","model_id",b"model_id","project_id",b"project_id"]) -> None: ...
global___PatchModelRequest = PatchModelRequest

class DeleteModelRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_ID_FIELD_NUMBER: builtins.int
    DATASET_ID_FIELD_NUMBER: builtins.int
    MODEL_ID_FIELD_NUMBER: builtins.int
    project_id: typing.Text = ...
    """Required. Project ID of the model to delete."""

    dataset_id: typing.Text = ...
    """Required. Dataset ID of the model to delete."""

    model_id: typing.Text = ...
    """Required. Model ID of the model to delete."""

    def __init__(self,
        *,
        project_id : typing.Text = ...,
        dataset_id : typing.Text = ...,
        model_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset_id",b"dataset_id","model_id",b"model_id","project_id",b"project_id"]) -> None: ...
global___DeleteModelRequest = DeleteModelRequest

class ListModelsRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_ID_FIELD_NUMBER: builtins.int
    DATASET_ID_FIELD_NUMBER: builtins.int
    MAX_RESULTS_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    project_id: typing.Text = ...
    """Required. Project ID of the models to list."""

    dataset_id: typing.Text = ...
    """Required. Dataset ID of the models to list."""

    @property
    def max_results(self) -> google.protobuf.wrappers_pb2.UInt32Value:
        """The maximum number of results to return in a single response page.
        Leverage the page tokens to iterate through the entire collection.
        """
        pass
    page_token: typing.Text = ...
    """Page token, returned by a previous call to request the next page of
    results
    """

    def __init__(self,
        *,
        project_id : typing.Text = ...,
        dataset_id : typing.Text = ...,
        max_results : typing.Optional[google.protobuf.wrappers_pb2.UInt32Value] = ...,
        page_token : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["max_results",b"max_results"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dataset_id",b"dataset_id","max_results",b"max_results","page_token",b"page_token","project_id",b"project_id"]) -> None: ...
global___ListModelsRequest = ListModelsRequest

class ListModelsResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MODELS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def models(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Model]:
        """Models in the requested dataset. Only the following fields are populated:
        model_reference, model_type, creation_time, last_modified_time and
        labels.
        """
        pass
    next_page_token: typing.Text = ...
    """A token to request the next page of results."""

    def __init__(self,
        *,
        models : typing.Optional[typing.Iterable[global___Model]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["models",b"models","next_page_token",b"next_page_token"]) -> None: ...
global___ListModelsResponse = ListModelsResponse
