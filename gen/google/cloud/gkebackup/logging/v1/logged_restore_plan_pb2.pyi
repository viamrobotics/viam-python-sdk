"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.cloud.gkebackup.logging.v1.logged_common_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class LoggedRestorePlan(google.protobuf.message.Message):
    """RestorePlan as stored in Platform log. It's used to log the details of
    a createRestorePlan/updateRestorePlan request, so only fields that can be
    taken from user input are included here.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    DESCRIPTION_FIELD_NUMBER: builtins.int
    BACKUP_PLAN_FIELD_NUMBER: builtins.int
    CLUSTER_FIELD_NUMBER: builtins.int
    RESTORE_CONFIG_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    description: typing.Text = ...
    """User specified descriptive string for this RestorePlan."""

    backup_plan: typing.Text = ...
    """The BackupPlan from which Backups may be used as the source
    for Restores created via this RestorePlan.
    Format: projects/*/locations/*/backupPlans/*.
    """

    cluster: typing.Text = ...
    """The target cluster into which Restores created via this RestorePlan
    will restore data. NOTE: the cluster's region must be the same as the
    RestorePlan.
    Possible formats:
      1. projects/*/locations/*/clusters/*
      2. projects/*/zones/*/clusters/*
    """

    @property
    def restore_config(self) -> global___RestoreConfig:
        """Configuration of Restores created via this RestorePlan."""
        pass
    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """A set of custom labels supplied by user."""
        pass
    def __init__(self,
        *,
        description : typing.Text = ...,
        backup_plan : typing.Text = ...,
        cluster : typing.Text = ...,
        restore_config : typing.Optional[global___RestoreConfig] = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["restore_config",b"restore_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["backup_plan",b"backup_plan","cluster",b"cluster","description",b"description","labels",b"labels","restore_config",b"restore_config"]) -> None: ...
global___LoggedRestorePlan = LoggedRestorePlan

class RestoreConfig(google.protobuf.message.Message):
    """Configuration of a restore."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _VolumeDataRestorePolicy:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _VolumeDataRestorePolicyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_VolumeDataRestorePolicy.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED: RestoreConfig.VolumeDataRestorePolicy.ValueType = ...  # 0
        """unspecified, default value"""

        RESTORE_VOLUME_DATA_FROM_BACKUP: RestoreConfig.VolumeDataRestorePolicy.ValueType = ...  # 1
        """For each PVC to be restored, will create a new underlying volume (and PV)
        from the corresponding VolumeBackup contained within the Backup.
        """

        REUSE_VOLUME_HANDLE_FROM_BACKUP: RestoreConfig.VolumeDataRestorePolicy.ValueType = ...  # 2
        """For each PVC to be restored, attempt to reuse the original PV contained
        in the Backup (with its original underlying volume).  Note that option
        is likely only usable when restoring a workload to its original cluster.
        """

        NO_VOLUME_DATA_RESTORATION: RestoreConfig.VolumeDataRestorePolicy.ValueType = ...  # 3
        """For each PVC to be restored, PVCs will be created without any particular
        action to restore data.  In this case, the normal Kubernetes provisioning
        logic would kick in, and this would likely result in either dynamically
        provisioning blank PVs or binding to statically provisioned PVs.
        """

    class VolumeDataRestorePolicy(_VolumeDataRestorePolicy, metaclass=_VolumeDataRestorePolicyEnumTypeWrapper):
        """Defines how volume data should be restored"""
        pass

    VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED: RestoreConfig.VolumeDataRestorePolicy.ValueType = ...  # 0
    """unspecified, default value"""

    RESTORE_VOLUME_DATA_FROM_BACKUP: RestoreConfig.VolumeDataRestorePolicy.ValueType = ...  # 1
    """For each PVC to be restored, will create a new underlying volume (and PV)
    from the corresponding VolumeBackup contained within the Backup.
    """

    REUSE_VOLUME_HANDLE_FROM_BACKUP: RestoreConfig.VolumeDataRestorePolicy.ValueType = ...  # 2
    """For each PVC to be restored, attempt to reuse the original PV contained
    in the Backup (with its original underlying volume).  Note that option
    is likely only usable when restoring a workload to its original cluster.
    """

    NO_VOLUME_DATA_RESTORATION: RestoreConfig.VolumeDataRestorePolicy.ValueType = ...  # 3
    """For each PVC to be restored, PVCs will be created without any particular
    action to restore data.  In this case, the normal Kubernetes provisioning
    logic would kick in, and this would likely result in either dynamically
    provisioning blank PVs or binding to statically provisioned PVs.
    """


    class _ClusterResourceConflictPolicy:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ClusterResourceConflictPolicyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ClusterResourceConflictPolicy.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED: RestoreConfig.ClusterResourceConflictPolicy.ValueType = ...  # 0
        """Unspecified. Only allowed if no cluster-scoped resources will be
        restored.
        """

        USE_EXISTING_VERSION: RestoreConfig.ClusterResourceConflictPolicy.ValueType = ...  # 1
        """Do not attempt to restore the conflicting resource."""

        USE_BACKUP_VERSION: RestoreConfig.ClusterResourceConflictPolicy.ValueType = ...  # 2
        """Delete the existing version before re-creating it from the Backup.
        Note that this is a dangerous option which could cause unintentional
        data loss if used inappropriately - for example, deleting a CRD will
        cause Kubernetes to delete all CRs of that type.
        """

    class ClusterResourceConflictPolicy(_ClusterResourceConflictPolicy, metaclass=_ClusterResourceConflictPolicyEnumTypeWrapper):
        """Defines the behavior for handling the situation where cluster-scoped
        resources being restored already exist in the target cluster.
        """
        pass

    CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED: RestoreConfig.ClusterResourceConflictPolicy.ValueType = ...  # 0
    """Unspecified. Only allowed if no cluster-scoped resources will be
    restored.
    """

    USE_EXISTING_VERSION: RestoreConfig.ClusterResourceConflictPolicy.ValueType = ...  # 1
    """Do not attempt to restore the conflicting resource."""

    USE_BACKUP_VERSION: RestoreConfig.ClusterResourceConflictPolicy.ValueType = ...  # 2
    """Delete the existing version before re-creating it from the Backup.
    Note that this is a dangerous option which could cause unintentional
    data loss if used inappropriately - for example, deleting a CRD will
    cause Kubernetes to delete all CRs of that type.
    """


    class _NamespacedResourceRestoreMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _NamespacedResourceRestoreModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_NamespacedResourceRestoreMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED: RestoreConfig.NamespacedResourceRestoreMode.ValueType = ...  # 0
        """Unspecified. Only allowed if no namespaced resources will be restored."""

        DELETE_AND_RESTORE: RestoreConfig.NamespacedResourceRestoreMode.ValueType = ...  # 1
        """When conflicting top-level resources (either Namespaces or
        ProtectedApplications, depending upon the scope) are encountered, this
        will first trigger a delete of the conflicting resource AND ALL OF ITS
        REFERENCED RESOURCES (e.g., all resources in the Namespace or all
        resources referenced by the ProtectedApplication) before restoring the
        resources from the Backup. This mode should only be used when you are
        intending to revert some portion of a cluster to an earlier state.
        """

        FAIL_ON_CONFLICT: RestoreConfig.NamespacedResourceRestoreMode.ValueType = ...  # 2
        """If conflicting top-level resources (either Namespaces or
        ProtectedApplications, depending upon the scope) are encountered at the
        beginning of a restore process, the Restore will fail.  If a conflict
        occurs during the restore process itself (e.g., because an out of band
        process creates conflicting resources), a conflict will be reported.
        """

    class NamespacedResourceRestoreMode(_NamespacedResourceRestoreMode, metaclass=_NamespacedResourceRestoreModeEnumTypeWrapper):
        """Defines the behavior for handling the situation where sets of namespaced
        resources being restored already exist in the target cluster.
        """
        pass

    NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED: RestoreConfig.NamespacedResourceRestoreMode.ValueType = ...  # 0
    """Unspecified. Only allowed if no namespaced resources will be restored."""

    DELETE_AND_RESTORE: RestoreConfig.NamespacedResourceRestoreMode.ValueType = ...  # 1
    """When conflicting top-level resources (either Namespaces or
    ProtectedApplications, depending upon the scope) are encountered, this
    will first trigger a delete of the conflicting resource AND ALL OF ITS
    REFERENCED RESOURCES (e.g., all resources in the Namespace or all
    resources referenced by the ProtectedApplication) before restoring the
    resources from the Backup. This mode should only be used when you are
    intending to revert some portion of a cluster to an earlier state.
    """

    FAIL_ON_CONFLICT: RestoreConfig.NamespacedResourceRestoreMode.ValueType = ...  # 2
    """If conflicting top-level resources (either Namespaces or
    ProtectedApplications, depending upon the scope) are encountered at the
    beginning of a restore process, the Restore will fail.  If a conflict
    occurs during the restore process itself (e.g., because an out of band
    process creates conflicting resources), a conflict will be reported.
    """


    class GroupKind(google.protobuf.message.Message):
        """This is a direct map to the Kubernetes GroupKind type
        [GroupKind](https://godoc.org/k8s.io/apimachinery/pkg/runtime/schema#GroupKind)
        and is used for identifying specific "types" of resources to restore.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        RESOURCE_GROUP_FIELD_NUMBER: builtins.int
        RESOURCE_KIND_FIELD_NUMBER: builtins.int
        resource_group: typing.Text = ...
        """API group string of a Kubernetes resource, e.g.
        "apiextensions.k8s.io", "storage.k8s.io", etc.
        Note: use empty string for core API group
        """

        resource_kind: typing.Text = ...
        """Kind of a Kubernetes resource, e.g.
        "CustomResourceDefinition", "StorageClass", etc.
        """

        def __init__(self,
            *,
            resource_group : typing.Text = ...,
            resource_kind : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["resource_group",b"resource_group","resource_kind",b"resource_kind"]) -> None: ...

    class ClusterResourceRestoreScope(google.protobuf.message.Message):
        """Identifies the cluster-scoped resources to restore from the Backup."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SELECTED_GROUP_KINDS_FIELD_NUMBER: builtins.int
        @property
        def selected_group_kinds(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RestoreConfig.GroupKind]:
            """A list of "types" of cluster-scoped resources to be restored from the
            Backup.  An empty list means that NO cluster-scoped resources will be
            restored. Note that Namespaces and PersistentVolume restoration is
            handled separately and is not governed by this field.
            """
            pass
        def __init__(self,
            *,
            selected_group_kinds : typing.Optional[typing.Iterable[global___RestoreConfig.GroupKind]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["selected_group_kinds",b"selected_group_kinds"]) -> None: ...

    class SubstitutionRule(google.protobuf.message.Message):
        """A transformation rule to be applied against Kubernetes resources as they
        are selected for restoration from a Backup. A rule contains both filtering
        logic (which resources are subject to substitution) and substitution logic.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TARGET_NAMESPACES_FIELD_NUMBER: builtins.int
        TARGET_GROUP_KINDS_FIELD_NUMBER: builtins.int
        TARGET_JSON_PATH_FIELD_NUMBER: builtins.int
        ORIGINAL_VALUE_PATTERN_FIELD_NUMBER: builtins.int
        NEW_VALUE_FIELD_NUMBER: builtins.int
        @property
        def target_namespaces(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """(Filtering parameter) Any resource subject to substitution must be
            contained within one of the listed Kubernetes Namespace in the Backup.
            If this field is not provided, no namespace filtering will be performed
            (all resources in all Namespaces, including all cluster-scoped resources,
            will be candidates for substitution).
            To mix cluster-scoped and namespaced resources in the same rule, use an
            empty string ("") as one of the target namespaces.
            """
            pass
        @property
        def target_group_kinds(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RestoreConfig.GroupKind]:
            """(Filtering parameter) Any resource subject to substitution must belong to
            one of the listed "types".
            If this field is not provided, no type filtering will be performed (all
            resources of all types matching previous filtering parameters will be
            candidates for substitution).
            """
            pass
        target_json_path: typing.Text = ...
        """This is a [JSONPath]
        ([https://kubernetes.io/docs/reference/kubectl/jsonpath/)
        expression that matches specific fields of candidate
        resources and it operates as both a filtering parameter (resources that
        are not matched with this expression will not be candidates for
        substitution) as well as a field identifier (identifies exactly which
        fields out of the candidate resources will be modified).
        """

        original_value_pattern: typing.Text = ...
        """(Filtering parameter) This is a [regular expression]
        (https://en.wikipedia.org/wiki/Regular_expression)
        that is compared against the fields matched by the target_json_path
        expression (and must also have passed the previous filters).
        Substitution will not be performed against fields whose
        value does not match this expression. If this field is NOT specified,
        then ALL fields matched by the target_json_path expression will undergo
        substitution. Note that an empty (e.g., "", rather than unspecified)
        value for for this field will only match empty fields.
        """

        new_value: typing.Text = ...
        """This is the new value to set for any fields that pass the filtering and
        selection criteria. To remove a value from a Kubernetes resource, either
        leave this field unspecified, or set it to the empty string ("").
        """

        def __init__(self,
            *,
            target_namespaces : typing.Optional[typing.Iterable[typing.Text]] = ...,
            target_group_kinds : typing.Optional[typing.Iterable[global___RestoreConfig.GroupKind]] = ...,
            target_json_path : typing.Text = ...,
            original_value_pattern : typing.Text = ...,
            new_value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["new_value",b"new_value","original_value_pattern",b"original_value_pattern","target_group_kinds",b"target_group_kinds","target_json_path",b"target_json_path","target_namespaces",b"target_namespaces"]) -> None: ...

    VOLUME_DATA_RESTORE_POLICY_FIELD_NUMBER: builtins.int
    CLUSTER_RESOURCE_CONFLICT_POLICY_FIELD_NUMBER: builtins.int
    NAMESPACED_RESOURCE_RESTORE_MODE_FIELD_NUMBER: builtins.int
    CLUSTER_RESOURCE_RESTORE_SCOPE_FIELD_NUMBER: builtins.int
    ALL_NAMESPACES_FIELD_NUMBER: builtins.int
    SELECTED_NAMESPACES_FIELD_NUMBER: builtins.int
    SELECTED_APPLICATIONS_FIELD_NUMBER: builtins.int
    SUBSTITUTION_RULES_FIELD_NUMBER: builtins.int
    volume_data_restore_policy: global___RestoreConfig.VolumeDataRestorePolicy.ValueType = ...
    """Specifies the mechanism to be used to restore volume data.
    Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as
    NO_VOLUME_DATA_RESTORATION).
    """

    cluster_resource_conflict_policy: global___RestoreConfig.ClusterResourceConflictPolicy.ValueType = ...
    """Defines the behavior for handling the situation where cluster-scoped
    resources being restored already exist in the target cluster. This MUST be
    set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if
    cluster_resource_restore_scope is not empty.
    """

    namespaced_resource_restore_mode: global___RestoreConfig.NamespacedResourceRestoreMode.ValueType = ...
    """Defines the behavior for handling the situation where sets of namespaced
    resources being restored already exist in the target cluster. This MUST be
    set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED if
    any namespaced restoration is configured via
    namespaced_resource_restore_scope .
    """

    @property
    def cluster_resource_restore_scope(self) -> global___RestoreConfig.ClusterResourceRestoreScope:
        """Identifies the cluster-scoped resources to restore from the Backup.
        Not specifying it means NO cluster resource will be restored.
        """
        pass
    all_namespaces: builtins.bool = ...
    """Restore all namespaced resources in the Backup if set to "True".
    Specifying this field to "False" is an error.
    """

    @property
    def selected_namespaces(self) -> google.cloud.gkebackup.logging.v1.logged_common_pb2.Namespaces:
        """A list of selected Namespaces to restore from the Backup. The listed
        Namespaces and all resources contained in them will be restored.
        """
        pass
    @property
    def selected_applications(self) -> google.cloud.gkebackup.logging.v1.logged_common_pb2.NamespacedNames:
        """A list of selected ProtectedApplications to restore. The listed
        ProtectedApplications and all the resources to which they refer will be
        restored.
        """
        pass
    @property
    def substitution_rules(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RestoreConfig.SubstitutionRule]:
        """A list of transformation rules to be applied against Kubernetes resources
        as they are selected for restoration from a Backup. Rules are executed in
        order defined - this order matters, as changes made by a rule may impact
        the filtering logic of subsequent rules. An empty list means no
        substitution will occur.
        """
        pass
    def __init__(self,
        *,
        volume_data_restore_policy : global___RestoreConfig.VolumeDataRestorePolicy.ValueType = ...,
        cluster_resource_conflict_policy : global___RestoreConfig.ClusterResourceConflictPolicy.ValueType = ...,
        namespaced_resource_restore_mode : global___RestoreConfig.NamespacedResourceRestoreMode.ValueType = ...,
        cluster_resource_restore_scope : typing.Optional[global___RestoreConfig.ClusterResourceRestoreScope] = ...,
        all_namespaces : builtins.bool = ...,
        selected_namespaces : typing.Optional[google.cloud.gkebackup.logging.v1.logged_common_pb2.Namespaces] = ...,
        selected_applications : typing.Optional[google.cloud.gkebackup.logging.v1.logged_common_pb2.NamespacedNames] = ...,
        substitution_rules : typing.Optional[typing.Iterable[global___RestoreConfig.SubstitutionRule]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["all_namespaces",b"all_namespaces","cluster_resource_restore_scope",b"cluster_resource_restore_scope","namespaced_resource_restore_scope",b"namespaced_resource_restore_scope","selected_applications",b"selected_applications","selected_namespaces",b"selected_namespaces"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["all_namespaces",b"all_namespaces","cluster_resource_conflict_policy",b"cluster_resource_conflict_policy","cluster_resource_restore_scope",b"cluster_resource_restore_scope","namespaced_resource_restore_mode",b"namespaced_resource_restore_mode","namespaced_resource_restore_scope",b"namespaced_resource_restore_scope","selected_applications",b"selected_applications","selected_namespaces",b"selected_namespaces","substitution_rules",b"substitution_rules","volume_data_restore_policy",b"volume_data_restore_policy"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["namespaced_resource_restore_scope",b"namespaced_resource_restore_scope"]) -> typing.Optional[typing_extensions.Literal["all_namespaces","selected_namespaces","selected_applications"]]: ...
global___RestoreConfig = RestoreConfig
