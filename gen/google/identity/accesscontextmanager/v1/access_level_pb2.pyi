"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.identity.accesscontextmanager.type.device_resources_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.type.expr_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class AccessLevel(google.protobuf.message.Message):
    """An `AccessLevel` is a label that can be applied to requests to Google Cloud
    services, along with a list of requirements necessary for the label to be
    applied.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    TITLE_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    BASIC_FIELD_NUMBER: builtins.int
    CUSTOM_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name for the Access Level. The `short_name` component
    must begin with a letter and only include alphanumeric and '_'. Format:
    `accessPolicies/{access_policy}/accessLevels/{access_level}`. The maximum
    length of the `access_level` component is 50 characters.
    """

    title: typing.Text = ...
    """Human readable title. Must be unique within the Policy."""

    description: typing.Text = ...
    """Description of the `AccessLevel` and its use. Does not affect behavior."""

    @property
    def basic(self) -> global___BasicLevel:
        """A `BasicLevel` composed of `Conditions`."""
        pass
    @property
    def custom(self) -> global___CustomLevel:
        """A `CustomLevel` written in the Common Expression Language."""
        pass
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Time the `AccessLevel` was created in UTC."""
        pass
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. Time the `AccessLevel` was updated in UTC."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        title : typing.Text = ...,
        description : typing.Text = ...,
        basic : typing.Optional[global___BasicLevel] = ...,
        custom : typing.Optional[global___CustomLevel] = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        update_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["basic",b"basic","create_time",b"create_time","custom",b"custom","level",b"level","update_time",b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["basic",b"basic","create_time",b"create_time","custom",b"custom","description",b"description","level",b"level","name",b"name","title",b"title","update_time",b"update_time"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["level",b"level"]) -> typing.Optional[typing_extensions.Literal["basic","custom"]]: ...
global___AccessLevel = AccessLevel

class BasicLevel(google.protobuf.message.Message):
    """`BasicLevel` is an `AccessLevel` using a set of recommended features."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _ConditionCombiningFunction:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ConditionCombiningFunctionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ConditionCombiningFunction.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        AND: BasicLevel.ConditionCombiningFunction.ValueType = ...  # 0
        """All `Conditions` must be true for the `BasicLevel` to be true."""

        OR: BasicLevel.ConditionCombiningFunction.ValueType = ...  # 1
        """If at least one `Condition` is true, then the `BasicLevel` is true."""

    class ConditionCombiningFunction(_ConditionCombiningFunction, metaclass=_ConditionCombiningFunctionEnumTypeWrapper):
        """Options for how the `conditions` list should be combined to determine if
        this `AccessLevel` is applied. Default is AND.
        """
        pass

    AND: BasicLevel.ConditionCombiningFunction.ValueType = ...  # 0
    """All `Conditions` must be true for the `BasicLevel` to be true."""

    OR: BasicLevel.ConditionCombiningFunction.ValueType = ...  # 1
    """If at least one `Condition` is true, then the `BasicLevel` is true."""


    CONDITIONS_FIELD_NUMBER: builtins.int
    COMBINING_FUNCTION_FIELD_NUMBER: builtins.int
    @property
    def conditions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Condition]:
        """Required. A list of requirements for the `AccessLevel` to be granted."""
        pass
    combining_function: global___BasicLevel.ConditionCombiningFunction.ValueType = ...
    """How the `conditions` list should be combined to determine if a request is
    granted this `AccessLevel`. If AND is used, each `Condition` in
    `conditions` must be satisfied for the `AccessLevel` to be applied. If OR
    is used, at least one `Condition` in `conditions` must be satisfied for the
    `AccessLevel` to be applied. Default behavior is AND.
    """

    def __init__(self,
        *,
        conditions : typing.Optional[typing.Iterable[global___Condition]] = ...,
        combining_function : global___BasicLevel.ConditionCombiningFunction.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["combining_function",b"combining_function","conditions",b"conditions"]) -> None: ...
global___BasicLevel = BasicLevel

class Condition(google.protobuf.message.Message):
    """A condition necessary for an `AccessLevel` to be granted. The Condition is an
    AND over its fields. So a Condition is true if: 1) the request IP is from one
    of the listed subnetworks AND 2) the originating device complies with the
    listed device policy AND 3) all listed access levels are granted AND 4) the
    request was sent at a time allowed by the DateTimeRestriction.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    IP_SUBNETWORKS_FIELD_NUMBER: builtins.int
    DEVICE_POLICY_FIELD_NUMBER: builtins.int
    REQUIRED_ACCESS_LEVELS_FIELD_NUMBER: builtins.int
    NEGATE_FIELD_NUMBER: builtins.int
    MEMBERS_FIELD_NUMBER: builtins.int
    REGIONS_FIELD_NUMBER: builtins.int
    @property
    def ip_subnetworks(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for
        a CIDR IP address block, the specified IP address portion must be properly
        truncated (i.e. all the host bits must be zero) or the input is considered
        malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is
        not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas
        "2001:db8::1/32" is not. The originating IP of a request must be in one of
        the listed subnets in order for this Condition to be true. If empty, all IP
        addresses are allowed.
        """
        pass
    @property
    def device_policy(self) -> global___DevicePolicy:
        """Device specific restrictions, all restrictions must hold for the
        Condition to be true. If not specified, all devices are allowed.
        """
        pass
    @property
    def required_access_levels(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of other access levels defined in the same `Policy`, referenced by
        resource name. Referencing an `AccessLevel` which does not exist is an
        error. All access levels listed must be granted for the Condition
        to be true. Example:
        "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
        """
        pass
    negate: builtins.bool = ...
    """Whether to negate the Condition. If true, the Condition becomes a NAND over
    its non-empty fields, each field must be false for the Condition overall to
    be satisfied. Defaults to false.
    """

    @property
    def members(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The request must be made by one of the provided user or service
        accounts. Groups are not supported.
        Syntax:
        `user:{emailid}`
        `serviceAccount:{emailid}`
        If not specified, a request may come from any user.
        """
        pass
    @property
    def regions(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The request must originate from one of the provided countries/regions.
        Must be valid ISO 3166-1 alpha-2 codes.
        """
        pass
    def __init__(self,
        *,
        ip_subnetworks : typing.Optional[typing.Iterable[typing.Text]] = ...,
        device_policy : typing.Optional[global___DevicePolicy] = ...,
        required_access_levels : typing.Optional[typing.Iterable[typing.Text]] = ...,
        negate : builtins.bool = ...,
        members : typing.Optional[typing.Iterable[typing.Text]] = ...,
        regions : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["device_policy",b"device_policy"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["device_policy",b"device_policy","ip_subnetworks",b"ip_subnetworks","members",b"members","negate",b"negate","regions",b"regions","required_access_levels",b"required_access_levels"]) -> None: ...
global___Condition = Condition

class CustomLevel(google.protobuf.message.Message):
    """`CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language
    to represent the necessary conditions for the level to apply to a request.
    See CEL spec at: https://github.com/google/cel-spec
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXPR_FIELD_NUMBER: builtins.int
    @property
    def expr(self) -> google.type.expr_pb2.Expr:
        """Required. A Cloud CEL expression evaluating to a boolean."""
        pass
    def __init__(self,
        *,
        expr : typing.Optional[google.type.expr_pb2.Expr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["expr",b"expr"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["expr",b"expr"]) -> None: ...
global___CustomLevel = CustomLevel

class DevicePolicy(google.protobuf.message.Message):
    """`DevicePolicy` specifies device specific restrictions necessary to acquire a
    given access level. A `DevicePolicy` specifies requirements for requests from
    devices to be granted access levels, it does not do any enforcement on the
    device. `DevicePolicy` acts as an AND over all specified fields, and each
    repeated field is an OR over its elements. Any unset fields are ignored. For
    example, if the proto is { os_type : DESKTOP_WINDOWS, os_type :
    DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be
    true for requests originating from encrypted Linux desktops and encrypted
    Windows desktops.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    REQUIRE_SCREENLOCK_FIELD_NUMBER: builtins.int
    ALLOWED_ENCRYPTION_STATUSES_FIELD_NUMBER: builtins.int
    OS_CONSTRAINTS_FIELD_NUMBER: builtins.int
    ALLOWED_DEVICE_MANAGEMENT_LEVELS_FIELD_NUMBER: builtins.int
    REQUIRE_ADMIN_APPROVAL_FIELD_NUMBER: builtins.int
    REQUIRE_CORP_OWNED_FIELD_NUMBER: builtins.int
    require_screenlock: builtins.bool = ...
    """Whether or not screenlock is required for the DevicePolicy to be true.
    Defaults to `false`.
    """

    @property
    def allowed_encryption_statuses(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[google.identity.accesscontextmanager.type.device_resources_pb2.DeviceEncryptionStatus.ValueType]:
        """Allowed encryptions statuses, an empty list allows all statuses."""
        pass
    @property
    def os_constraints(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OsConstraint]:
        """Allowed OS versions, an empty list allows all types and all versions."""
        pass
    @property
    def allowed_device_management_levels(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[google.identity.accesscontextmanager.type.device_resources_pb2.DeviceManagementLevel.ValueType]:
        """Allowed device management levels, an empty list allows all management
        levels.
        """
        pass
    require_admin_approval: builtins.bool = ...
    """Whether the device needs to be approved by the customer admin."""

    require_corp_owned: builtins.bool = ...
    """Whether the device needs to be corp owned."""

    def __init__(self,
        *,
        require_screenlock : builtins.bool = ...,
        allowed_encryption_statuses : typing.Optional[typing.Iterable[google.identity.accesscontextmanager.type.device_resources_pb2.DeviceEncryptionStatus.ValueType]] = ...,
        os_constraints : typing.Optional[typing.Iterable[global___OsConstraint]] = ...,
        allowed_device_management_levels : typing.Optional[typing.Iterable[google.identity.accesscontextmanager.type.device_resources_pb2.DeviceManagementLevel.ValueType]] = ...,
        require_admin_approval : builtins.bool = ...,
        require_corp_owned : builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["allowed_device_management_levels",b"allowed_device_management_levels","allowed_encryption_statuses",b"allowed_encryption_statuses","os_constraints",b"os_constraints","require_admin_approval",b"require_admin_approval","require_corp_owned",b"require_corp_owned","require_screenlock",b"require_screenlock"]) -> None: ...
global___DevicePolicy = DevicePolicy

class OsConstraint(google.protobuf.message.Message):
    """A restriction on the OS type and version of devices making requests."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    OS_TYPE_FIELD_NUMBER: builtins.int
    MINIMUM_VERSION_FIELD_NUMBER: builtins.int
    REQUIRE_VERIFIED_CHROME_OS_FIELD_NUMBER: builtins.int
    os_type: google.identity.accesscontextmanager.type.device_resources_pb2.OsType.ValueType = ...
    """Required. The allowed OS type."""

    minimum_version: typing.Text = ...
    """The minimum allowed OS version. If not set, any version of this OS
    satisfies the constraint. Format: `"major.minor.patch"`.
    Examples: `"10.5.301"`, `"9.2.1"`.
    """

    require_verified_chrome_os: builtins.bool = ...
    """Only allows requests from devices with a verified Chrome OS.
    Verifications includes requirements that the device is enterprise-managed,
    conformant to domain policies, and the caller has permission to call
    the API targeted by the request.
    """

    def __init__(self,
        *,
        os_type : google.identity.accesscontextmanager.type.device_resources_pb2.OsType.ValueType = ...,
        minimum_version : typing.Text = ...,
        require_verified_chrome_os : builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["minimum_version",b"minimum_version","os_type",b"os_type","require_verified_chrome_os",b"require_verified_chrome_os"]) -> None: ...
global___OsConstraint = OsConstraint
