"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.api.monitored_resource_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _UptimeCheckRegion:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _UptimeCheckRegionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_UptimeCheckRegion.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    REGION_UNSPECIFIED: UptimeCheckRegion.ValueType = ...  # 0
    """Default value if no region is specified. Will result in Uptime checks
    running from all regions.
    """

    USA: UptimeCheckRegion.ValueType = ...  # 1
    """Allows checks to run from locations within the United States of America."""

    EUROPE: UptimeCheckRegion.ValueType = ...  # 2
    """Allows checks to run from locations within the continent of Europe."""

    SOUTH_AMERICA: UptimeCheckRegion.ValueType = ...  # 3
    """Allows checks to run from locations within the continent of South
    America.
    """

    ASIA_PACIFIC: UptimeCheckRegion.ValueType = ...  # 4
    """Allows checks to run from locations within the Asia Pacific area (ex:
    Singapore).
    """

class UptimeCheckRegion(_UptimeCheckRegion, metaclass=_UptimeCheckRegionEnumTypeWrapper):
    """The regions from which an Uptime check can be run."""
    pass

REGION_UNSPECIFIED: UptimeCheckRegion.ValueType = ...  # 0
"""Default value if no region is specified. Will result in Uptime checks
running from all regions.
"""

USA: UptimeCheckRegion.ValueType = ...  # 1
"""Allows checks to run from locations within the United States of America."""

EUROPE: UptimeCheckRegion.ValueType = ...  # 2
"""Allows checks to run from locations within the continent of Europe."""

SOUTH_AMERICA: UptimeCheckRegion.ValueType = ...  # 3
"""Allows checks to run from locations within the continent of South
America.
"""

ASIA_PACIFIC: UptimeCheckRegion.ValueType = ...  # 4
"""Allows checks to run from locations within the Asia Pacific area (ex:
Singapore).
"""

global___UptimeCheckRegion = UptimeCheckRegion


class _GroupResourceType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _GroupResourceTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_GroupResourceType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    RESOURCE_TYPE_UNSPECIFIED: GroupResourceType.ValueType = ...  # 0
    """Default value (not valid)."""

    INSTANCE: GroupResourceType.ValueType = ...  # 1
    """A group of instances from Google Cloud Platform (GCP) or
    Amazon Web Services (AWS).
    """

    AWS_ELB_LOAD_BALANCER: GroupResourceType.ValueType = ...  # 2
    """A group of Amazon ELB load balancers."""

class GroupResourceType(_GroupResourceType, metaclass=_GroupResourceTypeEnumTypeWrapper):
    """The supported resource types that can be used as values of
    `group_resource.resource_type`.
    `INSTANCE` includes `gce_instance` and `aws_ec2_instance` resource types.
    The resource types `gae_app` and `uptime_url` are not valid here because
    group checks on App Engine modules and URLs are not allowed.
    """
    pass

RESOURCE_TYPE_UNSPECIFIED: GroupResourceType.ValueType = ...  # 0
"""Default value (not valid)."""

INSTANCE: GroupResourceType.ValueType = ...  # 1
"""A group of instances from Google Cloud Platform (GCP) or
Amazon Web Services (AWS).
"""

AWS_ELB_LOAD_BALANCER: GroupResourceType.ValueType = ...  # 2
"""A group of Amazon ELB load balancers."""

global___GroupResourceType = GroupResourceType


class InternalChecker(google.protobuf.message.Message):
    """An internal checker allows Uptime checks to run on private/internal GCP
    resources.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _State:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_State.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNSPECIFIED: InternalChecker.State.ValueType = ...  # 0
        """An internal checker should never be in the unspecified state."""

        CREATING: InternalChecker.State.ValueType = ...  # 1
        """The checker is being created, provisioned, and configured. A checker in
        this state can be returned by `ListInternalCheckers` or
        `GetInternalChecker`, as well as by examining the [long running
        Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
        that created it.
        """

        RUNNING: InternalChecker.State.ValueType = ...  # 2
        """The checker is running and available for use. A checker in this state
        can be returned by `ListInternalCheckers` or `GetInternalChecker` as
        well as by examining the [long running
        Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
        that created it.
        If a checker is being torn down, it is neither visible nor usable, so
        there is no "deleting" or "down" state.
        """

    class State(_State, metaclass=_StateEnumTypeWrapper):
        """Operational states for an internal checker."""
        pass

    UNSPECIFIED: InternalChecker.State.ValueType = ...  # 0
    """An internal checker should never be in the unspecified state."""

    CREATING: InternalChecker.State.ValueType = ...  # 1
    """The checker is being created, provisioned, and configured. A checker in
    this state can be returned by `ListInternalCheckers` or
    `GetInternalChecker`, as well as by examining the [long running
    Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
    that created it.
    """

    RUNNING: InternalChecker.State.ValueType = ...  # 2
    """The checker is running and available for use. A checker in this state
    can be returned by `ListInternalCheckers` or `GetInternalChecker` as
    well as by examining the [long running
    Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
    that created it.
    If a checker is being torn down, it is neither visible nor usable, so
    there is no "deleting" or "down" state.
    """


    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    NETWORK_FIELD_NUMBER: builtins.int
    GCP_ZONE_FIELD_NUMBER: builtins.int
    PEER_PROJECT_ID_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """A unique resource name for this InternalChecker. The format is:

        projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID]

    `[PROJECT_ID_OR_NUMBER]` is the Stackdriver Workspace project for the
    Uptime check config associated with the internal checker.
    """

    display_name: typing.Text = ...
    """The checker's human-readable name. The display name
    should be unique within a Stackdriver Workspace in order to make it easier
    to identify; however, uniqueness is not enforced.
    """

    network: typing.Text = ...
    """The [GCP VPC network](https://cloud.google.com/vpc/docs/vpc) where the
    internal resource lives (ex: "default").
    """

    gcp_zone: typing.Text = ...
    """The GCP zone the Uptime check should egress from. Only respected for
    internal Uptime checks, where internal_network is specified.
    """

    peer_project_id: typing.Text = ...
    """The GCP project ID where the internal checker lives. Not necessary
    the same as the Workspace project.
    """

    state: global___InternalChecker.State.ValueType = ...
    """The current operational state of the internal checker."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        network : typing.Text = ...,
        gcp_zone : typing.Text = ...,
        peer_project_id : typing.Text = ...,
        state : global___InternalChecker.State.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["display_name",b"display_name","gcp_zone",b"gcp_zone","name",b"name","network",b"network","peer_project_id",b"peer_project_id","state",b"state"]) -> None: ...
global___InternalChecker = InternalChecker

class UptimeCheckConfig(google.protobuf.message.Message):
    """This message configures which resources and services to monitor for
    availability.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ResourceGroup(google.protobuf.message.Message):
        """The resource submessage for group checks. It can be used instead of a
        monitored resource, when multiple resources are being monitored.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        GROUP_ID_FIELD_NUMBER: builtins.int
        RESOURCE_TYPE_FIELD_NUMBER: builtins.int
        group_id: typing.Text = ...
        """The group of resources being monitored. Should be only the `[GROUP_ID]`,
        and not the full-path
        `projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]`.
        """

        resource_type: global___GroupResourceType.ValueType = ...
        """The resource type of the group members."""

        def __init__(self,
            *,
            group_id : typing.Text = ...,
            resource_type : global___GroupResourceType.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["group_id",b"group_id","resource_type",b"resource_type"]) -> None: ...

    class HttpCheck(google.protobuf.message.Message):
        """Information involved in an HTTP/HTTPS Uptime check request."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _RequestMethod:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _RequestMethodEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RequestMethod.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            METHOD_UNSPECIFIED: UptimeCheckConfig.HttpCheck.RequestMethod.ValueType = ...  # 0
            """No request method specified."""

            GET: UptimeCheckConfig.HttpCheck.RequestMethod.ValueType = ...  # 1
            """GET request."""

            POST: UptimeCheckConfig.HttpCheck.RequestMethod.ValueType = ...  # 2
            """POST request."""

        class RequestMethod(_RequestMethod, metaclass=_RequestMethodEnumTypeWrapper):
            """The HTTP request method options."""
            pass

        METHOD_UNSPECIFIED: UptimeCheckConfig.HttpCheck.RequestMethod.ValueType = ...  # 0
        """No request method specified."""

        GET: UptimeCheckConfig.HttpCheck.RequestMethod.ValueType = ...  # 1
        """GET request."""

        POST: UptimeCheckConfig.HttpCheck.RequestMethod.ValueType = ...  # 2
        """POST request."""


        class _ContentType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _ContentTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ContentType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            TYPE_UNSPECIFIED: UptimeCheckConfig.HttpCheck.ContentType.ValueType = ...  # 0
            """No content type specified."""

            URL_ENCODED: UptimeCheckConfig.HttpCheck.ContentType.ValueType = ...  # 1
            """`body` is in URL-encoded form. Equivalent to setting the `Content-Type`
            to `application/x-www-form-urlencoded` in the HTTP request.
            """

        class ContentType(_ContentType, metaclass=_ContentTypeEnumTypeWrapper):
            """Header options corresponding to the content type of a HTTP request body."""
            pass

        TYPE_UNSPECIFIED: UptimeCheckConfig.HttpCheck.ContentType.ValueType = ...  # 0
        """No content type specified."""

        URL_ENCODED: UptimeCheckConfig.HttpCheck.ContentType.ValueType = ...  # 1
        """`body` is in URL-encoded form. Equivalent to setting the `Content-Type`
        to `application/x-www-form-urlencoded` in the HTTP request.
        """


        class BasicAuthentication(google.protobuf.message.Message):
            """The authentication parameters to provide to the specified resource or
            URL that requires a username and password. Currently, only
            [Basic HTTP authentication](https://tools.ietf.org/html/rfc7617) is
            supported in Uptime checks.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            USERNAME_FIELD_NUMBER: builtins.int
            PASSWORD_FIELD_NUMBER: builtins.int
            username: typing.Text = ...
            """The username to use when authenticating with the HTTP server."""

            password: typing.Text = ...
            """The password to use when authenticating with the HTTP server."""

            def __init__(self,
                *,
                username : typing.Text = ...,
                password : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["password",b"password","username",b"username"]) -> None: ...

        class HeadersEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            value: typing.Text = ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        REQUEST_METHOD_FIELD_NUMBER: builtins.int
        USE_SSL_FIELD_NUMBER: builtins.int
        PATH_FIELD_NUMBER: builtins.int
        PORT_FIELD_NUMBER: builtins.int
        AUTH_INFO_FIELD_NUMBER: builtins.int
        MASK_HEADERS_FIELD_NUMBER: builtins.int
        HEADERS_FIELD_NUMBER: builtins.int
        CONTENT_TYPE_FIELD_NUMBER: builtins.int
        VALIDATE_SSL_FIELD_NUMBER: builtins.int
        BODY_FIELD_NUMBER: builtins.int
        request_method: global___UptimeCheckConfig.HttpCheck.RequestMethod.ValueType = ...
        """The HTTP request method to use for the check. If set to
        `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
        """

        use_ssl: builtins.bool = ...
        """If `true`, use HTTPS instead of HTTP to run the check."""

        path: typing.Text = ...
        """Optional (defaults to "/"). The path to the page against which to run
        the check. Will be combined with the `host` (specified within the
        `monitored_resource`) and `port` to construct the full URL. If the
        provided path does not begin with "/", a "/" will be prepended
        automatically.
        """

        port: builtins.int = ...
        """Optional (defaults to 80 when `use_ssl` is `false`, and 443 when
        `use_ssl` is `true`). The TCP port on the HTTP server against which to
        run the check. Will be combined with host (specified within the
        `monitored_resource`) and `path` to construct the full URL.
        """

        @property
        def auth_info(self) -> global___UptimeCheckConfig.HttpCheck.BasicAuthentication:
            """The authentication information. Optional when creating an HTTP check;
            defaults to empty.
            """
            pass
        mask_headers: builtins.bool = ...
        """Boolean specifying whether to encrypt the header information.
        Encryption should be specified for any headers related to authentication
        that you do not wish to be seen when retrieving the configuration. The
        server will be responsible for encrypting the headers.
        On Get/List calls, if `mask_headers` is set to `true` then the headers
        will be obscured with `******.`
        """

        @property
        def headers(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
            """The list of headers to send as part of the Uptime check request.
            If two headers have the same key and different values, they should
            be entered as a single header, with the value being a comma-separated
            list of all the desired values as described at
            https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31).
            Entering two separate headers with the same key in a Create call will
            cause the first to be overwritten by the second.
            The maximum number of headers allowed is 100.
            """
            pass
        content_type: global___UptimeCheckConfig.HttpCheck.ContentType.ValueType = ...
        """The content type header to use for the check. The following
        configurations result in errors:
        1. Content type is specified in both the `headers` field and the
        `content_type` field.
        2. Request method is `GET` and `content_type` is not `TYPE_UNSPECIFIED`
        3. Request method is `POST` and `content_type` is `TYPE_UNSPECIFIED`.
        4. Request method is `POST` and a "Content-Type" header is provided via
        `headers` field. The `content_type` field should be used instead.
        """

        validate_ssl: builtins.bool = ...
        """Boolean specifying whether to include SSL certificate validation as a
        part of the Uptime check. Only applies to checks where
        `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`,
        setting `validate_ssl` to `true` has no effect.
        """

        body: builtins.bytes = ...
        """The request body associated with the HTTP POST request. If `content_type`
        is `URL_ENCODED`, the body passed in must be URL-encoded. Users can
        provide a `Content-Length` header via the `headers` field or the API will
        do so. If the `request_method` is `GET` and `body` is not empty, the API
        will return an error. The maximum byte size is 1 megabyte. Note: As with
        all `bytes` fields, JSON representations are base64 encoded. e.g.:
        "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is
        "Zm9vJTI1M0RiYXI=".
        """

        def __init__(self,
            *,
            request_method : global___UptimeCheckConfig.HttpCheck.RequestMethod.ValueType = ...,
            use_ssl : builtins.bool = ...,
            path : typing.Text = ...,
            port : builtins.int = ...,
            auth_info : typing.Optional[global___UptimeCheckConfig.HttpCheck.BasicAuthentication] = ...,
            mask_headers : builtins.bool = ...,
            headers : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
            content_type : global___UptimeCheckConfig.HttpCheck.ContentType.ValueType = ...,
            validate_ssl : builtins.bool = ...,
            body : builtins.bytes = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["auth_info",b"auth_info"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["auth_info",b"auth_info","body",b"body","content_type",b"content_type","headers",b"headers","mask_headers",b"mask_headers","path",b"path","port",b"port","request_method",b"request_method","use_ssl",b"use_ssl","validate_ssl",b"validate_ssl"]) -> None: ...

    class TcpCheck(google.protobuf.message.Message):
        """Information required for a TCP Uptime check request."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        PORT_FIELD_NUMBER: builtins.int
        port: builtins.int = ...
        """The TCP port on the server against which to run the check. Will be
        combined with host (specified within the `monitored_resource`) to
        construct the full URL. Required.
        """

        def __init__(self,
            *,
            port : builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["port",b"port"]) -> None: ...

    class ContentMatcher(google.protobuf.message.Message):
        """Optional. Used to perform content matching. This allows matching based on
        substrings and regular expressions, together with their negations. Only the
        first 4&nbsp;MB of an HTTP or HTTPS check's response (and the first
        1&nbsp;MB of a TCP check's response) are examined for purposes of content
        matching.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _ContentMatcherOption:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _ContentMatcherOptionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ContentMatcherOption.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            CONTENT_MATCHER_OPTION_UNSPECIFIED: UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...  # 0
            """No content matcher type specified (maintained for backward
            compatibility, but deprecated for future use).
            Treated as `CONTAINS_STRING`.
            """

            CONTAINS_STRING: UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...  # 1
            """Selects substring matching. The match succeeds if the output contains
            the `content` string.  This is the default value for checks without
            a `matcher` option, or where the value of `matcher` is
            `CONTENT_MATCHER_OPTION_UNSPECIFIED`.
            """

            NOT_CONTAINS_STRING: UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...  # 2
            """Selects negation of substring matching. The match succeeds if the
            output does _NOT_ contain the `content` string.
            """

            MATCHES_REGEX: UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...  # 3
            """Selects regular-expression matching. The match succeeds of the output
            matches the regular expression specified in the `content` string.
            Regex matching is only supported for HTTP/HTTPS checks.
            """

            NOT_MATCHES_REGEX: UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...  # 4
            """Selects negation of regular-expression matching. The match succeeds if
            the output does _NOT_ match the regular expression specified in the
            `content` string. Regex matching is only supported for HTTP/HTTPS
            checks.
            """

        class ContentMatcherOption(_ContentMatcherOption, metaclass=_ContentMatcherOptionEnumTypeWrapper):
            """Options to perform content matching."""
            pass

        CONTENT_MATCHER_OPTION_UNSPECIFIED: UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...  # 0
        """No content matcher type specified (maintained for backward
        compatibility, but deprecated for future use).
        Treated as `CONTAINS_STRING`.
        """

        CONTAINS_STRING: UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...  # 1
        """Selects substring matching. The match succeeds if the output contains
        the `content` string.  This is the default value for checks without
        a `matcher` option, or where the value of `matcher` is
        `CONTENT_MATCHER_OPTION_UNSPECIFIED`.
        """

        NOT_CONTAINS_STRING: UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...  # 2
        """Selects negation of substring matching. The match succeeds if the
        output does _NOT_ contain the `content` string.
        """

        MATCHES_REGEX: UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...  # 3
        """Selects regular-expression matching. The match succeeds of the output
        matches the regular expression specified in the `content` string.
        Regex matching is only supported for HTTP/HTTPS checks.
        """

        NOT_MATCHES_REGEX: UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...  # 4
        """Selects negation of regular-expression matching. The match succeeds if
        the output does _NOT_ match the regular expression specified in the
        `content` string. Regex matching is only supported for HTTP/HTTPS
        checks.
        """


        CONTENT_FIELD_NUMBER: builtins.int
        MATCHER_FIELD_NUMBER: builtins.int
        content: typing.Text = ...
        """String or regex content to match. Maximum 1024 bytes. An empty `content`
        string indicates no content matching is to be performed.
        """

        matcher: global___UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...
        """The type of content matcher that will be applied to the server output,
        compared to the `content` string when the check is run.
        """

        def __init__(self,
            *,
            content : typing.Text = ...,
            matcher : global___UptimeCheckConfig.ContentMatcher.ContentMatcherOption.ValueType = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["content",b"content","matcher",b"matcher"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    MONITORED_RESOURCE_FIELD_NUMBER: builtins.int
    RESOURCE_GROUP_FIELD_NUMBER: builtins.int
    HTTP_CHECK_FIELD_NUMBER: builtins.int
    TCP_CHECK_FIELD_NUMBER: builtins.int
    PERIOD_FIELD_NUMBER: builtins.int
    TIMEOUT_FIELD_NUMBER: builtins.int
    CONTENT_MATCHERS_FIELD_NUMBER: builtins.int
    SELECTED_REGIONS_FIELD_NUMBER: builtins.int
    IS_INTERNAL_FIELD_NUMBER: builtins.int
    INTERNAL_CHECKERS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """A unique resource name for this Uptime check configuration. The format is:

         projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]

    `[PROJECT_ID_OR_NUMBER]` is the Workspace host project associated with the
    Uptime check.

    This field should be omitted when creating the Uptime check configuration;
    on create, the resource name is assigned by the server and included in the
    response.
    """

    display_name: typing.Text = ...
    """A human-friendly name for the Uptime check configuration. The display name
    should be unique within a Stackdriver Workspace in order to make it easier
    to identify; however, uniqueness is not enforced. Required.
    """

    @property
    def monitored_resource(self) -> google.api.monitored_resource_pb2.MonitoredResource:
        """The [monitored
        resource](https://cloud.google.com/monitoring/api/resources) associated
        with the configuration.
        The following monitored resource types are valid for this field:
          `uptime_url`,
          `gce_instance`,
          `gae_app`,
          `aws_ec2_instance`,
          `aws_elb_load_balancer`
          `k8s_service`
        """
        pass
    @property
    def resource_group(self) -> global___UptimeCheckConfig.ResourceGroup:
        """The group resource associated with the configuration."""
        pass
    @property
    def http_check(self) -> global___UptimeCheckConfig.HttpCheck:
        """Contains information needed to make an HTTP or HTTPS check."""
        pass
    @property
    def tcp_check(self) -> global___UptimeCheckConfig.TcpCheck:
        """Contains information needed to make a TCP check."""
        pass
    @property
    def period(self) -> google.protobuf.duration_pb2.Duration:
        """How often, in seconds, the Uptime check is performed.
        Currently, the only supported values are `60s` (1 minute), `300s`
        (5 minutes), `600s` (10 minutes), and `900s` (15 minutes). Optional,
        defaults to `60s`.
        """
        pass
    @property
    def timeout(self) -> google.protobuf.duration_pb2.Duration:
        """The maximum amount of time to wait for the request to complete (must be
        between 1 and 60 seconds). Required.
        """
        pass
    @property
    def content_matchers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___UptimeCheckConfig.ContentMatcher]:
        """The content that is expected to appear in the data returned by the target
        server against which the check is run.  Currently, only the first entry
        in the `content_matchers` list is supported, and additional entries will
        be ignored. This field is optional and should only be specified if a
        content match is required as part of the/ Uptime check.
        """
        pass
    @property
    def selected_regions(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___UptimeCheckRegion.ValueType]:
        """The list of regions from which the check will be run.
        Some regions contain one location, and others contain more than one.
        If this field is specified, enough regions must be provided to include a
        minimum of 3 locations.  Not specifying this field will result in Uptime
        checks running from all available regions.
        """
        pass
    is_internal: builtins.bool = ...
    """If this is `true`, then checks are made only from the 'internal_checkers'.
    If it is `false`, then checks are made only from the 'selected_regions'.
    It is an error to provide 'selected_regions' when is_internal is `true`,
    or to provide 'internal_checkers' when is_internal is `false`.
    """

    @property
    def internal_checkers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InternalChecker]:
        """The internal checkers that this check will egress from. If `is_internal` is
        `true` and this list is empty, the check will egress from all the
        InternalCheckers configured for the project that owns this
        `UptimeCheckConfig`.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        monitored_resource : typing.Optional[google.api.monitored_resource_pb2.MonitoredResource] = ...,
        resource_group : typing.Optional[global___UptimeCheckConfig.ResourceGroup] = ...,
        http_check : typing.Optional[global___UptimeCheckConfig.HttpCheck] = ...,
        tcp_check : typing.Optional[global___UptimeCheckConfig.TcpCheck] = ...,
        period : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        timeout : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        content_matchers : typing.Optional[typing.Iterable[global___UptimeCheckConfig.ContentMatcher]] = ...,
        selected_regions : typing.Optional[typing.Iterable[global___UptimeCheckRegion.ValueType]] = ...,
        is_internal : builtins.bool = ...,
        internal_checkers : typing.Optional[typing.Iterable[global___InternalChecker]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["check_request_type",b"check_request_type","http_check",b"http_check","monitored_resource",b"monitored_resource","period",b"period","resource",b"resource","resource_group",b"resource_group","tcp_check",b"tcp_check","timeout",b"timeout"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["check_request_type",b"check_request_type","content_matchers",b"content_matchers","display_name",b"display_name","http_check",b"http_check","internal_checkers",b"internal_checkers","is_internal",b"is_internal","monitored_resource",b"monitored_resource","name",b"name","period",b"period","resource",b"resource","resource_group",b"resource_group","selected_regions",b"selected_regions","tcp_check",b"tcp_check","timeout",b"timeout"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["check_request_type",b"check_request_type"]) -> typing.Optional[typing_extensions.Literal["http_check","tcp_check"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["resource",b"resource"]) -> typing.Optional[typing_extensions.Literal["monitored_resource","resource_group"]]: ...
global___UptimeCheckConfig = UptimeCheckConfig

class UptimeCheckIp(google.protobuf.message.Message):
    """Contains the region, location, and list of IP
    addresses where checkers in the location run from.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    REGION_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    IP_ADDRESS_FIELD_NUMBER: builtins.int
    region: global___UptimeCheckRegion.ValueType = ...
    """A broad region category in which the IP address is located."""

    location: typing.Text = ...
    """A more specific location within the region that typically encodes
    a particular city/town/metro (and its containing state/province or country)
    within the broader umbrella region category.
    """

    ip_address: typing.Text = ...
    """The IP address from which the Uptime check originates. This is a fully
    specified IP address (not an IP address range). Most IP addresses, as of
    this publication, are in IPv4 format; however, one should not rely on the
    IP addresses being in IPv4 format indefinitely, and should support
    interpreting this field in either IPv4 or IPv6 format.
    """

    def __init__(self,
        *,
        region : global___UptimeCheckRegion.ValueType = ...,
        location : typing.Text = ...,
        ip_address : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["ip_address",b"ip_address","location",b"location","region",b"region"]) -> None: ...
global___UptimeCheckIp = UptimeCheckIp
