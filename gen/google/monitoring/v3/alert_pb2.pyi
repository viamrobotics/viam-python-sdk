"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.monitoring.v3.common_pb2
import google.monitoring.v3.mutation_record_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.wrappers_pb2
import google.rpc.status_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class AlertPolicy(google.protobuf.message.Message):
    """A description of the conditions under which some aspect of your system is
    considered to be "unhealthy" and the ways to notify people or services about
    this state. For an overview of alert policies, see
    [Introduction to Alerting](https://cloud.google.com/monitoring/alerts/).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _ConditionCombinerType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ConditionCombinerTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ConditionCombinerType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        COMBINE_UNSPECIFIED: AlertPolicy.ConditionCombinerType.ValueType = ...  # 0
        """An unspecified combiner."""

        AND: AlertPolicy.ConditionCombinerType.ValueType = ...  # 1
        """Combine conditions using the logical `AND` operator. An
        incident is created only if all the conditions are met
        simultaneously. This combiner is satisfied if all conditions are
        met, even if they are met on completely different resources.
        """

        OR: AlertPolicy.ConditionCombinerType.ValueType = ...  # 2
        """Combine conditions using the logical `OR` operator. An incident
        is created if any of the listed conditions is met.
        """

        AND_WITH_MATCHING_RESOURCE: AlertPolicy.ConditionCombinerType.ValueType = ...  # 3
        """Combine conditions using logical `AND` operator, but unlike the regular
        `AND` option, an incident is created only if all conditions are met
        simultaneously on at least one resource.
        """

    class ConditionCombinerType(_ConditionCombinerType, metaclass=_ConditionCombinerTypeEnumTypeWrapper):
        """Operators for combining conditions."""
        pass

    COMBINE_UNSPECIFIED: AlertPolicy.ConditionCombinerType.ValueType = ...  # 0
    """An unspecified combiner."""

    AND: AlertPolicy.ConditionCombinerType.ValueType = ...  # 1
    """Combine conditions using the logical `AND` operator. An
    incident is created only if all the conditions are met
    simultaneously. This combiner is satisfied if all conditions are
    met, even if they are met on completely different resources.
    """

    OR: AlertPolicy.ConditionCombinerType.ValueType = ...  # 2
    """Combine conditions using the logical `OR` operator. An incident
    is created if any of the listed conditions is met.
    """

    AND_WITH_MATCHING_RESOURCE: AlertPolicy.ConditionCombinerType.ValueType = ...  # 3
    """Combine conditions using logical `AND` operator, but unlike the regular
    `AND` option, an incident is created only if all conditions are met
    simultaneously on at least one resource.
    """


    class Documentation(google.protobuf.message.Message):
        """A content string and a MIME type that describes the content string's
        format.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        CONTENT_FIELD_NUMBER: builtins.int
        MIME_TYPE_FIELD_NUMBER: builtins.int
        content: typing.Text = ...
        """The text of the documentation, interpreted according to `mime_type`.
        The content may not exceed 8,192 Unicode characters and may not exceed
        more than 10,240 bytes when encoded in UTF-8 format, whichever is
        smaller.
        """

        mime_type: typing.Text = ...
        """The format of the `content` field. Presently, only the value
        `"text/markdown"` is supported. See
        [Markdown](https://en.wikipedia.org/wiki/Markdown) for more information.
        """

        def __init__(self,
            *,
            content : typing.Text = ...,
            mime_type : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["content",b"content","mime_type",b"mime_type"]) -> None: ...

    class Condition(google.protobuf.message.Message):
        """A condition is a true/false test that determines when an alerting policy
        should open an incident. If a condition evaluates to true, it signifies
        that something is wrong.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Trigger(google.protobuf.message.Message):
            """Specifies how many time series must fail a predicate to trigger a
            condition. If not specified, then a `{count: 1}` trigger is used.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            COUNT_FIELD_NUMBER: builtins.int
            PERCENT_FIELD_NUMBER: builtins.int
            count: builtins.int = ...
            """The absolute number of time series that must fail
            the predicate for the condition to be triggered.
            """

            percent: builtins.float = ...
            """The percentage of time series that must fail the
            predicate for the condition to be triggered.
            """

            def __init__(self,
                *,
                count : builtins.int = ...,
                percent : builtins.float = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["count",b"count","percent",b"percent","type",b"type"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["count",b"count","percent",b"percent","type",b"type"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["count","percent"]]: ...

        class MetricThreshold(google.protobuf.message.Message):
            """A condition type that compares a collection of time series
            against a threshold.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            FILTER_FIELD_NUMBER: builtins.int
            AGGREGATIONS_FIELD_NUMBER: builtins.int
            DENOMINATOR_FILTER_FIELD_NUMBER: builtins.int
            DENOMINATOR_AGGREGATIONS_FIELD_NUMBER: builtins.int
            COMPARISON_FIELD_NUMBER: builtins.int
            THRESHOLD_VALUE_FIELD_NUMBER: builtins.int
            DURATION_FIELD_NUMBER: builtins.int
            TRIGGER_FIELD_NUMBER: builtins.int
            filter: typing.Text = ...
            """Required. A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
            identifies which time series should be compared with the threshold.

            The filter is similar to the one that is specified in the
            [`ListTimeSeries`
            request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
            (that call is useful to verify the time series that will be retrieved /
            processed). The filter must specify the metric type and the resource
            type. Optionally, it can specify resource labels and metric labels.
            This field must not exceed 2048 Unicode characters in length.
            """

            @property
            def aggregations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.monitoring.v3.common_pb2.Aggregation]:
                """Specifies the alignment of data points in individual time series as
                well as how to combine the retrieved time series together (such as
                when aggregating multiple streams on each resource to a single
                stream for each resource or when aggregating streams across all
                members of a group of resources). Multiple aggregations
                are applied in the order specified.

                This field is similar to the one in the [`ListTimeSeries`
                request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
                It is advisable to use the `ListTimeSeries` method when debugging this
                field.
                """
                pass
            denominator_filter: typing.Text = ...
            """A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
            identifies a time series that should be used as the denominator of a
            ratio that will be compared with the threshold. If a
            `denominator_filter` is specified, the time series specified by the
            `filter` field will be used as the numerator.

            The filter must specify the metric type and optionally may contain
            restrictions on resource type, resource labels, and metric labels.
            This field may not exceed 2048 Unicode characters in length.
            """

            @property
            def denominator_aggregations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.monitoring.v3.common_pb2.Aggregation]:
                """Specifies the alignment of data points in individual time series
                selected by `denominatorFilter` as
                well as how to combine the retrieved time series together (such as
                when aggregating multiple streams on each resource to a single
                stream for each resource or when aggregating streams across all
                members of a group of resources).

                When computing ratios, the `aggregations` and
                `denominator_aggregations` fields must use the same alignment period
                and produce time series that have the same periodicity and labels.
                """
                pass
            comparison: google.monitoring.v3.common_pb2.ComparisonType.ValueType = ...
            """The comparison to apply between the time series (indicated by `filter`
            and `aggregation`) and the threshold (indicated by `threshold_value`).
            The comparison is applied on each time series, with the time series
            on the left-hand side and the threshold on the right-hand side.

            Only `COMPARISON_LT` and `COMPARISON_GT` are supported currently.
            """

            threshold_value: builtins.float = ...
            """A value against which to compare the time series."""

            @property
            def duration(self) -> google.protobuf.duration_pb2.Duration:
                """The amount of time that a time series must violate the
                threshold to be considered failing. Currently, only values
                that are a multiple of a minute--e.g., 0, 60, 120, or 300
                seconds--are supported. If an invalid value is given, an
                error will be returned. When choosing a duration, it is useful to
                keep in mind the frequency of the underlying time series data
                (which may also be affected by any alignments specified in the
                `aggregations` field); a good duration is long enough so that a single
                outlier does not generate spurious alerts, but short enough that
                unhealthy states are detected and alerted on quickly.
                """
                pass
            @property
            def trigger(self) -> global___AlertPolicy.Condition.Trigger:
                """The number/percent of time series for which the comparison must hold
                in order for the condition to trigger. If unspecified, then the
                condition will trigger if the comparison is true for any of the
                time series that have been identified by `filter` and `aggregations`,
                or by the ratio, if `denominator_filter` and `denominator_aggregations`
                are specified.
                """
                pass
            def __init__(self,
                *,
                filter : typing.Text = ...,
                aggregations : typing.Optional[typing.Iterable[google.monitoring.v3.common_pb2.Aggregation]] = ...,
                denominator_filter : typing.Text = ...,
                denominator_aggregations : typing.Optional[typing.Iterable[google.monitoring.v3.common_pb2.Aggregation]] = ...,
                comparison : google.monitoring.v3.common_pb2.ComparisonType.ValueType = ...,
                threshold_value : builtins.float = ...,
                duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
                trigger : typing.Optional[global___AlertPolicy.Condition.Trigger] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["duration",b"duration","trigger",b"trigger"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["aggregations",b"aggregations","comparison",b"comparison","denominator_aggregations",b"denominator_aggregations","denominator_filter",b"denominator_filter","duration",b"duration","filter",b"filter","threshold_value",b"threshold_value","trigger",b"trigger"]) -> None: ...

        class MetricAbsence(google.protobuf.message.Message):
            """A condition type that checks that monitored resources
            are reporting data. The configuration defines a metric and
            a set of monitored resources. The predicate is considered in violation
            when a time series for the specified metric of a monitored
            resource does not include any data in the specified `duration`.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            FILTER_FIELD_NUMBER: builtins.int
            AGGREGATIONS_FIELD_NUMBER: builtins.int
            DURATION_FIELD_NUMBER: builtins.int
            TRIGGER_FIELD_NUMBER: builtins.int
            filter: typing.Text = ...
            """Required. A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
            identifies which time series should be compared with the threshold.

            The filter is similar to the one that is specified in the
            [`ListTimeSeries`
            request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
            (that call is useful to verify the time series that will be retrieved /
            processed). The filter must specify the metric type and the resource
            type. Optionally, it can specify resource labels and metric labels.
            This field must not exceed 2048 Unicode characters in length.
            """

            @property
            def aggregations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.monitoring.v3.common_pb2.Aggregation]:
                """Specifies the alignment of data points in individual time series as
                well as how to combine the retrieved time series together (such as
                when aggregating multiple streams on each resource to a single
                stream for each resource or when aggregating streams across all
                members of a group of resources). Multiple aggregations
                are applied in the order specified.

                This field is similar to the one in the [`ListTimeSeries`
                request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
                It is advisable to use the `ListTimeSeries` method when debugging this
                field.
                """
                pass
            @property
            def duration(self) -> google.protobuf.duration_pb2.Duration:
                """The amount of time that a time series must fail to report new
                data to be considered failing. The minimum value of this field
                is 120 seconds. Larger values that are a multiple of a
                minute--for example, 240 or 300 seconds--are supported.
                If an invalid value is given, an
                error will be returned. The `Duration.nanos` field is
                ignored.
                """
                pass
            @property
            def trigger(self) -> global___AlertPolicy.Condition.Trigger:
                """The number/percent of time series for which the comparison must hold
                in order for the condition to trigger. If unspecified, then the
                condition will trigger if the comparison is true for any of the
                time series that have been identified by `filter` and `aggregations`.
                """
                pass
            def __init__(self,
                *,
                filter : typing.Text = ...,
                aggregations : typing.Optional[typing.Iterable[google.monitoring.v3.common_pb2.Aggregation]] = ...,
                duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
                trigger : typing.Optional[global___AlertPolicy.Condition.Trigger] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["duration",b"duration","trigger",b"trigger"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["aggregations",b"aggregations","duration",b"duration","filter",b"filter","trigger",b"trigger"]) -> None: ...

        class LogMatch(google.protobuf.message.Message):
            """A condition type that checks whether a log message in the [scoping
            project](https://cloud.google.com/monitoring/api/v3#project_name)
            satisfies the given filter. Logs from other projects in the metrics
            scope are not evaluated.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class LabelExtractorsEntry(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                KEY_FIELD_NUMBER: builtins.int
                VALUE_FIELD_NUMBER: builtins.int
                key: typing.Text = ...
                value: typing.Text = ...
                def __init__(self,
                    *,
                    key : typing.Text = ...,
                    value : typing.Text = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

            FILTER_FIELD_NUMBER: builtins.int
            LABEL_EXTRACTORS_FIELD_NUMBER: builtins.int
            filter: typing.Text = ...
            """Required. A logs-based filter. See [Advanced Logs
            Queries](https://cloud.google.com/logging/docs/view/advanced-queries)
            for how this filter should be constructed.
            """

            @property
            def label_extractors(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
                """Optional. A map from a label key to an extractor expression, which is
                used to extract the value for this label key. Each entry in this map is
                a specification for how data should be extracted from log entries that
                match `filter`. Each combination of extracted values is treated as a
                separate rule for the purposes of triggering notifications. Label keys
                and corresponding values can be used in notifications generated by this
                condition.

                Please see [the documentation on logs-based metric
                `valueExtractor`s](https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor)
                for syntax and examples.
                """
                pass
            def __init__(self,
                *,
                filter : typing.Text = ...,
                label_extractors : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","label_extractors",b"label_extractors"]) -> None: ...

        class MonitoringQueryLanguageCondition(google.protobuf.message.Message):
            """A condition type that allows alert policies to be defined using
            [Monitoring Query Language](https://cloud.google.com/monitoring/mql).
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            QUERY_FIELD_NUMBER: builtins.int
            DURATION_FIELD_NUMBER: builtins.int
            TRIGGER_FIELD_NUMBER: builtins.int
            query: typing.Text = ...
            """[Monitoring Query Language](https://cloud.google.com/monitoring/mql)
            query that outputs a boolean stream.
            """

            @property
            def duration(self) -> google.protobuf.duration_pb2.Duration:
                """The amount of time that a time series must violate the
                threshold to be considered failing. Currently, only values
                that are a multiple of a minute--e.g., 0, 60, 120, or 300
                seconds--are supported. If an invalid value is given, an
                error will be returned. When choosing a duration, it is useful to
                keep in mind the frequency of the underlying time series data
                (which may also be affected by any alignments specified in the
                `aggregations` field); a good duration is long enough so that a single
                outlier does not generate spurious alerts, but short enough that
                unhealthy states are detected and alerted on quickly.
                """
                pass
            @property
            def trigger(self) -> global___AlertPolicy.Condition.Trigger:
                """The number/percent of time series for which the comparison must hold
                in order for the condition to trigger. If unspecified, then the
                condition will trigger if the comparison is true for any of the
                time series that have been identified by `filter` and `aggregations`,
                or by the ratio, if `denominator_filter` and `denominator_aggregations`
                are specified.
                """
                pass
            def __init__(self,
                *,
                query : typing.Text = ...,
                duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
                trigger : typing.Optional[global___AlertPolicy.Condition.Trigger] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["duration",b"duration","trigger",b"trigger"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["duration",b"duration","query",b"query","trigger",b"trigger"]) -> None: ...

        NAME_FIELD_NUMBER: builtins.int
        DISPLAY_NAME_FIELD_NUMBER: builtins.int
        CONDITION_THRESHOLD_FIELD_NUMBER: builtins.int
        CONDITION_ABSENT_FIELD_NUMBER: builtins.int
        CONDITION_MATCHED_LOG_FIELD_NUMBER: builtins.int
        CONDITION_MONITORING_QUERY_LANGUAGE_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        """Required if the condition exists. The unique resource name for this
        condition. Its format is:

            projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]

        `[CONDITION_ID]` is assigned by Stackdriver Monitoring when the
        condition is created as part of a new or updated alerting policy.

        When calling the
        [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
        method, do not include the `name` field in the conditions of the
        requested alerting policy. Stackdriver Monitoring creates the
        condition identifiers and includes them in the new policy.

        When calling the
        [alertPolicies.update][google.monitoring.v3.AlertPolicyService.UpdateAlertPolicy]
        method to update a policy, including a condition `name` causes the
        existing condition to be updated. Conditions without names are added to
        the updated policy. Existing conditions are deleted if they are not
        updated.

        Best practice is to preserve `[CONDITION_ID]` if you make only small
        changes, such as those to condition thresholds, durations, or trigger
        values.  Otherwise, treat the change as a new condition and let the
        existing condition be deleted.
        """

        display_name: typing.Text = ...
        """A short name or phrase used to identify the condition in dashboards,
        notifications, and incidents. To avoid confusion, don't use the same
        display name for multiple conditions in the same policy.
        """

        @property
        def condition_threshold(self) -> global___AlertPolicy.Condition.MetricThreshold:
            """A condition that compares a time series against a threshold."""
            pass
        @property
        def condition_absent(self) -> global___AlertPolicy.Condition.MetricAbsence:
            """A condition that checks that a time series continues to
            receive new data points.
            """
            pass
        @property
        def condition_matched_log(self) -> global___AlertPolicy.Condition.LogMatch:
            """A condition that checks for log messages matching given constraints. If
            set, no other conditions can be present.
            """
            pass
        @property
        def condition_monitoring_query_language(self) -> global___AlertPolicy.Condition.MonitoringQueryLanguageCondition:
            """A condition that uses the Monitoring Query Language to define
            alerts.
            """
            pass
        def __init__(self,
            *,
            name : typing.Text = ...,
            display_name : typing.Text = ...,
            condition_threshold : typing.Optional[global___AlertPolicy.Condition.MetricThreshold] = ...,
            condition_absent : typing.Optional[global___AlertPolicy.Condition.MetricAbsence] = ...,
            condition_matched_log : typing.Optional[global___AlertPolicy.Condition.LogMatch] = ...,
            condition_monitoring_query_language : typing.Optional[global___AlertPolicy.Condition.MonitoringQueryLanguageCondition] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["condition",b"condition","condition_absent",b"condition_absent","condition_matched_log",b"condition_matched_log","condition_monitoring_query_language",b"condition_monitoring_query_language","condition_threshold",b"condition_threshold"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["condition",b"condition","condition_absent",b"condition_absent","condition_matched_log",b"condition_matched_log","condition_monitoring_query_language",b"condition_monitoring_query_language","condition_threshold",b"condition_threshold","display_name",b"display_name","name",b"name"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["condition",b"condition"]) -> typing.Optional[typing_extensions.Literal["condition_threshold","condition_absent","condition_matched_log","condition_monitoring_query_language"]]: ...

    class AlertStrategy(google.protobuf.message.Message):
        """Control over how the notification channels in `notification_channels`
        are notified when this alert fires.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class NotificationRateLimit(google.protobuf.message.Message):
            """Control over the rate of notifications sent to this alert policy's
            notification channels.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            PERIOD_FIELD_NUMBER: builtins.int
            @property
            def period(self) -> google.protobuf.duration_pb2.Duration:
                """Not more than one notification per `period`."""
                pass
            def __init__(self,
                *,
                period : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["period",b"period"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["period",b"period"]) -> None: ...

        NOTIFICATION_RATE_LIMIT_FIELD_NUMBER: builtins.int
        AUTO_CLOSE_FIELD_NUMBER: builtins.int
        @property
        def notification_rate_limit(self) -> global___AlertPolicy.AlertStrategy.NotificationRateLimit:
            """Required for alert policies with a `LogMatch` condition.

            This limit is not implemented for alert policies that are not log-based.
            """
            pass
        @property
        def auto_close(self) -> google.protobuf.duration_pb2.Duration:
            """If an alert policy that was active has no data for this long, any open
            incidents will close
            """
            pass
        def __init__(self,
            *,
            notification_rate_limit : typing.Optional[global___AlertPolicy.AlertStrategy.NotificationRateLimit] = ...,
            auto_close : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["auto_close",b"auto_close","notification_rate_limit",b"notification_rate_limit"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["auto_close",b"auto_close","notification_rate_limit",b"notification_rate_limit"]) -> None: ...

    class UserLabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    DOCUMENTATION_FIELD_NUMBER: builtins.int
    USER_LABELS_FIELD_NUMBER: builtins.int
    CONDITIONS_FIELD_NUMBER: builtins.int
    COMBINER_FIELD_NUMBER: builtins.int
    ENABLED_FIELD_NUMBER: builtins.int
    VALIDITY_FIELD_NUMBER: builtins.int
    NOTIFICATION_CHANNELS_FIELD_NUMBER: builtins.int
    CREATION_RECORD_FIELD_NUMBER: builtins.int
    MUTATION_RECORD_FIELD_NUMBER: builtins.int
    ALERT_STRATEGY_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required if the policy exists. The resource name for this policy. The
    format is:

        projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]

    `[ALERT_POLICY_ID]` is assigned by Stackdriver Monitoring when the policy
    is created. When calling the
    [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
    method, do not include the `name` field in the alerting policy passed as
    part of the request.
    """

    display_name: typing.Text = ...
    """A short name or phrase used to identify the policy in dashboards,
    notifications, and incidents. To avoid confusion, don't use the same
    display name for multiple policies in the same project. The name is
    limited to 512 Unicode characters.
    """

    @property
    def documentation(self) -> global___AlertPolicy.Documentation:
        """Documentation that is included with notifications and incidents related to
        this policy. Best practice is for the documentation to include information
        to help responders understand, mitigate, escalate, and correct the
        underlying problems detected by the alerting policy. Notification channels
        that have limited capacity might not show this documentation.
        """
        pass
    @property
    def user_labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """User-supplied key/value data to be used for organizing and
        identifying the `AlertPolicy` objects.

        The field can contain up to 64 entries. Each key and value is limited to
        63 Unicode characters or 128 bytes, whichever is smaller. Labels and
        values can contain only lowercase letters, numerals, underscores, and
        dashes. Keys must begin with a letter.
        """
        pass
    @property
    def conditions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AlertPolicy.Condition]:
        """A list of conditions for the policy. The conditions are combined by AND or
        OR according to the `combiner` field. If the combined conditions evaluate
        to true, then an incident is created. A policy can have from one to six
        conditions.
        If `condition_time_series_query_language` is present, it must be the only
        `condition`.
        """
        pass
    combiner: global___AlertPolicy.ConditionCombinerType.ValueType = ...
    """How to combine the results of multiple conditions to determine if an
    incident should be opened.
    If `condition_time_series_query_language` is present, this must be
    `COMBINE_UNSPECIFIED`.
    """

    @property
    def enabled(self) -> google.protobuf.wrappers_pb2.BoolValue:
        """Whether or not the policy is enabled. On write, the default interpretation
        if unset is that the policy is enabled. On read, clients should not make
        any assumption about the state if it has not been populated. The
        field should always be populated on List and Get operations, unless
        a field projection has been specified that strips it out.
        """
        pass
    @property
    def validity(self) -> google.rpc.status_pb2.Status:
        """Read-only description of how the alert policy is invalid. OK if the alert
        policy is valid. If not OK, the alert policy will not generate incidents.
        """
        pass
    @property
    def notification_channels(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Identifies the notification channels to which notifications should be sent
        when incidents are opened or closed or when new violations occur on
        an already opened incident. Each element of this array corresponds to
        the `name` field in each of the
        [`NotificationChannel`][google.monitoring.v3.NotificationChannel]
        objects that are returned from the [`ListNotificationChannels`]
        [google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
        method. The format of the entries in this field is:

            projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
        """
        pass
    @property
    def creation_record(self) -> google.monitoring.v3.mutation_record_pb2.MutationRecord:
        """A read-only record of the creation of the alerting policy. If provided
        in a call to create or update, this field will be ignored.
        """
        pass
    @property
    def mutation_record(self) -> google.monitoring.v3.mutation_record_pb2.MutationRecord:
        """A read-only record of the most recent change to the alerting policy. If
        provided in a call to create or update, this field will be ignored.
        """
        pass
    @property
    def alert_strategy(self) -> global___AlertPolicy.AlertStrategy:
        """Control over how this alert policy's notification channels are notified."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        documentation : typing.Optional[global___AlertPolicy.Documentation] = ...,
        user_labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        conditions : typing.Optional[typing.Iterable[global___AlertPolicy.Condition]] = ...,
        combiner : global___AlertPolicy.ConditionCombinerType.ValueType = ...,
        enabled : typing.Optional[google.protobuf.wrappers_pb2.BoolValue] = ...,
        validity : typing.Optional[google.rpc.status_pb2.Status] = ...,
        notification_channels : typing.Optional[typing.Iterable[typing.Text]] = ...,
        creation_record : typing.Optional[google.monitoring.v3.mutation_record_pb2.MutationRecord] = ...,
        mutation_record : typing.Optional[google.monitoring.v3.mutation_record_pb2.MutationRecord] = ...,
        alert_strategy : typing.Optional[global___AlertPolicy.AlertStrategy] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["alert_strategy",b"alert_strategy","creation_record",b"creation_record","documentation",b"documentation","enabled",b"enabled","mutation_record",b"mutation_record","validity",b"validity"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["alert_strategy",b"alert_strategy","combiner",b"combiner","conditions",b"conditions","creation_record",b"creation_record","display_name",b"display_name","documentation",b"documentation","enabled",b"enabled","mutation_record",b"mutation_record","name",b"name","notification_channels",b"notification_channels","user_labels",b"user_labels","validity",b"validity"]) -> None: ...
global___AlertPolicy = AlertPolicy
