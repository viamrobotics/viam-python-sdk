"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.privacy.dlp.v2.storage_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.empty_pb2
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.rpc.status_pb2
import google.type.date_pb2
import google.type.dayofweek_pb2
import google.type.timeofday_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class _RelationalOperator:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _RelationalOperatorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RelationalOperator.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    RELATIONAL_OPERATOR_UNSPECIFIED: RelationalOperator.ValueType = ...  # 0
    """Unused"""

    EQUAL_TO: RelationalOperator.ValueType = ...  # 1
    """Equal. Attempts to match even with incompatible types."""

    NOT_EQUAL_TO: RelationalOperator.ValueType = ...  # 2
    """Not equal to. Attempts to match even with incompatible types."""

    GREATER_THAN: RelationalOperator.ValueType = ...  # 3
    """Greater than."""

    LESS_THAN: RelationalOperator.ValueType = ...  # 4
    """Less than."""

    GREATER_THAN_OR_EQUALS: RelationalOperator.ValueType = ...  # 5
    """Greater than or equals."""

    LESS_THAN_OR_EQUALS: RelationalOperator.ValueType = ...  # 6
    """Less than or equals."""

    EXISTS: RelationalOperator.ValueType = ...  # 7
    """Exists"""

class RelationalOperator(_RelationalOperator, metaclass=_RelationalOperatorEnumTypeWrapper):
    """Operators available for comparing the value of fields."""
    pass

RELATIONAL_OPERATOR_UNSPECIFIED: RelationalOperator.ValueType = ...  # 0
"""Unused"""

EQUAL_TO: RelationalOperator.ValueType = ...  # 1
"""Equal. Attempts to match even with incompatible types."""

NOT_EQUAL_TO: RelationalOperator.ValueType = ...  # 2
"""Not equal to. Attempts to match even with incompatible types."""

GREATER_THAN: RelationalOperator.ValueType = ...  # 3
"""Greater than."""

LESS_THAN: RelationalOperator.ValueType = ...  # 4
"""Less than."""

GREATER_THAN_OR_EQUALS: RelationalOperator.ValueType = ...  # 5
"""Greater than or equals."""

LESS_THAN_OR_EQUALS: RelationalOperator.ValueType = ...  # 6
"""Less than or equals."""

EXISTS: RelationalOperator.ValueType = ...  # 7
"""Exists"""

global___RelationalOperator = RelationalOperator


class _MatchingType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _MatchingTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_MatchingType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    MATCHING_TYPE_UNSPECIFIED: MatchingType.ValueType = ...  # 0
    """Invalid."""

    MATCHING_TYPE_FULL_MATCH: MatchingType.ValueType = ...  # 1
    """Full match.

    - Dictionary: join of Dictionary results matched complete finding quote
    - Regex: all regex matches fill a finding quote start to end
    - Exclude info type: completely inside affecting info types findings
    """

    MATCHING_TYPE_PARTIAL_MATCH: MatchingType.ValueType = ...  # 2
    """Partial match.

    - Dictionary: at least one of the tokens in the finding matches
    - Regex: substring of the finding matches
    - Exclude info type: intersects with affecting info types findings
    """

    MATCHING_TYPE_INVERSE_MATCH: MatchingType.ValueType = ...  # 3
    """Inverse match.

    - Dictionary: no tokens in the finding match the dictionary
    - Regex: finding doesn't match the regex
    - Exclude info type: no intersection with affecting info types findings
    """

class MatchingType(_MatchingType, metaclass=_MatchingTypeEnumTypeWrapper):
    """Type of the match which can be applied to different ways of matching, like
    Dictionary, regular expression and intersecting with findings of another
    info type.
    """
    pass

MATCHING_TYPE_UNSPECIFIED: MatchingType.ValueType = ...  # 0
"""Invalid."""

MATCHING_TYPE_FULL_MATCH: MatchingType.ValueType = ...  # 1
"""Full match.

- Dictionary: join of Dictionary results matched complete finding quote
- Regex: all regex matches fill a finding quote start to end
- Exclude info type: completely inside affecting info types findings
"""

MATCHING_TYPE_PARTIAL_MATCH: MatchingType.ValueType = ...  # 2
"""Partial match.

- Dictionary: at least one of the tokens in the finding matches
- Regex: substring of the finding matches
- Exclude info type: intersects with affecting info types findings
"""

MATCHING_TYPE_INVERSE_MATCH: MatchingType.ValueType = ...  # 3
"""Inverse match.

- Dictionary: no tokens in the finding match the dictionary
- Regex: finding doesn't match the regex
- Exclude info type: no intersection with affecting info types findings
"""

global___MatchingType = MatchingType


class _ContentOption:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _ContentOptionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ContentOption.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    CONTENT_UNSPECIFIED: ContentOption.ValueType = ...  # 0
    """Includes entire content of a file or a data stream."""

    CONTENT_TEXT: ContentOption.ValueType = ...  # 1
    """Text content within the data, excluding any metadata."""

    CONTENT_IMAGE: ContentOption.ValueType = ...  # 2
    """Images found in the data."""

class ContentOption(_ContentOption, metaclass=_ContentOptionEnumTypeWrapper):
    """Options describing which parts of the provided content should be scanned."""
    pass

CONTENT_UNSPECIFIED: ContentOption.ValueType = ...  # 0
"""Includes entire content of a file or a data stream."""

CONTENT_TEXT: ContentOption.ValueType = ...  # 1
"""Text content within the data, excluding any metadata."""

CONTENT_IMAGE: ContentOption.ValueType = ...  # 2
"""Images found in the data."""

global___ContentOption = ContentOption


class _MetadataType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _MetadataTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_MetadataType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    METADATATYPE_UNSPECIFIED: MetadataType.ValueType = ...  # 0
    """Unused"""

    STORAGE_METADATA: MetadataType.ValueType = ...  # 2
    """General file metadata provided by Cloud Storage."""

class MetadataType(_MetadataType, metaclass=_MetadataTypeEnumTypeWrapper):
    """Type of metadata containing the finding."""
    pass

METADATATYPE_UNSPECIFIED: MetadataType.ValueType = ...  # 0
"""Unused"""

STORAGE_METADATA: MetadataType.ValueType = ...  # 2
"""General file metadata provided by Cloud Storage."""

global___MetadataType = MetadataType


class _InfoTypeSupportedBy:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _InfoTypeSupportedByEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_InfoTypeSupportedBy.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    ENUM_TYPE_UNSPECIFIED: InfoTypeSupportedBy.ValueType = ...  # 0
    """Unused."""

    INSPECT: InfoTypeSupportedBy.ValueType = ...  # 1
    """Supported by the inspect operations."""

    RISK_ANALYSIS: InfoTypeSupportedBy.ValueType = ...  # 2
    """Supported by the risk analysis operations."""

class InfoTypeSupportedBy(_InfoTypeSupportedBy, metaclass=_InfoTypeSupportedByEnumTypeWrapper):
    """Parts of the APIs which use certain infoTypes."""
    pass

ENUM_TYPE_UNSPECIFIED: InfoTypeSupportedBy.ValueType = ...  # 0
"""Unused."""

INSPECT: InfoTypeSupportedBy.ValueType = ...  # 1
"""Supported by the inspect operations."""

RISK_ANALYSIS: InfoTypeSupportedBy.ValueType = ...  # 2
"""Supported by the risk analysis operations."""

global___InfoTypeSupportedBy = InfoTypeSupportedBy


class _DlpJobType:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _DlpJobTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DlpJobType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    DLP_JOB_TYPE_UNSPECIFIED: DlpJobType.ValueType = ...  # 0
    """Defaults to INSPECT_JOB."""

    INSPECT_JOB: DlpJobType.ValueType = ...  # 1
    """The job inspected Google Cloud for sensitive data."""

    RISK_ANALYSIS_JOB: DlpJobType.ValueType = ...  # 2
    """The job executed a Risk Analysis computation."""

class DlpJobType(_DlpJobType, metaclass=_DlpJobTypeEnumTypeWrapper):
    """An enum to represent the various types of DLP jobs."""
    pass

DLP_JOB_TYPE_UNSPECIFIED: DlpJobType.ValueType = ...  # 0
"""Defaults to INSPECT_JOB."""

INSPECT_JOB: DlpJobType.ValueType = ...  # 1
"""The job inspected Google Cloud for sensitive data."""

RISK_ANALYSIS_JOB: DlpJobType.ValueType = ...  # 2
"""The job executed a Risk Analysis computation."""

global___DlpJobType = DlpJobType


class _StoredInfoTypeState:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _StoredInfoTypeStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_StoredInfoTypeState.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    STORED_INFO_TYPE_STATE_UNSPECIFIED: StoredInfoTypeState.ValueType = ...  # 0
    """Unused"""

    PENDING: StoredInfoTypeState.ValueType = ...  # 1
    """StoredInfoType version is being created."""

    READY: StoredInfoTypeState.ValueType = ...  # 2
    """StoredInfoType version is ready for use."""

    FAILED: StoredInfoTypeState.ValueType = ...  # 3
    """StoredInfoType creation failed. All relevant error messages are returned in
    the `StoredInfoTypeVersion` message.
    """

    INVALID: StoredInfoTypeState.ValueType = ...  # 4
    """StoredInfoType is no longer valid because artifacts stored in
    user-controlled storage were modified. To fix an invalid StoredInfoType,
    use the `UpdateStoredInfoType` method to create a new version.
    """

class StoredInfoTypeState(_StoredInfoTypeState, metaclass=_StoredInfoTypeStateEnumTypeWrapper):
    """State of a StoredInfoType version."""
    pass

STORED_INFO_TYPE_STATE_UNSPECIFIED: StoredInfoTypeState.ValueType = ...  # 0
"""Unused"""

PENDING: StoredInfoTypeState.ValueType = ...  # 1
"""StoredInfoType version is being created."""

READY: StoredInfoTypeState.ValueType = ...  # 2
"""StoredInfoType version is ready for use."""

FAILED: StoredInfoTypeState.ValueType = ...  # 3
"""StoredInfoType creation failed. All relevant error messages are returned in
the `StoredInfoTypeVersion` message.
"""

INVALID: StoredInfoTypeState.ValueType = ...  # 4
"""StoredInfoType is no longer valid because artifacts stored in
user-controlled storage were modified. To fix an invalid StoredInfoType,
use the `UpdateStoredInfoType` method to create a new version.
"""

global___StoredInfoTypeState = StoredInfoTypeState


class ExcludeInfoTypes(google.protobuf.message.Message):
    """List of exclude infoTypes."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INFO_TYPES_FIELD_NUMBER: builtins.int
    @property
    def info_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.privacy.dlp.v2.storage_pb2.InfoType]:
        """InfoType list in ExclusionRule rule drops a finding when it overlaps or
        contained within with a finding of an infoType from this list. For
        example, for `InspectionRuleSet.info_types` containing "PHONE_NUMBER"` and
        `exclusion_rule` containing `exclude_info_types.info_types` with
        "EMAIL_ADDRESS" the phone number findings are dropped if they overlap
        with EMAIL_ADDRESS finding.
        That leads to "555-222-2222@example.org" to generate only a single
        finding, namely email address.
        """
        pass
    def __init__(self,
        *,
        info_types : typing.Optional[typing.Iterable[google.privacy.dlp.v2.storage_pb2.InfoType]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["info_types",b"info_types"]) -> None: ...
global___ExcludeInfoTypes = ExcludeInfoTypes

class ExclusionRule(google.protobuf.message.Message):
    """The rule that specifies conditions when findings of infoTypes specified in
    `InspectionRuleSet` are removed from results.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DICTIONARY_FIELD_NUMBER: builtins.int
    REGEX_FIELD_NUMBER: builtins.int
    EXCLUDE_INFO_TYPES_FIELD_NUMBER: builtins.int
    MATCHING_TYPE_FIELD_NUMBER: builtins.int
    @property
    def dictionary(self) -> google.privacy.dlp.v2.storage_pb2.CustomInfoType.Dictionary:
        """Dictionary which defines the rule."""
        pass
    @property
    def regex(self) -> google.privacy.dlp.v2.storage_pb2.CustomInfoType.Regex:
        """Regular expression which defines the rule."""
        pass
    @property
    def exclude_info_types(self) -> global___ExcludeInfoTypes:
        """Set of infoTypes for which findings would affect this rule."""
        pass
    matching_type: global___MatchingType.ValueType = ...
    """How the rule is applied, see MatchingType documentation for details."""

    def __init__(self,
        *,
        dictionary : typing.Optional[google.privacy.dlp.v2.storage_pb2.CustomInfoType.Dictionary] = ...,
        regex : typing.Optional[google.privacy.dlp.v2.storage_pb2.CustomInfoType.Regex] = ...,
        exclude_info_types : typing.Optional[global___ExcludeInfoTypes] = ...,
        matching_type : global___MatchingType.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dictionary",b"dictionary","exclude_info_types",b"exclude_info_types","regex",b"regex","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dictionary",b"dictionary","exclude_info_types",b"exclude_info_types","matching_type",b"matching_type","regex",b"regex","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["dictionary","regex","exclude_info_types"]]: ...
global___ExclusionRule = ExclusionRule

class InspectionRule(google.protobuf.message.Message):
    """A single inspection rule to be applied to infoTypes, specified in
    `InspectionRuleSet`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    HOTWORD_RULE_FIELD_NUMBER: builtins.int
    EXCLUSION_RULE_FIELD_NUMBER: builtins.int
    @property
    def hotword_rule(self) -> google.privacy.dlp.v2.storage_pb2.CustomInfoType.DetectionRule.HotwordRule:
        """Hotword-based detection rule."""
        pass
    @property
    def exclusion_rule(self) -> global___ExclusionRule:
        """Exclusion rule."""
        pass
    def __init__(self,
        *,
        hotword_rule : typing.Optional[google.privacy.dlp.v2.storage_pb2.CustomInfoType.DetectionRule.HotwordRule] = ...,
        exclusion_rule : typing.Optional[global___ExclusionRule] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["exclusion_rule",b"exclusion_rule","hotword_rule",b"hotword_rule","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["exclusion_rule",b"exclusion_rule","hotword_rule",b"hotword_rule","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["hotword_rule","exclusion_rule"]]: ...
global___InspectionRule = InspectionRule

class InspectionRuleSet(google.protobuf.message.Message):
    """Rule set for modifying a set of infoTypes to alter behavior under certain
    circumstances, depending on the specific details of the rules within the set.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INFO_TYPES_FIELD_NUMBER: builtins.int
    RULES_FIELD_NUMBER: builtins.int
    @property
    def info_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.privacy.dlp.v2.storage_pb2.InfoType]:
        """List of infoTypes this rule set is applied to."""
        pass
    @property
    def rules(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InspectionRule]:
        """Set of rules to be applied to infoTypes. The rules are applied in order."""
        pass
    def __init__(self,
        *,
        info_types : typing.Optional[typing.Iterable[google.privacy.dlp.v2.storage_pb2.InfoType]] = ...,
        rules : typing.Optional[typing.Iterable[global___InspectionRule]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["info_types",b"info_types","rules",b"rules"]) -> None: ...
global___InspectionRuleSet = InspectionRuleSet

class InspectConfig(google.protobuf.message.Message):
    """Configuration description of the scanning process.
    When used with redactContent only info_types and min_likelihood are currently
    used.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class FindingLimits(google.protobuf.message.Message):
        """Configuration to control the number of findings returned. Cannot be set if
        de-identification is requested.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class InfoTypeLimit(google.protobuf.message.Message):
            """Max findings configuration per infoType, per content item or long
            running DlpJob.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            INFO_TYPE_FIELD_NUMBER: builtins.int
            MAX_FINDINGS_FIELD_NUMBER: builtins.int
            @property
            def info_type(self) -> google.privacy.dlp.v2.storage_pb2.InfoType:
                """Type of information the findings limit applies to. Only one limit per
                info_type should be provided. If InfoTypeLimit does not have an
                info_type, the DLP API applies the limit against all info_types that
                are found but not specified in another InfoTypeLimit.
                """
                pass
            max_findings: builtins.int = ...
            """Max findings limit for the given infoType."""

            def __init__(self,
                *,
                info_type : typing.Optional[google.privacy.dlp.v2.storage_pb2.InfoType] = ...,
                max_findings : builtins.int = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["info_type",b"info_type"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["info_type",b"info_type","max_findings",b"max_findings"]) -> None: ...

        MAX_FINDINGS_PER_ITEM_FIELD_NUMBER: builtins.int
        MAX_FINDINGS_PER_REQUEST_FIELD_NUMBER: builtins.int
        MAX_FINDINGS_PER_INFO_TYPE_FIELD_NUMBER: builtins.int
        max_findings_per_item: builtins.int = ...
        """Max number of findings that will be returned for each item scanned.
        When set within `InspectJobConfig`,
        the maximum returned is 2000 regardless if this is set higher.
        When set within `InspectContentRequest`, this field is ignored.
        """

        max_findings_per_request: builtins.int = ...
        """Max number of findings that will be returned per request/job.
        When set within `InspectContentRequest`, the maximum returned is 2000
        regardless if this is set higher.
        """

        @property
        def max_findings_per_info_type(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InspectConfig.FindingLimits.InfoTypeLimit]:
            """Configuration of findings limit given for specified infoTypes."""
            pass
        def __init__(self,
            *,
            max_findings_per_item : builtins.int = ...,
            max_findings_per_request : builtins.int = ...,
            max_findings_per_info_type : typing.Optional[typing.Iterable[global___InspectConfig.FindingLimits.InfoTypeLimit]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["max_findings_per_info_type",b"max_findings_per_info_type","max_findings_per_item",b"max_findings_per_item","max_findings_per_request",b"max_findings_per_request"]) -> None: ...

    INFO_TYPES_FIELD_NUMBER: builtins.int
    MIN_LIKELIHOOD_FIELD_NUMBER: builtins.int
    LIMITS_FIELD_NUMBER: builtins.int
    INCLUDE_QUOTE_FIELD_NUMBER: builtins.int
    EXCLUDE_INFO_TYPES_FIELD_NUMBER: builtins.int
    CUSTOM_INFO_TYPES_FIELD_NUMBER: builtins.int
    CONTENT_OPTIONS_FIELD_NUMBER: builtins.int
    RULE_SET_FIELD_NUMBER: builtins.int
    @property
    def info_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.privacy.dlp.v2.storage_pb2.InfoType]:
        """Restricts what info_types to look for. The values must correspond to
        InfoType values returned by ListInfoTypes or listed at
        https://cloud.google.com/dlp/docs/infotypes-reference.

        When no InfoTypes or CustomInfoTypes are specified in a request, the
        system may automatically choose what detectors to run. By default this may
        be all types, but may change over time as detectors are updated.

        If you need precise control and predictability as to what detectors are
        run you should specify specific InfoTypes listed in the reference,
        otherwise a default list will be used, which may change over time.
        """
        pass
    min_likelihood: google.privacy.dlp.v2.storage_pb2.Likelihood.ValueType = ...
    """Only returns findings equal or above this threshold. The default is
    POSSIBLE.
    See https://cloud.google.com/dlp/docs/likelihood to learn more.
    """

    @property
    def limits(self) -> global___InspectConfig.FindingLimits:
        """Configuration to control the number of findings returned."""
        pass
    include_quote: builtins.bool = ...
    """When true, a contextual quote from the data that triggered a finding is
    included in the response; see Finding.quote.
    """

    exclude_info_types: builtins.bool = ...
    """When true, excludes type information of the findings."""

    @property
    def custom_info_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.privacy.dlp.v2.storage_pb2.CustomInfoType]:
        """CustomInfoTypes provided by the user. See
        https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
        """
        pass
    @property
    def content_options(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___ContentOption.ValueType]:
        """List of options defining data content to scan.
        If empty, text, images, and other content will be included.
        """
        pass
    @property
    def rule_set(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InspectionRuleSet]:
        """Set of rules to apply to the findings for this InspectConfig.
        Exclusion rules, contained in the set are executed in the end, other
        rules are executed in the order they are specified for each info type.
        """
        pass
    def __init__(self,
        *,
        info_types : typing.Optional[typing.Iterable[google.privacy.dlp.v2.storage_pb2.InfoType]] = ...,
        min_likelihood : google.privacy.dlp.v2.storage_pb2.Likelihood.ValueType = ...,
        limits : typing.Optional[global___InspectConfig.FindingLimits] = ...,
        include_quote : builtins.bool = ...,
        exclude_info_types : builtins.bool = ...,
        custom_info_types : typing.Optional[typing.Iterable[google.privacy.dlp.v2.storage_pb2.CustomInfoType]] = ...,
        content_options : typing.Optional[typing.Iterable[global___ContentOption.ValueType]] = ...,
        rule_set : typing.Optional[typing.Iterable[global___InspectionRuleSet]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["limits",b"limits"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["content_options",b"content_options","custom_info_types",b"custom_info_types","exclude_info_types",b"exclude_info_types","include_quote",b"include_quote","info_types",b"info_types","limits",b"limits","min_likelihood",b"min_likelihood","rule_set",b"rule_set"]) -> None: ...
global___InspectConfig = InspectConfig

class ByteContentItem(google.protobuf.message.Message):
    """Container for bytes to inspect or redact."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _BytesType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _BytesTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_BytesType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        BYTES_TYPE_UNSPECIFIED: ByteContentItem.BytesType.ValueType = ...  # 0
        """Unused"""

        IMAGE: ByteContentItem.BytesType.ValueType = ...  # 6
        """Any image type."""

        IMAGE_JPEG: ByteContentItem.BytesType.ValueType = ...  # 1
        """jpeg"""

        IMAGE_BMP: ByteContentItem.BytesType.ValueType = ...  # 2
        """bmp"""

        IMAGE_PNG: ByteContentItem.BytesType.ValueType = ...  # 3
        """png"""

        IMAGE_SVG: ByteContentItem.BytesType.ValueType = ...  # 4
        """svg"""

        TEXT_UTF8: ByteContentItem.BytesType.ValueType = ...  # 5
        """plain text"""

        WORD_DOCUMENT: ByteContentItem.BytesType.ValueType = ...  # 7
        """docx, docm, dotx, dotm"""

        PDF: ByteContentItem.BytesType.ValueType = ...  # 8
        """pdf"""

        AVRO: ByteContentItem.BytesType.ValueType = ...  # 11
        """avro"""

        CSV: ByteContentItem.BytesType.ValueType = ...  # 12
        """csv"""

        TSV: ByteContentItem.BytesType.ValueType = ...  # 13
        """tsv"""

    class BytesType(_BytesType, metaclass=_BytesTypeEnumTypeWrapper):
        """The type of data being sent for inspection. To learn more, see
        [Supported file
        types](https://cloud.google.com/dlp/docs/supported-file-types).
        """
        pass

    BYTES_TYPE_UNSPECIFIED: ByteContentItem.BytesType.ValueType = ...  # 0
    """Unused"""

    IMAGE: ByteContentItem.BytesType.ValueType = ...  # 6
    """Any image type."""

    IMAGE_JPEG: ByteContentItem.BytesType.ValueType = ...  # 1
    """jpeg"""

    IMAGE_BMP: ByteContentItem.BytesType.ValueType = ...  # 2
    """bmp"""

    IMAGE_PNG: ByteContentItem.BytesType.ValueType = ...  # 3
    """png"""

    IMAGE_SVG: ByteContentItem.BytesType.ValueType = ...  # 4
    """svg"""

    TEXT_UTF8: ByteContentItem.BytesType.ValueType = ...  # 5
    """plain text"""

    WORD_DOCUMENT: ByteContentItem.BytesType.ValueType = ...  # 7
    """docx, docm, dotx, dotm"""

    PDF: ByteContentItem.BytesType.ValueType = ...  # 8
    """pdf"""

    AVRO: ByteContentItem.BytesType.ValueType = ...  # 11
    """avro"""

    CSV: ByteContentItem.BytesType.ValueType = ...  # 12
    """csv"""

    TSV: ByteContentItem.BytesType.ValueType = ...  # 13
    """tsv"""


    TYPE_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    type: global___ByteContentItem.BytesType.ValueType = ...
    """The type of data stored in the bytes string. Default will be TEXT_UTF8."""

    data: builtins.bytes = ...
    """Content data to inspect or redact."""

    def __init__(self,
        *,
        type : global___ByteContentItem.BytesType.ValueType = ...,
        data : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["data",b"data","type",b"type"]) -> None: ...
global___ByteContentItem = ByteContentItem

class ContentItem(google.protobuf.message.Message):
    """Container structure for the content to inspect."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VALUE_FIELD_NUMBER: builtins.int
    TABLE_FIELD_NUMBER: builtins.int
    BYTE_ITEM_FIELD_NUMBER: builtins.int
    value: typing.Text = ...
    """String data to inspect or redact."""

    @property
    def table(self) -> global___Table:
        """Structured content for inspection. See
        https://cloud.google.com/dlp/docs/inspecting-text#inspecting_a_table to
        learn more.
        """
        pass
    @property
    def byte_item(self) -> global___ByteContentItem:
        """Content data to inspect or redact. Replaces `type` and `data`."""
        pass
    def __init__(self,
        *,
        value : typing.Text = ...,
        table : typing.Optional[global___Table] = ...,
        byte_item : typing.Optional[global___ByteContentItem] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["byte_item",b"byte_item","data_item",b"data_item","table",b"table","value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["byte_item",b"byte_item","data_item",b"data_item","table",b"table","value",b"value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["data_item",b"data_item"]) -> typing.Optional[typing_extensions.Literal["value","table","byte_item"]]: ...
global___ContentItem = ContentItem

class Table(google.protobuf.message.Message):
    """Structured content to inspect. Up to 50,000 `Value`s per request allowed. See
    https://cloud.google.com/dlp/docs/inspecting-structured-text#inspecting_a_table
    to learn more.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Row(google.protobuf.message.Message):
        """Values of the row."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        VALUES_FIELD_NUMBER: builtins.int
        @property
        def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Value]:
            """Individual cells."""
            pass
        def __init__(self,
            *,
            values : typing.Optional[typing.Iterable[global___Value]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["values",b"values"]) -> None: ...

    HEADERS_FIELD_NUMBER: builtins.int
    ROWS_FIELD_NUMBER: builtins.int
    @property
    def headers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.privacy.dlp.v2.storage_pb2.FieldId]:
        """Headers of the table."""
        pass
    @property
    def rows(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Table.Row]:
        """Rows of the table."""
        pass
    def __init__(self,
        *,
        headers : typing.Optional[typing.Iterable[google.privacy.dlp.v2.storage_pb2.FieldId]] = ...,
        rows : typing.Optional[typing.Iterable[global___Table.Row]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["headers",b"headers","rows",b"rows"]) -> None: ...
global___Table = Table

class InspectResult(google.protobuf.message.Message):
    """All the findings for a single scanned item."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FINDINGS_FIELD_NUMBER: builtins.int
    FINDINGS_TRUNCATED_FIELD_NUMBER: builtins.int
    @property
    def findings(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Finding]:
        """List of findings for an item."""
        pass
    findings_truncated: builtins.bool = ...
    """If true, then this item might have more findings than were returned,
    and the findings returned are an arbitrary subset of all findings.
    The findings list might be truncated because the input items were too
    large, or because the server reached the maximum amount of resources
    allowed for a single API call. For best results, divide the input into
    smaller batches.
    """

    def __init__(self,
        *,
        findings : typing.Optional[typing.Iterable[global___Finding]] = ...,
        findings_truncated : builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["findings",b"findings","findings_truncated",b"findings_truncated"]) -> None: ...
global___InspectResult = InspectResult

class Finding(google.protobuf.message.Message):
    """Represents a piece of potentially sensitive content."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    QUOTE_FIELD_NUMBER: builtins.int
    INFO_TYPE_FIELD_NUMBER: builtins.int
    LIKELIHOOD_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    QUOTE_INFO_FIELD_NUMBER: builtins.int
    RESOURCE_NAME_FIELD_NUMBER: builtins.int
    TRIGGER_NAME_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    JOB_CREATE_TIME_FIELD_NUMBER: builtins.int
    JOB_NAME_FIELD_NUMBER: builtins.int
    FINDING_ID_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Resource name in format
    projects/{project}/locations/{location}/findings/{finding} Populated only
    when viewing persisted findings.
    """

    quote: typing.Text = ...
    """The content that was found. Even if the content is not textual, it
    may be converted to a textual representation here.
    Provided if `include_quote` is true and the finding is
    less than or equal to 4096 bytes long. If the finding exceeds 4096 bytes
    in length, the quote may be omitted.
    """

    @property
    def info_type(self) -> google.privacy.dlp.v2.storage_pb2.InfoType:
        """The type of content that might have been found.
        Provided if `excluded_types` is false.
        """
        pass
    likelihood: google.privacy.dlp.v2.storage_pb2.Likelihood.ValueType = ...
    """Confidence of how likely it is that the `info_type` is correct."""

    @property
    def location(self) -> global___Location:
        """Where the content was found."""
        pass
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Timestamp when finding was detected."""
        pass
    @property
    def quote_info(self) -> global___QuoteInfo:
        """Contains data parsed from quotes. Only populated if include_quote was set
        to true and a supported infoType was requested. Currently supported
        infoTypes: DATE, DATE_OF_BIRTH and TIME.
        """
        pass
    resource_name: typing.Text = ...
    """The job that stored the finding."""

    trigger_name: typing.Text = ...
    """Job trigger name, if applicable, for this finding."""

    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """The labels associated with this `Finding`.

        Label keys must be between 1 and 63 characters long and must conform
        to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.

        Label values must be between 0 and 63 characters long and must conform
        to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.

        No more than 10 labels can be associated with a given finding.

        Examples:
        * `"environment" : "production"`
        * `"pipeline" : "etl"`
        """
        pass
    @property
    def job_create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time the job started that produced this finding."""
        pass
    job_name: typing.Text = ...
    """The job that stored the finding."""

    finding_id: typing.Text = ...
    """The unique finding id."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        quote : typing.Text = ...,
        info_type : typing.Optional[google.privacy.dlp.v2.storage_pb2.InfoType] = ...,
        likelihood : google.privacy.dlp.v2.storage_pb2.Likelihood.ValueType = ...,
        location : typing.Optional[global___Location] = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        quote_info : typing.Optional[global___QuoteInfo] = ...,
        resource_name : typing.Text = ...,
        trigger_name : typing.Text = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        job_create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        job_name : typing.Text = ...,
        finding_id : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time",b"create_time","info_type",b"info_type","job_create_time",b"job_create_time","location",b"location","quote_info",b"quote_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time",b"create_time","finding_id",b"finding_id","info_type",b"info_type","job_create_time",b"job_create_time","job_name",b"job_name","labels",b"labels","likelihood",b"likelihood","location",b"location","name",b"name","quote",b"quote","quote_info",b"quote_info","resource_name",b"resource_name","trigger_name",b"trigger_name"]) -> None: ...
global___Finding = Finding

class Location(google.protobuf.message.Message):
    """Specifies the location of the finding."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    BYTE_RANGE_FIELD_NUMBER: builtins.int
    CODEPOINT_RANGE_FIELD_NUMBER: builtins.int
    CONTENT_LOCATIONS_FIELD_NUMBER: builtins.int
    CONTAINER_FIELD_NUMBER: builtins.int
    @property
    def byte_range(self) -> global___Range:
        """Zero-based byte offsets delimiting the finding.
        These are relative to the finding's containing element.
        Note that when the content is not textual, this references
        the UTF-8 encoded textual representation of the content.
        Omitted if content is an image.
        """
        pass
    @property
    def codepoint_range(self) -> global___Range:
        """Unicode character offsets delimiting the finding.
        These are relative to the finding's containing element.
        Provided when the content is text.
        """
        pass
    @property
    def content_locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ContentLocation]:
        """List of nested objects pointing to the precise location of the finding
        within the file or record.
        """
        pass
    @property
    def container(self) -> global___Container:
        """Information about the container where this finding occurred, if available."""
        pass
    def __init__(self,
        *,
        byte_range : typing.Optional[global___Range] = ...,
        codepoint_range : typing.Optional[global___Range] = ...,
        content_locations : typing.Optional[typing.Iterable[global___ContentLocation]] = ...,
        container : typing.Optional[global___Container] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["byte_range",b"byte_range","codepoint_range",b"codepoint_range","container",b"container"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["byte_range",b"byte_range","codepoint_range",b"codepoint_range","container",b"container","content_locations",b"content_locations"]) -> None: ...
global___Location = Location

class ContentLocation(google.protobuf.message.Message):
    """Precise location of the finding within a document, record, image, or metadata
    container.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONTAINER_NAME_FIELD_NUMBER: builtins.int
    RECORD_LOCATION_FIELD_NUMBER: builtins.int
    IMAGE_LOCATION_FIELD_NUMBER: builtins.int
    DOCUMENT_LOCATION_FIELD_NUMBER: builtins.int
    METADATA_LOCATION_FIELD_NUMBER: builtins.int
    CONTAINER_TIMESTAMP_FIELD_NUMBER: builtins.int
    CONTAINER_VERSION_FIELD_NUMBER: builtins.int
    container_name: typing.Text = ...
    """Name of the container where the finding is located.
    The top level name is the source file name or table name. Names of some
    common storage containers are formatted as follows:

    * BigQuery tables:  `{project_id}:{dataset_id}.{table_id}`
    * Cloud Storage files: `gs://{bucket}/{path}`
    * Datastore namespace: {namespace}

    Nested names could be absent if the embedded object has no string
    identifier (for an example an image contained within a document).
    """

    @property
    def record_location(self) -> global___RecordLocation:
        """Location within a row or record of a database table."""
        pass
    @property
    def image_location(self) -> global___ImageLocation:
        """Location within an image's pixels."""
        pass
    @property
    def document_location(self) -> global___DocumentLocation:
        """Location data for document files."""
        pass
    @property
    def metadata_location(self) -> global___MetadataLocation:
        """Location within the metadata for inspected content."""
        pass
    @property
    def container_timestamp(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Findings container modification timestamp, if applicable.
        For Google Cloud Storage contains last file modification timestamp.
        For BigQuery table contains last_modified_time property.
        For Datastore - not populated.
        """
        pass
    container_version: typing.Text = ...
    """Findings container version, if available
    ("generation" for Google Cloud Storage).
    """

    def __init__(self,
        *,
        container_name : typing.Text = ...,
        record_location : typing.Optional[global___RecordLocation] = ...,
        image_location : typing.Optional[global___ImageLocation] = ...,
        document_location : typing.Optional[global___DocumentLocation] = ...,
        metadata_location : typing.Optional[global___MetadataLocation] = ...,
        container_timestamp : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        container_version : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["container_timestamp",b"container_timestamp","document_location",b"document_location","image_location",b"image_location","location",b"location","metadata_location",b"metadata_location","record_location",b"record_location"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["container_name",b"container_name","container_timestamp",b"container_timestamp","container_version",b"container_version","document_location",b"document_location","image_location",b"image_location","location",b"location","metadata_location",b"metadata_location","record_location",b"record_location"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["location",b"location"]) -> typing.Optional[typing_extensions.Literal["record_location","image_location","document_location","metadata_location"]]: ...
global___ContentLocation = ContentLocation

class MetadataLocation(google.protobuf.message.Message):
    """Metadata Location"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TYPE_FIELD_NUMBER: builtins.int
    STORAGE_LABEL_FIELD_NUMBER: builtins.int
    type: global___MetadataType.ValueType = ...
    """Type of metadata containing the finding."""

    @property
    def storage_label(self) -> global___StorageMetadataLabel:
        """Storage metadata."""
        pass
    def __init__(self,
        *,
        type : global___MetadataType.ValueType = ...,
        storage_label : typing.Optional[global___StorageMetadataLabel] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["label",b"label","storage_label",b"storage_label"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["label",b"label","storage_label",b"storage_label","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["label",b"label"]) -> typing.Optional[typing_extensions.Literal["storage_label"]]: ...
global___MetadataLocation = MetadataLocation

class StorageMetadataLabel(google.protobuf.message.Message):
    """Storage metadata label to indicate which metadata entry contains findings."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_FIELD_NUMBER: builtins.int
    key: typing.Text = ...
    def __init__(self,
        *,
        key : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["key",b"key"]) -> None: ...
global___StorageMetadataLabel = StorageMetadataLabel

class DocumentLocation(google.protobuf.message.Message):
    """Location of a finding within a document."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FILE_OFFSET_FIELD_NUMBER: builtins.int
    file_offset: builtins.int = ...
    """Offset of the line, from the beginning of the file, where the finding
    is located.
    """

    def __init__(self,
        *,
        file_offset : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["file_offset",b"file_offset"]) -> None: ...
global___DocumentLocation = DocumentLocation

class RecordLocation(google.protobuf.message.Message):
    """Location of a finding within a row or record."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RECORD_KEY_FIELD_NUMBER: builtins.int
    FIELD_ID_FIELD_NUMBER: builtins.int
    TABLE_LOCATION_FIELD_NUMBER: builtins.int
    @property
    def record_key(self) -> google.privacy.dlp.v2.storage_pb2.RecordKey:
        """Key of the finding."""
        pass
    @property
    def field_id(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
        """Field id of the field containing the finding."""
        pass
    @property
    def table_location(self) -> global___TableLocation:
        """Location within a `ContentItem.Table`."""
        pass
    def __init__(self,
        *,
        record_key : typing.Optional[google.privacy.dlp.v2.storage_pb2.RecordKey] = ...,
        field_id : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
        table_location : typing.Optional[global___TableLocation] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["field_id",b"field_id","record_key",b"record_key","table_location",b"table_location"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["field_id",b"field_id","record_key",b"record_key","table_location",b"table_location"]) -> None: ...
global___RecordLocation = RecordLocation

class TableLocation(google.protobuf.message.Message):
    """Location of a finding within a table."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ROW_INDEX_FIELD_NUMBER: builtins.int
    row_index: builtins.int = ...
    """The zero-based index of the row where the finding is located. Only
    populated for resources that have a natural ordering, not BigQuery. In
    BigQuery, to identify the row a finding came from, populate
    BigQueryOptions.identifying_fields with your primary key column names and
    when you store the findings the value of those columns will be stored
    inside of Finding.
    """

    def __init__(self,
        *,
        row_index : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["row_index",b"row_index"]) -> None: ...
global___TableLocation = TableLocation

class Container(google.protobuf.message.Message):
    """Represents a container that may contain DLP findings.
    Examples of a container include a file, table, or database record.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TYPE_FIELD_NUMBER: builtins.int
    PROJECT_ID_FIELD_NUMBER: builtins.int
    FULL_PATH_FIELD_NUMBER: builtins.int
    ROOT_PATH_FIELD_NUMBER: builtins.int
    RELATIVE_PATH_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    type: typing.Text = ...
    """Container type, for example BigQuery or Google Cloud Storage."""

    project_id: typing.Text = ...
    """Project where the finding was found.
    Can be different from the project that owns the finding.
    """

    full_path: typing.Text = ...
    """A string representation of the full container name.
    Examples:
    - BigQuery: 'Project:DataSetId.TableId'
    - Google Cloud Storage: 'gs://Bucket/folders/filename.txt'
    """

    root_path: typing.Text = ...
    """The root of the container.
    Examples:
    - For BigQuery table `project_id:dataset_id.table_id`, the root is
     `dataset_id`
    - For Google Cloud Storage file `gs://bucket/folder/filename.txt`, the root
     is `gs://bucket`
    """

    relative_path: typing.Text = ...
    """The rest of the path after the root.
    Examples:
    - For BigQuery table `project_id:dataset_id.table_id`, the relative path is
     `table_id`
    - Google Cloud Storage file `gs://bucket/folder/filename.txt`, the relative
     path is `folder/filename.txt`
    """

    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Findings container modification timestamp, if applicable.
        For Google Cloud Storage contains last file modification timestamp.
        For BigQuery table contains last_modified_time property.
        For Datastore - not populated.
        """
        pass
    version: typing.Text = ...
    """Findings container version, if available
    ("generation" for Google Cloud Storage).
    """

    def __init__(self,
        *,
        type : typing.Text = ...,
        project_id : typing.Text = ...,
        full_path : typing.Text = ...,
        root_path : typing.Text = ...,
        relative_path : typing.Text = ...,
        update_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        version : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["update_time",b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["full_path",b"full_path","project_id",b"project_id","relative_path",b"relative_path","root_path",b"root_path","type",b"type","update_time",b"update_time","version",b"version"]) -> None: ...
global___Container = Container

class Range(google.protobuf.message.Message):
    """Generic half-open interval [start, end)"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    START_FIELD_NUMBER: builtins.int
    END_FIELD_NUMBER: builtins.int
    start: builtins.int = ...
    """Index of the first character of the range (inclusive)."""

    end: builtins.int = ...
    """Index of the last character of the range (exclusive)."""

    def __init__(self,
        *,
        start : builtins.int = ...,
        end : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["end",b"end","start",b"start"]) -> None: ...
global___Range = Range

class ImageLocation(google.protobuf.message.Message):
    """Location of the finding within an image."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    BOUNDING_BOXES_FIELD_NUMBER: builtins.int
    @property
    def bounding_boxes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BoundingBox]:
        """Bounding boxes locating the pixels within the image containing the finding."""
        pass
    def __init__(self,
        *,
        bounding_boxes : typing.Optional[typing.Iterable[global___BoundingBox]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["bounding_boxes",b"bounding_boxes"]) -> None: ...
global___ImageLocation = ImageLocation

class BoundingBox(google.protobuf.message.Message):
    """Bounding box encompassing detected text within an image."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TOP_FIELD_NUMBER: builtins.int
    LEFT_FIELD_NUMBER: builtins.int
    WIDTH_FIELD_NUMBER: builtins.int
    HEIGHT_FIELD_NUMBER: builtins.int
    top: builtins.int = ...
    """Top coordinate of the bounding box. (0,0) is upper left."""

    left: builtins.int = ...
    """Left coordinate of the bounding box. (0,0) is upper left."""

    width: builtins.int = ...
    """Width of the bounding box in pixels."""

    height: builtins.int = ...
    """Height of the bounding box in pixels."""

    def __init__(self,
        *,
        top : builtins.int = ...,
        left : builtins.int = ...,
        width : builtins.int = ...,
        height : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["height",b"height","left",b"left","top",b"top","width",b"width"]) -> None: ...
global___BoundingBox = BoundingBox

class RedactImageRequest(google.protobuf.message.Message):
    """Request to search for potentially sensitive info in an image and redact it
    by covering it with a colored rectangle.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ImageRedactionConfig(google.protobuf.message.Message):
        """Configuration for determining how redaction of images should occur."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        INFO_TYPE_FIELD_NUMBER: builtins.int
        REDACT_ALL_TEXT_FIELD_NUMBER: builtins.int
        REDACTION_COLOR_FIELD_NUMBER: builtins.int
        @property
        def info_type(self) -> google.privacy.dlp.v2.storage_pb2.InfoType:
            """Only one per info_type should be provided per request. If not
            specified, and redact_all_text is false, the DLP API will redact all
            text that it matches against all info_types that are found, but not
            specified in another ImageRedactionConfig.
            """
            pass
        redact_all_text: builtins.bool = ...
        """If true, all text found in the image, regardless whether it matches an
        info_type, is redacted. Only one should be provided.
        """

        @property
        def redaction_color(self) -> global___Color:
            """The color to use when redacting content from an image. If not specified,
            the default is black.
            """
            pass
        def __init__(self,
            *,
            info_type : typing.Optional[google.privacy.dlp.v2.storage_pb2.InfoType] = ...,
            redact_all_text : builtins.bool = ...,
            redaction_color : typing.Optional[global___Color] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["info_type",b"info_type","redact_all_text",b"redact_all_text","redaction_color",b"redaction_color","target",b"target"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["info_type",b"info_type","redact_all_text",b"redact_all_text","redaction_color",b"redaction_color","target",b"target"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["target",b"target"]) -> typing.Optional[typing_extensions.Literal["info_type","redact_all_text"]]: ...

    PARENT_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    INSPECT_CONFIG_FIELD_NUMBER: builtins.int
    IMAGE_REDACTION_CONFIGS_FIELD_NUMBER: builtins.int
    INCLUDE_FINDINGS_FIELD_NUMBER: builtins.int
    BYTE_ITEM_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Parent resource name.

    The format of this value varies depending on whether you have [specified a
    processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    @property
    def inspect_config(self) -> global___InspectConfig:
        """Configuration for the inspector."""
        pass
    @property
    def image_redaction_configs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RedactImageRequest.ImageRedactionConfig]:
        """The configuration for specifying what content to redact from images."""
        pass
    include_findings: builtins.bool = ...
    """Whether the response should include findings along with the redacted
    image.
    """

    @property
    def byte_item(self) -> global___ByteContentItem:
        """The content must be PNG, JPEG, SVG or BMP."""
        pass
    def __init__(self,
        *,
        parent : typing.Text = ...,
        location_id : typing.Text = ...,
        inspect_config : typing.Optional[global___InspectConfig] = ...,
        image_redaction_configs : typing.Optional[typing.Iterable[global___RedactImageRequest.ImageRedactionConfig]] = ...,
        include_findings : builtins.bool = ...,
        byte_item : typing.Optional[global___ByteContentItem] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["byte_item",b"byte_item","inspect_config",b"inspect_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["byte_item",b"byte_item","image_redaction_configs",b"image_redaction_configs","include_findings",b"include_findings","inspect_config",b"inspect_config","location_id",b"location_id","parent",b"parent"]) -> None: ...
global___RedactImageRequest = RedactImageRequest

class Color(google.protobuf.message.Message):
    """Represents a color in the RGB color space."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RED_FIELD_NUMBER: builtins.int
    GREEN_FIELD_NUMBER: builtins.int
    BLUE_FIELD_NUMBER: builtins.int
    red: builtins.float = ...
    """The amount of red in the color as a value in the interval [0, 1]."""

    green: builtins.float = ...
    """The amount of green in the color as a value in the interval [0, 1]."""

    blue: builtins.float = ...
    """The amount of blue in the color as a value in the interval [0, 1]."""

    def __init__(self,
        *,
        red : builtins.float = ...,
        green : builtins.float = ...,
        blue : builtins.float = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["blue",b"blue","green",b"green","red",b"red"]) -> None: ...
global___Color = Color

class RedactImageResponse(google.protobuf.message.Message):
    """Results of redacting an image."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    REDACTED_IMAGE_FIELD_NUMBER: builtins.int
    EXTRACTED_TEXT_FIELD_NUMBER: builtins.int
    INSPECT_RESULT_FIELD_NUMBER: builtins.int
    redacted_image: builtins.bytes = ...
    """The redacted image. The type will be the same as the original image."""

    extracted_text: typing.Text = ...
    """If an image was being inspected and the InspectConfig's include_quote was
    set to true, then this field will include all text, if any, that was found
    in the image.
    """

    @property
    def inspect_result(self) -> global___InspectResult:
        """The findings. Populated when include_findings in the request is true."""
        pass
    def __init__(self,
        *,
        redacted_image : builtins.bytes = ...,
        extracted_text : typing.Text = ...,
        inspect_result : typing.Optional[global___InspectResult] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["inspect_result",b"inspect_result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["extracted_text",b"extracted_text","inspect_result",b"inspect_result","redacted_image",b"redacted_image"]) -> None: ...
global___RedactImageResponse = RedactImageResponse

class DeidentifyContentRequest(google.protobuf.message.Message):
    """Request to de-identify a list of items."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    DEIDENTIFY_CONFIG_FIELD_NUMBER: builtins.int
    INSPECT_CONFIG_FIELD_NUMBER: builtins.int
    ITEM_FIELD_NUMBER: builtins.int
    INSPECT_TEMPLATE_NAME_FIELD_NUMBER: builtins.int
    DEIDENTIFY_TEMPLATE_NAME_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Parent resource name.

    The format of this value varies depending on whether you have [specified a
    processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    @property
    def deidentify_config(self) -> global___DeidentifyConfig:
        """Configuration for the de-identification of the content item.
        Items specified here will override the template referenced by the
        deidentify_template_name argument.
        """
        pass
    @property
    def inspect_config(self) -> global___InspectConfig:
        """Configuration for the inspector.
        Items specified here will override the template referenced by the
        inspect_template_name argument.
        """
        pass
    @property
    def item(self) -> global___ContentItem:
        """The item to de-identify. Will be treated as text."""
        pass
    inspect_template_name: typing.Text = ...
    """Template to use. Any configuration directly specified in
    inspect_config will override those set in the template. Singular fields
    that are set in this request will replace their corresponding fields in the
    template. Repeated fields are appended. Singular sub-messages and groups
    are recursively merged.
    """

    deidentify_template_name: typing.Text = ...
    """Template to use. Any configuration directly specified in
    deidentify_config will override those set in the template. Singular fields
    that are set in this request will replace their corresponding fields in the
    template. Repeated fields are appended. Singular sub-messages and groups
    are recursively merged.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        deidentify_config : typing.Optional[global___DeidentifyConfig] = ...,
        inspect_config : typing.Optional[global___InspectConfig] = ...,
        item : typing.Optional[global___ContentItem] = ...,
        inspect_template_name : typing.Text = ...,
        deidentify_template_name : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["deidentify_config",b"deidentify_config","inspect_config",b"inspect_config","item",b"item"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["deidentify_config",b"deidentify_config","deidentify_template_name",b"deidentify_template_name","inspect_config",b"inspect_config","inspect_template_name",b"inspect_template_name","item",b"item","location_id",b"location_id","parent",b"parent"]) -> None: ...
global___DeidentifyContentRequest = DeidentifyContentRequest

class DeidentifyContentResponse(google.protobuf.message.Message):
    """Results of de-identifying a ContentItem."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ITEM_FIELD_NUMBER: builtins.int
    OVERVIEW_FIELD_NUMBER: builtins.int
    @property
    def item(self) -> global___ContentItem:
        """The de-identified item."""
        pass
    @property
    def overview(self) -> global___TransformationOverview:
        """An overview of the changes that were made on the `item`."""
        pass
    def __init__(self,
        *,
        item : typing.Optional[global___ContentItem] = ...,
        overview : typing.Optional[global___TransformationOverview] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["item",b"item","overview",b"overview"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["item",b"item","overview",b"overview"]) -> None: ...
global___DeidentifyContentResponse = DeidentifyContentResponse

class ReidentifyContentRequest(google.protobuf.message.Message):
    """Request to re-identify an item."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    REIDENTIFY_CONFIG_FIELD_NUMBER: builtins.int
    INSPECT_CONFIG_FIELD_NUMBER: builtins.int
    ITEM_FIELD_NUMBER: builtins.int
    INSPECT_TEMPLATE_NAME_FIELD_NUMBER: builtins.int
    REIDENTIFY_TEMPLATE_NAME_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Parent resource name.

    The format of this value varies depending on whether you have [specified a
    processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    @property
    def reidentify_config(self) -> global___DeidentifyConfig:
        """Configuration for the re-identification of the content item.
        This field shares the same proto message type that is used for
        de-identification, however its usage here is for the reversal of the
        previous de-identification. Re-identification is performed by examining
        the transformations used to de-identify the items and executing the
        reverse. This requires that only reversible transformations
        be provided here. The reversible transformations are:

         - `CryptoDeterministicConfig`
         - `CryptoReplaceFfxFpeConfig`
        """
        pass
    @property
    def inspect_config(self) -> global___InspectConfig:
        """Configuration for the inspector."""
        pass
    @property
    def item(self) -> global___ContentItem:
        """The item to re-identify. Will be treated as text."""
        pass
    inspect_template_name: typing.Text = ...
    """Template to use. Any configuration directly specified in
    `inspect_config` will override those set in the template. Singular fields
    that are set in this request will replace their corresponding fields in the
    template. Repeated fields are appended. Singular sub-messages and groups
    are recursively merged.
    """

    reidentify_template_name: typing.Text = ...
    """Template to use. References an instance of `DeidentifyTemplate`.
    Any configuration directly specified in `reidentify_config` or
    `inspect_config` will override those set in the template. The
    `DeidentifyTemplate` used must include only reversible transformations.
    Singular fields that are set in this request will replace their
    corresponding fields in the template. Repeated fields are appended.
    Singular sub-messages and groups are recursively merged.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        reidentify_config : typing.Optional[global___DeidentifyConfig] = ...,
        inspect_config : typing.Optional[global___InspectConfig] = ...,
        item : typing.Optional[global___ContentItem] = ...,
        inspect_template_name : typing.Text = ...,
        reidentify_template_name : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["inspect_config",b"inspect_config","item",b"item","reidentify_config",b"reidentify_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["inspect_config",b"inspect_config","inspect_template_name",b"inspect_template_name","item",b"item","location_id",b"location_id","parent",b"parent","reidentify_config",b"reidentify_config","reidentify_template_name",b"reidentify_template_name"]) -> None: ...
global___ReidentifyContentRequest = ReidentifyContentRequest

class ReidentifyContentResponse(google.protobuf.message.Message):
    """Results of re-identifying a item."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ITEM_FIELD_NUMBER: builtins.int
    OVERVIEW_FIELD_NUMBER: builtins.int
    @property
    def item(self) -> global___ContentItem:
        """The re-identified item."""
        pass
    @property
    def overview(self) -> global___TransformationOverview:
        """An overview of the changes that were made to the `item`."""
        pass
    def __init__(self,
        *,
        item : typing.Optional[global___ContentItem] = ...,
        overview : typing.Optional[global___TransformationOverview] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["item",b"item","overview",b"overview"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["item",b"item","overview",b"overview"]) -> None: ...
global___ReidentifyContentResponse = ReidentifyContentResponse

class InspectContentRequest(google.protobuf.message.Message):
    """Request to search for potentially sensitive info in a ContentItem."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    INSPECT_CONFIG_FIELD_NUMBER: builtins.int
    ITEM_FIELD_NUMBER: builtins.int
    INSPECT_TEMPLATE_NAME_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Parent resource name.

    The format of this value varies depending on whether you have [specified a
    processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    @property
    def inspect_config(self) -> global___InspectConfig:
        """Configuration for the inspector. What specified here will override
        the template referenced by the inspect_template_name argument.
        """
        pass
    @property
    def item(self) -> global___ContentItem:
        """The item to inspect."""
        pass
    inspect_template_name: typing.Text = ...
    """Template to use. Any configuration directly specified in
    inspect_config will override those set in the template. Singular fields
    that are set in this request will replace their corresponding fields in the
    template. Repeated fields are appended. Singular sub-messages and groups
    are recursively merged.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        inspect_config : typing.Optional[global___InspectConfig] = ...,
        item : typing.Optional[global___ContentItem] = ...,
        inspect_template_name : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["inspect_config",b"inspect_config","item",b"item"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["inspect_config",b"inspect_config","inspect_template_name",b"inspect_template_name","item",b"item","location_id",b"location_id","parent",b"parent"]) -> None: ...
global___InspectContentRequest = InspectContentRequest

class InspectContentResponse(google.protobuf.message.Message):
    """Results of inspecting an item."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RESULT_FIELD_NUMBER: builtins.int
    @property
    def result(self) -> global___InspectResult:
        """The findings."""
        pass
    def __init__(self,
        *,
        result : typing.Optional[global___InspectResult] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["result",b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["result",b"result"]) -> None: ...
global___InspectContentResponse = InspectContentResponse

class OutputStorageConfig(google.protobuf.message.Message):
    """Cloud repository for storing output."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _OutputSchema:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _OutputSchemaEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_OutputSchema.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        OUTPUT_SCHEMA_UNSPECIFIED: OutputStorageConfig.OutputSchema.ValueType = ...  # 0
        """Unused."""

        BASIC_COLUMNS: OutputStorageConfig.OutputSchema.ValueType = ...  # 1
        """Basic schema including only `info_type`, `quote`, `certainty`, and
        `timestamp`.
        """

        GCS_COLUMNS: OutputStorageConfig.OutputSchema.ValueType = ...  # 2
        """Schema tailored to findings from scanning Google Cloud Storage."""

        DATASTORE_COLUMNS: OutputStorageConfig.OutputSchema.ValueType = ...  # 3
        """Schema tailored to findings from scanning Google Datastore."""

        BIG_QUERY_COLUMNS: OutputStorageConfig.OutputSchema.ValueType = ...  # 4
        """Schema tailored to findings from scanning Google BigQuery."""

        ALL_COLUMNS: OutputStorageConfig.OutputSchema.ValueType = ...  # 5
        """Schema containing all columns."""

    class OutputSchema(_OutputSchema, metaclass=_OutputSchemaEnumTypeWrapper):
        """Predefined schemas for storing findings.
        Only for use with external storage.
        """
        pass

    OUTPUT_SCHEMA_UNSPECIFIED: OutputStorageConfig.OutputSchema.ValueType = ...  # 0
    """Unused."""

    BASIC_COLUMNS: OutputStorageConfig.OutputSchema.ValueType = ...  # 1
    """Basic schema including only `info_type`, `quote`, `certainty`, and
    `timestamp`.
    """

    GCS_COLUMNS: OutputStorageConfig.OutputSchema.ValueType = ...  # 2
    """Schema tailored to findings from scanning Google Cloud Storage."""

    DATASTORE_COLUMNS: OutputStorageConfig.OutputSchema.ValueType = ...  # 3
    """Schema tailored to findings from scanning Google Datastore."""

    BIG_QUERY_COLUMNS: OutputStorageConfig.OutputSchema.ValueType = ...  # 4
    """Schema tailored to findings from scanning Google BigQuery."""

    ALL_COLUMNS: OutputStorageConfig.OutputSchema.ValueType = ...  # 5
    """Schema containing all columns."""


    TABLE_FIELD_NUMBER: builtins.int
    OUTPUT_SCHEMA_FIELD_NUMBER: builtins.int
    @property
    def table(self) -> google.privacy.dlp.v2.storage_pb2.BigQueryTable:
        """Store findings in an existing table or a new table in an existing
        dataset. If table_id is not set a new one will be generated
        for you with the following format:
        dlp_googleapis_yyyy_mm_dd_[dlp_job_id]. Pacific timezone will be used for
        generating the date details.

        For Inspect, each column in an existing output table must have the same
        name, type, and mode of a field in the `Finding` object.

        For Risk, an existing output table should be the output of a previous
        Risk analysis job run on the same source table, with the same privacy
        metric and quasi-identifiers. Risk jobs that analyze the same table but
        compute a different privacy metric, or use different sets of
        quasi-identifiers, cannot store their results in the same table.
        """
        pass
    output_schema: global___OutputStorageConfig.OutputSchema.ValueType = ...
    """Schema used for writing the findings for Inspect jobs. This field is only
    used for Inspect and must be unspecified for Risk jobs. Columns are derived
    from the `Finding` object. If appending to an existing table, any columns
    from the predefined schema that are missing will be added. No columns in
    the existing table will be deleted.

    If unspecified, then all available columns will be used for a new table or
    an (existing) table with no schema, and no changes will be made to an
    existing table that has a schema.
    Only for use with external storage.
    """

    def __init__(self,
        *,
        table : typing.Optional[google.privacy.dlp.v2.storage_pb2.BigQueryTable] = ...,
        output_schema : global___OutputStorageConfig.OutputSchema.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["table",b"table","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["output_schema",b"output_schema","table",b"table","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["table"]]: ...
global___OutputStorageConfig = OutputStorageConfig

class InfoTypeStats(google.protobuf.message.Message):
    """Statistics regarding a specific InfoType."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INFO_TYPE_FIELD_NUMBER: builtins.int
    COUNT_FIELD_NUMBER: builtins.int
    @property
    def info_type(self) -> google.privacy.dlp.v2.storage_pb2.InfoType:
        """The type of finding this stat is for."""
        pass
    count: builtins.int = ...
    """Number of findings for this infoType."""

    def __init__(self,
        *,
        info_type : typing.Optional[google.privacy.dlp.v2.storage_pb2.InfoType] = ...,
        count : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["info_type",b"info_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["count",b"count","info_type",b"info_type"]) -> None: ...
global___InfoTypeStats = InfoTypeStats

class InspectDataSourceDetails(google.protobuf.message.Message):
    """The results of an inspect DataSource job."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class RequestedOptions(google.protobuf.message.Message):
        """Snapshot of the inspection configuration."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SNAPSHOT_INSPECT_TEMPLATE_FIELD_NUMBER: builtins.int
        JOB_CONFIG_FIELD_NUMBER: builtins.int
        @property
        def snapshot_inspect_template(self) -> global___InspectTemplate:
            """If run with an InspectTemplate, a snapshot of its state at the time of
            this run.
            """
            pass
        @property
        def job_config(self) -> global___InspectJobConfig:
            """Inspect config."""
            pass
        def __init__(self,
            *,
            snapshot_inspect_template : typing.Optional[global___InspectTemplate] = ...,
            job_config : typing.Optional[global___InspectJobConfig] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["job_config",b"job_config","snapshot_inspect_template",b"snapshot_inspect_template"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["job_config",b"job_config","snapshot_inspect_template",b"snapshot_inspect_template"]) -> None: ...

    class Result(google.protobuf.message.Message):
        """All result fields mentioned below are updated while the job is processing."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        PROCESSED_BYTES_FIELD_NUMBER: builtins.int
        TOTAL_ESTIMATED_BYTES_FIELD_NUMBER: builtins.int
        INFO_TYPE_STATS_FIELD_NUMBER: builtins.int
        HYBRID_STATS_FIELD_NUMBER: builtins.int
        processed_bytes: builtins.int = ...
        """Total size in bytes that were processed."""

        total_estimated_bytes: builtins.int = ...
        """Estimate of the number of bytes to process."""

        @property
        def info_type_stats(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InfoTypeStats]:
            """Statistics of how many instances of each info type were found during
            inspect job.
            """
            pass
        @property
        def hybrid_stats(self) -> global___HybridInspectStatistics:
            """Statistics related to the processing of hybrid inspect."""
            pass
        def __init__(self,
            *,
            processed_bytes : builtins.int = ...,
            total_estimated_bytes : builtins.int = ...,
            info_type_stats : typing.Optional[typing.Iterable[global___InfoTypeStats]] = ...,
            hybrid_stats : typing.Optional[global___HybridInspectStatistics] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["hybrid_stats",b"hybrid_stats"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["hybrid_stats",b"hybrid_stats","info_type_stats",b"info_type_stats","processed_bytes",b"processed_bytes","total_estimated_bytes",b"total_estimated_bytes"]) -> None: ...

    REQUESTED_OPTIONS_FIELD_NUMBER: builtins.int
    RESULT_FIELD_NUMBER: builtins.int
    @property
    def requested_options(self) -> global___InspectDataSourceDetails.RequestedOptions:
        """The configuration used for this job."""
        pass
    @property
    def result(self) -> global___InspectDataSourceDetails.Result:
        """A summary of the outcome of this inspection job."""
        pass
    def __init__(self,
        *,
        requested_options : typing.Optional[global___InspectDataSourceDetails.RequestedOptions] = ...,
        result : typing.Optional[global___InspectDataSourceDetails.Result] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["requested_options",b"requested_options","result",b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["requested_options",b"requested_options","result",b"result"]) -> None: ...
global___InspectDataSourceDetails = InspectDataSourceDetails

class HybridInspectStatistics(google.protobuf.message.Message):
    """Statistics related to processing hybrid inspect requests."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROCESSED_COUNT_FIELD_NUMBER: builtins.int
    ABORTED_COUNT_FIELD_NUMBER: builtins.int
    PENDING_COUNT_FIELD_NUMBER: builtins.int
    processed_count: builtins.int = ...
    """The number of hybrid inspection requests processed within this job."""

    aborted_count: builtins.int = ...
    """The number of hybrid inspection requests aborted because the job ran
    out of quota or was ended before they could be processed.
    """

    pending_count: builtins.int = ...
    """The number of hybrid requests currently being processed. Only populated
    when called via method `getDlpJob`.
    A burst of traffic may cause hybrid inspect requests to be enqueued.
    Processing will take place as quickly as possible, but resource limitations
    may impact how long a request is enqueued for.
    """

    def __init__(self,
        *,
        processed_count : builtins.int = ...,
        aborted_count : builtins.int = ...,
        pending_count : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["aborted_count",b"aborted_count","pending_count",b"pending_count","processed_count",b"processed_count"]) -> None: ...
global___HybridInspectStatistics = HybridInspectStatistics

class InfoTypeDescription(google.protobuf.message.Message):
    """InfoType description."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    SUPPORTED_BY_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Internal name of the infoType."""

    display_name: typing.Text = ...
    """Human readable form of the infoType name."""

    @property
    def supported_by(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___InfoTypeSupportedBy.ValueType]:
        """Which parts of the API supports this InfoType."""
        pass
    description: typing.Text = ...
    """Description of the infotype. Translated when language is provided in the
    request.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        supported_by : typing.Optional[typing.Iterable[global___InfoTypeSupportedBy.ValueType]] = ...,
        description : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["description",b"description","display_name",b"display_name","name",b"name","supported_by",b"supported_by"]) -> None: ...
global___InfoTypeDescription = InfoTypeDescription

class ListInfoTypesRequest(google.protobuf.message.Message):
    """Request for the list of infoTypes."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    LANGUAGE_CODE_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """The parent resource name.

    The format of this value is as follows:

        locations/<var>LOCATION_ID</var>
    """

    language_code: typing.Text = ...
    """BCP-47 language code for localized infoType friendly
    names. If omitted, or if localized strings are not available,
    en-US strings will be returned.
    """

    filter: typing.Text = ...
    """filter to only return infoTypes supported by certain parts of the
    API. Defaults to supported_by=INSPECT.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        language_code : typing.Text = ...,
        filter : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","language_code",b"language_code","location_id",b"location_id","parent",b"parent"]) -> None: ...
global___ListInfoTypesRequest = ListInfoTypesRequest

class ListInfoTypesResponse(google.protobuf.message.Message):
    """Response to the ListInfoTypes request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INFO_TYPES_FIELD_NUMBER: builtins.int
    @property
    def info_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InfoTypeDescription]:
        """Set of sensitive infoTypes."""
        pass
    def __init__(self,
        *,
        info_types : typing.Optional[typing.Iterable[global___InfoTypeDescription]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["info_types",b"info_types"]) -> None: ...
global___ListInfoTypesResponse = ListInfoTypesResponse

class RiskAnalysisJobConfig(google.protobuf.message.Message):
    """Configuration for a risk analysis job. See
    https://cloud.google.com/dlp/docs/concepts-risk-analysis to learn more.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PRIVACY_METRIC_FIELD_NUMBER: builtins.int
    SOURCE_TABLE_FIELD_NUMBER: builtins.int
    ACTIONS_FIELD_NUMBER: builtins.int
    @property
    def privacy_metric(self) -> global___PrivacyMetric:
        """Privacy metric to compute."""
        pass
    @property
    def source_table(self) -> google.privacy.dlp.v2.storage_pb2.BigQueryTable:
        """Input dataset to compute metrics over."""
        pass
    @property
    def actions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Action]:
        """Actions to execute at the completion of the job. Are executed in the order
        provided.
        """
        pass
    def __init__(self,
        *,
        privacy_metric : typing.Optional[global___PrivacyMetric] = ...,
        source_table : typing.Optional[google.privacy.dlp.v2.storage_pb2.BigQueryTable] = ...,
        actions : typing.Optional[typing.Iterable[global___Action]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["privacy_metric",b"privacy_metric","source_table",b"source_table"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["actions",b"actions","privacy_metric",b"privacy_metric","source_table",b"source_table"]) -> None: ...
global___RiskAnalysisJobConfig = RiskAnalysisJobConfig

class QuasiId(google.protobuf.message.Message):
    """A column with a semantic tag attached."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FIELD_FIELD_NUMBER: builtins.int
    INFO_TYPE_FIELD_NUMBER: builtins.int
    CUSTOM_TAG_FIELD_NUMBER: builtins.int
    INFERRED_FIELD_NUMBER: builtins.int
    @property
    def field(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
        """Required. Identifies the column."""
        pass
    @property
    def info_type(self) -> google.privacy.dlp.v2.storage_pb2.InfoType:
        """A column can be tagged with a InfoType to use the relevant public
        dataset as a statistical model of population, if available. We
        currently support US ZIP codes, region codes, ages and genders.
        To programmatically obtain the list of supported InfoTypes, use
        ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
        """
        pass
    custom_tag: typing.Text = ...
    """A column can be tagged with a custom tag. In this case, the user must
    indicate an auxiliary table that contains statistical information on
    the possible values of this column (below).
    """

    @property
    def inferred(self) -> google.protobuf.empty_pb2.Empty:
        """If no semantic tag is indicated, we infer the statistical model from
        the distribution of values in the input data
        """
        pass
    def __init__(self,
        *,
        field : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
        info_type : typing.Optional[google.privacy.dlp.v2.storage_pb2.InfoType] = ...,
        custom_tag : typing.Text = ...,
        inferred : typing.Optional[google.protobuf.empty_pb2.Empty] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["custom_tag",b"custom_tag","field",b"field","inferred",b"inferred","info_type",b"info_type","tag",b"tag"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["custom_tag",b"custom_tag","field",b"field","inferred",b"inferred","info_type",b"info_type","tag",b"tag"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["tag",b"tag"]) -> typing.Optional[typing_extensions.Literal["info_type","custom_tag","inferred"]]: ...
global___QuasiId = QuasiId

class StatisticalTable(google.protobuf.message.Message):
    """An auxiliary table containing statistical information on the relative
    frequency of different quasi-identifiers values. It has one or several
    quasi-identifiers columns, and one column that indicates the relative
    frequency of each quasi-identifier tuple.
    If a tuple is present in the data but not in the auxiliary table, the
    corresponding relative frequency is assumed to be zero (and thus, the
    tuple is highly reidentifiable).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class QuasiIdentifierField(google.protobuf.message.Message):
        """A quasi-identifier column has a custom_tag, used to know which column
        in the data corresponds to which column in the statistical model.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FIELD_FIELD_NUMBER: builtins.int
        CUSTOM_TAG_FIELD_NUMBER: builtins.int
        @property
        def field(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
            """Identifies the column."""
            pass
        custom_tag: typing.Text = ...
        """A column can be tagged with a custom tag. In this case, the user must
        indicate an auxiliary table that contains statistical information on
        the possible values of this column (below).
        """

        def __init__(self,
            *,
            field : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
            custom_tag : typing.Text = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["field",b"field"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["custom_tag",b"custom_tag","field",b"field"]) -> None: ...

    TABLE_FIELD_NUMBER: builtins.int
    QUASI_IDS_FIELD_NUMBER: builtins.int
    RELATIVE_FREQUENCY_FIELD_NUMBER: builtins.int
    @property
    def table(self) -> google.privacy.dlp.v2.storage_pb2.BigQueryTable:
        """Required. Auxiliary table location."""
        pass
    @property
    def quasi_ids(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StatisticalTable.QuasiIdentifierField]:
        """Required. Quasi-identifier columns."""
        pass
    @property
    def relative_frequency(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
        """Required. The relative frequency column must contain a floating-point number
        between 0 and 1 (inclusive). Null values are assumed to be zero.
        """
        pass
    def __init__(self,
        *,
        table : typing.Optional[google.privacy.dlp.v2.storage_pb2.BigQueryTable] = ...,
        quasi_ids : typing.Optional[typing.Iterable[global___StatisticalTable.QuasiIdentifierField]] = ...,
        relative_frequency : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["relative_frequency",b"relative_frequency","table",b"table"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["quasi_ids",b"quasi_ids","relative_frequency",b"relative_frequency","table",b"table"]) -> None: ...
global___StatisticalTable = StatisticalTable

class PrivacyMetric(google.protobuf.message.Message):
    """Privacy metric to compute for reidentification risk analysis."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class NumericalStatsConfig(google.protobuf.message.Message):
        """Compute numerical stats over an individual column, including
        min, max, and quantiles.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FIELD_FIELD_NUMBER: builtins.int
        @property
        def field(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
            """Field to compute numerical stats on. Supported types are
            integer, float, date, datetime, timestamp, time.
            """
            pass
        def __init__(self,
            *,
            field : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["field",b"field"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["field",b"field"]) -> None: ...

    class CategoricalStatsConfig(google.protobuf.message.Message):
        """Compute numerical stats over an individual column, including
        number of distinct values and value count distribution.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FIELD_FIELD_NUMBER: builtins.int
        @property
        def field(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
            """Field to compute categorical stats on. All column types are
            supported except for arrays and structs. However, it may be more
            informative to use NumericalStats when the field type is supported,
            depending on the data.
            """
            pass
        def __init__(self,
            *,
            field : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["field",b"field"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["field",b"field"]) -> None: ...

    class KAnonymityConfig(google.protobuf.message.Message):
        """k-anonymity metric, used for analysis of reidentification risk."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        QUASI_IDS_FIELD_NUMBER: builtins.int
        ENTITY_ID_FIELD_NUMBER: builtins.int
        @property
        def quasi_ids(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.privacy.dlp.v2.storage_pb2.FieldId]:
            """Set of fields to compute k-anonymity over. When multiple fields are
            specified, they are considered a single composite key. Structs and
            repeated data types are not supported; however, nested fields are
            supported so long as they are not structs themselves or nested within
            a repeated field.
            """
            pass
        @property
        def entity_id(self) -> google.privacy.dlp.v2.storage_pb2.EntityId:
            """Message indicating that multiple rows might be associated to a
            single individual. If the same entity_id is associated to multiple
            quasi-identifier tuples over distinct rows, we consider the entire
            collection of tuples as the composite quasi-identifier. This collection
            is a multiset: the order in which the different tuples appear in the
            dataset is ignored, but their frequency is taken into account.

            Important note: a maximum of 1000 rows can be associated to a single
            entity ID. If more rows are associated with the same entity ID, some
            might be ignored.
            """
            pass
        def __init__(self,
            *,
            quasi_ids : typing.Optional[typing.Iterable[google.privacy.dlp.v2.storage_pb2.FieldId]] = ...,
            entity_id : typing.Optional[google.privacy.dlp.v2.storage_pb2.EntityId] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["entity_id",b"entity_id"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["entity_id",b"entity_id","quasi_ids",b"quasi_ids"]) -> None: ...

    class LDiversityConfig(google.protobuf.message.Message):
        """l-diversity metric, used for analysis of reidentification risk."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        QUASI_IDS_FIELD_NUMBER: builtins.int
        SENSITIVE_ATTRIBUTE_FIELD_NUMBER: builtins.int
        @property
        def quasi_ids(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.privacy.dlp.v2.storage_pb2.FieldId]:
            """Set of quasi-identifiers indicating how equivalence classes are
            defined for the l-diversity computation. When multiple fields are
            specified, they are considered a single composite key.
            """
            pass
        @property
        def sensitive_attribute(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
            """Sensitive field for computing the l-value."""
            pass
        def __init__(self,
            *,
            quasi_ids : typing.Optional[typing.Iterable[google.privacy.dlp.v2.storage_pb2.FieldId]] = ...,
            sensitive_attribute : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["sensitive_attribute",b"sensitive_attribute"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["quasi_ids",b"quasi_ids","sensitive_attribute",b"sensitive_attribute"]) -> None: ...

    class KMapEstimationConfig(google.protobuf.message.Message):
        """Reidentifiability metric. This corresponds to a risk model similar to what
        is called "journalist risk" in the literature, except the attack dataset is
        statistically modeled instead of being perfectly known. This can be done
        using publicly available data (like the US Census), or using a custom
        statistical model (indicated as one or several BigQuery tables), or by
        extrapolating from the distribution of values in the input dataset.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class TaggedField(google.protobuf.message.Message):
            """A column with a semantic tag attached."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            FIELD_FIELD_NUMBER: builtins.int
            INFO_TYPE_FIELD_NUMBER: builtins.int
            CUSTOM_TAG_FIELD_NUMBER: builtins.int
            INFERRED_FIELD_NUMBER: builtins.int
            @property
            def field(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
                """Required. Identifies the column."""
                pass
            @property
            def info_type(self) -> google.privacy.dlp.v2.storage_pb2.InfoType:
                """A column can be tagged with a InfoType to use the relevant public
                dataset as a statistical model of population, if available. We
                currently support US ZIP codes, region codes, ages and genders.
                To programmatically obtain the list of supported InfoTypes, use
                ListInfoTypes with the supported_by=RISK_ANALYSIS filter.
                """
                pass
            custom_tag: typing.Text = ...
            """A column can be tagged with a custom tag. In this case, the user must
            indicate an auxiliary table that contains statistical information on
            the possible values of this column (below).
            """

            @property
            def inferred(self) -> google.protobuf.empty_pb2.Empty:
                """If no semantic tag is indicated, we infer the statistical model from
                the distribution of values in the input data
                """
                pass
            def __init__(self,
                *,
                field : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
                info_type : typing.Optional[google.privacy.dlp.v2.storage_pb2.InfoType] = ...,
                custom_tag : typing.Text = ...,
                inferred : typing.Optional[google.protobuf.empty_pb2.Empty] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["custom_tag",b"custom_tag","field",b"field","inferred",b"inferred","info_type",b"info_type","tag",b"tag"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["custom_tag",b"custom_tag","field",b"field","inferred",b"inferred","info_type",b"info_type","tag",b"tag"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["tag",b"tag"]) -> typing.Optional[typing_extensions.Literal["info_type","custom_tag","inferred"]]: ...

        class AuxiliaryTable(google.protobuf.message.Message):
            """An auxiliary table contains statistical information on the relative
            frequency of different quasi-identifiers values. It has one or several
            quasi-identifiers columns, and one column that indicates the relative
            frequency of each quasi-identifier tuple.
            If a tuple is present in the data but not in the auxiliary table, the
            corresponding relative frequency is assumed to be zero (and thus, the
            tuple is highly reidentifiable).
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class QuasiIdField(google.protobuf.message.Message):
                """A quasi-identifier column has a custom_tag, used to know which column
                in the data corresponds to which column in the statistical model.
                """
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                FIELD_FIELD_NUMBER: builtins.int
                CUSTOM_TAG_FIELD_NUMBER: builtins.int
                @property
                def field(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
                    """Identifies the column."""
                    pass
                custom_tag: typing.Text = ...
                """A auxiliary field."""

                def __init__(self,
                    *,
                    field : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
                    custom_tag : typing.Text = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["field",b"field"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["custom_tag",b"custom_tag","field",b"field"]) -> None: ...

            TABLE_FIELD_NUMBER: builtins.int
            QUASI_IDS_FIELD_NUMBER: builtins.int
            RELATIVE_FREQUENCY_FIELD_NUMBER: builtins.int
            @property
            def table(self) -> google.privacy.dlp.v2.storage_pb2.BigQueryTable:
                """Required. Auxiliary table location."""
                pass
            @property
            def quasi_ids(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PrivacyMetric.KMapEstimationConfig.AuxiliaryTable.QuasiIdField]:
                """Required. Quasi-identifier columns."""
                pass
            @property
            def relative_frequency(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
                """Required. The relative frequency column must contain a floating-point number
                between 0 and 1 (inclusive). Null values are assumed to be zero.
                """
                pass
            def __init__(self,
                *,
                table : typing.Optional[google.privacy.dlp.v2.storage_pb2.BigQueryTable] = ...,
                quasi_ids : typing.Optional[typing.Iterable[global___PrivacyMetric.KMapEstimationConfig.AuxiliaryTable.QuasiIdField]] = ...,
                relative_frequency : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["relative_frequency",b"relative_frequency","table",b"table"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["quasi_ids",b"quasi_ids","relative_frequency",b"relative_frequency","table",b"table"]) -> None: ...

        QUASI_IDS_FIELD_NUMBER: builtins.int
        REGION_CODE_FIELD_NUMBER: builtins.int
        AUXILIARY_TABLES_FIELD_NUMBER: builtins.int
        @property
        def quasi_ids(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PrivacyMetric.KMapEstimationConfig.TaggedField]:
            """Required. Fields considered to be quasi-identifiers. No two columns can have the
            same tag.
            """
            pass
        region_code: typing.Text = ...
        """ISO 3166-1 alpha-2 region code to use in the statistical modeling.
        Set if no column is tagged with a region-specific InfoType (like
        US_ZIP_5) or a region code.
        """

        @property
        def auxiliary_tables(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PrivacyMetric.KMapEstimationConfig.AuxiliaryTable]:
            """Several auxiliary tables can be used in the analysis. Each custom_tag
            used to tag a quasi-identifiers column must appear in exactly one column
            of one auxiliary table.
            """
            pass
        def __init__(self,
            *,
            quasi_ids : typing.Optional[typing.Iterable[global___PrivacyMetric.KMapEstimationConfig.TaggedField]] = ...,
            region_code : typing.Text = ...,
            auxiliary_tables : typing.Optional[typing.Iterable[global___PrivacyMetric.KMapEstimationConfig.AuxiliaryTable]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["auxiliary_tables",b"auxiliary_tables","quasi_ids",b"quasi_ids","region_code",b"region_code"]) -> None: ...

    class DeltaPresenceEstimationConfig(google.protobuf.message.Message):
        """-presence metric, used to estimate how likely it is for an attacker to
        figure out that one given individual appears in a de-identified dataset.
        Similarly to the k-map metric, we cannot compute -presence exactly without
        knowing the attack dataset, so we use a statistical model instead.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        QUASI_IDS_FIELD_NUMBER: builtins.int
        REGION_CODE_FIELD_NUMBER: builtins.int
        AUXILIARY_TABLES_FIELD_NUMBER: builtins.int
        @property
        def quasi_ids(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___QuasiId]:
            """Required. Fields considered to be quasi-identifiers. No two fields can have the
            same tag.
            """
            pass
        region_code: typing.Text = ...
        """ISO 3166-1 alpha-2 region code to use in the statistical modeling.
        Set if no column is tagged with a region-specific InfoType (like
        US_ZIP_5) or a region code.
        """

        @property
        def auxiliary_tables(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StatisticalTable]:
            """Several auxiliary tables can be used in the analysis. Each custom_tag
            used to tag a quasi-identifiers field must appear in exactly one
            field of one auxiliary table.
            """
            pass
        def __init__(self,
            *,
            quasi_ids : typing.Optional[typing.Iterable[global___QuasiId]] = ...,
            region_code : typing.Text = ...,
            auxiliary_tables : typing.Optional[typing.Iterable[global___StatisticalTable]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["auxiliary_tables",b"auxiliary_tables","quasi_ids",b"quasi_ids","region_code",b"region_code"]) -> None: ...

    NUMERICAL_STATS_CONFIG_FIELD_NUMBER: builtins.int
    CATEGORICAL_STATS_CONFIG_FIELD_NUMBER: builtins.int
    K_ANONYMITY_CONFIG_FIELD_NUMBER: builtins.int
    L_DIVERSITY_CONFIG_FIELD_NUMBER: builtins.int
    K_MAP_ESTIMATION_CONFIG_FIELD_NUMBER: builtins.int
    DELTA_PRESENCE_ESTIMATION_CONFIG_FIELD_NUMBER: builtins.int
    @property
    def numerical_stats_config(self) -> global___PrivacyMetric.NumericalStatsConfig:
        """Numerical stats"""
        pass
    @property
    def categorical_stats_config(self) -> global___PrivacyMetric.CategoricalStatsConfig:
        """Categorical stats"""
        pass
    @property
    def k_anonymity_config(self) -> global___PrivacyMetric.KAnonymityConfig:
        """K-anonymity"""
        pass
    @property
    def l_diversity_config(self) -> global___PrivacyMetric.LDiversityConfig:
        """l-diversity"""
        pass
    @property
    def k_map_estimation_config(self) -> global___PrivacyMetric.KMapEstimationConfig:
        """k-map"""
        pass
    @property
    def delta_presence_estimation_config(self) -> global___PrivacyMetric.DeltaPresenceEstimationConfig:
        """delta-presence"""
        pass
    def __init__(self,
        *,
        numerical_stats_config : typing.Optional[global___PrivacyMetric.NumericalStatsConfig] = ...,
        categorical_stats_config : typing.Optional[global___PrivacyMetric.CategoricalStatsConfig] = ...,
        k_anonymity_config : typing.Optional[global___PrivacyMetric.KAnonymityConfig] = ...,
        l_diversity_config : typing.Optional[global___PrivacyMetric.LDiversityConfig] = ...,
        k_map_estimation_config : typing.Optional[global___PrivacyMetric.KMapEstimationConfig] = ...,
        delta_presence_estimation_config : typing.Optional[global___PrivacyMetric.DeltaPresenceEstimationConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["categorical_stats_config",b"categorical_stats_config","delta_presence_estimation_config",b"delta_presence_estimation_config","k_anonymity_config",b"k_anonymity_config","k_map_estimation_config",b"k_map_estimation_config","l_diversity_config",b"l_diversity_config","numerical_stats_config",b"numerical_stats_config","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["categorical_stats_config",b"categorical_stats_config","delta_presence_estimation_config",b"delta_presence_estimation_config","k_anonymity_config",b"k_anonymity_config","k_map_estimation_config",b"k_map_estimation_config","l_diversity_config",b"l_diversity_config","numerical_stats_config",b"numerical_stats_config","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["numerical_stats_config","categorical_stats_config","k_anonymity_config","l_diversity_config","k_map_estimation_config","delta_presence_estimation_config"]]: ...
global___PrivacyMetric = PrivacyMetric

class AnalyzeDataSourceRiskDetails(google.protobuf.message.Message):
    """Result of a risk analysis operation request."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class NumericalStatsResult(google.protobuf.message.Message):
        """Result of the numerical stats computation."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MIN_VALUE_FIELD_NUMBER: builtins.int
        MAX_VALUE_FIELD_NUMBER: builtins.int
        QUANTILE_VALUES_FIELD_NUMBER: builtins.int
        @property
        def min_value(self) -> global___Value:
            """Minimum value appearing in the column."""
            pass
        @property
        def max_value(self) -> global___Value:
            """Maximum value appearing in the column."""
            pass
        @property
        def quantile_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Value]:
            """List of 99 values that partition the set of field values into 100 equal
            sized buckets.
            """
            pass
        def __init__(self,
            *,
            min_value : typing.Optional[global___Value] = ...,
            max_value : typing.Optional[global___Value] = ...,
            quantile_values : typing.Optional[typing.Iterable[global___Value]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["max_value",b"max_value","min_value",b"min_value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["max_value",b"max_value","min_value",b"min_value","quantile_values",b"quantile_values"]) -> None: ...

    class CategoricalStatsResult(google.protobuf.message.Message):
        """Result of the categorical stats computation."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class CategoricalStatsHistogramBucket(google.protobuf.message.Message):
            """Histogram of value frequencies in the column."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            VALUE_FREQUENCY_LOWER_BOUND_FIELD_NUMBER: builtins.int
            VALUE_FREQUENCY_UPPER_BOUND_FIELD_NUMBER: builtins.int
            BUCKET_SIZE_FIELD_NUMBER: builtins.int
            BUCKET_VALUES_FIELD_NUMBER: builtins.int
            BUCKET_VALUE_COUNT_FIELD_NUMBER: builtins.int
            value_frequency_lower_bound: builtins.int = ...
            """Lower bound on the value frequency of the values in this bucket."""

            value_frequency_upper_bound: builtins.int = ...
            """Upper bound on the value frequency of the values in this bucket."""

            bucket_size: builtins.int = ...
            """Total number of values in this bucket."""

            @property
            def bucket_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ValueFrequency]:
                """Sample of value frequencies in this bucket. The total number of
                values returned per bucket is capped at 20.
                """
                pass
            bucket_value_count: builtins.int = ...
            """Total number of distinct values in this bucket."""

            def __init__(self,
                *,
                value_frequency_lower_bound : builtins.int = ...,
                value_frequency_upper_bound : builtins.int = ...,
                bucket_size : builtins.int = ...,
                bucket_values : typing.Optional[typing.Iterable[global___ValueFrequency]] = ...,
                bucket_value_count : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["bucket_size",b"bucket_size","bucket_value_count",b"bucket_value_count","bucket_values",b"bucket_values","value_frequency_lower_bound",b"value_frequency_lower_bound","value_frequency_upper_bound",b"value_frequency_upper_bound"]) -> None: ...

        VALUE_FREQUENCY_HISTOGRAM_BUCKETS_FIELD_NUMBER: builtins.int
        @property
        def value_frequency_histogram_buckets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnalyzeDataSourceRiskDetails.CategoricalStatsResult.CategoricalStatsHistogramBucket]:
            """Histogram of value frequencies in the column."""
            pass
        def __init__(self,
            *,
            value_frequency_histogram_buckets : typing.Optional[typing.Iterable[global___AnalyzeDataSourceRiskDetails.CategoricalStatsResult.CategoricalStatsHistogramBucket]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["value_frequency_histogram_buckets",b"value_frequency_histogram_buckets"]) -> None: ...

    class KAnonymityResult(google.protobuf.message.Message):
        """Result of the k-anonymity computation."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class KAnonymityEquivalenceClass(google.protobuf.message.Message):
            """The set of columns' values that share the same ldiversity value"""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            QUASI_IDS_VALUES_FIELD_NUMBER: builtins.int
            EQUIVALENCE_CLASS_SIZE_FIELD_NUMBER: builtins.int
            @property
            def quasi_ids_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Value]:
                """Set of values defining the equivalence class. One value per
                quasi-identifier column in the original KAnonymity metric message.
                The order is always the same as the original request.
                """
                pass
            equivalence_class_size: builtins.int = ...
            """Size of the equivalence class, for example number of rows with the
            above set of values.
            """

            def __init__(self,
                *,
                quasi_ids_values : typing.Optional[typing.Iterable[global___Value]] = ...,
                equivalence_class_size : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["equivalence_class_size",b"equivalence_class_size","quasi_ids_values",b"quasi_ids_values"]) -> None: ...

        class KAnonymityHistogramBucket(google.protobuf.message.Message):
            """Histogram of k-anonymity equivalence classes."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            EQUIVALENCE_CLASS_SIZE_LOWER_BOUND_FIELD_NUMBER: builtins.int
            EQUIVALENCE_CLASS_SIZE_UPPER_BOUND_FIELD_NUMBER: builtins.int
            BUCKET_SIZE_FIELD_NUMBER: builtins.int
            BUCKET_VALUES_FIELD_NUMBER: builtins.int
            BUCKET_VALUE_COUNT_FIELD_NUMBER: builtins.int
            equivalence_class_size_lower_bound: builtins.int = ...
            """Lower bound on the size of the equivalence classes in this bucket."""

            equivalence_class_size_upper_bound: builtins.int = ...
            """Upper bound on the size of the equivalence classes in this bucket."""

            bucket_size: builtins.int = ...
            """Total number of equivalence classes in this bucket."""

            @property
            def bucket_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityEquivalenceClass]:
                """Sample of equivalence classes in this bucket. The total number of
                classes returned per bucket is capped at 20.
                """
                pass
            bucket_value_count: builtins.int = ...
            """Total number of distinct equivalence classes in this bucket."""

            def __init__(self,
                *,
                equivalence_class_size_lower_bound : builtins.int = ...,
                equivalence_class_size_upper_bound : builtins.int = ...,
                bucket_size : builtins.int = ...,
                bucket_values : typing.Optional[typing.Iterable[global___AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityEquivalenceClass]] = ...,
                bucket_value_count : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["bucket_size",b"bucket_size","bucket_value_count",b"bucket_value_count","bucket_values",b"bucket_values","equivalence_class_size_lower_bound",b"equivalence_class_size_lower_bound","equivalence_class_size_upper_bound",b"equivalence_class_size_upper_bound"]) -> None: ...

        EQUIVALENCE_CLASS_HISTOGRAM_BUCKETS_FIELD_NUMBER: builtins.int
        @property
        def equivalence_class_histogram_buckets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityHistogramBucket]:
            """Histogram of k-anonymity equivalence classes."""
            pass
        def __init__(self,
            *,
            equivalence_class_histogram_buckets : typing.Optional[typing.Iterable[global___AnalyzeDataSourceRiskDetails.KAnonymityResult.KAnonymityHistogramBucket]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["equivalence_class_histogram_buckets",b"equivalence_class_histogram_buckets"]) -> None: ...

    class LDiversityResult(google.protobuf.message.Message):
        """Result of the l-diversity computation."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class LDiversityEquivalenceClass(google.protobuf.message.Message):
            """The set of columns' values that share the same ldiversity value."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            QUASI_IDS_VALUES_FIELD_NUMBER: builtins.int
            EQUIVALENCE_CLASS_SIZE_FIELD_NUMBER: builtins.int
            NUM_DISTINCT_SENSITIVE_VALUES_FIELD_NUMBER: builtins.int
            TOP_SENSITIVE_VALUES_FIELD_NUMBER: builtins.int
            @property
            def quasi_ids_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Value]:
                """Quasi-identifier values defining the k-anonymity equivalence
                class. The order is always the same as the original request.
                """
                pass
            equivalence_class_size: builtins.int = ...
            """Size of the k-anonymity equivalence class."""

            num_distinct_sensitive_values: builtins.int = ...
            """Number of distinct sensitive values in this equivalence class."""

            @property
            def top_sensitive_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ValueFrequency]:
                """Estimated frequencies of top sensitive values."""
                pass
            def __init__(self,
                *,
                quasi_ids_values : typing.Optional[typing.Iterable[global___Value]] = ...,
                equivalence_class_size : builtins.int = ...,
                num_distinct_sensitive_values : builtins.int = ...,
                top_sensitive_values : typing.Optional[typing.Iterable[global___ValueFrequency]] = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["equivalence_class_size",b"equivalence_class_size","num_distinct_sensitive_values",b"num_distinct_sensitive_values","quasi_ids_values",b"quasi_ids_values","top_sensitive_values",b"top_sensitive_values"]) -> None: ...

        class LDiversityHistogramBucket(google.protobuf.message.Message):
            """Histogram of l-diversity equivalence class sensitive value frequencies."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            SENSITIVE_VALUE_FREQUENCY_LOWER_BOUND_FIELD_NUMBER: builtins.int
            SENSITIVE_VALUE_FREQUENCY_UPPER_BOUND_FIELD_NUMBER: builtins.int
            BUCKET_SIZE_FIELD_NUMBER: builtins.int
            BUCKET_VALUES_FIELD_NUMBER: builtins.int
            BUCKET_VALUE_COUNT_FIELD_NUMBER: builtins.int
            sensitive_value_frequency_lower_bound: builtins.int = ...
            """Lower bound on the sensitive value frequencies of the equivalence
            classes in this bucket.
            """

            sensitive_value_frequency_upper_bound: builtins.int = ...
            """Upper bound on the sensitive value frequencies of the equivalence
            classes in this bucket.
            """

            bucket_size: builtins.int = ...
            """Total number of equivalence classes in this bucket."""

            @property
            def bucket_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityEquivalenceClass]:
                """Sample of equivalence classes in this bucket. The total number of
                classes returned per bucket is capped at 20.
                """
                pass
            bucket_value_count: builtins.int = ...
            """Total number of distinct equivalence classes in this bucket."""

            def __init__(self,
                *,
                sensitive_value_frequency_lower_bound : builtins.int = ...,
                sensitive_value_frequency_upper_bound : builtins.int = ...,
                bucket_size : builtins.int = ...,
                bucket_values : typing.Optional[typing.Iterable[global___AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityEquivalenceClass]] = ...,
                bucket_value_count : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["bucket_size",b"bucket_size","bucket_value_count",b"bucket_value_count","bucket_values",b"bucket_values","sensitive_value_frequency_lower_bound",b"sensitive_value_frequency_lower_bound","sensitive_value_frequency_upper_bound",b"sensitive_value_frequency_upper_bound"]) -> None: ...

        SENSITIVE_VALUE_FREQUENCY_HISTOGRAM_BUCKETS_FIELD_NUMBER: builtins.int
        @property
        def sensitive_value_frequency_histogram_buckets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityHistogramBucket]:
            """Histogram of l-diversity equivalence class sensitive value frequencies."""
            pass
        def __init__(self,
            *,
            sensitive_value_frequency_histogram_buckets : typing.Optional[typing.Iterable[global___AnalyzeDataSourceRiskDetails.LDiversityResult.LDiversityHistogramBucket]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["sensitive_value_frequency_histogram_buckets",b"sensitive_value_frequency_histogram_buckets"]) -> None: ...

    class KMapEstimationResult(google.protobuf.message.Message):
        """Result of the reidentifiability analysis. Note that these results are an
        estimation, not exact values.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class KMapEstimationQuasiIdValues(google.protobuf.message.Message):
            """A tuple of values for the quasi-identifier columns."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            QUASI_IDS_VALUES_FIELD_NUMBER: builtins.int
            ESTIMATED_ANONYMITY_FIELD_NUMBER: builtins.int
            @property
            def quasi_ids_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Value]:
                """The quasi-identifier values."""
                pass
            estimated_anonymity: builtins.int = ...
            """The estimated anonymity for these quasi-identifier values."""

            def __init__(self,
                *,
                quasi_ids_values : typing.Optional[typing.Iterable[global___Value]] = ...,
                estimated_anonymity : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["estimated_anonymity",b"estimated_anonymity","quasi_ids_values",b"quasi_ids_values"]) -> None: ...

        class KMapEstimationHistogramBucket(google.protobuf.message.Message):
            """A KMapEstimationHistogramBucket message with the following values:
              min_anonymity: 3
              max_anonymity: 5
              frequency: 42
            means that there are 42 records whose quasi-identifier values correspond
            to 3, 4 or 5 people in the overlying population. An important particular
            case is when min_anonymity = max_anonymity = 1: the frequency field then
            corresponds to the number of uniquely identifiable records.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            MIN_ANONYMITY_FIELD_NUMBER: builtins.int
            MAX_ANONYMITY_FIELD_NUMBER: builtins.int
            BUCKET_SIZE_FIELD_NUMBER: builtins.int
            BUCKET_VALUES_FIELD_NUMBER: builtins.int
            BUCKET_VALUE_COUNT_FIELD_NUMBER: builtins.int
            min_anonymity: builtins.int = ...
            """Always positive."""

            max_anonymity: builtins.int = ...
            """Always greater than or equal to min_anonymity."""

            bucket_size: builtins.int = ...
            """Number of records within these anonymity bounds."""

            @property
            def bucket_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationQuasiIdValues]:
                """Sample of quasi-identifier tuple values in this bucket. The total
                number of classes returned per bucket is capped at 20.
                """
                pass
            bucket_value_count: builtins.int = ...
            """Total number of distinct quasi-identifier tuple values in this bucket."""

            def __init__(self,
                *,
                min_anonymity : builtins.int = ...,
                max_anonymity : builtins.int = ...,
                bucket_size : builtins.int = ...,
                bucket_values : typing.Optional[typing.Iterable[global___AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationQuasiIdValues]] = ...,
                bucket_value_count : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["bucket_size",b"bucket_size","bucket_value_count",b"bucket_value_count","bucket_values",b"bucket_values","max_anonymity",b"max_anonymity","min_anonymity",b"min_anonymity"]) -> None: ...

        K_MAP_ESTIMATION_HISTOGRAM_FIELD_NUMBER: builtins.int
        @property
        def k_map_estimation_histogram(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationHistogramBucket]:
            """The intervals [min_anonymity, max_anonymity] do not overlap. If a value
            doesn't correspond to any such interval, the associated frequency is
            zero. For example, the following records:
              {min_anonymity: 1, max_anonymity: 1, frequency: 17}
              {min_anonymity: 2, max_anonymity: 3, frequency: 42}
              {min_anonymity: 5, max_anonymity: 10, frequency: 99}
            mean that there are no record with an estimated anonymity of 4, 5, or
            larger than 10.
            """
            pass
        def __init__(self,
            *,
            k_map_estimation_histogram : typing.Optional[typing.Iterable[global___AnalyzeDataSourceRiskDetails.KMapEstimationResult.KMapEstimationHistogramBucket]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["k_map_estimation_histogram",b"k_map_estimation_histogram"]) -> None: ...

    class DeltaPresenceEstimationResult(google.protobuf.message.Message):
        """Result of the -presence computation. Note that these results are an
        estimation, not exact values.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class DeltaPresenceEstimationQuasiIdValues(google.protobuf.message.Message):
            """A tuple of values for the quasi-identifier columns."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            QUASI_IDS_VALUES_FIELD_NUMBER: builtins.int
            ESTIMATED_PROBABILITY_FIELD_NUMBER: builtins.int
            @property
            def quasi_ids_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Value]:
                """The quasi-identifier values."""
                pass
            estimated_probability: builtins.float = ...
            """The estimated probability that a given individual sharing these
            quasi-identifier values is in the dataset. This value, typically called
            , is the ratio between the number of records in the dataset with these
            quasi-identifier values, and the total number of individuals (inside
            *and* outside the dataset) with these quasi-identifier values.
            For example, if there are 15 individuals in the dataset who share the
            same quasi-identifier values, and an estimated 100 people in the entire
            population with these values, then  is 0.15.
            """

            def __init__(self,
                *,
                quasi_ids_values : typing.Optional[typing.Iterable[global___Value]] = ...,
                estimated_probability : builtins.float = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["estimated_probability",b"estimated_probability","quasi_ids_values",b"quasi_ids_values"]) -> None: ...

        class DeltaPresenceEstimationHistogramBucket(google.protobuf.message.Message):
            """A DeltaPresenceEstimationHistogramBucket message with the following
            values:
              min_probability: 0.1
              max_probability: 0.2
              frequency: 42
            means that there are 42 records for which  is in [0.1, 0.2). An
            important particular case is when min_probability = max_probability = 1:
            then, every individual who shares this quasi-identifier combination is in
            the dataset.
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            MIN_PROBABILITY_FIELD_NUMBER: builtins.int
            MAX_PROBABILITY_FIELD_NUMBER: builtins.int
            BUCKET_SIZE_FIELD_NUMBER: builtins.int
            BUCKET_VALUES_FIELD_NUMBER: builtins.int
            BUCKET_VALUE_COUNT_FIELD_NUMBER: builtins.int
            min_probability: builtins.float = ...
            """Between 0 and 1."""

            max_probability: builtins.float = ...
            """Always greater than or equal to min_probability."""

            bucket_size: builtins.int = ...
            """Number of records within these probability bounds."""

            @property
            def bucket_values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationQuasiIdValues]:
                """Sample of quasi-identifier tuple values in this bucket. The total
                number of classes returned per bucket is capped at 20.
                """
                pass
            bucket_value_count: builtins.int = ...
            """Total number of distinct quasi-identifier tuple values in this bucket."""

            def __init__(self,
                *,
                min_probability : builtins.float = ...,
                max_probability : builtins.float = ...,
                bucket_size : builtins.int = ...,
                bucket_values : typing.Optional[typing.Iterable[global___AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationQuasiIdValues]] = ...,
                bucket_value_count : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["bucket_size",b"bucket_size","bucket_value_count",b"bucket_value_count","bucket_values",b"bucket_values","max_probability",b"max_probability","min_probability",b"min_probability"]) -> None: ...

        DELTA_PRESENCE_ESTIMATION_HISTOGRAM_FIELD_NUMBER: builtins.int
        @property
        def delta_presence_estimation_histogram(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationHistogramBucket]:
            """The intervals [min_probability, max_probability) do not overlap. If a
            value doesn't correspond to any such interval, the associated frequency
            is zero. For example, the following records:
              {min_probability: 0, max_probability: 0.1, frequency: 17}
              {min_probability: 0.2, max_probability: 0.3, frequency: 42}
              {min_probability: 0.3, max_probability: 0.4, frequency: 99}
            mean that there are no record with an estimated probability in [0.1, 0.2)
            nor larger or equal to 0.4.
            """
            pass
        def __init__(self,
            *,
            delta_presence_estimation_histogram : typing.Optional[typing.Iterable[global___AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult.DeltaPresenceEstimationHistogramBucket]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["delta_presence_estimation_histogram",b"delta_presence_estimation_histogram"]) -> None: ...

    class RequestedRiskAnalysisOptions(google.protobuf.message.Message):
        """Risk analysis options."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        JOB_CONFIG_FIELD_NUMBER: builtins.int
        @property
        def job_config(self) -> global___RiskAnalysisJobConfig:
            """The job config for the risk job."""
            pass
        def __init__(self,
            *,
            job_config : typing.Optional[global___RiskAnalysisJobConfig] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["job_config",b"job_config"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["job_config",b"job_config"]) -> None: ...

    REQUESTED_PRIVACY_METRIC_FIELD_NUMBER: builtins.int
    REQUESTED_SOURCE_TABLE_FIELD_NUMBER: builtins.int
    NUMERICAL_STATS_RESULT_FIELD_NUMBER: builtins.int
    CATEGORICAL_STATS_RESULT_FIELD_NUMBER: builtins.int
    K_ANONYMITY_RESULT_FIELD_NUMBER: builtins.int
    L_DIVERSITY_RESULT_FIELD_NUMBER: builtins.int
    K_MAP_ESTIMATION_RESULT_FIELD_NUMBER: builtins.int
    DELTA_PRESENCE_ESTIMATION_RESULT_FIELD_NUMBER: builtins.int
    REQUESTED_OPTIONS_FIELD_NUMBER: builtins.int
    @property
    def requested_privacy_metric(self) -> global___PrivacyMetric:
        """Privacy metric to compute."""
        pass
    @property
    def requested_source_table(self) -> google.privacy.dlp.v2.storage_pb2.BigQueryTable:
        """Input dataset to compute metrics over."""
        pass
    @property
    def numerical_stats_result(self) -> global___AnalyzeDataSourceRiskDetails.NumericalStatsResult:
        """Numerical stats result"""
        pass
    @property
    def categorical_stats_result(self) -> global___AnalyzeDataSourceRiskDetails.CategoricalStatsResult:
        """Categorical stats result"""
        pass
    @property
    def k_anonymity_result(self) -> global___AnalyzeDataSourceRiskDetails.KAnonymityResult:
        """K-anonymity result"""
        pass
    @property
    def l_diversity_result(self) -> global___AnalyzeDataSourceRiskDetails.LDiversityResult:
        """L-divesity result"""
        pass
    @property
    def k_map_estimation_result(self) -> global___AnalyzeDataSourceRiskDetails.KMapEstimationResult:
        """K-map result"""
        pass
    @property
    def delta_presence_estimation_result(self) -> global___AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult:
        """Delta-presence result"""
        pass
    @property
    def requested_options(self) -> global___AnalyzeDataSourceRiskDetails.RequestedRiskAnalysisOptions:
        """The configuration used for this job."""
        pass
    def __init__(self,
        *,
        requested_privacy_metric : typing.Optional[global___PrivacyMetric] = ...,
        requested_source_table : typing.Optional[google.privacy.dlp.v2.storage_pb2.BigQueryTable] = ...,
        numerical_stats_result : typing.Optional[global___AnalyzeDataSourceRiskDetails.NumericalStatsResult] = ...,
        categorical_stats_result : typing.Optional[global___AnalyzeDataSourceRiskDetails.CategoricalStatsResult] = ...,
        k_anonymity_result : typing.Optional[global___AnalyzeDataSourceRiskDetails.KAnonymityResult] = ...,
        l_diversity_result : typing.Optional[global___AnalyzeDataSourceRiskDetails.LDiversityResult] = ...,
        k_map_estimation_result : typing.Optional[global___AnalyzeDataSourceRiskDetails.KMapEstimationResult] = ...,
        delta_presence_estimation_result : typing.Optional[global___AnalyzeDataSourceRiskDetails.DeltaPresenceEstimationResult] = ...,
        requested_options : typing.Optional[global___AnalyzeDataSourceRiskDetails.RequestedRiskAnalysisOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["categorical_stats_result",b"categorical_stats_result","delta_presence_estimation_result",b"delta_presence_estimation_result","k_anonymity_result",b"k_anonymity_result","k_map_estimation_result",b"k_map_estimation_result","l_diversity_result",b"l_diversity_result","numerical_stats_result",b"numerical_stats_result","requested_options",b"requested_options","requested_privacy_metric",b"requested_privacy_metric","requested_source_table",b"requested_source_table","result",b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["categorical_stats_result",b"categorical_stats_result","delta_presence_estimation_result",b"delta_presence_estimation_result","k_anonymity_result",b"k_anonymity_result","k_map_estimation_result",b"k_map_estimation_result","l_diversity_result",b"l_diversity_result","numerical_stats_result",b"numerical_stats_result","requested_options",b"requested_options","requested_privacy_metric",b"requested_privacy_metric","requested_source_table",b"requested_source_table","result",b"result"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["result",b"result"]) -> typing.Optional[typing_extensions.Literal["numerical_stats_result","categorical_stats_result","k_anonymity_result","l_diversity_result","k_map_estimation_result","delta_presence_estimation_result"]]: ...
global___AnalyzeDataSourceRiskDetails = AnalyzeDataSourceRiskDetails

class ValueFrequency(google.protobuf.message.Message):
    """A value of a field, including its frequency."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VALUE_FIELD_NUMBER: builtins.int
    COUNT_FIELD_NUMBER: builtins.int
    @property
    def value(self) -> global___Value:
        """A value contained in the field in question."""
        pass
    count: builtins.int = ...
    """How many times the value is contained in the field."""

    def __init__(self,
        *,
        value : typing.Optional[global___Value] = ...,
        count : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["count",b"count","value",b"value"]) -> None: ...
global___ValueFrequency = ValueFrequency

class Value(google.protobuf.message.Message):
    """Set of primitive values supported by the system.
    Note that for the purposes of inspection or transformation, the number
    of bytes considered to comprise a 'Value' is based on its representation
    as a UTF-8 encoded string. For example, if 'integer_value' is set to
    123456789, the number of bytes would be counted as 9, even though an
    int64 only holds up to 8 bytes of data.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INTEGER_VALUE_FIELD_NUMBER: builtins.int
    FLOAT_VALUE_FIELD_NUMBER: builtins.int
    STRING_VALUE_FIELD_NUMBER: builtins.int
    BOOLEAN_VALUE_FIELD_NUMBER: builtins.int
    TIMESTAMP_VALUE_FIELD_NUMBER: builtins.int
    TIME_VALUE_FIELD_NUMBER: builtins.int
    DATE_VALUE_FIELD_NUMBER: builtins.int
    DAY_OF_WEEK_VALUE_FIELD_NUMBER: builtins.int
    integer_value: builtins.int = ...
    """integer"""

    float_value: builtins.float = ...
    """float"""

    string_value: typing.Text = ...
    """string"""

    boolean_value: builtins.bool = ...
    """boolean"""

    @property
    def timestamp_value(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """timestamp"""
        pass
    @property
    def time_value(self) -> google.type.timeofday_pb2.TimeOfDay:
        """time of day"""
        pass
    @property
    def date_value(self) -> google.type.date_pb2.Date:
        """date"""
        pass
    day_of_week_value: google.type.dayofweek_pb2.DayOfWeek.ValueType = ...
    """day of week"""

    def __init__(self,
        *,
        integer_value : builtins.int = ...,
        float_value : builtins.float = ...,
        string_value : typing.Text = ...,
        boolean_value : builtins.bool = ...,
        timestamp_value : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        time_value : typing.Optional[google.type.timeofday_pb2.TimeOfDay] = ...,
        date_value : typing.Optional[google.type.date_pb2.Date] = ...,
        day_of_week_value : google.type.dayofweek_pb2.DayOfWeek.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["boolean_value",b"boolean_value","date_value",b"date_value","day_of_week_value",b"day_of_week_value","float_value",b"float_value","integer_value",b"integer_value","string_value",b"string_value","time_value",b"time_value","timestamp_value",b"timestamp_value","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["boolean_value",b"boolean_value","date_value",b"date_value","day_of_week_value",b"day_of_week_value","float_value",b"float_value","integer_value",b"integer_value","string_value",b"string_value","time_value",b"time_value","timestamp_value",b"timestamp_value","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["integer_value","float_value","string_value","boolean_value","timestamp_value","time_value","date_value","day_of_week_value"]]: ...
global___Value = Value

class QuoteInfo(google.protobuf.message.Message):
    """Message for infoType-dependent details parsed from quote."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATE_TIME_FIELD_NUMBER: builtins.int
    @property
    def date_time(self) -> global___DateTime:
        """The date time indicated by the quote."""
        pass
    def __init__(self,
        *,
        date_time : typing.Optional[global___DateTime] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["date_time",b"date_time","parsed_quote",b"parsed_quote"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["date_time",b"date_time","parsed_quote",b"parsed_quote"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["parsed_quote",b"parsed_quote"]) -> typing.Optional[typing_extensions.Literal["date_time"]]: ...
global___QuoteInfo = QuoteInfo

class DateTime(google.protobuf.message.Message):
    """Message for a date time object.
    e.g. 2018-01-01, 5th August.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class TimeZone(google.protobuf.message.Message):
        """Time zone of the date time object."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        OFFSET_MINUTES_FIELD_NUMBER: builtins.int
        offset_minutes: builtins.int = ...
        """Set only if the offset can be determined. Positive for time ahead of UTC.
        E.g. For "UTC-9", this value is -540.
        """

        def __init__(self,
            *,
            offset_minutes : builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["offset_minutes",b"offset_minutes"]) -> None: ...

    DATE_FIELD_NUMBER: builtins.int
    DAY_OF_WEEK_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    TIME_ZONE_FIELD_NUMBER: builtins.int
    @property
    def date(self) -> google.type.date_pb2.Date:
        """One or more of the following must be set.
        Must be a valid date or time value.
        """
        pass
    day_of_week: google.type.dayofweek_pb2.DayOfWeek.ValueType = ...
    """Day of week"""

    @property
    def time(self) -> google.type.timeofday_pb2.TimeOfDay:
        """Time of day"""
        pass
    @property
    def time_zone(self) -> global___DateTime.TimeZone:
        """Time zone"""
        pass
    def __init__(self,
        *,
        date : typing.Optional[google.type.date_pb2.Date] = ...,
        day_of_week : google.type.dayofweek_pb2.DayOfWeek.ValueType = ...,
        time : typing.Optional[google.type.timeofday_pb2.TimeOfDay] = ...,
        time_zone : typing.Optional[global___DateTime.TimeZone] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["date",b"date","time",b"time","time_zone",b"time_zone"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["date",b"date","day_of_week",b"day_of_week","time",b"time","time_zone",b"time_zone"]) -> None: ...
global___DateTime = DateTime

class DeidentifyConfig(google.protobuf.message.Message):
    """The configuration that controls how the data will change."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INFO_TYPE_TRANSFORMATIONS_FIELD_NUMBER: builtins.int
    RECORD_TRANSFORMATIONS_FIELD_NUMBER: builtins.int
    TRANSFORMATION_ERROR_HANDLING_FIELD_NUMBER: builtins.int
    @property
    def info_type_transformations(self) -> global___InfoTypeTransformations:
        """Treat the dataset as free-form text and apply the same free text
        transformation everywhere.
        """
        pass
    @property
    def record_transformations(self) -> global___RecordTransformations:
        """Treat the dataset as structured. Transformations can be applied to
        specific locations within structured datasets, such as transforming
        a column within a table.
        """
        pass
    @property
    def transformation_error_handling(self) -> global___TransformationErrorHandling:
        """Mode for handling transformation errors. If left unspecified, the default
        mode is `TransformationErrorHandling.ThrowError`.
        """
        pass
    def __init__(self,
        *,
        info_type_transformations : typing.Optional[global___InfoTypeTransformations] = ...,
        record_transformations : typing.Optional[global___RecordTransformations] = ...,
        transformation_error_handling : typing.Optional[global___TransformationErrorHandling] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["info_type_transformations",b"info_type_transformations","record_transformations",b"record_transformations","transformation",b"transformation","transformation_error_handling",b"transformation_error_handling"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["info_type_transformations",b"info_type_transformations","record_transformations",b"record_transformations","transformation",b"transformation","transformation_error_handling",b"transformation_error_handling"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["transformation",b"transformation"]) -> typing.Optional[typing_extensions.Literal["info_type_transformations","record_transformations"]]: ...
global___DeidentifyConfig = DeidentifyConfig

class TransformationErrorHandling(google.protobuf.message.Message):
    """How to handle transformation errors during de-identification. A
    transformation error occurs when the requested transformation is incompatible
    with the data. For example, trying to de-identify an IP address using a
    `DateShift` transformation would result in a transformation error, since date
    info cannot be extracted from an IP address.
    Information about any incompatible transformations, and how they were
    handled, is returned in the response as part of the
    `TransformationOverviews`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ThrowError(google.protobuf.message.Message):
        """Throw an error and fail the request when a transformation error occurs."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    class LeaveUntransformed(google.protobuf.message.Message):
        """Skips the data without modifying it if the requested transformation would
        cause an error. For example, if a `DateShift` transformation were applied
        an an IP address, this mode would leave the IP address unchanged in the
        response.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    THROW_ERROR_FIELD_NUMBER: builtins.int
    LEAVE_UNTRANSFORMED_FIELD_NUMBER: builtins.int
    @property
    def throw_error(self) -> global___TransformationErrorHandling.ThrowError:
        """Throw an error"""
        pass
    @property
    def leave_untransformed(self) -> global___TransformationErrorHandling.LeaveUntransformed:
        """Ignore errors"""
        pass
    def __init__(self,
        *,
        throw_error : typing.Optional[global___TransformationErrorHandling.ThrowError] = ...,
        leave_untransformed : typing.Optional[global___TransformationErrorHandling.LeaveUntransformed] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["leave_untransformed",b"leave_untransformed","mode",b"mode","throw_error",b"throw_error"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["leave_untransformed",b"leave_untransformed","mode",b"mode","throw_error",b"throw_error"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["mode",b"mode"]) -> typing.Optional[typing_extensions.Literal["throw_error","leave_untransformed"]]: ...
global___TransformationErrorHandling = TransformationErrorHandling

class PrimitiveTransformation(google.protobuf.message.Message):
    """A rule for transforming a value."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    REPLACE_CONFIG_FIELD_NUMBER: builtins.int
    REDACT_CONFIG_FIELD_NUMBER: builtins.int
    CHARACTER_MASK_CONFIG_FIELD_NUMBER: builtins.int
    CRYPTO_REPLACE_FFX_FPE_CONFIG_FIELD_NUMBER: builtins.int
    FIXED_SIZE_BUCKETING_CONFIG_FIELD_NUMBER: builtins.int
    BUCKETING_CONFIG_FIELD_NUMBER: builtins.int
    REPLACE_WITH_INFO_TYPE_CONFIG_FIELD_NUMBER: builtins.int
    TIME_PART_CONFIG_FIELD_NUMBER: builtins.int
    CRYPTO_HASH_CONFIG_FIELD_NUMBER: builtins.int
    DATE_SHIFT_CONFIG_FIELD_NUMBER: builtins.int
    CRYPTO_DETERMINISTIC_CONFIG_FIELD_NUMBER: builtins.int
    REPLACE_DICTIONARY_CONFIG_FIELD_NUMBER: builtins.int
    @property
    def replace_config(self) -> global___ReplaceValueConfig:
        """Replace with a specified value."""
        pass
    @property
    def redact_config(self) -> global___RedactConfig:
        """Redact"""
        pass
    @property
    def character_mask_config(self) -> global___CharacterMaskConfig:
        """Mask"""
        pass
    @property
    def crypto_replace_ffx_fpe_config(self) -> global___CryptoReplaceFfxFpeConfig:
        """Ffx-Fpe"""
        pass
    @property
    def fixed_size_bucketing_config(self) -> global___FixedSizeBucketingConfig:
        """Fixed size bucketing"""
        pass
    @property
    def bucketing_config(self) -> global___BucketingConfig:
        """Bucketing"""
        pass
    @property
    def replace_with_info_type_config(self) -> global___ReplaceWithInfoTypeConfig:
        """Replace with infotype"""
        pass
    @property
    def time_part_config(self) -> global___TimePartConfig:
        """Time extraction"""
        pass
    @property
    def crypto_hash_config(self) -> global___CryptoHashConfig:
        """Crypto"""
        pass
    @property
    def date_shift_config(self) -> global___DateShiftConfig:
        """Date Shift"""
        pass
    @property
    def crypto_deterministic_config(self) -> global___CryptoDeterministicConfig:
        """Deterministic Crypto"""
        pass
    @property
    def replace_dictionary_config(self) -> global___ReplaceDictionaryConfig:
        """Replace with a value randomly drawn (with replacement) from a dictionary."""
        pass
    def __init__(self,
        *,
        replace_config : typing.Optional[global___ReplaceValueConfig] = ...,
        redact_config : typing.Optional[global___RedactConfig] = ...,
        character_mask_config : typing.Optional[global___CharacterMaskConfig] = ...,
        crypto_replace_ffx_fpe_config : typing.Optional[global___CryptoReplaceFfxFpeConfig] = ...,
        fixed_size_bucketing_config : typing.Optional[global___FixedSizeBucketingConfig] = ...,
        bucketing_config : typing.Optional[global___BucketingConfig] = ...,
        replace_with_info_type_config : typing.Optional[global___ReplaceWithInfoTypeConfig] = ...,
        time_part_config : typing.Optional[global___TimePartConfig] = ...,
        crypto_hash_config : typing.Optional[global___CryptoHashConfig] = ...,
        date_shift_config : typing.Optional[global___DateShiftConfig] = ...,
        crypto_deterministic_config : typing.Optional[global___CryptoDeterministicConfig] = ...,
        replace_dictionary_config : typing.Optional[global___ReplaceDictionaryConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bucketing_config",b"bucketing_config","character_mask_config",b"character_mask_config","crypto_deterministic_config",b"crypto_deterministic_config","crypto_hash_config",b"crypto_hash_config","crypto_replace_ffx_fpe_config",b"crypto_replace_ffx_fpe_config","date_shift_config",b"date_shift_config","fixed_size_bucketing_config",b"fixed_size_bucketing_config","redact_config",b"redact_config","replace_config",b"replace_config","replace_dictionary_config",b"replace_dictionary_config","replace_with_info_type_config",b"replace_with_info_type_config","time_part_config",b"time_part_config","transformation",b"transformation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bucketing_config",b"bucketing_config","character_mask_config",b"character_mask_config","crypto_deterministic_config",b"crypto_deterministic_config","crypto_hash_config",b"crypto_hash_config","crypto_replace_ffx_fpe_config",b"crypto_replace_ffx_fpe_config","date_shift_config",b"date_shift_config","fixed_size_bucketing_config",b"fixed_size_bucketing_config","redact_config",b"redact_config","replace_config",b"replace_config","replace_dictionary_config",b"replace_dictionary_config","replace_with_info_type_config",b"replace_with_info_type_config","time_part_config",b"time_part_config","transformation",b"transformation"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["transformation",b"transformation"]) -> typing.Optional[typing_extensions.Literal["replace_config","redact_config","character_mask_config","crypto_replace_ffx_fpe_config","fixed_size_bucketing_config","bucketing_config","replace_with_info_type_config","time_part_config","crypto_hash_config","date_shift_config","crypto_deterministic_config","replace_dictionary_config"]]: ...
global___PrimitiveTransformation = PrimitiveTransformation

class TimePartConfig(google.protobuf.message.Message):
    """For use with `Date`, `Timestamp`, and `TimeOfDay`, extract or preserve a
    portion of the value.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _TimePart:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TimePartEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TimePart.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        TIME_PART_UNSPECIFIED: TimePartConfig.TimePart.ValueType = ...  # 0
        """Unused"""

        YEAR: TimePartConfig.TimePart.ValueType = ...  # 1
        """[0-9999]"""

        MONTH: TimePartConfig.TimePart.ValueType = ...  # 2
        """[1-12]"""

        DAY_OF_MONTH: TimePartConfig.TimePart.ValueType = ...  # 3
        """[1-31]"""

        DAY_OF_WEEK: TimePartConfig.TimePart.ValueType = ...  # 4
        """[1-7]"""

        WEEK_OF_YEAR: TimePartConfig.TimePart.ValueType = ...  # 5
        """[1-53]"""

        HOUR_OF_DAY: TimePartConfig.TimePart.ValueType = ...  # 6
        """[0-23]"""

    class TimePart(_TimePart, metaclass=_TimePartEnumTypeWrapper):
        """Components that make up time."""
        pass

    TIME_PART_UNSPECIFIED: TimePartConfig.TimePart.ValueType = ...  # 0
    """Unused"""

    YEAR: TimePartConfig.TimePart.ValueType = ...  # 1
    """[0-9999]"""

    MONTH: TimePartConfig.TimePart.ValueType = ...  # 2
    """[1-12]"""

    DAY_OF_MONTH: TimePartConfig.TimePart.ValueType = ...  # 3
    """[1-31]"""

    DAY_OF_WEEK: TimePartConfig.TimePart.ValueType = ...  # 4
    """[1-7]"""

    WEEK_OF_YEAR: TimePartConfig.TimePart.ValueType = ...  # 5
    """[1-53]"""

    HOUR_OF_DAY: TimePartConfig.TimePart.ValueType = ...  # 6
    """[0-23]"""


    PART_TO_EXTRACT_FIELD_NUMBER: builtins.int
    part_to_extract: global___TimePartConfig.TimePart.ValueType = ...
    """The part of the time to keep."""

    def __init__(self,
        *,
        part_to_extract : global___TimePartConfig.TimePart.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["part_to_extract",b"part_to_extract"]) -> None: ...
global___TimePartConfig = TimePartConfig

class CryptoHashConfig(google.protobuf.message.Message):
    """Pseudonymization method that generates surrogates via cryptographic hashing.
    Uses SHA-256.
    The key size must be either 32 or 64 bytes.
    Outputs a base64 encoded representation of the hashed output
    (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
    Currently, only string and integer values can be hashed.
    See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CRYPTO_KEY_FIELD_NUMBER: builtins.int
    @property
    def crypto_key(self) -> global___CryptoKey:
        """The key used by the hash function."""
        pass
    def __init__(self,
        *,
        crypto_key : typing.Optional[global___CryptoKey] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["crypto_key",b"crypto_key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["crypto_key",b"crypto_key"]) -> None: ...
global___CryptoHashConfig = CryptoHashConfig

class CryptoDeterministicConfig(google.protobuf.message.Message):
    """Pseudonymization method that generates deterministic encryption for the given
    input. Outputs a base64 encoded representation of the encrypted output.
    Uses AES-SIV based on the RFC https://tools.ietf.org/html/rfc5297.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CRYPTO_KEY_FIELD_NUMBER: builtins.int
    SURROGATE_INFO_TYPE_FIELD_NUMBER: builtins.int
    CONTEXT_FIELD_NUMBER: builtins.int
    @property
    def crypto_key(self) -> global___CryptoKey:
        """The key used by the encryption function. For deterministic encryption
        using AES-SIV, the provided key is internally expanded to 64 bytes prior to
        use.
        """
        pass
    @property
    def surrogate_info_type(self) -> google.privacy.dlp.v2.storage_pb2.InfoType:
        """The custom info type to annotate the surrogate with.
        This annotation will be applied to the surrogate by prefixing it with
        the name of the custom info type followed by the number of
        characters comprising the surrogate. The following scheme defines the
        format: {info type name}({surrogate character count}):{surrogate}

        For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and
        the surrogate is 'abc', the full replacement value
        will be: 'MY_TOKEN_INFO_TYPE(3):abc'

        This annotation identifies the surrogate when inspecting content using the
        custom info type 'Surrogate'. This facilitates reversal of the
        surrogate when it occurs in free text.

        Note: For record transformations where the entire cell in a table is being
        transformed, surrogates are not mandatory. Surrogates are used to denote
        the location of the token and are necessary for re-identification in free
        form text.

        In order for inspection to work properly, the name of this info type must
        not occur naturally anywhere in your data; otherwise, inspection may either

        - reverse a surrogate that does not correspond to an actual identifier
        - be unable to parse the surrogate and result in an error

        Therefore, choose your custom info type name carefully after considering
        what your data looks like. One way to select a name that has a high chance
        of yielding reliable detection is to include one or more unicode characters
        that are highly improbable to exist in your data.
        For example, assuming your data is entered from a regular ASCII keyboard,
        the symbol with the hex code point 29DD might be used like so:
        MY_TOKEN_TYPE.
        """
        pass
    @property
    def context(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
        """A context may be used for higher security and maintaining
        referential integrity such that the same identifier in two different
        contexts will be given a distinct surrogate. The context is appended to
        plaintext value being encrypted. On decryption the provided context is
        validated against the value used during encryption. If a context was
        provided during encryption, same context must be provided during decryption
        as well.

        If the context is not set, plaintext would be used as is for encryption.
        If the context is set but:

        1. there is no record present when transforming a given value or
        2. the field is not present when transforming a given value,

        plaintext would be used as is for encryption.

        Note that case (1) is expected when an `InfoTypeTransformation` is
        applied to both structured and non-structured `ContentItem`s.
        """
        pass
    def __init__(self,
        *,
        crypto_key : typing.Optional[global___CryptoKey] = ...,
        surrogate_info_type : typing.Optional[google.privacy.dlp.v2.storage_pb2.InfoType] = ...,
        context : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["context",b"context","crypto_key",b"crypto_key","surrogate_info_type",b"surrogate_info_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["context",b"context","crypto_key",b"crypto_key","surrogate_info_type",b"surrogate_info_type"]) -> None: ...
global___CryptoDeterministicConfig = CryptoDeterministicConfig

class ReplaceValueConfig(google.protobuf.message.Message):
    """Replace each input value with a given `Value`."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NEW_VALUE_FIELD_NUMBER: builtins.int
    @property
    def new_value(self) -> global___Value:
        """Value to replace it with."""
        pass
    def __init__(self,
        *,
        new_value : typing.Optional[global___Value] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["new_value",b"new_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["new_value",b"new_value"]) -> None: ...
global___ReplaceValueConfig = ReplaceValueConfig

class ReplaceDictionaryConfig(google.protobuf.message.Message):
    """Replace each input value with a value randomly selected from the dictionary."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    WORD_LIST_FIELD_NUMBER: builtins.int
    @property
    def word_list(self) -> google.privacy.dlp.v2.storage_pb2.CustomInfoType.Dictionary.WordList:
        """A list of words to select from for random replacement. The
        [limits](https://cloud.google.com/dlp/limits) page contains details about
        the size limits of dictionaries.
        """
        pass
    def __init__(self,
        *,
        word_list : typing.Optional[google.privacy.dlp.v2.storage_pb2.CustomInfoType.Dictionary.WordList] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["type",b"type","word_list",b"word_list"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["type",b"type","word_list",b"word_list"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["word_list"]]: ...
global___ReplaceDictionaryConfig = ReplaceDictionaryConfig

class ReplaceWithInfoTypeConfig(google.protobuf.message.Message):
    """Replace each matching finding with the name of the info_type."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___ReplaceWithInfoTypeConfig = ReplaceWithInfoTypeConfig

class RedactConfig(google.protobuf.message.Message):
    """Redact a given value. For example, if used with an `InfoTypeTransformation`
    transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the
    output would be 'My phone number is '.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___RedactConfig = RedactConfig

class CharsToIgnore(google.protobuf.message.Message):
    """Characters to skip when doing deidentification of a value. These will be left
    alone and skipped.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _CommonCharsToIgnore:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _CommonCharsToIgnoreEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_CommonCharsToIgnore.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        COMMON_CHARS_TO_IGNORE_UNSPECIFIED: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 0
        """Unused."""

        NUMERIC: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 1
        """0-9"""

        ALPHA_UPPER_CASE: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 2
        """A-Z"""

        ALPHA_LOWER_CASE: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 3
        """a-z"""

        PUNCTUATION: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 4
        """US Punctuation, one of !"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"""

        WHITESPACE: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 5
        """Whitespace character, one of [ \\t\\n\\x0B\\f\\r]"""

    class CommonCharsToIgnore(_CommonCharsToIgnore, metaclass=_CommonCharsToIgnoreEnumTypeWrapper):
        """Convenience enum for indication common characters to not transform."""
        pass

    COMMON_CHARS_TO_IGNORE_UNSPECIFIED: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 0
    """Unused."""

    NUMERIC: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 1
    """0-9"""

    ALPHA_UPPER_CASE: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 2
    """A-Z"""

    ALPHA_LOWER_CASE: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 3
    """a-z"""

    PUNCTUATION: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 4
    """US Punctuation, one of !"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"""

    WHITESPACE: CharsToIgnore.CommonCharsToIgnore.ValueType = ...  # 5
    """Whitespace character, one of [ \\t\\n\\x0B\\f\\r]"""


    CHARACTERS_TO_SKIP_FIELD_NUMBER: builtins.int
    COMMON_CHARACTERS_TO_IGNORE_FIELD_NUMBER: builtins.int
    characters_to_skip: typing.Text = ...
    """Characters to not transform when masking."""

    common_characters_to_ignore: global___CharsToIgnore.CommonCharsToIgnore.ValueType = ...
    """Common characters to not transform when masking. Useful to avoid removing
    punctuation.
    """

    def __init__(self,
        *,
        characters_to_skip : typing.Text = ...,
        common_characters_to_ignore : global___CharsToIgnore.CommonCharsToIgnore.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["characters",b"characters","characters_to_skip",b"characters_to_skip","common_characters_to_ignore",b"common_characters_to_ignore"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["characters",b"characters","characters_to_skip",b"characters_to_skip","common_characters_to_ignore",b"common_characters_to_ignore"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["characters",b"characters"]) -> typing.Optional[typing_extensions.Literal["characters_to_skip","common_characters_to_ignore"]]: ...
global___CharsToIgnore = CharsToIgnore

class CharacterMaskConfig(google.protobuf.message.Message):
    """Partially mask a string by replacing a given number of characters with a
    fixed character. Masking can start from the beginning or end of the string.
    This can be used on data of any type (numbers, longs, and so on) and when
    de-identifying structured data we'll attempt to preserve the original data's
    type. (This allows you to take a long like 123 and modify it to a string like
    **3.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MASKING_CHARACTER_FIELD_NUMBER: builtins.int
    NUMBER_TO_MASK_FIELD_NUMBER: builtins.int
    REVERSE_ORDER_FIELD_NUMBER: builtins.int
    CHARACTERS_TO_IGNORE_FIELD_NUMBER: builtins.int
    masking_character: typing.Text = ...
    """Character to use to mask the sensitive values&mdash;for example, `*` for an
    alphabetic string such as a name, or `0` for a numeric string such as ZIP
    code or credit card number. This string must have a length of 1. If not
    supplied, this value defaults to `*` for strings, and `0` for digits.
    """

    number_to_mask: builtins.int = ...
    """Number of characters to mask. If not set, all matching chars will be
    masked. Skipped characters do not count towards this tally.
    """

    reverse_order: builtins.bool = ...
    """Mask characters in reverse order. For example, if `masking_character` is
    `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the
    input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
    If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order`
    is `true`, then the string `12345` is masked as `12***`.
    """

    @property
    def characters_to_ignore(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CharsToIgnore]:
        """When masking a string, items in this list will be skipped when replacing
        characters. For example, if the input string is `555-555-5555` and you
        instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP
        returns `***-**5-5555`.
        """
        pass
    def __init__(self,
        *,
        masking_character : typing.Text = ...,
        number_to_mask : builtins.int = ...,
        reverse_order : builtins.bool = ...,
        characters_to_ignore : typing.Optional[typing.Iterable[global___CharsToIgnore]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["characters_to_ignore",b"characters_to_ignore","masking_character",b"masking_character","number_to_mask",b"number_to_mask","reverse_order",b"reverse_order"]) -> None: ...
global___CharacterMaskConfig = CharacterMaskConfig

class FixedSizeBucketingConfig(google.protobuf.message.Message):
    """Buckets values based on fixed size ranges. The
    Bucketing transformation can provide all of this functionality,
    but requires more configuration. This message is provided as a convenience to
    the user for simple bucketing strategies.

    The transformed value will be a hyphenated string of
    {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound
    = 20, all values that are within this bucket will be replaced with "10-20".

    This can be used on data of type: double, long.

    If the bound Value type differs from the type of data
    being transformed, we will first attempt converting the type of the data to
    be transformed to match the type of the bound before comparing.

    See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LOWER_BOUND_FIELD_NUMBER: builtins.int
    UPPER_BOUND_FIELD_NUMBER: builtins.int
    BUCKET_SIZE_FIELD_NUMBER: builtins.int
    @property
    def lower_bound(self) -> global___Value:
        """Required. Lower bound value of buckets. All values less than `lower_bound` are
        grouped together into a single bucket; for example if `lower_bound` = 10,
        then all values less than 10 are replaced with the value "-10".
        """
        pass
    @property
    def upper_bound(self) -> global___Value:
        """Required. Upper bound value of buckets. All values greater than upper_bound are
        grouped together into a single bucket; for example if `upper_bound` = 89,
        then all values greater than 89 are replaced with the value "89+".
        """
        pass
    bucket_size: builtins.float = ...
    """Required. Size of each bucket (except for minimum and maximum buckets). So if
    `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the
    following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60,
    60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.
    """

    def __init__(self,
        *,
        lower_bound : typing.Optional[global___Value] = ...,
        upper_bound : typing.Optional[global___Value] = ...,
        bucket_size : builtins.float = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["lower_bound",b"lower_bound","upper_bound",b"upper_bound"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bucket_size",b"bucket_size","lower_bound",b"lower_bound","upper_bound",b"upper_bound"]) -> None: ...
global___FixedSizeBucketingConfig = FixedSizeBucketingConfig

class BucketingConfig(google.protobuf.message.Message):
    """Generalization function that buckets values based on ranges. The ranges and
    replacement values are dynamically provided by the user for custom behavior,
    such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
    This can be used on
    data of type: number, long, string, timestamp.
    If the bound `Value` type differs from the type of data being transformed, we
    will first attempt converting the type of the data to be transformed to match
    the type of the bound before comparing.
    See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Bucket(google.protobuf.message.Message):
        """Bucket is represented as a range, along with replacement values."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MIN_FIELD_NUMBER: builtins.int
        MAX_FIELD_NUMBER: builtins.int
        REPLACEMENT_VALUE_FIELD_NUMBER: builtins.int
        @property
        def min(self) -> global___Value:
            """Lower bound of the range, inclusive. Type should be the same as max if
            used.
            """
            pass
        @property
        def max(self) -> global___Value:
            """Upper bound of the range, exclusive; type must match min."""
            pass
        @property
        def replacement_value(self) -> global___Value:
            """Required. Replacement value for this bucket."""
            pass
        def __init__(self,
            *,
            min : typing.Optional[global___Value] = ...,
            max : typing.Optional[global___Value] = ...,
            replacement_value : typing.Optional[global___Value] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["max",b"max","min",b"min","replacement_value",b"replacement_value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["max",b"max","min",b"min","replacement_value",b"replacement_value"]) -> None: ...

    BUCKETS_FIELD_NUMBER: builtins.int
    @property
    def buckets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BucketingConfig.Bucket]:
        """Set of buckets. Ranges must be non-overlapping."""
        pass
    def __init__(self,
        *,
        buckets : typing.Optional[typing.Iterable[global___BucketingConfig.Bucket]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["buckets",b"buckets"]) -> None: ...
global___BucketingConfig = BucketingConfig

class CryptoReplaceFfxFpeConfig(google.protobuf.message.Message):
    """Replaces an identifier with a surrogate using Format Preserving Encryption
    (FPE) with the FFX mode of operation; however when used in the
    `ReidentifyContent` API method, it serves the opposite function by reversing
    the surrogate back into the original identifier. The identifier must be
    encoded as ASCII. For a given crypto key and context, the same identifier
    will be replaced with the same surrogate. Identifiers must be at least two
    characters long. In the case that the identifier is the empty string, it will
    be skipped. See https://cloud.google.com/dlp/docs/pseudonymization to learn
    more.

    Note: We recommend using  CryptoDeterministicConfig for all use cases which
    do not require preserving the input alphabet space and size, plus warrant
    referential integrity.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _FfxCommonNativeAlphabet:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _FfxCommonNativeAlphabetEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_FfxCommonNativeAlphabet.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED: CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...  # 0
        """Unused."""

        NUMERIC: CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...  # 1
        """`[0-9]` (radix of 10)"""

        HEXADECIMAL: CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...  # 2
        """`[0-9A-F]` (radix of 16)"""

        UPPER_CASE_ALPHA_NUMERIC: CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...  # 3
        """`[0-9A-Z]` (radix of 36)"""

        ALPHA_NUMERIC: CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...  # 4
        """`[0-9A-Za-z]` (radix of 62)"""

    class FfxCommonNativeAlphabet(_FfxCommonNativeAlphabet, metaclass=_FfxCommonNativeAlphabetEnumTypeWrapper):
        """These are commonly used subsets of the alphabet that the FFX mode
        natively supports. In the algorithm, the alphabet is selected using
        the "radix". Therefore each corresponds to particular radix.
        """
        pass

    FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED: CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...  # 0
    """Unused."""

    NUMERIC: CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...  # 1
    """`[0-9]` (radix of 10)"""

    HEXADECIMAL: CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...  # 2
    """`[0-9A-F]` (radix of 16)"""

    UPPER_CASE_ALPHA_NUMERIC: CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...  # 3
    """`[0-9A-Z]` (radix of 36)"""

    ALPHA_NUMERIC: CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...  # 4
    """`[0-9A-Za-z]` (radix of 62)"""


    CRYPTO_KEY_FIELD_NUMBER: builtins.int
    CONTEXT_FIELD_NUMBER: builtins.int
    COMMON_ALPHABET_FIELD_NUMBER: builtins.int
    CUSTOM_ALPHABET_FIELD_NUMBER: builtins.int
    RADIX_FIELD_NUMBER: builtins.int
    SURROGATE_INFO_TYPE_FIELD_NUMBER: builtins.int
    @property
    def crypto_key(self) -> global___CryptoKey:
        """Required. The key used by the encryption algorithm."""
        pass
    @property
    def context(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
        """The 'tweak', a context may be used for higher security since the same
        identifier in two different contexts won't be given the same surrogate. If
        the context is not set, a default tweak will be used.

        If the context is set but:

        1. there is no record present when transforming a given value or
        1. the field is not present when transforming a given value,

        a default tweak will be used.

        Note that case (1) is expected when an `InfoTypeTransformation` is
        applied to both structured and non-structured `ContentItem`s.
        Currently, the referenced field may be of value type integer or string.

        The tweak is constructed as a sequence of bytes in big endian byte order
        such that:

        - a 64 bit integer is encoded followed by a single byte of value 1
        - a string is encoded in UTF-8 format followed by a single byte of value 2
        """
        pass
    common_alphabet: global___CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...
    """Common alphabets."""

    custom_alphabet: typing.Text = ...
    """This is supported by mapping these to the alphanumeric characters
    that the FFX mode natively supports. This happens before/after
    encryption/decryption.
    Each character listed must appear only once.
    Number of characters must be in the range [2, 95].
    This must be encoded as ASCII.
    The order of characters does not matter.
    The full list of allowed characters is:
    <code>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
    ~`!@#$%^&*()_-+={[}]|\\:;"'<,>.?/</code>
    """

    radix: builtins.int = ...
    """The native way to select the alphabet. Must be in the range [2, 95]."""

    @property
    def surrogate_info_type(self) -> google.privacy.dlp.v2.storage_pb2.InfoType:
        """The custom infoType to annotate the surrogate with.
        This annotation will be applied to the surrogate by prefixing it with
        the name of the custom infoType followed by the number of
        characters comprising the surrogate. The following scheme defines the
        format: info_type_name(surrogate_character_count):surrogate

        For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and
        the surrogate is 'abc', the full replacement value
        will be: 'MY_TOKEN_INFO_TYPE(3):abc'

        This annotation identifies the surrogate when inspecting content using the
        custom infoType
        [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype).
        This facilitates reversal of the surrogate when it occurs in free text.

        In order for inspection to work properly, the name of this infoType must
        not occur naturally anywhere in your data; otherwise, inspection may
        find a surrogate that does not correspond to an actual identifier.
        Therefore, choose your custom infoType name carefully after considering
        what your data looks like. One way to select a name that has a high chance
        of yielding reliable detection is to include one or more unicode characters
        that are highly improbable to exist in your data.
        For example, assuming your data is entered from a regular ASCII keyboard,
        the symbol with the hex code point 29DD might be used like so:
        MY_TOKEN_TYPE
        """
        pass
    def __init__(self,
        *,
        crypto_key : typing.Optional[global___CryptoKey] = ...,
        context : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
        common_alphabet : global___CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet.ValueType = ...,
        custom_alphabet : typing.Text = ...,
        radix : builtins.int = ...,
        surrogate_info_type : typing.Optional[google.privacy.dlp.v2.storage_pb2.InfoType] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["alphabet",b"alphabet","common_alphabet",b"common_alphabet","context",b"context","crypto_key",b"crypto_key","custom_alphabet",b"custom_alphabet","radix",b"radix","surrogate_info_type",b"surrogate_info_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["alphabet",b"alphabet","common_alphabet",b"common_alphabet","context",b"context","crypto_key",b"crypto_key","custom_alphabet",b"custom_alphabet","radix",b"radix","surrogate_info_type",b"surrogate_info_type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["alphabet",b"alphabet"]) -> typing.Optional[typing_extensions.Literal["common_alphabet","custom_alphabet","radix"]]: ...
global___CryptoReplaceFfxFpeConfig = CryptoReplaceFfxFpeConfig

class CryptoKey(google.protobuf.message.Message):
    """This is a data encryption key (DEK) (as opposed to
    a key encryption key (KEK) stored by Cloud Key Management Service
    (Cloud KMS).
    When using Cloud KMS to wrap or unwrap a DEK, be sure to set an appropriate
    IAM policy on the KEK to ensure an attacker cannot
    unwrap the DEK.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TRANSIENT_FIELD_NUMBER: builtins.int
    UNWRAPPED_FIELD_NUMBER: builtins.int
    KMS_WRAPPED_FIELD_NUMBER: builtins.int
    @property
    def transient(self) -> global___TransientCryptoKey:
        """Transient crypto key"""
        pass
    @property
    def unwrapped(self) -> global___UnwrappedCryptoKey:
        """Unwrapped crypto key"""
        pass
    @property
    def kms_wrapped(self) -> global___KmsWrappedCryptoKey:
        """Key wrapped using Cloud KMS"""
        pass
    def __init__(self,
        *,
        transient : typing.Optional[global___TransientCryptoKey] = ...,
        unwrapped : typing.Optional[global___UnwrappedCryptoKey] = ...,
        kms_wrapped : typing.Optional[global___KmsWrappedCryptoKey] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["kms_wrapped",b"kms_wrapped","source",b"source","transient",b"transient","unwrapped",b"unwrapped"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["kms_wrapped",b"kms_wrapped","source",b"source","transient",b"transient","unwrapped",b"unwrapped"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["transient","unwrapped","kms_wrapped"]]: ...
global___CryptoKey = CryptoKey

class TransientCryptoKey(google.protobuf.message.Message):
    """Use this to have a random data crypto key generated.
    It will be discarded after the request finishes.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Name of the key.
    This is an arbitrary string used to differentiate different keys.
    A unique key is generated per name: two separate `TransientCryptoKey`
    protos share the same generated key if their names are the same.
    When the data crypto key is generated, this name is not used in any way
    (repeating the api call will result in a different key being generated).
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___TransientCryptoKey = TransientCryptoKey

class UnwrappedCryptoKey(google.protobuf.message.Message):
    """Using raw keys is prone to security risks due to accidentally
    leaking the key. Choose another type of key if possible.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_FIELD_NUMBER: builtins.int
    key: builtins.bytes = ...
    """Required. A 128/192/256 bit key."""

    def __init__(self,
        *,
        key : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["key",b"key"]) -> None: ...
global___UnwrappedCryptoKey = UnwrappedCryptoKey

class KmsWrappedCryptoKey(google.protobuf.message.Message):
    """Include to use an existing data crypto key wrapped by KMS.
    The wrapped key must be a 128-, 192-, or 256-bit key.
    Authorization requires the following IAM permissions when sending a request
    to perform a crypto transformation using a KMS-wrapped crypto key:
    dlp.kms.encrypt

    For more information, see [Creating a wrapped key]
    (https://cloud.google.com/dlp/docs/create-wrapped-key).

    Note: When you use Cloud KMS for cryptographic operations,
    [charges apply](https://cloud.google.com/kms/pricing).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    WRAPPED_KEY_FIELD_NUMBER: builtins.int
    CRYPTO_KEY_NAME_FIELD_NUMBER: builtins.int
    wrapped_key: builtins.bytes = ...
    """Required. The wrapped data crypto key."""

    crypto_key_name: typing.Text = ...
    """Required. The resource name of the KMS CryptoKey to use for unwrapping."""

    def __init__(self,
        *,
        wrapped_key : builtins.bytes = ...,
        crypto_key_name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["crypto_key_name",b"crypto_key_name","wrapped_key",b"wrapped_key"]) -> None: ...
global___KmsWrappedCryptoKey = KmsWrappedCryptoKey

class DateShiftConfig(google.protobuf.message.Message):
    """Shifts dates by random number of days, with option to be consistent for the
    same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting
    to learn more.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    UPPER_BOUND_DAYS_FIELD_NUMBER: builtins.int
    LOWER_BOUND_DAYS_FIELD_NUMBER: builtins.int
    CONTEXT_FIELD_NUMBER: builtins.int
    CRYPTO_KEY_FIELD_NUMBER: builtins.int
    upper_bound_days: builtins.int = ...
    """Required. Range of shift in days. Actual shift will be selected at random within this
    range (inclusive ends). Negative means shift to earlier in time. Must not
    be more than 365250 days (1000 years) each direction.

    For example, 3 means shift date to at most 3 days into the future.
    """

    lower_bound_days: builtins.int = ...
    """Required. For example, -5 means shift date to at most 5 days back in the past."""

    @property
    def context(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
        """Points to the field that contains the context, for example, an entity id.
        If set, must also set cryptoKey. If set, shift will be consistent for the
        given context.
        """
        pass
    @property
    def crypto_key(self) -> global___CryptoKey:
        """Causes the shift to be computed based on this key and the context. This
        results in the same shift for the same context and crypto_key. If
        set, must also set context. Can only be applied to table items.
        """
        pass
    def __init__(self,
        *,
        upper_bound_days : builtins.int = ...,
        lower_bound_days : builtins.int = ...,
        context : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
        crypto_key : typing.Optional[global___CryptoKey] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["context",b"context","crypto_key",b"crypto_key","method",b"method"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["context",b"context","crypto_key",b"crypto_key","lower_bound_days",b"lower_bound_days","method",b"method","upper_bound_days",b"upper_bound_days"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["method",b"method"]) -> typing.Optional[typing_extensions.Literal["crypto_key"]]: ...
global___DateShiftConfig = DateShiftConfig

class InfoTypeTransformations(google.protobuf.message.Message):
    """A type of transformation that will scan unstructured text and
    apply various `PrimitiveTransformation`s to each finding, where the
    transformation is applied to only values that were identified as a specific
    info_type.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class InfoTypeTransformation(google.protobuf.message.Message):
        """A transformation to apply to text that is identified as a specific
        info_type.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        INFO_TYPES_FIELD_NUMBER: builtins.int
        PRIMITIVE_TRANSFORMATION_FIELD_NUMBER: builtins.int
        @property
        def info_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.privacy.dlp.v2.storage_pb2.InfoType]:
            """InfoTypes to apply the transformation to. An empty list will cause
            this transformation to apply to all findings that correspond to
            infoTypes that were requested in `InspectConfig`.
            """
            pass
        @property
        def primitive_transformation(self) -> global___PrimitiveTransformation:
            """Required. Primitive transformation to apply to the infoType."""
            pass
        def __init__(self,
            *,
            info_types : typing.Optional[typing.Iterable[google.privacy.dlp.v2.storage_pb2.InfoType]] = ...,
            primitive_transformation : typing.Optional[global___PrimitiveTransformation] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["primitive_transformation",b"primitive_transformation"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["info_types",b"info_types","primitive_transformation",b"primitive_transformation"]) -> None: ...

    TRANSFORMATIONS_FIELD_NUMBER: builtins.int
    @property
    def transformations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InfoTypeTransformations.InfoTypeTransformation]:
        """Required. Transformation for each infoType. Cannot specify more than one
        for a given infoType.
        """
        pass
    def __init__(self,
        *,
        transformations : typing.Optional[typing.Iterable[global___InfoTypeTransformations.InfoTypeTransformation]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["transformations",b"transformations"]) -> None: ...
global___InfoTypeTransformations = InfoTypeTransformations

class FieldTransformation(google.protobuf.message.Message):
    """The transformation to apply to the field."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FIELDS_FIELD_NUMBER: builtins.int
    CONDITION_FIELD_NUMBER: builtins.int
    PRIMITIVE_TRANSFORMATION_FIELD_NUMBER: builtins.int
    INFO_TYPE_TRANSFORMATIONS_FIELD_NUMBER: builtins.int
    @property
    def fields(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.privacy.dlp.v2.storage_pb2.FieldId]:
        """Required. Input field(s) to apply the transformation to.
        When you have columns that reference their position within a list,
        omit the index from the FieldId. FieldId name matching ignores the index.
        For example, instead of "contact.nums[0].type", use "contact.nums.type".
        """
        pass
    @property
    def condition(self) -> global___RecordCondition:
        """Only apply the transformation if the condition evaluates to true for the
        given `RecordCondition`. The conditions are allowed to reference fields
        that are not used in the actual transformation.

        Example Use Cases:

        - Apply a different bucket transformation to an age column if the zip code
        column for the same record is within a specific range.
        - Redact a field if the date of birth field is greater than 85.
        """
        pass
    @property
    def primitive_transformation(self) -> global___PrimitiveTransformation:
        """Apply the transformation to the entire field."""
        pass
    @property
    def info_type_transformations(self) -> global___InfoTypeTransformations:
        """Treat the contents of the field as free text, and selectively
        transform content that matches an `InfoType`.
        """
        pass
    def __init__(self,
        *,
        fields : typing.Optional[typing.Iterable[google.privacy.dlp.v2.storage_pb2.FieldId]] = ...,
        condition : typing.Optional[global___RecordCondition] = ...,
        primitive_transformation : typing.Optional[global___PrimitiveTransformation] = ...,
        info_type_transformations : typing.Optional[global___InfoTypeTransformations] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["condition",b"condition","info_type_transformations",b"info_type_transformations","primitive_transformation",b"primitive_transformation","transformation",b"transformation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["condition",b"condition","fields",b"fields","info_type_transformations",b"info_type_transformations","primitive_transformation",b"primitive_transformation","transformation",b"transformation"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["transformation",b"transformation"]) -> typing.Optional[typing_extensions.Literal["primitive_transformation","info_type_transformations"]]: ...
global___FieldTransformation = FieldTransformation

class RecordTransformations(google.protobuf.message.Message):
    """A type of transformation that is applied over structured data such as a
    table.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FIELD_TRANSFORMATIONS_FIELD_NUMBER: builtins.int
    RECORD_SUPPRESSIONS_FIELD_NUMBER: builtins.int
    @property
    def field_transformations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FieldTransformation]:
        """Transform the record by applying various field transformations."""
        pass
    @property
    def record_suppressions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RecordSuppression]:
        """Configuration defining which records get suppressed entirely. Records that
        match any suppression rule are omitted from the output.
        """
        pass
    def __init__(self,
        *,
        field_transformations : typing.Optional[typing.Iterable[global___FieldTransformation]] = ...,
        record_suppressions : typing.Optional[typing.Iterable[global___RecordSuppression]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["field_transformations",b"field_transformations","record_suppressions",b"record_suppressions"]) -> None: ...
global___RecordTransformations = RecordTransformations

class RecordSuppression(google.protobuf.message.Message):
    """Configuration to suppress records whose suppression conditions evaluate to
    true.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONDITION_FIELD_NUMBER: builtins.int
    @property
    def condition(self) -> global___RecordCondition:
        """A condition that when it evaluates to true will result in the record being
        evaluated to be suppressed from the transformed content.
        """
        pass
    def __init__(self,
        *,
        condition : typing.Optional[global___RecordCondition] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["condition",b"condition"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["condition",b"condition"]) -> None: ...
global___RecordSuppression = RecordSuppression

class RecordCondition(google.protobuf.message.Message):
    """A condition for determining whether a transformation should be applied to
    a field.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Condition(google.protobuf.message.Message):
        """The field type of `value` and `field` do not need to match to be
        considered equal, but not all comparisons are possible.
        EQUAL_TO and NOT_EQUAL_TO attempt to compare even with incompatible types,
        but all other comparisons are invalid with incompatible types.
        A `value` of type:

        - `string` can be compared against all other types
        - `boolean` can only be compared against other booleans
        - `integer` can be compared against doubles or a string if the string value
        can be parsed as an integer.
        - `double` can be compared against integers or a string if the string can
        be parsed as a double.
        - `Timestamp` can be compared against strings in RFC 3339 date string
        format.
        - `TimeOfDay` can be compared against timestamps and strings in the format
        of 'HH:mm:ss'.

        If we fail to compare do to type mismatch, a warning will be given and
        the condition will evaluate to false.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FIELD_FIELD_NUMBER: builtins.int
        OPERATOR_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        @property
        def field(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
            """Required. Field within the record this condition is evaluated against."""
            pass
        operator: global___RelationalOperator.ValueType = ...
        """Required. Operator used to compare the field or infoType to the value."""

        @property
        def value(self) -> global___Value:
            """Value to compare against. [Mandatory, except for `EXISTS` tests.]"""
            pass
        def __init__(self,
            *,
            field : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
            operator : global___RelationalOperator.ValueType = ...,
            value : typing.Optional[global___Value] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["field",b"field","value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["field",b"field","operator",b"operator","value",b"value"]) -> None: ...

    class Conditions(google.protobuf.message.Message):
        """A collection of conditions."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        CONDITIONS_FIELD_NUMBER: builtins.int
        @property
        def conditions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RecordCondition.Condition]:
            """A collection of conditions."""
            pass
        def __init__(self,
            *,
            conditions : typing.Optional[typing.Iterable[global___RecordCondition.Condition]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["conditions",b"conditions"]) -> None: ...

    class Expressions(google.protobuf.message.Message):
        """An expression, consisting or an operator and conditions."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _LogicalOperator:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _LogicalOperatorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_LogicalOperator.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            LOGICAL_OPERATOR_UNSPECIFIED: RecordCondition.Expressions.LogicalOperator.ValueType = ...  # 0
            """Unused"""

            AND: RecordCondition.Expressions.LogicalOperator.ValueType = ...  # 1
            """Conditional AND"""

        class LogicalOperator(_LogicalOperator, metaclass=_LogicalOperatorEnumTypeWrapper):
            """Logical operators for conditional checks."""
            pass

        LOGICAL_OPERATOR_UNSPECIFIED: RecordCondition.Expressions.LogicalOperator.ValueType = ...  # 0
        """Unused"""

        AND: RecordCondition.Expressions.LogicalOperator.ValueType = ...  # 1
        """Conditional AND"""


        LOGICAL_OPERATOR_FIELD_NUMBER: builtins.int
        CONDITIONS_FIELD_NUMBER: builtins.int
        logical_operator: global___RecordCondition.Expressions.LogicalOperator.ValueType = ...
        """The operator to apply to the result of conditions. Default and currently
        only supported value is `AND`.
        """

        @property
        def conditions(self) -> global___RecordCondition.Conditions:
            """Conditions to apply to the expression."""
            pass
        def __init__(self,
            *,
            logical_operator : global___RecordCondition.Expressions.LogicalOperator.ValueType = ...,
            conditions : typing.Optional[global___RecordCondition.Conditions] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["conditions",b"conditions","type",b"type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["conditions",b"conditions","logical_operator",b"logical_operator","type",b"type"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["conditions"]]: ...

    EXPRESSIONS_FIELD_NUMBER: builtins.int
    @property
    def expressions(self) -> global___RecordCondition.Expressions:
        """An expression."""
        pass
    def __init__(self,
        *,
        expressions : typing.Optional[global___RecordCondition.Expressions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["expressions",b"expressions"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["expressions",b"expressions"]) -> None: ...
global___RecordCondition = RecordCondition

class TransformationOverview(google.protobuf.message.Message):
    """Overview of the modifications that occurred."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TRANSFORMED_BYTES_FIELD_NUMBER: builtins.int
    TRANSFORMATION_SUMMARIES_FIELD_NUMBER: builtins.int
    transformed_bytes: builtins.int = ...
    """Total size in bytes that were transformed in some way."""

    @property
    def transformation_summaries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TransformationSummary]:
        """Transformations applied to the dataset."""
        pass
    def __init__(self,
        *,
        transformed_bytes : builtins.int = ...,
        transformation_summaries : typing.Optional[typing.Iterable[global___TransformationSummary]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["transformation_summaries",b"transformation_summaries","transformed_bytes",b"transformed_bytes"]) -> None: ...
global___TransformationOverview = TransformationOverview

class TransformationSummary(google.protobuf.message.Message):
    """Summary of a single transformation.
    Only one of 'transformation', 'field_transformation', or 'record_suppress'
    will be set.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _TransformationResultCode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _TransformationResultCodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_TransformationResultCode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        TRANSFORMATION_RESULT_CODE_UNSPECIFIED: TransformationSummary.TransformationResultCode.ValueType = ...  # 0
        """Unused"""

        SUCCESS: TransformationSummary.TransformationResultCode.ValueType = ...  # 1
        """Transformation completed without an error."""

        ERROR: TransformationSummary.TransformationResultCode.ValueType = ...  # 2
        """Transformation had an error."""

    class TransformationResultCode(_TransformationResultCode, metaclass=_TransformationResultCodeEnumTypeWrapper):
        """Possible outcomes of transformations."""
        pass

    TRANSFORMATION_RESULT_CODE_UNSPECIFIED: TransformationSummary.TransformationResultCode.ValueType = ...  # 0
    """Unused"""

    SUCCESS: TransformationSummary.TransformationResultCode.ValueType = ...  # 1
    """Transformation completed without an error."""

    ERROR: TransformationSummary.TransformationResultCode.ValueType = ...  # 2
    """Transformation had an error."""


    class SummaryResult(google.protobuf.message.Message):
        """A collection that informs the user the number of times a particular
        `TransformationResultCode` and error details occurred.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        COUNT_FIELD_NUMBER: builtins.int
        CODE_FIELD_NUMBER: builtins.int
        DETAILS_FIELD_NUMBER: builtins.int
        count: builtins.int = ...
        """Number of transformations counted by this result."""

        code: global___TransformationSummary.TransformationResultCode.ValueType = ...
        """Outcome of the transformation."""

        details: typing.Text = ...
        """A place for warnings or errors to show up if a transformation didn't
        work as expected.
        """

        def __init__(self,
            *,
            count : builtins.int = ...,
            code : global___TransformationSummary.TransformationResultCode.ValueType = ...,
            details : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["code",b"code","count",b"count","details",b"details"]) -> None: ...

    INFO_TYPE_FIELD_NUMBER: builtins.int
    FIELD_FIELD_NUMBER: builtins.int
    TRANSFORMATION_FIELD_NUMBER: builtins.int
    FIELD_TRANSFORMATIONS_FIELD_NUMBER: builtins.int
    RECORD_SUPPRESS_FIELD_NUMBER: builtins.int
    RESULTS_FIELD_NUMBER: builtins.int
    TRANSFORMED_BYTES_FIELD_NUMBER: builtins.int
    @property
    def info_type(self) -> google.privacy.dlp.v2.storage_pb2.InfoType:
        """Set if the transformation was limited to a specific InfoType."""
        pass
    @property
    def field(self) -> google.privacy.dlp.v2.storage_pb2.FieldId:
        """Set if the transformation was limited to a specific FieldId."""
        pass
    @property
    def transformation(self) -> global___PrimitiveTransformation:
        """The specific transformation these stats apply to."""
        pass
    @property
    def field_transformations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FieldTransformation]:
        """The field transformation that was applied.
        If multiple field transformations are requested for a single field,
        this list will contain all of them; otherwise, only one is supplied.
        """
        pass
    @property
    def record_suppress(self) -> global___RecordSuppression:
        """The specific suppression option these stats apply to."""
        pass
    @property
    def results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TransformationSummary.SummaryResult]:
        """Collection of all transformations that took place or had an error."""
        pass
    transformed_bytes: builtins.int = ...
    """Total size in bytes that were transformed in some way."""

    def __init__(self,
        *,
        info_type : typing.Optional[google.privacy.dlp.v2.storage_pb2.InfoType] = ...,
        field : typing.Optional[google.privacy.dlp.v2.storage_pb2.FieldId] = ...,
        transformation : typing.Optional[global___PrimitiveTransformation] = ...,
        field_transformations : typing.Optional[typing.Iterable[global___FieldTransformation]] = ...,
        record_suppress : typing.Optional[global___RecordSuppression] = ...,
        results : typing.Optional[typing.Iterable[global___TransformationSummary.SummaryResult]] = ...,
        transformed_bytes : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["field",b"field","info_type",b"info_type","record_suppress",b"record_suppress","transformation",b"transformation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["field",b"field","field_transformations",b"field_transformations","info_type",b"info_type","record_suppress",b"record_suppress","results",b"results","transformation",b"transformation","transformed_bytes",b"transformed_bytes"]) -> None: ...
global___TransformationSummary = TransformationSummary

class Schedule(google.protobuf.message.Message):
    """Schedule for inspect job triggers."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RECURRENCE_PERIOD_DURATION_FIELD_NUMBER: builtins.int
    @property
    def recurrence_period_duration(self) -> google.protobuf.duration_pb2.Duration:
        """With this option a job is started a regular periodic basis. For
        example: every day (86400 seconds).

        A scheduled start time will be skipped if the previous
        execution has not ended when its scheduled time occurs.

        This value must be set to a time duration greater than or equal
        to 1 day and can be no longer than 60 days.
        """
        pass
    def __init__(self,
        *,
        recurrence_period_duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["option",b"option","recurrence_period_duration",b"recurrence_period_duration"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["option",b"option","recurrence_period_duration",b"recurrence_period_duration"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["option",b"option"]) -> typing.Optional[typing_extensions.Literal["recurrence_period_duration"]]: ...
global___Schedule = Schedule

class Manual(google.protobuf.message.Message):
    """Job trigger option for hybrid jobs. Jobs must be manually created
    and finished.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___Manual = Manual

class InspectTemplate(google.protobuf.message.Message):
    """The inspectTemplate contains a configuration (set of types of sensitive data
    to be detected) to be used anywhere you otherwise would normally specify
    InspectConfig. See https://cloud.google.com/dlp/docs/concepts-templates
    to learn more.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    INSPECT_CONFIG_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Output only. The template name.

    The template will have one of the following formats:
    `projects/PROJECT_ID/inspectTemplates/TEMPLATE_ID` OR
    `organizations/ORGANIZATION_ID/inspectTemplates/TEMPLATE_ID`;
    """

    display_name: typing.Text = ...
    """Display name (max 256 chars)."""

    description: typing.Text = ...
    """Short description (max 256 chars)."""

    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The creation timestamp of an inspectTemplate."""
        pass
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The last update timestamp of an inspectTemplate."""
        pass
    @property
    def inspect_config(self) -> global___InspectConfig:
        """The core content of the template. Configuration of the scanning process."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        description : typing.Text = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        update_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        inspect_config : typing.Optional[global___InspectConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time",b"create_time","inspect_config",b"inspect_config","update_time",b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time",b"create_time","description",b"description","display_name",b"display_name","inspect_config",b"inspect_config","name",b"name","update_time",b"update_time"]) -> None: ...
global___InspectTemplate = InspectTemplate

class DeidentifyTemplate(google.protobuf.message.Message):
    """DeidentifyTemplates contains instructions on how to de-identify content.
    See https://cloud.google.com/dlp/docs/concepts-templates to learn more.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    DEIDENTIFY_CONFIG_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Output only. The template name.

    The template will have one of the following formats:
    `projects/PROJECT_ID/deidentifyTemplates/TEMPLATE_ID` OR
    `organizations/ORGANIZATION_ID/deidentifyTemplates/TEMPLATE_ID`
    """

    display_name: typing.Text = ...
    """Display name (max 256 chars)."""

    description: typing.Text = ...
    """Short description (max 256 chars)."""

    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The creation timestamp of an inspectTemplate."""
        pass
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The last update timestamp of an inspectTemplate."""
        pass
    @property
    def deidentify_config(self) -> global___DeidentifyConfig:
        """The core content of the template."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        description : typing.Text = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        update_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        deidentify_config : typing.Optional[global___DeidentifyConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time",b"create_time","deidentify_config",b"deidentify_config","update_time",b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time",b"create_time","deidentify_config",b"deidentify_config","description",b"description","display_name",b"display_name","name",b"name","update_time",b"update_time"]) -> None: ...
global___DeidentifyTemplate = DeidentifyTemplate

class Error(google.protobuf.message.Message):
    """Details information about an error encountered during job execution or
    the results of an unsuccessful activation of the JobTrigger.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DETAILS_FIELD_NUMBER: builtins.int
    TIMESTAMPS_FIELD_NUMBER: builtins.int
    @property
    def details(self) -> google.rpc.status_pb2.Status:
        """Detailed error codes and messages."""
        pass
    @property
    def timestamps(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.timestamp_pb2.Timestamp]:
        """The times the error occurred."""
        pass
    def __init__(self,
        *,
        details : typing.Optional[google.rpc.status_pb2.Status] = ...,
        timestamps : typing.Optional[typing.Iterable[google.protobuf.timestamp_pb2.Timestamp]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["details",b"details"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["details",b"details","timestamps",b"timestamps"]) -> None: ...
global___Error = Error

class JobTrigger(google.protobuf.message.Message):
    """Contains a configuration to make dlp api calls on a repeating basis.
    See https://cloud.google.com/dlp/docs/concepts-job-triggers to learn more.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Status:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _StatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Status.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        STATUS_UNSPECIFIED: JobTrigger.Status.ValueType = ...  # 0
        """Unused."""

        HEALTHY: JobTrigger.Status.ValueType = ...  # 1
        """Trigger is healthy."""

        PAUSED: JobTrigger.Status.ValueType = ...  # 2
        """Trigger is temporarily paused."""

        CANCELLED: JobTrigger.Status.ValueType = ...  # 3
        """Trigger is cancelled and can not be resumed."""

    class Status(_Status, metaclass=_StatusEnumTypeWrapper):
        """Whether the trigger is currently active. If PAUSED or CANCELLED, no jobs
        will be created with this configuration. The service may automatically
        pause triggers experiencing frequent errors. To restart a job, set the
        status to HEALTHY after correcting user errors.
        """
        pass

    STATUS_UNSPECIFIED: JobTrigger.Status.ValueType = ...  # 0
    """Unused."""

    HEALTHY: JobTrigger.Status.ValueType = ...  # 1
    """Trigger is healthy."""

    PAUSED: JobTrigger.Status.ValueType = ...  # 2
    """Trigger is temporarily paused."""

    CANCELLED: JobTrigger.Status.ValueType = ...  # 3
    """Trigger is cancelled and can not be resumed."""


    class Trigger(google.protobuf.message.Message):
        """What event needs to occur for a new job to be started."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SCHEDULE_FIELD_NUMBER: builtins.int
        MANUAL_FIELD_NUMBER: builtins.int
        @property
        def schedule(self) -> global___Schedule:
            """Create a job on a repeating basis based on the elapse of time."""
            pass
        @property
        def manual(self) -> global___Manual:
            """For use with hybrid jobs. Jobs must be manually created and finished."""
            pass
        def __init__(self,
            *,
            schedule : typing.Optional[global___Schedule] = ...,
            manual : typing.Optional[global___Manual] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["manual",b"manual","schedule",b"schedule","trigger",b"trigger"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["manual",b"manual","schedule",b"schedule","trigger",b"trigger"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["trigger",b"trigger"]) -> typing.Optional[typing_extensions.Literal["schedule","manual"]]: ...

    NAME_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    INSPECT_JOB_FIELD_NUMBER: builtins.int
    TRIGGERS_FIELD_NUMBER: builtins.int
    ERRORS_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    LAST_RUN_TIME_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Unique resource name for the triggeredJob, assigned by the service when the
    triggeredJob is created, for example
    `projects/dlp-test-project/jobTriggers/53234423`.
    """

    display_name: typing.Text = ...
    """Display name (max 100 chars)"""

    description: typing.Text = ...
    """User provided description (max 256 chars)"""

    @property
    def inspect_job(self) -> global___InspectJobConfig:
        """For inspect jobs, a snapshot of the configuration."""
        pass
    @property
    def triggers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___JobTrigger.Trigger]:
        """A list of triggers which will be OR'ed together. Only one in the list
        needs to trigger for a job to be started. The list may contain only
        a single Schedule trigger and must have at least one object.
        """
        pass
    @property
    def errors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Error]:
        """Output only. A stream of errors encountered when the trigger was activated. Repeated
        errors may result in the JobTrigger automatically being paused.
        Will return the last 100 errors. Whenever the JobTrigger is modified
        this list will be cleared.
        """
        pass
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The creation timestamp of a triggeredJob."""
        pass
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The last update timestamp of a triggeredJob."""
        pass
    @property
    def last_run_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The timestamp of the last time this trigger executed."""
        pass
    status: global___JobTrigger.Status.ValueType = ...
    """Required. A status for this trigger."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        display_name : typing.Text = ...,
        description : typing.Text = ...,
        inspect_job : typing.Optional[global___InspectJobConfig] = ...,
        triggers : typing.Optional[typing.Iterable[global___JobTrigger.Trigger]] = ...,
        errors : typing.Optional[typing.Iterable[global___Error]] = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        update_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        last_run_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        status : global___JobTrigger.Status.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time",b"create_time","inspect_job",b"inspect_job","job",b"job","last_run_time",b"last_run_time","update_time",b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time",b"create_time","description",b"description","display_name",b"display_name","errors",b"errors","inspect_job",b"inspect_job","job",b"job","last_run_time",b"last_run_time","name",b"name","status",b"status","triggers",b"triggers","update_time",b"update_time"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["job",b"job"]) -> typing.Optional[typing_extensions.Literal["inspect_job"]]: ...
global___JobTrigger = JobTrigger

class Action(google.protobuf.message.Message):
    """A task to execute on the completion of a job.
    See https://cloud.google.com/dlp/docs/concepts-actions to learn more.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SaveFindings(google.protobuf.message.Message):
        """If set, the detailed findings will be persisted to the specified
        OutputStorageConfig. Only a single instance of this action can be
        specified.
        Compatible with: Inspect, Risk
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        OUTPUT_CONFIG_FIELD_NUMBER: builtins.int
        @property
        def output_config(self) -> global___OutputStorageConfig:
            """Location to store findings outside of DLP."""
            pass
        def __init__(self,
            *,
            output_config : typing.Optional[global___OutputStorageConfig] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["output_config",b"output_config"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["output_config",b"output_config"]) -> None: ...

    class PublishToPubSub(google.protobuf.message.Message):
        """Publish a message into given Pub/Sub topic when DlpJob has completed. The
        message contains a single field, `DlpJobName`, which is equal to the
        finished job's
        [`DlpJob.name`](https://cloud.google.com/dlp/docs/reference/rest/v2/projects.dlpJobs#DlpJob).
        Compatible with: Inspect, Risk
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TOPIC_FIELD_NUMBER: builtins.int
        topic: typing.Text = ...
        """Cloud Pub/Sub topic to send notifications to. The topic must have given
        publishing access rights to the DLP API service account executing
        the long running DlpJob sending the notifications.
        Format is projects/{project}/topics/{topic}.
        """

        def __init__(self,
            *,
            topic : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["topic",b"topic"]) -> None: ...

    class PublishSummaryToCscc(google.protobuf.message.Message):
        """Publish the result summary of a DlpJob to the Cloud Security
        Command Center (CSCC Alpha).
        This action is only available for projects which are parts of
        an organization and whitelisted for the alpha Cloud Security Command
        Center.
        The action will publish count of finding instances and their info types.
        The summary of findings will be persisted in CSCC and are governed by CSCC
        service-specific policy, see https://cloud.google.com/terms/service-terms
        Only a single instance of this action can be specified.
        Compatible with: Inspect
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    class PublishFindingsToCloudDataCatalog(google.protobuf.message.Message):
        """Publish findings of a DlpJob to Data Catalog. Labels summarizing the
        results of the DlpJob will be applied to the entry for the resource scanned
        in Data Catalog. Any labels previously written by another DlpJob will
        be deleted. InfoType naming patterns are strictly enforced when using this
        feature. Note that the findings will be persisted in Data Catalog
        storage and are governed by Data Catalog service-specific policy, see
        https://cloud.google.com/terms/service-terms
        Only a single instance of this action can be specified and only allowed if
        all resources being scanned are BigQuery tables.
        Compatible with: Inspect
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    class JobNotificationEmails(google.protobuf.message.Message):
        """Enable email notification to project owners and editors on jobs's
        completion/failure.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    class PublishToStackdriver(google.protobuf.message.Message):
        """Enable Stackdriver metric dlp.googleapis.com/finding_count. This
        will publish a metric to stack driver on each infotype requested and
        how many findings were found for it. CustomDetectors will be bucketed
        as 'Custom' under the Stackdriver label 'info_type'.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    SAVE_FINDINGS_FIELD_NUMBER: builtins.int
    PUB_SUB_FIELD_NUMBER: builtins.int
    PUBLISH_SUMMARY_TO_CSCC_FIELD_NUMBER: builtins.int
    PUBLISH_FINDINGS_TO_CLOUD_DATA_CATALOG_FIELD_NUMBER: builtins.int
    JOB_NOTIFICATION_EMAILS_FIELD_NUMBER: builtins.int
    PUBLISH_TO_STACKDRIVER_FIELD_NUMBER: builtins.int
    @property
    def save_findings(self) -> global___Action.SaveFindings:
        """Save resulting findings in a provided location."""
        pass
    @property
    def pub_sub(self) -> global___Action.PublishToPubSub:
        """Publish a notification to a pubsub topic."""
        pass
    @property
    def publish_summary_to_cscc(self) -> global___Action.PublishSummaryToCscc:
        """Publish summary to Cloud Security Command Center (Alpha)."""
        pass
    @property
    def publish_findings_to_cloud_data_catalog(self) -> global___Action.PublishFindingsToCloudDataCatalog:
        """Publish findings to Cloud Datahub."""
        pass
    @property
    def job_notification_emails(self) -> global___Action.JobNotificationEmails:
        """Enable email notification for project owners and editors on job's
        completion/failure.
        """
        pass
    @property
    def publish_to_stackdriver(self) -> global___Action.PublishToStackdriver:
        """Enable Stackdriver metric dlp.googleapis.com/finding_count."""
        pass
    def __init__(self,
        *,
        save_findings : typing.Optional[global___Action.SaveFindings] = ...,
        pub_sub : typing.Optional[global___Action.PublishToPubSub] = ...,
        publish_summary_to_cscc : typing.Optional[global___Action.PublishSummaryToCscc] = ...,
        publish_findings_to_cloud_data_catalog : typing.Optional[global___Action.PublishFindingsToCloudDataCatalog] = ...,
        job_notification_emails : typing.Optional[global___Action.JobNotificationEmails] = ...,
        publish_to_stackdriver : typing.Optional[global___Action.PublishToStackdriver] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["action",b"action","job_notification_emails",b"job_notification_emails","pub_sub",b"pub_sub","publish_findings_to_cloud_data_catalog",b"publish_findings_to_cloud_data_catalog","publish_summary_to_cscc",b"publish_summary_to_cscc","publish_to_stackdriver",b"publish_to_stackdriver","save_findings",b"save_findings"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["action",b"action","job_notification_emails",b"job_notification_emails","pub_sub",b"pub_sub","publish_findings_to_cloud_data_catalog",b"publish_findings_to_cloud_data_catalog","publish_summary_to_cscc",b"publish_summary_to_cscc","publish_to_stackdriver",b"publish_to_stackdriver","save_findings",b"save_findings"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["action",b"action"]) -> typing.Optional[typing_extensions.Literal["save_findings","pub_sub","publish_summary_to_cscc","publish_findings_to_cloud_data_catalog","job_notification_emails","publish_to_stackdriver"]]: ...
global___Action = Action

class CreateInspectTemplateRequest(google.protobuf.message.Message):
    """Request message for CreateInspectTemplate."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    INSPECT_TEMPLATE_FIELD_NUMBER: builtins.int
    TEMPLATE_ID_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Parent resource name.

    The format of this value varies depending on the scope of the request
    (project or organization) and whether you have [specified a processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>
    + Organizations scope, location specified:<br/>
      `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Organizations scope, no location specified (defaults to global):<br/>
      `organizations/`<var>ORG_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    @property
    def inspect_template(self) -> global___InspectTemplate:
        """Required. The InspectTemplate to create."""
        pass
    template_id: typing.Text = ...
    """The template id can contain uppercase and lowercase letters,
    numbers, and hyphens; that is, it must match the regular
    expression: `[a-zA-Z\\d-_]+`. The maximum length is 100
    characters. Can be empty to allow the system to generate one.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        inspect_template : typing.Optional[global___InspectTemplate] = ...,
        template_id : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["inspect_template",b"inspect_template"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["inspect_template",b"inspect_template","location_id",b"location_id","parent",b"parent","template_id",b"template_id"]) -> None: ...
global___CreateInspectTemplateRequest = CreateInspectTemplateRequest

class UpdateInspectTemplateRequest(google.protobuf.message.Message):
    """Request message for UpdateInspectTemplate."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    INSPECT_TEMPLATE_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of organization and inspectTemplate to be updated, for
    example `organizations/433245324/inspectTemplates/432452342` or
    projects/project-id/inspectTemplates/432452342.
    """

    @property
    def inspect_template(self) -> global___InspectTemplate:
        """New InspectTemplate value."""
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Mask to control which fields get updated."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        inspect_template : typing.Optional[global___InspectTemplate] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["inspect_template",b"inspect_template","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["inspect_template",b"inspect_template","name",b"name","update_mask",b"update_mask"]) -> None: ...
global___UpdateInspectTemplateRequest = UpdateInspectTemplateRequest

class GetInspectTemplateRequest(google.protobuf.message.Message):
    """Request message for GetInspectTemplate."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the organization and inspectTemplate to be read, for
    example `organizations/433245324/inspectTemplates/432452342` or
    projects/project-id/inspectTemplates/432452342.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetInspectTemplateRequest = GetInspectTemplateRequest

class ListInspectTemplatesRequest(google.protobuf.message.Message):
    """Request message for ListInspectTemplates."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    ORDER_BY_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Parent resource name.

    The format of this value varies depending on the scope of the request
    (project or organization) and whether you have [specified a processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>
    + Organizations scope, location specified:<br/>
      `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Organizations scope, no location specified (defaults to global):<br/>
      `organizations/`<var>ORG_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    page_token: typing.Text = ...
    """Page token to continue retrieval. Comes from previous call
    to `ListInspectTemplates`.
    """

    page_size: builtins.int = ...
    """Size of the page, can be limited by server. If zero server returns
    a page of max size 100.
    """

    order_by: typing.Text = ...
    """Comma separated list of fields to order by,
    followed by `asc` or `desc` postfix. This list is case-insensitive,
    default sorting order is ascending, redundant space characters are
    insignificant.

    Example: `name asc,update_time, create_time desc`

    Supported fields are:

    - `create_time`: corresponds to time the template was created.
    - `update_time`: corresponds to time the template was last updated.
    - `name`: corresponds to template's name.
    - `display_name`: corresponds to template's display name.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_token : typing.Text = ...,
        page_size : builtins.int = ...,
        order_by : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["location_id",b"location_id","order_by",b"order_by","page_size",b"page_size","page_token",b"page_token","parent",b"parent"]) -> None: ...
global___ListInspectTemplatesRequest = ListInspectTemplatesRequest

class ListInspectTemplatesResponse(google.protobuf.message.Message):
    """Response message for ListInspectTemplates."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INSPECT_TEMPLATES_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def inspect_templates(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InspectTemplate]:
        """List of inspectTemplates, up to page_size in ListInspectTemplatesRequest."""
        pass
    next_page_token: typing.Text = ...
    """If the next page is available then the next page token to be used
    in following ListInspectTemplates request.
    """

    def __init__(self,
        *,
        inspect_templates : typing.Optional[typing.Iterable[global___InspectTemplate]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["inspect_templates",b"inspect_templates","next_page_token",b"next_page_token"]) -> None: ...
global___ListInspectTemplatesResponse = ListInspectTemplatesResponse

class DeleteInspectTemplateRequest(google.protobuf.message.Message):
    """Request message for DeleteInspectTemplate."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the organization and inspectTemplate to be deleted, for
    example `organizations/433245324/inspectTemplates/432452342` or
    projects/project-id/inspectTemplates/432452342.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___DeleteInspectTemplateRequest = DeleteInspectTemplateRequest

class CreateJobTriggerRequest(google.protobuf.message.Message):
    """Request message for CreateJobTrigger."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    JOB_TRIGGER_FIELD_NUMBER: builtins.int
    TRIGGER_ID_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Parent resource name.

    The format of this value varies depending on whether you have [specified a
    processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    @property
    def job_trigger(self) -> global___JobTrigger:
        """Required. The JobTrigger to create."""
        pass
    trigger_id: typing.Text = ...
    """The trigger id can contain uppercase and lowercase letters,
    numbers, and hyphens; that is, it must match the regular
    expression: `[a-zA-Z\\d-_]+`. The maximum length is 100
    characters. Can be empty to allow the system to generate one.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        job_trigger : typing.Optional[global___JobTrigger] = ...,
        trigger_id : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["job_trigger",b"job_trigger"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["job_trigger",b"job_trigger","location_id",b"location_id","parent",b"parent","trigger_id",b"trigger_id"]) -> None: ...
global___CreateJobTriggerRequest = CreateJobTriggerRequest

class ActivateJobTriggerRequest(google.protobuf.message.Message):
    """Request message for ActivateJobTrigger."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the trigger to activate, for example
    `projects/dlp-test-project/jobTriggers/53234423`.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___ActivateJobTriggerRequest = ActivateJobTriggerRequest

class UpdateJobTriggerRequest(google.protobuf.message.Message):
    """Request message for UpdateJobTrigger."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    JOB_TRIGGER_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the project and the triggeredJob, for example
    `projects/dlp-test-project/jobTriggers/53234423`.
    """

    @property
    def job_trigger(self) -> global___JobTrigger:
        """New JobTrigger value."""
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Mask to control which fields get updated."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        job_trigger : typing.Optional[global___JobTrigger] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["job_trigger",b"job_trigger","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["job_trigger",b"job_trigger","name",b"name","update_mask",b"update_mask"]) -> None: ...
global___UpdateJobTriggerRequest = UpdateJobTriggerRequest

class GetJobTriggerRequest(google.protobuf.message.Message):
    """Request message for GetJobTrigger."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the project and the triggeredJob, for example
    `projects/dlp-test-project/jobTriggers/53234423`.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetJobTriggerRequest = GetJobTriggerRequest

class CreateDlpJobRequest(google.protobuf.message.Message):
    """Request message for CreateDlpJobRequest. Used to initiate long running
    jobs such as calculating risk metrics or inspecting Google Cloud
    Storage.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    INSPECT_JOB_FIELD_NUMBER: builtins.int
    RISK_JOB_FIELD_NUMBER: builtins.int
    JOB_ID_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Parent resource name.

    The format of this value varies depending on whether you have [specified a
    processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    @property
    def inspect_job(self) -> global___InspectJobConfig:
        """An inspection job scans a storage repository for InfoTypes."""
        pass
    @property
    def risk_job(self) -> global___RiskAnalysisJobConfig:
        """A risk analysis job calculates re-identification risk metrics for a
        BigQuery table.
        """
        pass
    job_id: typing.Text = ...
    """The job id can contain uppercase and lowercase letters,
    numbers, and hyphens; that is, it must match the regular
    expression: `[a-zA-Z\\d-_]+`. The maximum length is 100
    characters. Can be empty to allow the system to generate one.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        inspect_job : typing.Optional[global___InspectJobConfig] = ...,
        risk_job : typing.Optional[global___RiskAnalysisJobConfig] = ...,
        job_id : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["inspect_job",b"inspect_job","job",b"job","risk_job",b"risk_job"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["inspect_job",b"inspect_job","job",b"job","job_id",b"job_id","location_id",b"location_id","parent",b"parent","risk_job",b"risk_job"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["job",b"job"]) -> typing.Optional[typing_extensions.Literal["inspect_job","risk_job"]]: ...
global___CreateDlpJobRequest = CreateDlpJobRequest

class ListJobTriggersRequest(google.protobuf.message.Message):
    """Request message for ListJobTriggers."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    ORDER_BY_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Parent resource name.

    The format of this value varies depending on whether you have [specified a
    processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    page_token: typing.Text = ...
    """Page token to continue retrieval. Comes from previous call
    to ListJobTriggers. `order_by` field must not
    change for subsequent calls.
    """

    page_size: builtins.int = ...
    """Size of the page, can be limited by a server."""

    order_by: typing.Text = ...
    """Comma separated list of triggeredJob fields to order by,
    followed by `asc` or `desc` postfix. This list is case-insensitive,
    default sorting order is ascending, redundant space characters are
    insignificant.

    Example: `name asc,update_time, create_time desc`

    Supported fields are:

    - `create_time`: corresponds to time the JobTrigger was created.
    - `update_time`: corresponds to time the JobTrigger was last updated.
    - `last_run_time`: corresponds to the last time the JobTrigger ran.
    - `name`: corresponds to JobTrigger's name.
    - `display_name`: corresponds to JobTrigger's display name.
    - `status`: corresponds to JobTrigger's status.
    """

    filter: typing.Text = ...
    """Allows filtering.

    Supported syntax:

    * Filter expressions are made up of one or more restrictions.
    * Restrictions can be combined by `AND` or `OR` logical operators. A
    sequence of restrictions implicitly uses `AND`.
    * A restriction has the form of `{field} {operator} {value}`.
    * Supported fields/values for inspect triggers:
        - `status` - HEALTHY|PAUSED|CANCELLED
        - `inspected_storage` - DATASTORE|CLOUD_STORAGE|BIGQUERY
        - 'last_run_time` - RFC 3339 formatted timestamp, surrounded by
        quotation marks. Nanoseconds are ignored.
        - 'error_count' - Number of errors that have occurred while running.
    * The operator must be `=` or `!=` for status and inspected_storage.

    Examples:

    * inspected_storage = cloud_storage AND status = HEALTHY
    * inspected_storage = cloud_storage OR inspected_storage = bigquery
    * inspected_storage = cloud_storage AND (state = PAUSED OR state = HEALTHY)
    * last_run_time > \\"2017-12-12T00:00:00+00:00\\"

    The length of this field should be no more than 500 characters.
    """

    type: global___DlpJobType.ValueType = ...
    """The type of jobs. Will use `DlpJobType.INSPECT` if not set."""

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_token : typing.Text = ...,
        page_size : builtins.int = ...,
        order_by : typing.Text = ...,
        filter : typing.Text = ...,
        type : global___DlpJobType.ValueType = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","location_id",b"location_id","order_by",b"order_by","page_size",b"page_size","page_token",b"page_token","parent",b"parent","type",b"type"]) -> None: ...
global___ListJobTriggersRequest = ListJobTriggersRequest

class ListJobTriggersResponse(google.protobuf.message.Message):
    """Response message for ListJobTriggers."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    JOB_TRIGGERS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def job_triggers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___JobTrigger]:
        """List of triggeredJobs, up to page_size in ListJobTriggersRequest."""
        pass
    next_page_token: typing.Text = ...
    """If the next page is available then the next page token to be used
    in following ListJobTriggers request.
    """

    def __init__(self,
        *,
        job_triggers : typing.Optional[typing.Iterable[global___JobTrigger]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["job_triggers",b"job_triggers","next_page_token",b"next_page_token"]) -> None: ...
global___ListJobTriggersResponse = ListJobTriggersResponse

class DeleteJobTriggerRequest(google.protobuf.message.Message):
    """Request message for DeleteJobTrigger."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the project and the triggeredJob, for example
    `projects/dlp-test-project/jobTriggers/53234423`.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___DeleteJobTriggerRequest = DeleteJobTriggerRequest

class InspectJobConfig(google.protobuf.message.Message):
    """Controls what and how to inspect for findings."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    STORAGE_CONFIG_FIELD_NUMBER: builtins.int
    INSPECT_CONFIG_FIELD_NUMBER: builtins.int
    INSPECT_TEMPLATE_NAME_FIELD_NUMBER: builtins.int
    ACTIONS_FIELD_NUMBER: builtins.int
    @property
    def storage_config(self) -> google.privacy.dlp.v2.storage_pb2.StorageConfig:
        """The data to scan."""
        pass
    @property
    def inspect_config(self) -> global___InspectConfig:
        """How and what to scan for."""
        pass
    inspect_template_name: typing.Text = ...
    """If provided, will be used as the default for all values in InspectConfig.
    `inspect_config` will be merged into the values persisted as part of the
    template.
    """

    @property
    def actions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Action]:
        """Actions to execute at the completion of the job."""
        pass
    def __init__(self,
        *,
        storage_config : typing.Optional[google.privacy.dlp.v2.storage_pb2.StorageConfig] = ...,
        inspect_config : typing.Optional[global___InspectConfig] = ...,
        inspect_template_name : typing.Text = ...,
        actions : typing.Optional[typing.Iterable[global___Action]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["inspect_config",b"inspect_config","storage_config",b"storage_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["actions",b"actions","inspect_config",b"inspect_config","inspect_template_name",b"inspect_template_name","storage_config",b"storage_config"]) -> None: ...
global___InspectJobConfig = InspectJobConfig

class DlpJob(google.protobuf.message.Message):
    """Combines all of the information about a DLP job."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _JobState:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _JobStateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_JobState.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        JOB_STATE_UNSPECIFIED: DlpJob.JobState.ValueType = ...  # 0
        """Unused."""

        PENDING: DlpJob.JobState.ValueType = ...  # 1
        """The job has not yet started."""

        RUNNING: DlpJob.JobState.ValueType = ...  # 2
        """The job is currently running. Once a job has finished it will transition
        to FAILED or DONE.
        """

        DONE: DlpJob.JobState.ValueType = ...  # 3
        """The job is no longer running."""

        CANCELED: DlpJob.JobState.ValueType = ...  # 4
        """The job was canceled before it could complete."""

        FAILED: DlpJob.JobState.ValueType = ...  # 5
        """The job had an error and did not complete."""

        ACTIVE: DlpJob.JobState.ValueType = ...  # 6
        """The job is currently accepting findings via hybridInspect.
        A hybrid job in ACTIVE state may continue to have findings added to it
        through calling of hybridInspect. After the job has finished no more
        calls to hybridInspect may be made. ACTIVE jobs can transition to DONE.
        """

    class JobState(_JobState, metaclass=_JobStateEnumTypeWrapper):
        """Possible states of a job. New items may be added."""
        pass

    JOB_STATE_UNSPECIFIED: DlpJob.JobState.ValueType = ...  # 0
    """Unused."""

    PENDING: DlpJob.JobState.ValueType = ...  # 1
    """The job has not yet started."""

    RUNNING: DlpJob.JobState.ValueType = ...  # 2
    """The job is currently running. Once a job has finished it will transition
    to FAILED or DONE.
    """

    DONE: DlpJob.JobState.ValueType = ...  # 3
    """The job is no longer running."""

    CANCELED: DlpJob.JobState.ValueType = ...  # 4
    """The job was canceled before it could complete."""

    FAILED: DlpJob.JobState.ValueType = ...  # 5
    """The job had an error and did not complete."""

    ACTIVE: DlpJob.JobState.ValueType = ...  # 6
    """The job is currently accepting findings via hybridInspect.
    A hybrid job in ACTIVE state may continue to have findings added to it
    through calling of hybridInspect. After the job has finished no more
    calls to hybridInspect may be made. ACTIVE jobs can transition to DONE.
    """


    NAME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    RISK_DETAILS_FIELD_NUMBER: builtins.int
    INSPECT_DETAILS_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    JOB_TRIGGER_NAME_FIELD_NUMBER: builtins.int
    ERRORS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The server-assigned name."""

    type: global___DlpJobType.ValueType = ...
    """The type of job."""

    state: global___DlpJob.JobState.ValueType = ...
    """State of a job."""

    @property
    def risk_details(self) -> global___AnalyzeDataSourceRiskDetails:
        """Results from analyzing risk of a data source."""
        pass
    @property
    def inspect_details(self) -> global___InspectDataSourceDetails:
        """Results from inspecting a data source."""
        pass
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time when the job was created."""
        pass
    @property
    def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time when the job started."""
        pass
    @property
    def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time when the job finished."""
        pass
    job_trigger_name: typing.Text = ...
    """If created by a job trigger, the resource name of the trigger that
    instantiated the job.
    """

    @property
    def errors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Error]:
        """A stream of errors encountered running the job."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        type : global___DlpJobType.ValueType = ...,
        state : global___DlpJob.JobState.ValueType = ...,
        risk_details : typing.Optional[global___AnalyzeDataSourceRiskDetails] = ...,
        inspect_details : typing.Optional[global___InspectDataSourceDetails] = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        start_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        end_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        job_trigger_name : typing.Text = ...,
        errors : typing.Optional[typing.Iterable[global___Error]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time",b"create_time","details",b"details","end_time",b"end_time","inspect_details",b"inspect_details","risk_details",b"risk_details","start_time",b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time",b"create_time","details",b"details","end_time",b"end_time","errors",b"errors","inspect_details",b"inspect_details","job_trigger_name",b"job_trigger_name","name",b"name","risk_details",b"risk_details","start_time",b"start_time","state",b"state","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["details",b"details"]) -> typing.Optional[typing_extensions.Literal["risk_details","inspect_details"]]: ...
global___DlpJob = DlpJob

class GetDlpJobRequest(google.protobuf.message.Message):
    """The request message for [DlpJobs.GetDlpJob][]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the DlpJob resource."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetDlpJobRequest = GetDlpJobRequest

class ListDlpJobsRequest(google.protobuf.message.Message):
    """The request message for listing DLP jobs."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    ORDER_BY_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Parent resource name.

    The format of this value varies depending on whether you have [specified a
    processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    filter: typing.Text = ...
    """Allows filtering.

    Supported syntax:

    * Filter expressions are made up of one or more restrictions.
    * Restrictions can be combined by `AND` or `OR` logical operators. A
    sequence of restrictions implicitly uses `AND`.
    * A restriction has the form of `{field} {operator} {value}`.
    * Supported fields/values for inspect jobs:
        - `state` - PENDING|RUNNING|CANCELED|FINISHED|FAILED
        - `inspected_storage` - DATASTORE|CLOUD_STORAGE|BIGQUERY
        - `trigger_name` - The resource name of the trigger that created job.
        - 'end_time` - Corresponds to time the job finished.
        - 'start_time` - Corresponds to time the job finished.
    * Supported fields for risk analysis jobs:
        - `state` - RUNNING|CANCELED|FINISHED|FAILED
        - 'end_time` - Corresponds to time the job finished.
        - 'start_time` - Corresponds to time the job finished.
    * The operator must be `=` or `!=`.

    Examples:

    * inspected_storage = cloud_storage AND state = done
    * inspected_storage = cloud_storage OR inspected_storage = bigquery
    * inspected_storage = cloud_storage AND (state = done OR state = canceled)
    * end_time > \\"2017-12-12T00:00:00+00:00\\"

    The length of this field should be no more than 500 characters.
    """

    page_size: builtins.int = ...
    """The standard list page size."""

    page_token: typing.Text = ...
    """The standard list page token."""

    type: global___DlpJobType.ValueType = ...
    """The type of job. Defaults to `DlpJobType.INSPECT`"""

    order_by: typing.Text = ...
    """Comma separated list of fields to order by,
    followed by `asc` or `desc` postfix. This list is case-insensitive,
    default sorting order is ascending, redundant space characters are
    insignificant.

    Example: `name asc, end_time asc, create_time desc`

    Supported fields are:

    - `create_time`: corresponds to time the job was created.
    - `end_time`: corresponds to time the job ended.
    - `name`: corresponds to job's name.
    - `state`: corresponds to `state`
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        filter : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        type : global___DlpJobType.ValueType = ...,
        order_by : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter",b"filter","location_id",b"location_id","order_by",b"order_by","page_size",b"page_size","page_token",b"page_token","parent",b"parent","type",b"type"]) -> None: ...
global___ListDlpJobsRequest = ListDlpJobsRequest

class ListDlpJobsResponse(google.protobuf.message.Message):
    """The response message for listing DLP jobs."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    JOBS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def jobs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___DlpJob]:
        """A list of DlpJobs that matches the specified filter in the request."""
        pass
    next_page_token: typing.Text = ...
    """The standard List next-page token."""

    def __init__(self,
        *,
        jobs : typing.Optional[typing.Iterable[global___DlpJob]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["jobs",b"jobs","next_page_token",b"next_page_token"]) -> None: ...
global___ListDlpJobsResponse = ListDlpJobsResponse

class CancelDlpJobRequest(google.protobuf.message.Message):
    """The request message for canceling a DLP job."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the DlpJob resource to be cancelled."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___CancelDlpJobRequest = CancelDlpJobRequest

class FinishDlpJobRequest(google.protobuf.message.Message):
    """The request message for finishing a DLP hybrid job."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the DlpJob resource to be cancelled."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___FinishDlpJobRequest = FinishDlpJobRequest

class DeleteDlpJobRequest(google.protobuf.message.Message):
    """The request message for deleting a DLP job."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the DlpJob resource to be deleted."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___DeleteDlpJobRequest = DeleteDlpJobRequest

class CreateDeidentifyTemplateRequest(google.protobuf.message.Message):
    """Request message for CreateDeidentifyTemplate."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    DEIDENTIFY_TEMPLATE_FIELD_NUMBER: builtins.int
    TEMPLATE_ID_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Parent resource name.

    The format of this value varies depending on the scope of the request
    (project or organization) and whether you have [specified a processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>
    + Organizations scope, location specified:<br/>
      `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Organizations scope, no location specified (defaults to global):<br/>
      `organizations/`<var>ORG_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    @property
    def deidentify_template(self) -> global___DeidentifyTemplate:
        """Required. The DeidentifyTemplate to create."""
        pass
    template_id: typing.Text = ...
    """The template id can contain uppercase and lowercase letters,
    numbers, and hyphens; that is, it must match the regular
    expression: `[a-zA-Z\\d-_]+`. The maximum length is 100
    characters. Can be empty to allow the system to generate one.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        deidentify_template : typing.Optional[global___DeidentifyTemplate] = ...,
        template_id : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["deidentify_template",b"deidentify_template"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["deidentify_template",b"deidentify_template","location_id",b"location_id","parent",b"parent","template_id",b"template_id"]) -> None: ...
global___CreateDeidentifyTemplateRequest = CreateDeidentifyTemplateRequest

class UpdateDeidentifyTemplateRequest(google.protobuf.message.Message):
    """Request message for UpdateDeidentifyTemplate."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    DEIDENTIFY_TEMPLATE_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of organization and deidentify template to be updated, for
    example `organizations/433245324/deidentifyTemplates/432452342` or
    projects/project-id/deidentifyTemplates/432452342.
    """

    @property
    def deidentify_template(self) -> global___DeidentifyTemplate:
        """New DeidentifyTemplate value."""
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Mask to control which fields get updated."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        deidentify_template : typing.Optional[global___DeidentifyTemplate] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["deidentify_template",b"deidentify_template","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["deidentify_template",b"deidentify_template","name",b"name","update_mask",b"update_mask"]) -> None: ...
global___UpdateDeidentifyTemplateRequest = UpdateDeidentifyTemplateRequest

class GetDeidentifyTemplateRequest(google.protobuf.message.Message):
    """Request message for GetDeidentifyTemplate."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the organization and deidentify template to be read, for
    example `organizations/433245324/deidentifyTemplates/432452342` or
    projects/project-id/deidentifyTemplates/432452342.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetDeidentifyTemplateRequest = GetDeidentifyTemplateRequest

class ListDeidentifyTemplatesRequest(google.protobuf.message.Message):
    """Request message for ListDeidentifyTemplates."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    ORDER_BY_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Parent resource name.

    The format of this value varies depending on the scope of the request
    (project or organization) and whether you have [specified a processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>
    + Organizations scope, location specified:<br/>
      `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Organizations scope, no location specified (defaults to global):<br/>
      `organizations/`<var>ORG_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    page_token: typing.Text = ...
    """Page token to continue retrieval. Comes from previous call
    to `ListDeidentifyTemplates`.
    """

    page_size: builtins.int = ...
    """Size of the page, can be limited by server. If zero server returns
    a page of max size 100.
    """

    order_by: typing.Text = ...
    """Comma separated list of fields to order by,
    followed by `asc` or `desc` postfix. This list is case-insensitive,
    default sorting order is ascending, redundant space characters are
    insignificant.

    Example: `name asc,update_time, create_time desc`

    Supported fields are:

    - `create_time`: corresponds to time the template was created.
    - `update_time`: corresponds to time the template was last updated.
    - `name`: corresponds to template's name.
    - `display_name`: corresponds to template's display name.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_token : typing.Text = ...,
        page_size : builtins.int = ...,
        order_by : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["location_id",b"location_id","order_by",b"order_by","page_size",b"page_size","page_token",b"page_token","parent",b"parent"]) -> None: ...
global___ListDeidentifyTemplatesRequest = ListDeidentifyTemplatesRequest

class ListDeidentifyTemplatesResponse(google.protobuf.message.Message):
    """Response message for ListDeidentifyTemplates."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DEIDENTIFY_TEMPLATES_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def deidentify_templates(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___DeidentifyTemplate]:
        """List of deidentify templates, up to page_size in
        ListDeidentifyTemplatesRequest.
        """
        pass
    next_page_token: typing.Text = ...
    """If the next page is available then the next page token to be used
    in following ListDeidentifyTemplates request.
    """

    def __init__(self,
        *,
        deidentify_templates : typing.Optional[typing.Iterable[global___DeidentifyTemplate]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["deidentify_templates",b"deidentify_templates","next_page_token",b"next_page_token"]) -> None: ...
global___ListDeidentifyTemplatesResponse = ListDeidentifyTemplatesResponse

class DeleteDeidentifyTemplateRequest(google.protobuf.message.Message):
    """Request message for DeleteDeidentifyTemplate."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the organization and deidentify template to be deleted,
    for example `organizations/433245324/deidentifyTemplates/432452342` or
    projects/project-id/deidentifyTemplates/432452342.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___DeleteDeidentifyTemplateRequest = DeleteDeidentifyTemplateRequest

class LargeCustomDictionaryConfig(google.protobuf.message.Message):
    """Configuration for a custom dictionary created from a data source of any size
    up to the maximum size defined in the
    [limits](https://cloud.google.com/dlp/limits) page. The artifacts of
    dictionary creation are stored in the specified Google Cloud Storage
    location. Consider using `CustomInfoType.Dictionary` for smaller dictionaries
    that satisfy the size requirements.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    OUTPUT_PATH_FIELD_NUMBER: builtins.int
    CLOUD_STORAGE_FILE_SET_FIELD_NUMBER: builtins.int
    BIG_QUERY_FIELD_FIELD_NUMBER: builtins.int
    @property
    def output_path(self) -> google.privacy.dlp.v2.storage_pb2.CloudStoragePath:
        """Location to store dictionary artifacts in Google Cloud Storage. These files
        will only be accessible by project owners and the DLP API. If any of these
        artifacts are modified, the dictionary is considered invalid and can no
        longer be used.
        """
        pass
    @property
    def cloud_storage_file_set(self) -> google.privacy.dlp.v2.storage_pb2.CloudStorageFileSet:
        """Set of files containing newline-delimited lists of dictionary phrases."""
        pass
    @property
    def big_query_field(self) -> google.privacy.dlp.v2.storage_pb2.BigQueryField:
        """Field in a BigQuery table where each cell represents a dictionary phrase."""
        pass
    def __init__(self,
        *,
        output_path : typing.Optional[google.privacy.dlp.v2.storage_pb2.CloudStoragePath] = ...,
        cloud_storage_file_set : typing.Optional[google.privacy.dlp.v2.storage_pb2.CloudStorageFileSet] = ...,
        big_query_field : typing.Optional[google.privacy.dlp.v2.storage_pb2.BigQueryField] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["big_query_field",b"big_query_field","cloud_storage_file_set",b"cloud_storage_file_set","output_path",b"output_path","source",b"source"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["big_query_field",b"big_query_field","cloud_storage_file_set",b"cloud_storage_file_set","output_path",b"output_path","source",b"source"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["source",b"source"]) -> typing.Optional[typing_extensions.Literal["cloud_storage_file_set","big_query_field"]]: ...
global___LargeCustomDictionaryConfig = LargeCustomDictionaryConfig

class LargeCustomDictionaryStats(google.protobuf.message.Message):
    """Summary statistics of a custom dictionary."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    APPROX_NUM_PHRASES_FIELD_NUMBER: builtins.int
    approx_num_phrases: builtins.int = ...
    """Approximate number of distinct phrases in the dictionary."""

    def __init__(self,
        *,
        approx_num_phrases : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["approx_num_phrases",b"approx_num_phrases"]) -> None: ...
global___LargeCustomDictionaryStats = LargeCustomDictionaryStats

class StoredInfoTypeConfig(google.protobuf.message.Message):
    """Configuration for stored infoTypes. All fields and subfield are provided
    by the user. For more information, see
    https://cloud.google.com/dlp/docs/creating-custom-infotypes.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    LARGE_CUSTOM_DICTIONARY_FIELD_NUMBER: builtins.int
    DICTIONARY_FIELD_NUMBER: builtins.int
    REGEX_FIELD_NUMBER: builtins.int
    display_name: typing.Text = ...
    """Display name of the StoredInfoType (max 256 characters)."""

    description: typing.Text = ...
    """Description of the StoredInfoType (max 256 characters)."""

    @property
    def large_custom_dictionary(self) -> global___LargeCustomDictionaryConfig:
        """StoredInfoType where findings are defined by a dictionary of phrases."""
        pass
    @property
    def dictionary(self) -> google.privacy.dlp.v2.storage_pb2.CustomInfoType.Dictionary:
        """Store dictionary-based CustomInfoType."""
        pass
    @property
    def regex(self) -> google.privacy.dlp.v2.storage_pb2.CustomInfoType.Regex:
        """Store regular expression-based StoredInfoType."""
        pass
    def __init__(self,
        *,
        display_name : typing.Text = ...,
        description : typing.Text = ...,
        large_custom_dictionary : typing.Optional[global___LargeCustomDictionaryConfig] = ...,
        dictionary : typing.Optional[google.privacy.dlp.v2.storage_pb2.CustomInfoType.Dictionary] = ...,
        regex : typing.Optional[google.privacy.dlp.v2.storage_pb2.CustomInfoType.Regex] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dictionary",b"dictionary","large_custom_dictionary",b"large_custom_dictionary","regex",b"regex","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["description",b"description","dictionary",b"dictionary","display_name",b"display_name","large_custom_dictionary",b"large_custom_dictionary","regex",b"regex","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["large_custom_dictionary","dictionary","regex"]]: ...
global___StoredInfoTypeConfig = StoredInfoTypeConfig

class StoredInfoTypeStats(google.protobuf.message.Message):
    """Statistics for a StoredInfoType."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LARGE_CUSTOM_DICTIONARY_FIELD_NUMBER: builtins.int
    @property
    def large_custom_dictionary(self) -> global___LargeCustomDictionaryStats:
        """StoredInfoType where findings are defined by a dictionary of phrases."""
        pass
    def __init__(self,
        *,
        large_custom_dictionary : typing.Optional[global___LargeCustomDictionaryStats] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["large_custom_dictionary",b"large_custom_dictionary","type",b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["large_custom_dictionary",b"large_custom_dictionary","type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["large_custom_dictionary"]]: ...
global___StoredInfoTypeStats = StoredInfoTypeStats

class StoredInfoTypeVersion(google.protobuf.message.Message):
    """Version of a StoredInfoType, including the configuration used to build it,
    create timestamp, and current state.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONFIG_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    ERRORS_FIELD_NUMBER: builtins.int
    STATS_FIELD_NUMBER: builtins.int
    @property
    def config(self) -> global___StoredInfoTypeConfig:
        """StoredInfoType configuration."""
        pass
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Create timestamp of the version. Read-only, determined by the system
        when the version is created.
        """
        pass
    state: global___StoredInfoTypeState.ValueType = ...
    """Stored info type version state. Read-only, updated by the system
    during dictionary creation.
    """

    @property
    def errors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Error]:
        """Errors that occurred when creating this storedInfoType version, or
        anomalies detected in the storedInfoType data that render it unusable. Only
        the five most recent errors will be displayed, with the most recent error
        appearing first.

        For example, some of the data for stored custom dictionaries is put in
        the user's Google Cloud Storage bucket, and if this data is modified or
        deleted by the user or another system, the dictionary becomes invalid.

        If any errors occur, fix the problem indicated by the error message and
        use the UpdateStoredInfoType API method to create another version of the
        storedInfoType to continue using it, reusing the same `config` if it was
        not the source of the error.
        """
        pass
    @property
    def stats(self) -> global___StoredInfoTypeStats:
        """Statistics about this storedInfoType version."""
        pass
    def __init__(self,
        *,
        config : typing.Optional[global___StoredInfoTypeConfig] = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        state : global___StoredInfoTypeState.ValueType = ...,
        errors : typing.Optional[typing.Iterable[global___Error]] = ...,
        stats : typing.Optional[global___StoredInfoTypeStats] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["config",b"config","create_time",b"create_time","stats",b"stats"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["config",b"config","create_time",b"create_time","errors",b"errors","state",b"state","stats",b"stats"]) -> None: ...
global___StoredInfoTypeVersion = StoredInfoTypeVersion

class StoredInfoType(google.protobuf.message.Message):
    """StoredInfoType resource message that contains information about the current
    version and any pending updates.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    CURRENT_VERSION_FIELD_NUMBER: builtins.int
    PENDING_VERSIONS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Resource name."""

    @property
    def current_version(self) -> global___StoredInfoTypeVersion:
        """Current version of the stored info type."""
        pass
    @property
    def pending_versions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StoredInfoTypeVersion]:
        """Pending versions of the stored info type. Empty if no versions are
        pending.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        current_version : typing.Optional[global___StoredInfoTypeVersion] = ...,
        pending_versions : typing.Optional[typing.Iterable[global___StoredInfoTypeVersion]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["current_version",b"current_version"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["current_version",b"current_version","name",b"name","pending_versions",b"pending_versions"]) -> None: ...
global___StoredInfoType = StoredInfoType

class CreateStoredInfoTypeRequest(google.protobuf.message.Message):
    """Request message for CreateStoredInfoType."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    CONFIG_FIELD_NUMBER: builtins.int
    STORED_INFO_TYPE_ID_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Parent resource name.

    The format of this value varies depending on the scope of the request
    (project or organization) and whether you have [specified a processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>
    + Organizations scope, location specified:<br/>
      `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Organizations scope, no location specified (defaults to global):<br/>
      `organizations/`<var>ORG_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    @property
    def config(self) -> global___StoredInfoTypeConfig:
        """Required. Configuration of the storedInfoType to create."""
        pass
    stored_info_type_id: typing.Text = ...
    """The storedInfoType ID can contain uppercase and lowercase letters,
    numbers, and hyphens; that is, it must match the regular
    expression: `[a-zA-Z\\d-_]+`. The maximum length is 100
    characters. Can be empty to allow the system to generate one.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        config : typing.Optional[global___StoredInfoTypeConfig] = ...,
        stored_info_type_id : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["config",b"config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["config",b"config","location_id",b"location_id","parent",b"parent","stored_info_type_id",b"stored_info_type_id"]) -> None: ...
global___CreateStoredInfoTypeRequest = CreateStoredInfoTypeRequest

class UpdateStoredInfoTypeRequest(google.protobuf.message.Message):
    """Request message for UpdateStoredInfoType."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    CONFIG_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of organization and storedInfoType to be updated, for
    example `organizations/433245324/storedInfoTypes/432452342` or
    projects/project-id/storedInfoTypes/432452342.
    """

    @property
    def config(self) -> global___StoredInfoTypeConfig:
        """Updated configuration for the storedInfoType. If not provided, a new
        version of the storedInfoType will be created with the existing
        configuration.
        """
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Mask to control which fields get updated."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        config : typing.Optional[global___StoredInfoTypeConfig] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["config",b"config","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["config",b"config","name",b"name","update_mask",b"update_mask"]) -> None: ...
global___UpdateStoredInfoTypeRequest = UpdateStoredInfoTypeRequest

class GetStoredInfoTypeRequest(google.protobuf.message.Message):
    """Request message for GetStoredInfoType."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the organization and storedInfoType to be read, for
    example `organizations/433245324/storedInfoTypes/432452342` or
    projects/project-id/storedInfoTypes/432452342.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetStoredInfoTypeRequest = GetStoredInfoTypeRequest

class ListStoredInfoTypesRequest(google.protobuf.message.Message):
    """Request message for ListStoredInfoTypes."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARENT_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    ORDER_BY_FIELD_NUMBER: builtins.int
    LOCATION_ID_FIELD_NUMBER: builtins.int
    parent: typing.Text = ...
    """Required. Parent resource name.

    The format of this value varies depending on the scope of the request
    (project or organization) and whether you have [specified a processing
    location](https://cloud.google.com/dlp/docs/specifying-location):

    + Projects scope, location specified:<br/>
      `projects/`<var>PROJECT_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Projects scope, no location specified (defaults to global):<br/>
      `projects/`<var>PROJECT_ID</var>
    + Organizations scope, location specified:<br/>
      `organizations/`<var>ORG_ID</var>`/locations/`<var>LOCATION_ID</var>
    + Organizations scope, no location specified (defaults to global):<br/>
      `organizations/`<var>ORG_ID</var>

    The following example `parent` string specifies a parent project with the
    identifier `example-project`, and specifies the `europe-west3` location
    for processing data:

        parent=projects/example-project/locations/europe-west3
    """

    page_token: typing.Text = ...
    """Page token to continue retrieval. Comes from previous call
    to `ListStoredInfoTypes`.
    """

    page_size: builtins.int = ...
    """Size of the page, can be limited by server. If zero server returns
    a page of max size 100.
    """

    order_by: typing.Text = ...
    """Comma separated list of fields to order by,
    followed by `asc` or `desc` postfix. This list is case-insensitive,
    default sorting order is ascending, redundant space characters are
    insignificant.

    Example: `name asc, display_name, create_time desc`

    Supported fields are:

    - `create_time`: corresponds to time the most recent version of the
    resource was created.
    - `state`: corresponds to the state of the resource.
    - `name`: corresponds to resource name.
    - `display_name`: corresponds to info type's display name.
    """

    location_id: typing.Text = ...
    """Deprecated. This field has no effect."""

    def __init__(self,
        *,
        parent : typing.Text = ...,
        page_token : typing.Text = ...,
        page_size : builtins.int = ...,
        order_by : typing.Text = ...,
        location_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["location_id",b"location_id","order_by",b"order_by","page_size",b"page_size","page_token",b"page_token","parent",b"parent"]) -> None: ...
global___ListStoredInfoTypesRequest = ListStoredInfoTypesRequest

class ListStoredInfoTypesResponse(google.protobuf.message.Message):
    """Response message for ListStoredInfoTypes."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    STORED_INFO_TYPES_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def stored_info_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StoredInfoType]:
        """List of storedInfoTypes, up to page_size in ListStoredInfoTypesRequest."""
        pass
    next_page_token: typing.Text = ...
    """If the next page is available then the next page token to be used
    in following ListStoredInfoTypes request.
    """

    def __init__(self,
        *,
        stored_info_types : typing.Optional[typing.Iterable[global___StoredInfoType]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["next_page_token",b"next_page_token","stored_info_types",b"stored_info_types"]) -> None: ...
global___ListStoredInfoTypesResponse = ListStoredInfoTypesResponse

class DeleteStoredInfoTypeRequest(google.protobuf.message.Message):
    """Request message for DeleteStoredInfoType."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the organization and storedInfoType to be deleted, for
    example `organizations/433245324/storedInfoTypes/432452342` or
    projects/project-id/storedInfoTypes/432452342.
    """

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___DeleteStoredInfoTypeRequest = DeleteStoredInfoTypeRequest

class HybridInspectJobTriggerRequest(google.protobuf.message.Message):
    """Request to search for potentially sensitive info in a custom location."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    HYBRID_ITEM_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the trigger to execute a hybrid inspect on, for example
    `projects/dlp-test-project/jobTriggers/53234423`.
    """

    @property
    def hybrid_item(self) -> global___HybridContentItem:
        """The item to inspect."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        hybrid_item : typing.Optional[global___HybridContentItem] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["hybrid_item",b"hybrid_item"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["hybrid_item",b"hybrid_item","name",b"name"]) -> None: ...
global___HybridInspectJobTriggerRequest = HybridInspectJobTriggerRequest

class HybridInspectDlpJobRequest(google.protobuf.message.Message):
    """Request to search for potentially sensitive info in a custom location."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    HYBRID_ITEM_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. Resource name of the job to execute a hybrid inspect on, for example
    `projects/dlp-test-project/dlpJob/53234423`.
    """

    @property
    def hybrid_item(self) -> global___HybridContentItem:
        """The item to inspect."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        hybrid_item : typing.Optional[global___HybridContentItem] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["hybrid_item",b"hybrid_item"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["hybrid_item",b"hybrid_item","name",b"name"]) -> None: ...
global___HybridInspectDlpJobRequest = HybridInspectDlpJobRequest

class HybridContentItem(google.protobuf.message.Message):
    """An individual hybrid item to inspect. Will be stored temporarily during
    processing.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ITEM_FIELD_NUMBER: builtins.int
    FINDING_DETAILS_FIELD_NUMBER: builtins.int
    @property
    def item(self) -> global___ContentItem:
        """The item to inspect."""
        pass
    @property
    def finding_details(self) -> global___HybridFindingDetails:
        """Supplementary information that will be added to each finding."""
        pass
    def __init__(self,
        *,
        item : typing.Optional[global___ContentItem] = ...,
        finding_details : typing.Optional[global___HybridFindingDetails] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["finding_details",b"finding_details","item",b"item"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["finding_details",b"finding_details","item",b"item"]) -> None: ...
global___HybridContentItem = HybridContentItem

class HybridFindingDetails(google.protobuf.message.Message):
    """Populate to associate additional data with each finding."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    CONTAINER_DETAILS_FIELD_NUMBER: builtins.int
    FILE_OFFSET_FIELD_NUMBER: builtins.int
    ROW_OFFSET_FIELD_NUMBER: builtins.int
    TABLE_OPTIONS_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    @property
    def container_details(self) -> global___Container:
        """Details about the container where the content being inspected is from."""
        pass
    file_offset: builtins.int = ...
    """Offset in bytes of the line, from the beginning of the file, where the
    finding  is located. Populate if the item being scanned is only part of a
    bigger item, such as a shard of a file and you want to track the absolute
    position of the finding.
    """

    row_offset: builtins.int = ...
    """Offset of the row for tables. Populate if the row(s) being scanned are
    part of a bigger dataset and you want to keep track of their absolute
    position.
    """

    @property
    def table_options(self) -> google.privacy.dlp.v2.storage_pb2.TableOptions:
        """If the container is a table, additional information to make findings
        meaningful such as the columns that are primary keys. If not known ahead
        of time, can also be set within each inspect hybrid call and the two
        will be merged. Note that identifying_fields will only be stored to
        BigQuery, and only if the BigQuery action has been included.
        """
        pass
    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Labels to represent user provided metadata about the data being inspected.
        If configured by the job, some key values may be required.
        The labels associated with `Finding`'s produced by hybrid
        inspection.

        Label keys must be between 1 and 63 characters long and must conform
        to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.

        Label values must be between 0 and 63 characters long and must conform
        to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.

        No more than 10 labels can be associated with a given finding.

        Examples:
        * `"environment" : "production"`
        * `"pipeline" : "etl"`
        """
        pass
    def __init__(self,
        *,
        container_details : typing.Optional[global___Container] = ...,
        file_offset : builtins.int = ...,
        row_offset : builtins.int = ...,
        table_options : typing.Optional[google.privacy.dlp.v2.storage_pb2.TableOptions] = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["container_details",b"container_details","table_options",b"table_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["container_details",b"container_details","file_offset",b"file_offset","labels",b"labels","row_offset",b"row_offset","table_options",b"table_options"]) -> None: ...
global___HybridFindingDetails = HybridFindingDetails

class HybridInspectResponse(google.protobuf.message.Message):
    """Quota exceeded errors will be thrown once quota has been met."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___HybridInspectResponse = HybridInspectResponse
