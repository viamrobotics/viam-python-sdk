"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.api.expr.v1alpha1.syntax_pb2
import google.protobuf.descriptor
import google.protobuf.empty_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class CheckedExpr(google.protobuf.message.Message):
    """Protos for representing CEL declarations and typed checked expressions.

    A CEL expression which has been successfully type checked.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ReferenceMapEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int = ...
        @property
        def value(self) -> global___Reference: ...
        def __init__(self,
            *,
            key : builtins.int = ...,
            value : typing.Optional[global___Reference] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class TypeMapEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int = ...
        @property
        def value(self) -> global___Type: ...
        def __init__(self,
            *,
            key : builtins.int = ...,
            value : typing.Optional[global___Type] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    REFERENCE_MAP_FIELD_NUMBER: builtins.int
    TYPE_MAP_FIELD_NUMBER: builtins.int
    SOURCE_INFO_FIELD_NUMBER: builtins.int
    EXPR_VERSION_FIELD_NUMBER: builtins.int
    EXPR_FIELD_NUMBER: builtins.int
    @property
    def reference_map(self) -> google.protobuf.internal.containers.MessageMap[builtins.int, global___Reference]:
        """A map from expression ids to resolved references.

        The following entries are in this table:

        - An Ident or Select expression is represented here if it resolves to a
          declaration. For instance, if `a.b.c` is represented by
          `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
          while `c` is a field selection, then the reference is attached to the
          nested select expression (but not to the id or or the outer select).
          In turn, if `a` resolves to a declaration and `b.c` are field selections,
          the reference is attached to the ident expression.
        - Every Call expression has an entry here, identifying the function being
          called.
        - Every CreateStruct expression for a message has an entry, identifying
          the message.
        """
        pass
    @property
    def type_map(self) -> google.protobuf.internal.containers.MessageMap[builtins.int, global___Type]:
        """A map from expression ids to types.

        Every expression node which has a type different than DYN has a mapping
        here. If an expression has type DYN, it is omitted from this map to save
        space.
        """
        pass
    @property
    def source_info(self) -> google.api.expr.v1alpha1.syntax_pb2.SourceInfo:
        """The source info derived from input that generated the parsed `expr` and
        any optimizations made during the type-checking pass.
        """
        pass
    expr_version: typing.Text = ...
    """The expr version indicates the major / minor version number of the `expr`
    representation.

    The most common reason for a version change will be to indicate to the CEL
    runtimes that transformations have been performed on the expr during static
    analysis. In some cases, this will save the runtime the work of applying
    the same or similar transformations prior to evaluation.
    """

    @property
    def expr(self) -> google.api.expr.v1alpha1.syntax_pb2.Expr:
        """The checked expression. Semantically equivalent to the parsed `expr`, but
        may have structural differences.
        """
        pass
    def __init__(self,
        *,
        reference_map : typing.Optional[typing.Mapping[builtins.int, global___Reference]] = ...,
        type_map : typing.Optional[typing.Mapping[builtins.int, global___Type]] = ...,
        source_info : typing.Optional[google.api.expr.v1alpha1.syntax_pb2.SourceInfo] = ...,
        expr_version : typing.Text = ...,
        expr : typing.Optional[google.api.expr.v1alpha1.syntax_pb2.Expr] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["expr",b"expr","source_info",b"source_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["expr",b"expr","expr_version",b"expr_version","reference_map",b"reference_map","source_info",b"source_info","type_map",b"type_map"]) -> None: ...
global___CheckedExpr = CheckedExpr

class Type(google.protobuf.message.Message):
    """Represents a CEL type."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _PrimitiveType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _PrimitiveTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PrimitiveType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        PRIMITIVE_TYPE_UNSPECIFIED: Type.PrimitiveType.ValueType = ...  # 0
        """Unspecified type."""

        BOOL: Type.PrimitiveType.ValueType = ...  # 1
        """Boolean type."""

        INT64: Type.PrimitiveType.ValueType = ...  # 2
        """Int64 type.

        Proto-based integer values are widened to int64.
        """

        UINT64: Type.PrimitiveType.ValueType = ...  # 3
        """Uint64 type.

        Proto-based unsigned integer values are widened to uint64.
        """

        DOUBLE: Type.PrimitiveType.ValueType = ...  # 4
        """Double type.

        Proto-based float values are widened to double values.
        """

        STRING: Type.PrimitiveType.ValueType = ...  # 5
        """String type."""

        BYTES: Type.PrimitiveType.ValueType = ...  # 6
        """Bytes type."""

    class PrimitiveType(_PrimitiveType, metaclass=_PrimitiveTypeEnumTypeWrapper):
        """CEL primitive types."""
        pass

    PRIMITIVE_TYPE_UNSPECIFIED: Type.PrimitiveType.ValueType = ...  # 0
    """Unspecified type."""

    BOOL: Type.PrimitiveType.ValueType = ...  # 1
    """Boolean type."""

    INT64: Type.PrimitiveType.ValueType = ...  # 2
    """Int64 type.

    Proto-based integer values are widened to int64.
    """

    UINT64: Type.PrimitiveType.ValueType = ...  # 3
    """Uint64 type.

    Proto-based unsigned integer values are widened to uint64.
    """

    DOUBLE: Type.PrimitiveType.ValueType = ...  # 4
    """Double type.

    Proto-based float values are widened to double values.
    """

    STRING: Type.PrimitiveType.ValueType = ...  # 5
    """String type."""

    BYTES: Type.PrimitiveType.ValueType = ...  # 6
    """Bytes type."""


    class _WellKnownType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _WellKnownTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_WellKnownType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        WELL_KNOWN_TYPE_UNSPECIFIED: Type.WellKnownType.ValueType = ...  # 0
        """Unspecified type."""

        ANY: Type.WellKnownType.ValueType = ...  # 1
        """Well-known protobuf.Any type.

        Any types are a polymorphic message type. During type-checking they are
        treated like `DYN` types, but at runtime they are resolved to a specific
        message type specified at evaluation time.
        """

        TIMESTAMP: Type.WellKnownType.ValueType = ...  # 2
        """Well-known protobuf.Timestamp type, internally referenced as `timestamp`."""

        DURATION: Type.WellKnownType.ValueType = ...  # 3
        """Well-known protobuf.Duration type, internally referenced as `duration`."""

    class WellKnownType(_WellKnownType, metaclass=_WellKnownTypeEnumTypeWrapper):
        """Well-known protobuf types treated with first-class support in CEL."""
        pass

    WELL_KNOWN_TYPE_UNSPECIFIED: Type.WellKnownType.ValueType = ...  # 0
    """Unspecified type."""

    ANY: Type.WellKnownType.ValueType = ...  # 1
    """Well-known protobuf.Any type.

    Any types are a polymorphic message type. During type-checking they are
    treated like `DYN` types, but at runtime they are resolved to a specific
    message type specified at evaluation time.
    """

    TIMESTAMP: Type.WellKnownType.ValueType = ...  # 2
    """Well-known protobuf.Timestamp type, internally referenced as `timestamp`."""

    DURATION: Type.WellKnownType.ValueType = ...  # 3
    """Well-known protobuf.Duration type, internally referenced as `duration`."""


    class ListType(google.protobuf.message.Message):
        """List type with typed elements, e.g. `list<example.proto.MyMessage>`."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        ELEM_TYPE_FIELD_NUMBER: builtins.int
        @property
        def elem_type(self) -> global___Type:
            """The element type."""
            pass
        def __init__(self,
            *,
            elem_type : typing.Optional[global___Type] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["elem_type",b"elem_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["elem_type",b"elem_type"]) -> None: ...

    class MapType(google.protobuf.message.Message):
        """Map type with parameterized key and value types, e.g. `map<string, int>`."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_TYPE_FIELD_NUMBER: builtins.int
        VALUE_TYPE_FIELD_NUMBER: builtins.int
        @property
        def key_type(self) -> global___Type:
            """The type of the key."""
            pass
        @property
        def value_type(self) -> global___Type:
            """The type of the value."""
            pass
        def __init__(self,
            *,
            key_type : typing.Optional[global___Type] = ...,
            value_type : typing.Optional[global___Type] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["key_type",b"key_type","value_type",b"value_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key_type",b"key_type","value_type",b"value_type"]) -> None: ...

    class FunctionType(google.protobuf.message.Message):
        """Function type with result and arg types."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        RESULT_TYPE_FIELD_NUMBER: builtins.int
        ARG_TYPES_FIELD_NUMBER: builtins.int
        @property
        def result_type(self) -> global___Type:
            """Result type of the function."""
            pass
        @property
        def arg_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Type]:
            """Argument types of the function."""
            pass
        def __init__(self,
            *,
            result_type : typing.Optional[global___Type] = ...,
            arg_types : typing.Optional[typing.Iterable[global___Type]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["result_type",b"result_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["arg_types",b"arg_types","result_type",b"result_type"]) -> None: ...

    class AbstractType(google.protobuf.message.Message):
        """Application defined abstract type."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        NAME_FIELD_NUMBER: builtins.int
        PARAMETER_TYPES_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        """The fully qualified name of this abstract type."""

        @property
        def parameter_types(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Type]:
            """Parameter types for this abstract type."""
            pass
        def __init__(self,
            *,
            name : typing.Text = ...,
            parameter_types : typing.Optional[typing.Iterable[global___Type]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["name",b"name","parameter_types",b"parameter_types"]) -> None: ...

    DYN_FIELD_NUMBER: builtins.int
    NULL_FIELD_NUMBER: builtins.int
    PRIMITIVE_FIELD_NUMBER: builtins.int
    WRAPPER_FIELD_NUMBER: builtins.int
    WELL_KNOWN_FIELD_NUMBER: builtins.int
    LIST_TYPE_FIELD_NUMBER: builtins.int
    MAP_TYPE_FIELD_NUMBER: builtins.int
    FUNCTION_FIELD_NUMBER: builtins.int
    MESSAGE_TYPE_FIELD_NUMBER: builtins.int
    TYPE_PARAM_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    ABSTRACT_TYPE_FIELD_NUMBER: builtins.int
    @property
    def dyn(self) -> google.protobuf.empty_pb2.Empty:
        """Dynamic type."""
        pass
    null: google.protobuf.struct_pb2.NullValue.ValueType = ...
    """Null value."""

    primitive: global___Type.PrimitiveType.ValueType = ...
    """Primitive types: `true`, `1u`, `-2.0`, `'string'`, `b'bytes'`."""

    wrapper: global___Type.PrimitiveType.ValueType = ...
    """Wrapper of a primitive type, e.g. `google.protobuf.Int64Value`."""

    well_known: global___Type.WellKnownType.ValueType = ...
    """Well-known protobuf type such as `google.protobuf.Timestamp`."""

    @property
    def list_type(self) -> global___Type.ListType:
        """Parameterized list with elements of `list_type`, e.g. `list<timestamp>`."""
        pass
    @property
    def map_type(self) -> global___Type.MapType:
        """Parameterized map with typed keys and values."""
        pass
    @property
    def function(self) -> global___Type.FunctionType:
        """Function type."""
        pass
    message_type: typing.Text = ...
    """Protocol buffer message type.

    The `message_type` string specifies the qualified message type name. For
    example, `google.plus.Profile`.
    """

    type_param: typing.Text = ...
    """Type param type.

    The `type_param` string specifies the type parameter name, e.g. `list<E>`
    would be a `list_type` whose element type was a `type_param` type
    named `E`.
    """

    @property
    def type(self) -> global___Type:
        """Type type.

        The `type` value specifies the target type. e.g. int is type with a
        target type of `Primitive.INT`.
        """
        pass
    @property
    def error(self) -> google.protobuf.empty_pb2.Empty:
        """Error type.

        During type-checking if an expression is an error, its type is propagated
        as the `ERROR` type. This permits the type-checker to discover other
        errors present in the expression.
        """
        pass
    @property
    def abstract_type(self) -> global___Type.AbstractType:
        """Abstract, application defined type."""
        pass
    def __init__(self,
        *,
        dyn : typing.Optional[google.protobuf.empty_pb2.Empty] = ...,
        null : google.protobuf.struct_pb2.NullValue.ValueType = ...,
        primitive : global___Type.PrimitiveType.ValueType = ...,
        wrapper : global___Type.PrimitiveType.ValueType = ...,
        well_known : global___Type.WellKnownType.ValueType = ...,
        list_type : typing.Optional[global___Type.ListType] = ...,
        map_type : typing.Optional[global___Type.MapType] = ...,
        function : typing.Optional[global___Type.FunctionType] = ...,
        message_type : typing.Text = ...,
        type_param : typing.Text = ...,
        type : typing.Optional[global___Type] = ...,
        error : typing.Optional[google.protobuf.empty_pb2.Empty] = ...,
        abstract_type : typing.Optional[global___Type.AbstractType] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["abstract_type",b"abstract_type","dyn",b"dyn","error",b"error","function",b"function","list_type",b"list_type","map_type",b"map_type","message_type",b"message_type","null",b"null","primitive",b"primitive","type",b"type","type_kind",b"type_kind","type_param",b"type_param","well_known",b"well_known","wrapper",b"wrapper"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["abstract_type",b"abstract_type","dyn",b"dyn","error",b"error","function",b"function","list_type",b"list_type","map_type",b"map_type","message_type",b"message_type","null",b"null","primitive",b"primitive","type",b"type","type_kind",b"type_kind","type_param",b"type_param","well_known",b"well_known","wrapper",b"wrapper"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["type_kind",b"type_kind"]) -> typing.Optional[typing_extensions.Literal["dyn","null","primitive","wrapper","well_known","list_type","map_type","function","message_type","type_param","type","error","abstract_type"]]: ...
global___Type = Type

class Decl(google.protobuf.message.Message):
    """Represents a declaration of a named value or function.

    A declaration is part of the contract between the expression, the agent
    evaluating that expression, and the caller requesting evaluation.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class IdentDecl(google.protobuf.message.Message):
        """Identifier declaration which specifies its type and optional `Expr` value.

        An identifier without a value is a declaration that must be provided at
        evaluation time. An identifier with a value should resolve to a constant,
        but may be used in conjunction with other identifiers bound at evaluation
        time.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TYPE_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        DOC_FIELD_NUMBER: builtins.int
        @property
        def type(self) -> global___Type:
            """Required. The type of the identifier."""
            pass
        @property
        def value(self) -> google.api.expr.v1alpha1.syntax_pb2.Constant:
            """The constant value of the identifier. If not specified, the identifier
            must be supplied at evaluation time.
            """
            pass
        doc: typing.Text = ...
        """Documentation string for the identifier."""

        def __init__(self,
            *,
            type : typing.Optional[global___Type] = ...,
            value : typing.Optional[google.api.expr.v1alpha1.syntax_pb2.Constant] = ...,
            doc : typing.Text = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["type",b"type","value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["doc",b"doc","type",b"type","value",b"value"]) -> None: ...

    class FunctionDecl(google.protobuf.message.Message):
        """Function declaration specifies one or more overloads which indicate the
        function's parameter types and return type.

        Functions have no observable side-effects (there may be side-effects like
        logging which are not observable from CEL).
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Overload(google.protobuf.message.Message):
            """An overload indicates a function's parameter types and return type, and
            may optionally include a function body described in terms of [Expr][google.api.expr.v1alpha1.Expr]
            values.

            Functions overloads are declared in either a function or method
            call-style. For methods, the `params[0]` is the expected type of the
            target receiver.

            Overloads must have non-overlapping argument types after erasure of all
            parameterized type variables (similar as type erasure in Java).
            """
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            OVERLOAD_ID_FIELD_NUMBER: builtins.int
            PARAMS_FIELD_NUMBER: builtins.int
            TYPE_PARAMS_FIELD_NUMBER: builtins.int
            RESULT_TYPE_FIELD_NUMBER: builtins.int
            IS_INSTANCE_FUNCTION_FIELD_NUMBER: builtins.int
            DOC_FIELD_NUMBER: builtins.int
            overload_id: typing.Text = ...
            """Required. Globally unique overload name of the function which reflects
            the function name and argument types.

            This will be used by a [Reference][google.api.expr.v1alpha1.Reference] to indicate the `overload_id` that
            was resolved for the function `name`.
            """

            @property
            def params(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Type]:
                """List of function parameter [Type][google.api.expr.v1alpha1.Type] values.

                Param types are disjoint after generic type parameters have been
                replaced with the type `DYN`. Since the `DYN` type is compatible with
                any other type, this means that if `A` is a type parameter, the
                function types `int<A>` and `int<int>` are not disjoint. Likewise,
                `map<string, string>` is not disjoint from `map<K, V>`.

                When the `result_type` of a function is a generic type param, the
                type param name also appears as the `type` of on at least one params.
                """
                pass
            @property
            def type_params(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
                """The type param names associated with the function declaration.

                For example, `function ex<K,V>(K key, map<K, V> map) : V` would yield
                the type params of `K, V`.
                """
                pass
            @property
            def result_type(self) -> global___Type:
                """Required. The result type of the function. For example, the operator
                `string.isEmpty()` would have `result_type` of `kind: BOOL`.
                """
                pass
            is_instance_function: builtins.bool = ...
            """Whether the function is to be used in a method call-style `x.f(...)`
            of a function call-style `f(x, ...)`.

            For methods, the first parameter declaration, `params[0]` is the
            expected type of the target receiver.
            """

            doc: typing.Text = ...
            """Documentation string for the overload."""

            def __init__(self,
                *,
                overload_id : typing.Text = ...,
                params : typing.Optional[typing.Iterable[global___Type]] = ...,
                type_params : typing.Optional[typing.Iterable[typing.Text]] = ...,
                result_type : typing.Optional[global___Type] = ...,
                is_instance_function : builtins.bool = ...,
                doc : typing.Text = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["result_type",b"result_type"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["doc",b"doc","is_instance_function",b"is_instance_function","overload_id",b"overload_id","params",b"params","result_type",b"result_type","type_params",b"type_params"]) -> None: ...

        OVERLOADS_FIELD_NUMBER: builtins.int
        @property
        def overloads(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Decl.FunctionDecl.Overload]:
            """Required. List of function overloads, must contain at least one overload."""
            pass
        def __init__(self,
            *,
            overloads : typing.Optional[typing.Iterable[global___Decl.FunctionDecl.Overload]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["overloads",b"overloads"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    IDENT_FIELD_NUMBER: builtins.int
    FUNCTION_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The fully qualified name of the declaration.

    Declarations are organized in containers and this represents the full path
    to the declaration in its container, as in `google.api.expr.Decl`.

    Declarations used as [FunctionDecl.Overload][google.api.expr.v1alpha1.Decl.FunctionDecl.Overload] parameters may or may not
    have a name depending on whether the overload is function declaration or a
    function definition containing a result [Expr][google.api.expr.v1alpha1.Expr].
    """

    @property
    def ident(self) -> global___Decl.IdentDecl:
        """Identifier declaration."""
        pass
    @property
    def function(self) -> global___Decl.FunctionDecl:
        """Function declaration."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        ident : typing.Optional[global___Decl.IdentDecl] = ...,
        function : typing.Optional[global___Decl.FunctionDecl] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["decl_kind",b"decl_kind","function",b"function","ident",b"ident"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["decl_kind",b"decl_kind","function",b"function","ident",b"ident","name",b"name"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["decl_kind",b"decl_kind"]) -> typing.Optional[typing_extensions.Literal["ident","function"]]: ...
global___Decl = Decl

class Reference(google.protobuf.message.Message):
    """Describes a resolved reference to a declaration."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    OVERLOAD_ID_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The fully qualified name of the declaration."""

    @property
    def overload_id(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """For references to functions, this is a list of `Overload.overload_id`
        values which match according to typing rules.

        If the list has more than one element, overload resolution among the
        presented candidates must happen at runtime because of dynamic types. The
        type checker attempts to narrow down this list as much as possible.

        Empty if this is not a reference to a [Decl.FunctionDecl][google.api.expr.v1alpha1.Decl.FunctionDecl].
        """
        pass
    @property
    def value(self) -> google.api.expr.v1alpha1.syntax_pb2.Constant:
        """For references to constants, this may contain the value of the
        constant if known at compile time.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        overload_id : typing.Optional[typing.Iterable[typing.Text]] = ...,
        value : typing.Optional[google.api.expr.v1alpha1.syntax_pb2.Constant] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name","overload_id",b"overload_id","value",b"value"]) -> None: ...
global___Reference = Reference
