"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.api.servicecontrol.v1.metric_value_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.rpc.status_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class AllocateQuotaRequest(google.protobuf.message.Message):
    """Request message for the AllocateQuota method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SERVICE_NAME_FIELD_NUMBER: builtins.int
    ALLOCATE_OPERATION_FIELD_NUMBER: builtins.int
    SERVICE_CONFIG_ID_FIELD_NUMBER: builtins.int
    service_name: typing.Text = ...
    """Name of the service as specified in the service configuration. For example,
    `"pubsub.googleapis.com"`.

    See [google.api.Service][google.api.Service] for the definition of a service name.
    """

    @property
    def allocate_operation(self) -> global___QuotaOperation:
        """Operation that describes the quota allocation."""
        pass
    service_config_id: typing.Text = ...
    """Specifies which version of service configuration should be used to process
    the request. If unspecified or no matching version can be found, the latest
    one will be used.
    """

    def __init__(self,
        *,
        service_name : typing.Text = ...,
        allocate_operation : typing.Optional[global___QuotaOperation] = ...,
        service_config_id : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["allocate_operation",b"allocate_operation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["allocate_operation",b"allocate_operation","service_config_id",b"service_config_id","service_name",b"service_name"]) -> None: ...
global___AllocateQuotaRequest = AllocateQuotaRequest

class QuotaOperation(google.protobuf.message.Message):
    """Represents information regarding a quota operation."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _QuotaMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _QuotaModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_QuotaMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNSPECIFIED: QuotaOperation.QuotaMode.ValueType = ...  # 0
        """Guard against implicit default. Must not be used."""

        NORMAL: QuotaOperation.QuotaMode.ValueType = ...  # 1
        """For AllocateQuota request, allocates quota for the amount specified in
        the service configuration or specified using the quota metrics. If the
        amount is higher than the available quota, allocation error will be
        returned and no quota will be allocated.
        If multiple quotas are part of the request, and one fails, none of the
        quotas are allocated or released.
        """

        BEST_EFFORT: QuotaOperation.QuotaMode.ValueType = ...  # 2
        """The operation allocates quota for the amount specified in the service
        configuration or specified using the quota metrics. If the amount is
        higher than the available quota, request does not fail but all available
        quota will be allocated.
        For rate quota, BEST_EFFORT will continue to deduct from other groups
        even if one does not have enough quota. For allocation, it will find the
        minimum available amount across all groups and deduct that amount from
        all the affected groups.
        """

        CHECK_ONLY: QuotaOperation.QuotaMode.ValueType = ...  # 3
        """For AllocateQuota request, only checks if there is enough quota
        available and does not change the available quota. No lock is placed on
        the available quota either.
        """

        QUERY_ONLY: QuotaOperation.QuotaMode.ValueType = ...  # 4
        """Unimplemented. When used in AllocateQuotaRequest, this returns the
        effective quota limit(s) in the response, and no quota check will be
        performed. Not supported for other requests, and even for
        AllocateQuotaRequest, this is currently supported only for allowlisted
        services.
        """

        ADJUST_ONLY: QuotaOperation.QuotaMode.ValueType = ...  # 5
        """The operation allocates quota for the amount specified in the service
        configuration or specified using the quota metrics. If the requested
        amount is higher than the available quota, request does not fail and
        remaining quota would become negative (going over the limit).
        Not supported for Rate Quota.
        """

    class QuotaMode(_QuotaMode, metaclass=_QuotaModeEnumTypeWrapper):
        """Supported quota modes."""
        pass

    UNSPECIFIED: QuotaOperation.QuotaMode.ValueType = ...  # 0
    """Guard against implicit default. Must not be used."""

    NORMAL: QuotaOperation.QuotaMode.ValueType = ...  # 1
    """For AllocateQuota request, allocates quota for the amount specified in
    the service configuration or specified using the quota metrics. If the
    amount is higher than the available quota, allocation error will be
    returned and no quota will be allocated.
    If multiple quotas are part of the request, and one fails, none of the
    quotas are allocated or released.
    """

    BEST_EFFORT: QuotaOperation.QuotaMode.ValueType = ...  # 2
    """The operation allocates quota for the amount specified in the service
    configuration or specified using the quota metrics. If the amount is
    higher than the available quota, request does not fail but all available
    quota will be allocated.
    For rate quota, BEST_EFFORT will continue to deduct from other groups
    even if one does not have enough quota. For allocation, it will find the
    minimum available amount across all groups and deduct that amount from
    all the affected groups.
    """

    CHECK_ONLY: QuotaOperation.QuotaMode.ValueType = ...  # 3
    """For AllocateQuota request, only checks if there is enough quota
    available and does not change the available quota. No lock is placed on
    the available quota either.
    """

    QUERY_ONLY: QuotaOperation.QuotaMode.ValueType = ...  # 4
    """Unimplemented. When used in AllocateQuotaRequest, this returns the
    effective quota limit(s) in the response, and no quota check will be
    performed. Not supported for other requests, and even for
    AllocateQuotaRequest, this is currently supported only for allowlisted
    services.
    """

    ADJUST_ONLY: QuotaOperation.QuotaMode.ValueType = ...  # 5
    """The operation allocates quota for the amount specified in the service
    configuration or specified using the quota metrics. If the requested
    amount is higher than the available quota, request does not fail and
    remaining quota would become negative (going over the limit).
    Not supported for Rate Quota.
    """


    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    OPERATION_ID_FIELD_NUMBER: builtins.int
    METHOD_NAME_FIELD_NUMBER: builtins.int
    CONSUMER_ID_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    QUOTA_METRICS_FIELD_NUMBER: builtins.int
    QUOTA_MODE_FIELD_NUMBER: builtins.int
    operation_id: typing.Text = ...
    """Identity of the operation. This is expected to be unique within the scope
    of the service that generated the operation, and guarantees idempotency in
    case of retries.

    In order to ensure best performance and latency in the Quota backends,
    operation_ids are optimally associated with time, so that related
    operations can be accessed fast in storage. For this reason, the
    recommended token for services that intend to operate at a high QPS is
    Unix time in nanos + UUID
    """

    method_name: typing.Text = ...
    """Fully qualified name of the API method for which this quota operation is
    requested. This name is used for matching quota rules or metric rules and
    billing status rules defined in service configuration.

    This field should not be set if any of the following is true:
    (1) the quota operation is performed on non-API resources.
    (2) quota_metrics is set because the caller is doing quota override.


    Example of an RPC method name:
        google.example.library.v1.LibraryService.CreateShelf
    """

    consumer_id: typing.Text = ...
    """Identity of the consumer for whom this quota operation is being performed.

    This can be in one of the following formats:
      project:<project_id>,
      project_number:<project_number>,
      api_key:<api_key>.
    """

    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Labels describing the operation."""
        pass
    @property
    def quota_metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.api.servicecontrol.v1.metric_value_pb2.MetricValueSet]:
        """Represents information about this operation. Each MetricValueSet
        corresponds to a metric defined in the service configuration.
        The data type used in the MetricValueSet must agree with
        the data type specified in the metric definition.

        Within a single operation, it is not allowed to have more than one
        MetricValue instances that have the same metric names and identical
        label value combinations. If a request has such duplicated MetricValue
        instances, the entire request is rejected with
        an invalid argument error.

        This field is mutually exclusive with method_name.
        """
        pass
    quota_mode: global___QuotaOperation.QuotaMode.ValueType = ...
    """Quota mode for this operation."""

    def __init__(self,
        *,
        operation_id : typing.Text = ...,
        method_name : typing.Text = ...,
        consumer_id : typing.Text = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        quota_metrics : typing.Optional[typing.Iterable[google.api.servicecontrol.v1.metric_value_pb2.MetricValueSet]] = ...,
        quota_mode : global___QuotaOperation.QuotaMode.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["consumer_id",b"consumer_id","labels",b"labels","method_name",b"method_name","operation_id",b"operation_id","quota_metrics",b"quota_metrics","quota_mode",b"quota_mode"]) -> None: ...
global___QuotaOperation = QuotaOperation

class AllocateQuotaResponse(google.protobuf.message.Message):
    """Response message for the AllocateQuota method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    OPERATION_ID_FIELD_NUMBER: builtins.int
    ALLOCATE_ERRORS_FIELD_NUMBER: builtins.int
    QUOTA_METRICS_FIELD_NUMBER: builtins.int
    SERVICE_CONFIG_ID_FIELD_NUMBER: builtins.int
    operation_id: typing.Text = ...
    """The same operation_id value used in the AllocateQuotaRequest. Used for
    logging and diagnostics purposes.
    """

    @property
    def allocate_errors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___QuotaError]:
        """Indicates the decision of the allocate."""
        pass
    @property
    def quota_metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.api.servicecontrol.v1.metric_value_pb2.MetricValueSet]:
        """Quota metrics to indicate the result of allocation. Depending on the
        request, one or more of the following metrics will be included:

        1. Per quota group or per quota metric incremental usage will be specified
        using the following delta metric :
          "serviceruntime.googleapis.com/api/consumer/quota_used_count"

        2. The quota limit reached condition will be specified using the following
        boolean metric :
          "serviceruntime.googleapis.com/quota/exceeded"
        """
        pass
    service_config_id: typing.Text = ...
    """ID of the actual config used to process the request."""

    def __init__(self,
        *,
        operation_id : typing.Text = ...,
        allocate_errors : typing.Optional[typing.Iterable[global___QuotaError]] = ...,
        quota_metrics : typing.Optional[typing.Iterable[google.api.servicecontrol.v1.metric_value_pb2.MetricValueSet]] = ...,
        service_config_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["allocate_errors",b"allocate_errors","operation_id",b"operation_id","quota_metrics",b"quota_metrics","service_config_id",b"service_config_id"]) -> None: ...
global___AllocateQuotaResponse = AllocateQuotaResponse

class QuotaError(google.protobuf.message.Message):
    """Represents error information for [QuotaOperation][google.api.servicecontrol.v1.QuotaOperation]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Code:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _CodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Code.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNSPECIFIED: QuotaError.Code.ValueType = ...  # 0
        """This is never used."""

        RESOURCE_EXHAUSTED: QuotaError.Code.ValueType = ...  # 8
        """Quota allocation failed.
        Same as [google.rpc.Code.RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED].
        """

        BILLING_NOT_ACTIVE: QuotaError.Code.ValueType = ...  # 107
        """Consumer cannot access the service because the service requires active
        billing.
        """

        PROJECT_DELETED: QuotaError.Code.ValueType = ...  # 108
        """Consumer's project has been marked as deleted (soft deletion)."""

        API_KEY_INVALID: QuotaError.Code.ValueType = ...  # 105
        """Specified API key is invalid."""

        API_KEY_EXPIRED: QuotaError.Code.ValueType = ...  # 112
        """Specified API Key has expired."""

    class Code(_Code, metaclass=_CodeEnumTypeWrapper):
        """Error codes related to project config validations are deprecated since the
        quota controller methods do not perform these validations. Instead services
        have to call the Check method, without quota_properties field, to perform
        these validations before calling the quota controller methods. These
        methods check only for project deletion to be wipe out compliant.
        """
        pass

    UNSPECIFIED: QuotaError.Code.ValueType = ...  # 0
    """This is never used."""

    RESOURCE_EXHAUSTED: QuotaError.Code.ValueType = ...  # 8
    """Quota allocation failed.
    Same as [google.rpc.Code.RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED].
    """

    BILLING_NOT_ACTIVE: QuotaError.Code.ValueType = ...  # 107
    """Consumer cannot access the service because the service requires active
    billing.
    """

    PROJECT_DELETED: QuotaError.Code.ValueType = ...  # 108
    """Consumer's project has been marked as deleted (soft deletion)."""

    API_KEY_INVALID: QuotaError.Code.ValueType = ...  # 105
    """Specified API key is invalid."""

    API_KEY_EXPIRED: QuotaError.Code.ValueType = ...  # 112
    """Specified API Key has expired."""


    CODE_FIELD_NUMBER: builtins.int
    SUBJECT_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    code: global___QuotaError.Code.ValueType = ...
    """Error code."""

    subject: typing.Text = ...
    """Subject to whom this error applies. See the specific enum for more details
    on this field. For example, "clientip:<ip address of client>" or
    "project:<Google developer project id>".
    """

    description: typing.Text = ...
    """Free-form text that provides details on the cause of the error."""

    @property
    def status(self) -> google.rpc.status_pb2.Status:
        """Contains additional information about the quota error.
        If available, `status.code` will be non zero.
        """
        pass
    def __init__(self,
        *,
        code : global___QuotaError.Code.ValueType = ...,
        subject : typing.Text = ...,
        description : typing.Text = ...,
        status : typing.Optional[google.rpc.status_pb2.Status] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["status",b"status"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["code",b"code","description",b"description","status",b"status","subject",b"subject"]) -> None: ...
global___QuotaError = QuotaError
