"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.type.latlng_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class PlayableLocation(google.protobuf.message.Message):
    """A geographical point suitable for placing game objects in location-based
    games.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    PLACE_ID_FIELD_NUMBER: builtins.int
    PLUS_CODE_FIELD_NUMBER: builtins.int
    TYPES_FIELD_NUMBER: builtins.int
    CENTER_POINT_FIELD_NUMBER: builtins.int
    SNAPPED_POINT_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of this playable location."""

    place_id: typing.Text = ...
    """A [place ID] (https://developers.google.com/places/place-id)"""

    plus_code: typing.Text = ...
    """A [plus code] (http://openlocationcode.com)"""

    @property
    def types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A collection of [Playable Location Types](/maps/tt/games/types) for this
        playable location. The first type in the collection is the primary type.

        Type information might not be available for all playable locations.
        """
        pass
    @property
    def center_point(self) -> google.type.latlng_pb2.LatLng:
        """Required. The latitude and longitude associated with the center of the
        playable location.

        By default, the set of playable locations returned from
        [SamplePlayableLocations][google.maps.playablelocations.v3.PlayableLocations.SamplePlayableLocations]
        use center-point coordinates.
        """
        pass
    @property
    def snapped_point(self) -> google.type.latlng_pb2.LatLng:
        """The playable location's coordinates, snapped to the sidewalk of the
        nearest road, if a nearby road exists.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        place_id : typing.Text = ...,
        plus_code : typing.Text = ...,
        types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        center_point : typing.Optional[google.type.latlng_pb2.LatLng] = ...,
        snapped_point : typing.Optional[google.type.latlng_pb2.LatLng] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["center_point",b"center_point","location_id",b"location_id","place_id",b"place_id","plus_code",b"plus_code","snapped_point",b"snapped_point"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["center_point",b"center_point","location_id",b"location_id","name",b"name","place_id",b"place_id","plus_code",b"plus_code","snapped_point",b"snapped_point","types",b"types"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["location_id",b"location_id"]) -> typing.Optional[typing_extensions.Literal["place_id","plus_code"]]: ...
global___PlayableLocation = PlayableLocation

class SpacingOptions(google.protobuf.message.Message):
    """A set of options that specifies the separation between playable locations."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _PointType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _PointTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_PointType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        POINT_TYPE_UNSPECIFIED: SpacingOptions.PointType.ValueType = ...  # 0
        """Unspecified point type. Do not use this value."""

        CENTER_POINT: SpacingOptions.PointType.ValueType = ...  # 1
        """The geographic coordinates correspond to the center of the location."""

        SNAPPED_POINT: SpacingOptions.PointType.ValueType = ...  # 2
        """The geographic coordinates correspond to the location snapped to the
        sidewalk of the nearest road (when a nearby road exists).
        """

    class PointType(_PointType, metaclass=_PointTypeEnumTypeWrapper):
        """Specifies whether the playable location's geographic coordinates (latitude
        and longitude) correspond to its center-point, or to its location snapped
        to the sidewalk of the nearest road.
        """
        pass

    POINT_TYPE_UNSPECIFIED: SpacingOptions.PointType.ValueType = ...  # 0
    """Unspecified point type. Do not use this value."""

    CENTER_POINT: SpacingOptions.PointType.ValueType = ...  # 1
    """The geographic coordinates correspond to the center of the location."""

    SNAPPED_POINT: SpacingOptions.PointType.ValueType = ...  # 2
    """The geographic coordinates correspond to the location snapped to the
    sidewalk of the nearest road (when a nearby road exists).
    """


    MIN_SPACING_METERS_FIELD_NUMBER: builtins.int
    POINT_TYPE_FIELD_NUMBER: builtins.int
    min_spacing_meters: builtins.float = ...
    """Required. The minimum spacing between any two playable locations, measured
    in meters. The minimum value is 30. The maximum value is 1000.

    Inputs will be rounded up to the next 10 meter interval.

    The default value is 200m.

    Set this field to remove tight clusters of playable locations.

    Note:

    The spacing is a greedy algorithm. It optimizes for selecting the highest
    ranking locations first, not to maximize the number of locations selected.
    Consider the following scenario:

      * Rank: A: 2, B: 1, C: 3.
      * Distance: A--200m--B--200m--C

    If spacing=250, it will pick the highest ranked location [B], not [A, C].


    Note:

    Spacing works within the game object type itself, as well as the previous
    ones.
    Suppose three game object types, each with the following spacing:

      * X: 400m, Y: undefined, Z: 200m.

    1. Add locations for X, within 400m of each other.
    2. Add locations for Y, without any spacing.
    3. Finally, add locations for Z within 200m of each other as well X and Y.

    The distance diagram between those locations end up as:

      * From->To.
      * X->X: 400m
      * Y->X, Y->Y: unspecified.
      * Z->X, Z->Y, Z->Z: 200m.
    """

    point_type: global___SpacingOptions.PointType.ValueType = ...
    """Specifies whether the minimum spacing constraint applies to the
    center-point or to the snapped point of playable locations. The default
    value is `CENTER_POINT`.

    If a snapped point is not available for a playable location, its
    center-point is used instead.

    Set this to the point type used in your game.
    """

    def __init__(self,
        *,
        min_spacing_meters : builtins.float = ...,
        point_type : global___SpacingOptions.PointType.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["min_spacing_meters",b"min_spacing_meters","point_type",b"point_type"]) -> None: ...
global___SpacingOptions = SpacingOptions

class Filter(google.protobuf.message.Message):
    """Specifies the filters to use when searching for playable locations."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MAX_LOCATION_COUNT_FIELD_NUMBER: builtins.int
    SPACING_FIELD_NUMBER: builtins.int
    INCLUDED_TYPES_FIELD_NUMBER: builtins.int
    max_location_count: builtins.int = ...
    """Specifies the maximum number of playable locations to return. This value
    must not be greater than 1000. The default value is 100.

    Only the top-ranking playable locations are returned.
    """

    @property
    def spacing(self) -> global___SpacingOptions:
        """A set of options that control the spacing between playable locations. By
        default the minimum distance between locations is 200m.
        """
        pass
    @property
    def included_types(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Restricts the set of playable locations to just the
        [types](/maps/tt/games/types) that you want.
        """
        pass
    def __init__(self,
        *,
        max_location_count : builtins.int = ...,
        spacing : typing.Optional[global___SpacingOptions] = ...,
        included_types : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["spacing",b"spacing"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["included_types",b"included_types","max_location_count",b"max_location_count","spacing",b"spacing"]) -> None: ...
global___Filter = Filter

class Criterion(google.protobuf.message.Message):
    """Encapsulates a filter criterion for searching for a set of playable
    locations.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GAME_OBJECT_TYPE_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    FIELDS_TO_RETURN_FIELD_NUMBER: builtins.int
    game_object_type: builtins.int = ...
    """Required. An arbitrary, developer-defined identifier of the type of game
    object that the playable location is used for. This field allows you to
    specify criteria per game object type when searching for playable
    locations.

    You should assign a unique `game_object_type` ID across all
    `request_criteria` to represent a distinct type of game object. For
    example, 1=monster location, 2=powerup location.

    The response contains a map<game_object_type, Response>.
    """

    @property
    def filter(self) -> global___Filter:
        """Specifies filtering options, and specifies what will be included in the
        result set.
        """
        pass
    @property
    def fields_to_return(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Specifies which `PlayableLocation` fields are returned.

        `name` (which is used for logging impressions), `center_point` and
        `place_id` (or `plus_code`) are always returned.

        The following fields are omitted unless you specify them here:

          * snapped_point
          * types

        Note: The more fields you include, the more expensive in terms of data and
        associated latency your query will be.
        """
        pass
    def __init__(self,
        *,
        game_object_type : builtins.int = ...,
        filter : typing.Optional[global___Filter] = ...,
        fields_to_return : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["fields_to_return",b"fields_to_return","filter",b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["fields_to_return",b"fields_to_return","filter",b"filter","game_object_type",b"game_object_type"]) -> None: ...
global___Criterion = Criterion

class AreaFilter(google.protobuf.message.Message):
    """Specifies the area to search for playable locations."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    S2_CELL_ID_FIELD_NUMBER: builtins.int
    s2_cell_id: builtins.int = ...
    """Required. The S2 cell ID of the area you want. This must be between cell
    level 11 and 14 (inclusive).

    S2 cells are 64-bit integers that identify areas on the Earth. They are
    hierarchical, and can therefore be used for spatial indexing.

    The S2 geometry library is available in a number of languages:

      * [C++](https://github.com/google/s2geometry)
      * [Java](https://github.com/google/s2-geometry-library-java)
      * [Go](https://github.com/golang/geo)
      * [Python](https://github.com/google/s2geometry/tree/master/src/python)
    """

    def __init__(self,
        *,
        s2_cell_id : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["s2_cell_id",b"s2_cell_id"]) -> None: ...
global___AreaFilter = AreaFilter

class PlayableLocationList(google.protobuf.message.Message):
    """A list of PlayableLocation objects that satisfies a single Criterion."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LOCATIONS_FIELD_NUMBER: builtins.int
    @property
    def locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PlayableLocation]:
        """A list of playable locations for this game object type."""
        pass
    def __init__(self,
        *,
        locations : typing.Optional[typing.Iterable[global___PlayableLocation]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["locations",b"locations"]) -> None: ...
global___PlayableLocationList = PlayableLocationList
