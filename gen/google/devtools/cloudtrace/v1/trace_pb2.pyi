"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Trace(google.protobuf.message.Message):
    """A trace describes how long it takes for an application to perform an
    operation. It consists of a set of spans, each of which represent a single
    timed event within the operation.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_ID_FIELD_NUMBER: builtins.int
    TRACE_ID_FIELD_NUMBER: builtins.int
    SPANS_FIELD_NUMBER: builtins.int
    project_id: typing.Text = ...
    """Project ID of the Cloud project where the trace data is stored."""

    trace_id: typing.Text = ...
    """Globally unique identifier for the trace. This identifier is a 128-bit
    numeric value formatted as a 32-byte hex string. For example,
    `382d4f4c6b7bb2f4a972559d9085001d`.
    """

    @property
    def spans(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TraceSpan]:
        """Collection of spans in the trace."""
        pass
    def __init__(self,
        *,
        project_id : typing.Text = ...,
        trace_id : typing.Text = ...,
        spans : typing.Optional[typing.Iterable[global___TraceSpan]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["project_id",b"project_id","spans",b"spans","trace_id",b"trace_id"]) -> None: ...
global___Trace = Trace

class Traces(google.protobuf.message.Message):
    """List of new or updated traces."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TRACES_FIELD_NUMBER: builtins.int
    @property
    def traces(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Trace]:
        """List of traces."""
        pass
    def __init__(self,
        *,
        traces : typing.Optional[typing.Iterable[global___Trace]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["traces",b"traces"]) -> None: ...
global___Traces = Traces

class TraceSpan(google.protobuf.message.Message):
    """A span represents a single timed event within a trace. Spans can be nested
    and form a trace tree. Often, a trace contains a root span that describes the
    end-to-end latency of an operation and, optionally, one or more subspans for
    its suboperations. Spans do not need to be contiguous. There may be gaps
    between spans in a trace.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _SpanKind:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _SpanKindEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SpanKind.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        SPAN_KIND_UNSPECIFIED: TraceSpan.SpanKind.ValueType = ...  # 0
        """Unspecified."""

        RPC_SERVER: TraceSpan.SpanKind.ValueType = ...  # 1
        """Indicates that the span covers server-side handling of an RPC or other
        remote network request.
        """

        RPC_CLIENT: TraceSpan.SpanKind.ValueType = ...  # 2
        """Indicates that the span covers the client-side wrapper around an RPC or
        other remote request.
        """

    class SpanKind(_SpanKind, metaclass=_SpanKindEnumTypeWrapper):
        """Type of span. Can be used to specify additional relationships between spans
        in addition to a parent/child relationship.
        """
        pass

    SPAN_KIND_UNSPECIFIED: TraceSpan.SpanKind.ValueType = ...  # 0
    """Unspecified."""

    RPC_SERVER: TraceSpan.SpanKind.ValueType = ...  # 1
    """Indicates that the span covers server-side handling of an RPC or other
    remote network request.
    """

    RPC_CLIENT: TraceSpan.SpanKind.ValueType = ...  # 2
    """Indicates that the span covers the client-side wrapper around an RPC or
    other remote request.
    """


    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    SPAN_ID_FIELD_NUMBER: builtins.int
    KIND_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    PARENT_SPAN_ID_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    span_id: builtins.int = ...
    """Identifier for the span. Must be a 64-bit integer other than 0 and
    unique within a trace. For example, `2205310701640571284`.
    """

    kind: global___TraceSpan.SpanKind.ValueType = ...
    """Distinguishes between spans generated in a particular context. For example,
    two spans with the same name may be distinguished using `RPC_CLIENT`
    and `RPC_SERVER` to identify queueing latency associated with the span.
    """

    name: typing.Text = ...
    """Name of the span. Must be less than 128 bytes. The span name is sanitized
    and displayed in the Stackdriver Trace tool in the
    Google Cloud Platform Console.
    The name may be a method name or some other per-call site name.
    For the same executable and the same call point, a best practice is
    to use a consistent name, which makes it easier to correlate
    cross-trace spans.
    """

    @property
    def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Start time of the span in nanoseconds from the UNIX epoch."""
        pass
    @property
    def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """End time of the span in nanoseconds from the UNIX epoch."""
        pass
    parent_span_id: builtins.int = ...
    """Optional. ID of the parent span, if any."""

    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Collection of labels associated with the span. Label keys must be less than
        128 bytes. Label values must be less than 16 kilobytes (10MB for
        `/stacktrace` values).

        Some predefined label keys exist, or you may create your own. When creating
        your own, we recommend the following formats:

        * `/category/product/key` for agents of well-known products (e.g.
          `/db/mongodb/read_size`).
        * `short_host/path/key` for domain-specific keys (e.g.
          `foo.com/myproduct/bar`)

        Predefined labels include:

        *   `/agent`
        *   `/component`
        *   `/error/message`
        *   `/error/name`
        *   `/http/client_city`
        *   `/http/client_country`
        *   `/http/client_protocol`
        *   `/http/client_region`
        *   `/http/host`
        *   `/http/method`
        *   `/http/path`
        *   `/http/redirected_url`
        *   `/http/request/size`
        *   `/http/response/size`
        *   `/http/route`
        *   `/http/status_code`
        *   `/http/url`
        *   `/http/user_agent`
        *   `/pid`
        *   `/stacktrace`
        *   `/tid`
        """
        pass
    def __init__(self,
        *,
        span_id : builtins.int = ...,
        kind : global___TraceSpan.SpanKind.ValueType = ...,
        name : typing.Text = ...,
        start_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        end_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        parent_span_id : builtins.int = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_time",b"end_time","start_time",b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["end_time",b"end_time","kind",b"kind","labels",b"labels","name",b"name","parent_span_id",b"parent_span_id","span_id",b"span_id","start_time",b"start_time"]) -> None: ...
global___TraceSpan = TraceSpan

class ListTracesRequest(google.protobuf.message.Message):
    """The request message for the `ListTraces` method. All fields are required
    unless specified.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _ViewType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ViewTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ViewType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        VIEW_TYPE_UNSPECIFIED: ListTracesRequest.ViewType.ValueType = ...  # 0
        """Default is `MINIMAL` if unspecified."""

        MINIMAL: ListTracesRequest.ViewType.ValueType = ...  # 1
        """Minimal view of the trace record that contains only the project
        and trace IDs.
        """

        ROOTSPAN: ListTracesRequest.ViewType.ValueType = ...  # 2
        """Root span view of the trace record that returns the root spans along
        with the minimal trace data.
        """

        COMPLETE: ListTracesRequest.ViewType.ValueType = ...  # 3
        """Complete view of the trace record that contains the actual trace data.
        This is equivalent to calling the REST `get` or RPC `GetTrace` method
        using the ID of each listed trace.
        """

    class ViewType(_ViewType, metaclass=_ViewTypeEnumTypeWrapper):
        """Type of data returned for traces in the list."""
        pass

    VIEW_TYPE_UNSPECIFIED: ListTracesRequest.ViewType.ValueType = ...  # 0
    """Default is `MINIMAL` if unspecified."""

    MINIMAL: ListTracesRequest.ViewType.ValueType = ...  # 1
    """Minimal view of the trace record that contains only the project
    and trace IDs.
    """

    ROOTSPAN: ListTracesRequest.ViewType.ValueType = ...  # 2
    """Root span view of the trace record that returns the root spans along
    with the minimal trace data.
    """

    COMPLETE: ListTracesRequest.ViewType.ValueType = ...  # 3
    """Complete view of the trace record that contains the actual trace data.
    This is equivalent to calling the REST `get` or RPC `GetTrace` method
    using the ID of each listed trace.
    """


    PROJECT_ID_FIELD_NUMBER: builtins.int
    VIEW_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    END_TIME_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    ORDER_BY_FIELD_NUMBER: builtins.int
    project_id: typing.Text = ...
    """Required. ID of the Cloud project where the trace data is stored."""

    view: global___ListTracesRequest.ViewType.ValueType = ...
    """Optional. Type of data returned for traces in the list. Default is
    `MINIMAL`.
    """

    page_size: builtins.int = ...
    """Optional. Maximum number of traces to return. If not specified or <= 0, the
    implementation selects a reasonable value.  The implementation may
    return fewer traces than the requested page size.
    """

    page_token: typing.Text = ...
    """Token identifying the page of results to return. If provided, use the
    value of the `next_page_token` field from a previous request.
    """

    @property
    def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Start of the time interval (inclusive) during which the trace data was
        collected from the application.
        """
        pass
    @property
    def end_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """End of the time interval (inclusive) during which the trace data was
        collected from the application.
        """
        pass
    filter: typing.Text = ...
    """Optional. A filter against labels for the request.

    By default, searches use prefix matching. To specify exact match, prepend
    a plus symbol (`+`) to the search term.
    Multiple terms are ANDed. Syntax:

    *   `root:NAME_PREFIX` or `NAME_PREFIX`: Return traces where any root
        span starts with `NAME_PREFIX`.
    *   `+root:NAME` or `+NAME`: Return traces where any root span's name is
        exactly `NAME`.
    *   `span:NAME_PREFIX`: Return traces where any span starts with
        `NAME_PREFIX`.
    *   `+span:NAME`: Return traces where any span's name is exactly
        `NAME`.
    *   `latency:DURATION`: Return traces whose overall latency is
        greater or equal to than `DURATION`. Accepted units are nanoseconds
        (`ns`), milliseconds (`ms`), and seconds (`s`). Default is `ms`. For
        example, `latency:24ms` returns traces whose overall latency
        is greater than or equal to 24 milliseconds.
    *   `label:LABEL_KEY`: Return all traces containing the specified
        label key (exact match, case-sensitive) regardless of the key:value
        pair's value (including empty values).
    *   `LABEL_KEY:VALUE_PREFIX`: Return all traces containing the specified
        label key (exact match, case-sensitive) whose value starts with
        `VALUE_PREFIX`. Both a key and a value must be specified.
    *   `+LABEL_KEY:VALUE`: Return all traces containing a key:value pair
        exactly matching the specified text. Both a key and a value must be
        specified.
    *   `method:VALUE`: Equivalent to `/http/method:VALUE`.
    *   `url:VALUE`: Equivalent to `/http/url:VALUE`.
    """

    order_by: typing.Text = ...
    """Optional. Field used to sort the returned traces.
    Can be one of the following:

    *   `trace_id`
    *   `name` (`name` field of root span in the trace)
    *   `duration` (difference between `end_time` and `start_time` fields of
         the root span)
    *   `start` (`start_time` field of the root span)

    Descending order can be specified by appending `desc` to the sort field
    (for example, `name desc`).

    Only one sort field is permitted.
    """

    def __init__(self,
        *,
        project_id : typing.Text = ...,
        view : global___ListTracesRequest.ViewType.ValueType = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        start_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        end_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        filter : typing.Text = ...,
        order_by : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_time",b"end_time","start_time",b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["end_time",b"end_time","filter",b"filter","order_by",b"order_by","page_size",b"page_size","page_token",b"page_token","project_id",b"project_id","start_time",b"start_time","view",b"view"]) -> None: ...
global___ListTracesRequest = ListTracesRequest

class ListTracesResponse(google.protobuf.message.Message):
    """The response message for the `ListTraces` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TRACES_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def traces(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Trace]:
        """List of trace records as specified by the view parameter."""
        pass
    next_page_token: typing.Text = ...
    """If defined, indicates that there are more traces that match the request
    and that this value should be passed to the next request to continue
    retrieving additional traces.
    """

    def __init__(self,
        *,
        traces : typing.Optional[typing.Iterable[global___Trace]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["next_page_token",b"next_page_token","traces",b"traces"]) -> None: ...
global___ListTracesResponse = ListTracesResponse

class GetTraceRequest(google.protobuf.message.Message):
    """The request message for the `GetTrace` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_ID_FIELD_NUMBER: builtins.int
    TRACE_ID_FIELD_NUMBER: builtins.int
    project_id: typing.Text = ...
    """Required. ID of the Cloud project where the trace data is stored."""

    trace_id: typing.Text = ...
    """Required. ID of the trace to return."""

    def __init__(self,
        *,
        project_id : typing.Text = ...,
        trace_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["project_id",b"project_id","trace_id",b"trace_id"]) -> None: ...
global___GetTraceRequest = GetTraceRequest

class PatchTracesRequest(google.protobuf.message.Message):
    """The request message for the `PatchTraces` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_ID_FIELD_NUMBER: builtins.int
    TRACES_FIELD_NUMBER: builtins.int
    project_id: typing.Text = ...
    """Required. ID of the Cloud project where the trace data is stored."""

    @property
    def traces(self) -> global___Traces:
        """Required. The body of the message."""
        pass
    def __init__(self,
        *,
        project_id : typing.Text = ...,
        traces : typing.Optional[global___Traces] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["traces",b"traces"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["project_id",b"project_id","traces",b"traces"]) -> None: ...
global___PatchTracesRequest = PatchTracesRequest
