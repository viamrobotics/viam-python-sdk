"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.pubsub.v1.schema_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class MessageStoragePolicy(google.protobuf.message.Message):
    """A policy constraining the storage of messages published to the topic."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ALLOWED_PERSISTENCE_REGIONS_FIELD_NUMBER: builtins.int
    @property
    def allowed_persistence_regions(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of IDs of GCP regions where messages that are published to the topic
        may be persisted in storage. Messages published by publishers running in
        non-allowed GCP regions (or running outside of GCP altogether) will be
        routed for storage in one of the allowed regions. An empty list means that
        no regions are allowed, and is not a valid configuration.
        """
        pass
    def __init__(self,
        *,
        allowed_persistence_regions : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["allowed_persistence_regions",b"allowed_persistence_regions"]) -> None: ...
global___MessageStoragePolicy = MessageStoragePolicy

class SchemaSettings(google.protobuf.message.Message):
    """Settings for validating messages published against a schema."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SCHEMA_FIELD_NUMBER: builtins.int
    ENCODING_FIELD_NUMBER: builtins.int
    schema: typing.Text = ...
    """Required. The name of the schema that messages published should be
    validated against. Format is `projects/{project}/schemas/{schema}`. The
    value of this field will be `_deleted-schema_` if the schema has been
    deleted.
    """

    encoding: google.pubsub.v1.schema_pb2.Encoding.ValueType = ...
    """The encoding of messages validated against `schema`."""

    def __init__(self,
        *,
        schema : typing.Text = ...,
        encoding : google.pubsub.v1.schema_pb2.Encoding.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["encoding",b"encoding","schema",b"schema"]) -> None: ...
global___SchemaSettings = SchemaSettings

class Topic(google.protobuf.message.Message):
    """A topic resource."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    MESSAGE_STORAGE_POLICY_FIELD_NUMBER: builtins.int
    KMS_KEY_NAME_FIELD_NUMBER: builtins.int
    SCHEMA_SETTINGS_FIELD_NUMBER: builtins.int
    SATISFIES_PZS_FIELD_NUMBER: builtins.int
    MESSAGE_RETENTION_DURATION_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the topic. It must have the format
    `"projects/{project}/topics/{topic}"`. `{topic}` must start with a letter,
    and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),
    underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent
    signs (`%`). It must be between 3 and 255 characters in length, and it
    must not start with `"goog"`.
    """

    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """See [Creating and managing labels]
        (https://cloud.google.com/pubsub/docs/labels).
        """
        pass
    @property
    def message_storage_policy(self) -> global___MessageStoragePolicy:
        """Policy constraining the set of Google Cloud Platform regions where messages
        published to the topic may be stored. If not present, then no constraints
        are in effect.
        """
        pass
    kms_key_name: typing.Text = ...
    """The resource name of the Cloud KMS CryptoKey to be used to protect access
    to messages published on this topic.

    The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    """

    @property
    def schema_settings(self) -> global___SchemaSettings:
        """Settings for validating messages published against a schema."""
        pass
    satisfies_pzs: builtins.bool = ...
    """Reserved for future use. This field is set only in responses from the
    server; it is ignored if it is set in any requests.
    """

    @property
    def message_retention_duration(self) -> google.protobuf.duration_pb2.Duration:
        """Indicates the minimum duration to retain a message after it is published to
        the topic. If this field is set, messages published to the topic in the
        last `message_retention_duration` are always available to subscribers. For
        instance, it allows any attached subscription to [seek to a
        timestamp](https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time)
        that is up to `message_retention_duration` in the past. If this field is
        not set, message retention is controlled by settings on individual
        subscriptions. Cannot be more than 7 days or less than 10 minutes.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        message_storage_policy : typing.Optional[global___MessageStoragePolicy] = ...,
        kms_key_name : typing.Text = ...,
        schema_settings : typing.Optional[global___SchemaSettings] = ...,
        satisfies_pzs : builtins.bool = ...,
        message_retention_duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["message_retention_duration",b"message_retention_duration","message_storage_policy",b"message_storage_policy","schema_settings",b"schema_settings"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["kms_key_name",b"kms_key_name","labels",b"labels","message_retention_duration",b"message_retention_duration","message_storage_policy",b"message_storage_policy","name",b"name","satisfies_pzs",b"satisfies_pzs","schema_settings",b"schema_settings"]) -> None: ...
global___Topic = Topic

class PubsubMessage(google.protobuf.message.Message):
    """A message that is published by publishers and consumed by subscribers. The
    message must contain either a non-empty data field or at least one attribute.
    Note that client libraries represent this object differently
    depending on the language. See the corresponding [client library
    documentation](https://cloud.google.com/pubsub/docs/reference/libraries) for
    more information. See [quotas and limits]
    (https://cloud.google.com/pubsub/quotas) for more information about message
    limits.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class AttributesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    DATA_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    MESSAGE_ID_FIELD_NUMBER: builtins.int
    PUBLISH_TIME_FIELD_NUMBER: builtins.int
    ORDERING_KEY_FIELD_NUMBER: builtins.int
    data: builtins.bytes = ...
    """The message data field. If this field is empty, the message must contain
    at least one attribute.
    """

    @property
    def attributes(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Attributes for this message. If this field is empty, the message must
        contain non-empty data. This can be used to filter messages on the
        subscription.
        """
        pass
    message_id: typing.Text = ...
    """ID of this message, assigned by the server when the message is published.
    Guaranteed to be unique within the topic. This value may be read by a
    subscriber that receives a `PubsubMessage` via a `Pull` call or a push
    delivery. It must not be populated by the publisher in a `Publish` call.
    """

    @property
    def publish_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The time at which the message was published, populated by the server when
        it receives the `Publish` call. It must not be populated by the
        publisher in a `Publish` call.
        """
        pass
    ordering_key: typing.Text = ...
    """If non-empty, identifies related messages for which publish order should be
    respected. If a `Subscription` has `enable_message_ordering` set to `true`,
    messages published with the same non-empty `ordering_key` value will be
    delivered to subscribers in the order in which they are received by the
    Pub/Sub system. All `PubsubMessage`s published in a given `PublishRequest`
    must specify the same `ordering_key` value.
    """

    def __init__(self,
        *,
        data : builtins.bytes = ...,
        attributes : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        message_id : typing.Text = ...,
        publish_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ordering_key : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["publish_time",b"publish_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["attributes",b"attributes","data",b"data","message_id",b"message_id","ordering_key",b"ordering_key","publish_time",b"publish_time"]) -> None: ...
global___PubsubMessage = PubsubMessage

class GetTopicRequest(google.protobuf.message.Message):
    """Request for the GetTopic method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TOPIC_FIELD_NUMBER: builtins.int
    topic: typing.Text = ...
    """Required. The name of the topic to get.
    Format is `projects/{project}/topics/{topic}`.
    """

    def __init__(self,
        *,
        topic : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["topic",b"topic"]) -> None: ...
global___GetTopicRequest = GetTopicRequest

class UpdateTopicRequest(google.protobuf.message.Message):
    """Request for the UpdateTopic method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TOPIC_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    @property
    def topic(self) -> global___Topic:
        """Required. The updated topic object."""
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Required. Indicates which fields in the provided topic to update. Must be
        specified and non-empty. Note that if `update_mask` contains
        "message_storage_policy" but the `message_storage_policy` is not set in
        the `topic` provided above, then the updated value is determined by the
        policy configured at the project or organization level.
        """
        pass
    def __init__(self,
        *,
        topic : typing.Optional[global___Topic] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["topic",b"topic","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["topic",b"topic","update_mask",b"update_mask"]) -> None: ...
global___UpdateTopicRequest = UpdateTopicRequest

class PublishRequest(google.protobuf.message.Message):
    """Request for the Publish method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TOPIC_FIELD_NUMBER: builtins.int
    MESSAGES_FIELD_NUMBER: builtins.int
    topic: typing.Text = ...
    """Required. The messages in the request will be published on this topic.
    Format is `projects/{project}/topics/{topic}`.
    """

    @property
    def messages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PubsubMessage]:
        """Required. The messages to publish."""
        pass
    def __init__(self,
        *,
        topic : typing.Text = ...,
        messages : typing.Optional[typing.Iterable[global___PubsubMessage]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["messages",b"messages","topic",b"topic"]) -> None: ...
global___PublishRequest = PublishRequest

class PublishResponse(google.protobuf.message.Message):
    """Response for the `Publish` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MESSAGE_IDS_FIELD_NUMBER: builtins.int
    @property
    def message_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The server-assigned ID of each published message, in the same order as
        the messages in the request. IDs are guaranteed to be unique within
        the topic.
        """
        pass
    def __init__(self,
        *,
        message_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["message_ids",b"message_ids"]) -> None: ...
global___PublishResponse = PublishResponse

class ListTopicsRequest(google.protobuf.message.Message):
    """Request for the `ListTopics` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    project: typing.Text = ...
    """Required. The name of the project in which to list topics.
    Format is `projects/{project-id}`.
    """

    page_size: builtins.int = ...
    """Maximum number of topics to return."""

    page_token: typing.Text = ...
    """The value returned by the last `ListTopicsResponse`; indicates that this is
    a continuation of a prior `ListTopics` call, and that the system should
    return the next page of data.
    """

    def __init__(self,
        *,
        project : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["page_size",b"page_size","page_token",b"page_token","project",b"project"]) -> None: ...
global___ListTopicsRequest = ListTopicsRequest

class ListTopicsResponse(google.protobuf.message.Message):
    """Response for the `ListTopics` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TOPICS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def topics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Topic]:
        """The resulting topics."""
        pass
    next_page_token: typing.Text = ...
    """If not empty, indicates that there may be more topics that match the
    request; this value should be passed in a new `ListTopicsRequest`.
    """

    def __init__(self,
        *,
        topics : typing.Optional[typing.Iterable[global___Topic]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["next_page_token",b"next_page_token","topics",b"topics"]) -> None: ...
global___ListTopicsResponse = ListTopicsResponse

class ListTopicSubscriptionsRequest(google.protobuf.message.Message):
    """Request for the `ListTopicSubscriptions` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TOPIC_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    topic: typing.Text = ...
    """Required. The name of the topic that subscriptions are attached to.
    Format is `projects/{project}/topics/{topic}`.
    """

    page_size: builtins.int = ...
    """Maximum number of subscription names to return."""

    page_token: typing.Text = ...
    """The value returned by the last `ListTopicSubscriptionsResponse`; indicates
    that this is a continuation of a prior `ListTopicSubscriptions` call, and
    that the system should return the next page of data.
    """

    def __init__(self,
        *,
        topic : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["page_size",b"page_size","page_token",b"page_token","topic",b"topic"]) -> None: ...
global___ListTopicSubscriptionsRequest = ListTopicSubscriptionsRequest

class ListTopicSubscriptionsResponse(google.protobuf.message.Message):
    """Response for the `ListTopicSubscriptions` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTIONS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def subscriptions(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The names of subscriptions attached to the topic specified in the request."""
        pass
    next_page_token: typing.Text = ...
    """If not empty, indicates that there may be more subscriptions that match
    the request; this value should be passed in a new
    `ListTopicSubscriptionsRequest` to get more subscriptions.
    """

    def __init__(self,
        *,
        subscriptions : typing.Optional[typing.Iterable[typing.Text]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["next_page_token",b"next_page_token","subscriptions",b"subscriptions"]) -> None: ...
global___ListTopicSubscriptionsResponse = ListTopicSubscriptionsResponse

class ListTopicSnapshotsRequest(google.protobuf.message.Message):
    """Request for the `ListTopicSnapshots` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TOPIC_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    topic: typing.Text = ...
    """Required. The name of the topic that snapshots are attached to.
    Format is `projects/{project}/topics/{topic}`.
    """

    page_size: builtins.int = ...
    """Maximum number of snapshot names to return."""

    page_token: typing.Text = ...
    """The value returned by the last `ListTopicSnapshotsResponse`; indicates
    that this is a continuation of a prior `ListTopicSnapshots` call, and
    that the system should return the next page of data.
    """

    def __init__(self,
        *,
        topic : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["page_size",b"page_size","page_token",b"page_token","topic",b"topic"]) -> None: ...
global___ListTopicSnapshotsRequest = ListTopicSnapshotsRequest

class ListTopicSnapshotsResponse(google.protobuf.message.Message):
    """Response for the `ListTopicSnapshots` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SNAPSHOTS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def snapshots(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The names of the snapshots that match the request."""
        pass
    next_page_token: typing.Text = ...
    """If not empty, indicates that there may be more snapshots that match
    the request; this value should be passed in a new
    `ListTopicSnapshotsRequest` to get more snapshots.
    """

    def __init__(self,
        *,
        snapshots : typing.Optional[typing.Iterable[typing.Text]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["next_page_token",b"next_page_token","snapshots",b"snapshots"]) -> None: ...
global___ListTopicSnapshotsResponse = ListTopicSnapshotsResponse

class DeleteTopicRequest(google.protobuf.message.Message):
    """Request for the `DeleteTopic` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TOPIC_FIELD_NUMBER: builtins.int
    topic: typing.Text = ...
    """Required. Name of the topic to delete.
    Format is `projects/{project}/topics/{topic}`.
    """

    def __init__(self,
        *,
        topic : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["topic",b"topic"]) -> None: ...
global___DeleteTopicRequest = DeleteTopicRequest

class DetachSubscriptionRequest(google.protobuf.message.Message):
    """Request for the DetachSubscription method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTION_FIELD_NUMBER: builtins.int
    subscription: typing.Text = ...
    """Required. The subscription to detach.
    Format is `projects/{project}/subscriptions/{subscription}`.
    """

    def __init__(self,
        *,
        subscription : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["subscription",b"subscription"]) -> None: ...
global___DetachSubscriptionRequest = DetachSubscriptionRequest

class DetachSubscriptionResponse(google.protobuf.message.Message):
    """Response for the DetachSubscription method.
    Reserved for future use.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___DetachSubscriptionResponse = DetachSubscriptionResponse

class Subscription(google.protobuf.message.Message):
    """A subscription resource."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    TOPIC_FIELD_NUMBER: builtins.int
    PUSH_CONFIG_FIELD_NUMBER: builtins.int
    ACK_DEADLINE_SECONDS_FIELD_NUMBER: builtins.int
    RETAIN_ACKED_MESSAGES_FIELD_NUMBER: builtins.int
    MESSAGE_RETENTION_DURATION_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    ENABLE_MESSAGE_ORDERING_FIELD_NUMBER: builtins.int
    EXPIRATION_POLICY_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    DEAD_LETTER_POLICY_FIELD_NUMBER: builtins.int
    RETRY_POLICY_FIELD_NUMBER: builtins.int
    DETACHED_FIELD_NUMBER: builtins.int
    TOPIC_MESSAGE_RETENTION_DURATION_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the subscription. It must have the format
    `"projects/{project}/subscriptions/{subscription}"`. `{subscription}` must
    start with a letter, and contain only letters (`[A-Za-z]`), numbers
    (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),
    plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters
    in length, and it must not start with `"goog"`.
    """

    topic: typing.Text = ...
    """Required. The name of the topic from which this subscription is receiving
    messages. Format is `projects/{project}/topics/{topic}`. The value of this
    field will be `_deleted-topic_` if the topic has been deleted.
    """

    @property
    def push_config(self) -> global___PushConfig:
        """If push delivery is used with this subscription, this field is
        used to configure it. An empty `pushConfig` signifies that the subscriber
        will pull and ack messages using API methods.
        """
        pass
    ack_deadline_seconds: builtins.int = ...
    """The approximate amount of time (on a best-effort basis) Pub/Sub waits for
    the subscriber to acknowledge receipt before resending the message. In the
    interval after the message is delivered and before it is acknowledged, it
    is considered to be <i>outstanding</i>. During that time period, the
    message will not be redelivered (on a best-effort basis).

    For pull subscriptions, this value is used as the initial value for the ack
    deadline. To override this value for a given message, call
    `ModifyAckDeadline` with the corresponding `ack_id` if using
    non-streaming pull or send the `ack_id` in a
    `StreamingModifyAckDeadlineRequest` if using streaming pull.
    The minimum custom deadline you can specify is 10 seconds.
    The maximum custom deadline you can specify is 600 seconds (10 minutes).
    If this parameter is 0, a default value of 10 seconds is used.

    For push delivery, this value is also used to set the request timeout for
    the call to the push endpoint.

    If the subscriber never acknowledges the message, the Pub/Sub
    system will eventually redeliver the message.
    """

    retain_acked_messages: builtins.bool = ...
    """Indicates whether to retain acknowledged messages. If true, then
    messages are not expunged from the subscription's backlog, even if they are
    acknowledged, until they fall out of the `message_retention_duration`
    window. This must be true if you would like to [`Seek` to a timestamp]
    (https://cloud.google.com/pubsub/docs/replay-overview#seek_to_a_time) in
    the past to replay previously-acknowledged messages.
    """

    @property
    def message_retention_duration(self) -> google.protobuf.duration_pb2.Duration:
        """How long to retain unacknowledged messages in the subscription's backlog,
        from the moment a message is published.
        If `retain_acked_messages` is true, then this also configures the retention
        of acknowledged messages, and thus configures how far back in time a `Seek`
        can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10
        minutes.
        """
        pass
    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """See <a href="https://cloud.google.com/pubsub/docs/labels"> Creating and
        managing labels</a>.
        """
        pass
    enable_message_ordering: builtins.bool = ...
    """If true, messages published with the same `ordering_key` in `PubsubMessage`
    will be delivered to the subscribers in the order in which they
    are received by the Pub/Sub system. Otherwise, they may be delivered in
    any order.
    """

    @property
    def expiration_policy(self) -> global___ExpirationPolicy:
        """A policy that specifies the conditions for this subscription's expiration.
        A subscription is considered active as long as any connected subscriber is
        successfully consuming messages from the subscription or is issuing
        operations on the subscription. If `expiration_policy` is not set, a
        *default policy* with `ttl` of 31 days will be used. The minimum allowed
        value for `expiration_policy.ttl` is 1 day.
        """
        pass
    filter: typing.Text = ...
    """An expression written in the Pub/Sub [filter
    language](https://cloud.google.com/pubsub/docs/filtering). If non-empty,
    then only `PubsubMessage`s whose `attributes` field matches the filter are
    delivered on this subscription. If empty, then no messages are filtered
    out.
    """

    @property
    def dead_letter_policy(self) -> global___DeadLetterPolicy:
        """A policy that specifies the conditions for dead lettering messages in
        this subscription. If dead_letter_policy is not set, dead lettering
        is disabled.

        The Cloud Pub/Sub service account associated with this subscriptions's
        parent project (i.e.,
        service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
        permission to Acknowledge() messages on this subscription.
        """
        pass
    @property
    def retry_policy(self) -> global___RetryPolicy:
        """A policy that specifies how Pub/Sub retries message delivery for this
        subscription.

        If not set, the default retry policy is applied. This generally implies
        that messages will be retried as soon as possible for healthy subscribers.
        RetryPolicy will be triggered on NACKs or acknowledgement deadline
        exceeded events for a given message.
        """
        pass
    detached: builtins.bool = ...
    """Indicates whether the subscription is detached from its topic. Detached
    subscriptions don't receive messages from their topic and don't retain any
    backlog. `Pull` and `StreamingPull` requests will return
    FAILED_PRECONDITION. If the subscription is a push subscription, pushes to
    the endpoint will not be made.
    """

    @property
    def topic_message_retention_duration(self) -> google.protobuf.duration_pb2.Duration:
        """Output only. Indicates the minimum duration for which a message is retained
        after it is published to the subscription's topic. If this field is set,
        messages published to the subscription's topic in the last
        `topic_message_retention_duration` are always available to subscribers. See
        the `message_retention_duration` field in `Topic`. This field is set only
        in responses from the server; it is ignored if it is set in any requests.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        topic : typing.Text = ...,
        push_config : typing.Optional[global___PushConfig] = ...,
        ack_deadline_seconds : builtins.int = ...,
        retain_acked_messages : builtins.bool = ...,
        message_retention_duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        enable_message_ordering : builtins.bool = ...,
        expiration_policy : typing.Optional[global___ExpirationPolicy] = ...,
        filter : typing.Text = ...,
        dead_letter_policy : typing.Optional[global___DeadLetterPolicy] = ...,
        retry_policy : typing.Optional[global___RetryPolicy] = ...,
        detached : builtins.bool = ...,
        topic_message_retention_duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dead_letter_policy",b"dead_letter_policy","expiration_policy",b"expiration_policy","message_retention_duration",b"message_retention_duration","push_config",b"push_config","retry_policy",b"retry_policy","topic_message_retention_duration",b"topic_message_retention_duration"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["ack_deadline_seconds",b"ack_deadline_seconds","dead_letter_policy",b"dead_letter_policy","detached",b"detached","enable_message_ordering",b"enable_message_ordering","expiration_policy",b"expiration_policy","filter",b"filter","labels",b"labels","message_retention_duration",b"message_retention_duration","name",b"name","push_config",b"push_config","retain_acked_messages",b"retain_acked_messages","retry_policy",b"retry_policy","topic",b"topic","topic_message_retention_duration",b"topic_message_retention_duration"]) -> None: ...
global___Subscription = Subscription

class RetryPolicy(google.protobuf.message.Message):
    """A policy that specifies how Cloud Pub/Sub retries message delivery.

    Retry delay will be exponential based on provided minimum and maximum
    backoffs. https://en.wikipedia.org/wiki/Exponential_backoff.

    RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded
    events for a given message.

    Retry Policy is implemented on a best effort basis. At times, the delay
    between consecutive deliveries may not match the configuration. That is,
    delay can be more or less than configured backoff.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    MINIMUM_BACKOFF_FIELD_NUMBER: builtins.int
    MAXIMUM_BACKOFF_FIELD_NUMBER: builtins.int
    @property
    def minimum_backoff(self) -> google.protobuf.duration_pb2.Duration:
        """The minimum delay between consecutive deliveries of a given message.
        Value should be between 0 and 600 seconds. Defaults to 10 seconds.
        """
        pass
    @property
    def maximum_backoff(self) -> google.protobuf.duration_pb2.Duration:
        """The maximum delay between consecutive deliveries of a given message.
        Value should be between 0 and 600 seconds. Defaults to 600 seconds.
        """
        pass
    def __init__(self,
        *,
        minimum_backoff : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        maximum_backoff : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["maximum_backoff",b"maximum_backoff","minimum_backoff",b"minimum_backoff"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["maximum_backoff",b"maximum_backoff","minimum_backoff",b"minimum_backoff"]) -> None: ...
global___RetryPolicy = RetryPolicy

class DeadLetterPolicy(google.protobuf.message.Message):
    """Dead lettering is done on a best effort basis. The same message might be
    dead lettered multiple times.

    If validation on any of the fields fails at subscription creation/updation,
    the create/update subscription request will fail.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DEAD_LETTER_TOPIC_FIELD_NUMBER: builtins.int
    MAX_DELIVERY_ATTEMPTS_FIELD_NUMBER: builtins.int
    dead_letter_topic: typing.Text = ...
    """The name of the topic to which dead letter messages should be published.
    Format is `projects/{project}/topics/{topic}`.The Cloud Pub/Sub service
    account associated with the enclosing subscription's parent project (i.e.,
    service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
    permission to Publish() to this topic.

    The operation will fail if the topic does not exist.
    Users should ensure that there is a subscription attached to this topic
    since messages published to a topic with no subscriptions are lost.
    """

    max_delivery_attempts: builtins.int = ...
    """The maximum number of delivery attempts for any message. The value must be
    between 5 and 100.

    The number of delivery attempts is defined as 1 + (the sum of number of
    NACKs and number of times the acknowledgement deadline has been exceeded
    for the message).

    A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
    client libraries may automatically extend ack_deadlines.

    This field will be honored on a best effort basis.

    If this parameter is 0, a default value of 5 is used.
    """

    def __init__(self,
        *,
        dead_letter_topic : typing.Text = ...,
        max_delivery_attempts : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["dead_letter_topic",b"dead_letter_topic","max_delivery_attempts",b"max_delivery_attempts"]) -> None: ...
global___DeadLetterPolicy = DeadLetterPolicy

class ExpirationPolicy(google.protobuf.message.Message):
    """A policy that specifies the conditions for resource expiration (i.e.,
    automatic resource deletion).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TTL_FIELD_NUMBER: builtins.int
    @property
    def ttl(self) -> google.protobuf.duration_pb2.Duration:
        """Specifies the "time-to-live" duration for an associated resource. The
        resource expires if it is not active for a period of `ttl`. The definition
        of "activity" depends on the type of the associated resource. The minimum
        and maximum allowed values for `ttl` depend on the type of the associated
        resource, as well. If `ttl` is not set, the associated resource never
        expires.
        """
        pass
    def __init__(self,
        *,
        ttl : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["ttl",b"ttl"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["ttl",b"ttl"]) -> None: ...
global___ExpirationPolicy = ExpirationPolicy

class PushConfig(google.protobuf.message.Message):
    """Configuration for a push delivery endpoint."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class OidcToken(google.protobuf.message.Message):
        """Contains information needed for generating an
        [OpenID Connect
        token](https://developers.google.com/identity/protocols/OpenIDConnect).
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        SERVICE_ACCOUNT_EMAIL_FIELD_NUMBER: builtins.int
        AUDIENCE_FIELD_NUMBER: builtins.int
        service_account_email: typing.Text = ...
        """[Service account
        email](https://cloud.google.com/iam/docs/service-accounts)
        to be used for generating the OIDC token. The caller (for
        CreateSubscription, UpdateSubscription, and ModifyPushConfig RPCs) must
        have the iam.serviceAccounts.actAs permission for the service account.
        """

        audience: typing.Text = ...
        """Audience to be used when generating OIDC token. The audience claim
        identifies the recipients that the JWT is intended for. The audience
        value is a single case-sensitive string. Having multiple values (array)
        for the audience field is not supported. More info about the OIDC JWT
        token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
        Note: if not specified, the Push endpoint URL will be used.
        """

        def __init__(self,
            *,
            service_account_email : typing.Text = ...,
            audience : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["audience",b"audience","service_account_email",b"service_account_email"]) -> None: ...

    class AttributesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    PUSH_ENDPOINT_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    OIDC_TOKEN_FIELD_NUMBER: builtins.int
    push_endpoint: typing.Text = ...
    """A URL locating the endpoint to which messages should be pushed.
    For example, a Webhook endpoint might use `https://example.com/push`.
    """

    @property
    def attributes(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Endpoint configuration attributes that can be used to control different
        aspects of the message delivery.

        The only currently supported attribute is `x-goog-version`, which you can
        use to change the format of the pushed message. This attribute
        indicates the version of the data expected by the endpoint. This
        controls the shape of the pushed message (i.e., its fields and metadata).

        If not present during the `CreateSubscription` call, it will default to
        the version of the Pub/Sub API used to make such call. If not present in a
        `ModifyPushConfig` call, its value will not be changed. `GetSubscription`
        calls will always return a valid version, even if the subscription was
        created without this attribute.

        The only supported values for the `x-goog-version` attribute are:

        * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.
        * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.

        For example:
        <pre><code>attributes { "x-goog-version": "v1" } </code></pre>
        """
        pass
    @property
    def oidc_token(self) -> global___PushConfig.OidcToken:
        """If specified, Pub/Sub will generate and attach an OIDC JWT token as an
        `Authorization` header in the HTTP request for every pushed message.
        """
        pass
    def __init__(self,
        *,
        push_endpoint : typing.Text = ...,
        attributes : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        oidc_token : typing.Optional[global___PushConfig.OidcToken] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["authentication_method",b"authentication_method","oidc_token",b"oidc_token"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["attributes",b"attributes","authentication_method",b"authentication_method","oidc_token",b"oidc_token","push_endpoint",b"push_endpoint"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["authentication_method",b"authentication_method"]) -> typing.Optional[typing_extensions.Literal["oidc_token"]]: ...
global___PushConfig = PushConfig

class ReceivedMessage(google.protobuf.message.Message):
    """A message and its corresponding acknowledgment ID."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ACK_ID_FIELD_NUMBER: builtins.int
    MESSAGE_FIELD_NUMBER: builtins.int
    DELIVERY_ATTEMPT_FIELD_NUMBER: builtins.int
    ack_id: typing.Text = ...
    """This ID can be used to acknowledge the received message."""

    @property
    def message(self) -> global___PubsubMessage:
        """The message."""
        pass
    delivery_attempt: builtins.int = ...
    """The approximate number of times that Cloud Pub/Sub has attempted to deliver
    the associated message to a subscriber.

    More precisely, this is 1 + (number of NACKs) +
    (number of ack_deadline exceeds) for this message.

    A NACK is any call to ModifyAckDeadline with a 0 deadline. An ack_deadline
    exceeds event is whenever a message is not acknowledged within
    ack_deadline. Note that ack_deadline is initially
    Subscription.ackDeadlineSeconds, but may get extended automatically by
    the client library.

    Upon the first delivery of a given message, `delivery_attempt` will have a
    value of 1. The value is calculated at best effort and is approximate.

    If a DeadLetterPolicy is not set on the subscription, this will be 0.
    """

    def __init__(self,
        *,
        ack_id : typing.Text = ...,
        message : typing.Optional[global___PubsubMessage] = ...,
        delivery_attempt : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["message",b"message"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["ack_id",b"ack_id","delivery_attempt",b"delivery_attempt","message",b"message"]) -> None: ...
global___ReceivedMessage = ReceivedMessage

class GetSubscriptionRequest(google.protobuf.message.Message):
    """Request for the GetSubscription method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTION_FIELD_NUMBER: builtins.int
    subscription: typing.Text = ...
    """Required. The name of the subscription to get.
    Format is `projects/{project}/subscriptions/{sub}`.
    """

    def __init__(self,
        *,
        subscription : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["subscription",b"subscription"]) -> None: ...
global___GetSubscriptionRequest = GetSubscriptionRequest

class UpdateSubscriptionRequest(google.protobuf.message.Message):
    """Request for the UpdateSubscription method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTION_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    @property
    def subscription(self) -> global___Subscription:
        """Required. The updated subscription object."""
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Required. Indicates which fields in the provided subscription to update.
        Must be specified and non-empty.
        """
        pass
    def __init__(self,
        *,
        subscription : typing.Optional[global___Subscription] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["subscription",b"subscription","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["subscription",b"subscription","update_mask",b"update_mask"]) -> None: ...
global___UpdateSubscriptionRequest = UpdateSubscriptionRequest

class ListSubscriptionsRequest(google.protobuf.message.Message):
    """Request for the `ListSubscriptions` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    project: typing.Text = ...
    """Required. The name of the project in which to list subscriptions.
    Format is `projects/{project-id}`.
    """

    page_size: builtins.int = ...
    """Maximum number of subscriptions to return."""

    page_token: typing.Text = ...
    """The value returned by the last `ListSubscriptionsResponse`; indicates that
    this is a continuation of a prior `ListSubscriptions` call, and that the
    system should return the next page of data.
    """

    def __init__(self,
        *,
        project : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["page_size",b"page_size","page_token",b"page_token","project",b"project"]) -> None: ...
global___ListSubscriptionsRequest = ListSubscriptionsRequest

class ListSubscriptionsResponse(google.protobuf.message.Message):
    """Response for the `ListSubscriptions` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTIONS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def subscriptions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Subscription]:
        """The subscriptions that match the request."""
        pass
    next_page_token: typing.Text = ...
    """If not empty, indicates that there may be more subscriptions that match
    the request; this value should be passed in a new
    `ListSubscriptionsRequest` to get more subscriptions.
    """

    def __init__(self,
        *,
        subscriptions : typing.Optional[typing.Iterable[global___Subscription]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["next_page_token",b"next_page_token","subscriptions",b"subscriptions"]) -> None: ...
global___ListSubscriptionsResponse = ListSubscriptionsResponse

class DeleteSubscriptionRequest(google.protobuf.message.Message):
    """Request for the DeleteSubscription method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTION_FIELD_NUMBER: builtins.int
    subscription: typing.Text = ...
    """Required. The subscription to delete.
    Format is `projects/{project}/subscriptions/{sub}`.
    """

    def __init__(self,
        *,
        subscription : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["subscription",b"subscription"]) -> None: ...
global___DeleteSubscriptionRequest = DeleteSubscriptionRequest

class ModifyPushConfigRequest(google.protobuf.message.Message):
    """Request for the ModifyPushConfig method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTION_FIELD_NUMBER: builtins.int
    PUSH_CONFIG_FIELD_NUMBER: builtins.int
    subscription: typing.Text = ...
    """Required. The name of the subscription.
    Format is `projects/{project}/subscriptions/{sub}`.
    """

    @property
    def push_config(self) -> global___PushConfig:
        """Required. The push configuration for future deliveries.

        An empty `pushConfig` indicates that the Pub/Sub system should
        stop pushing messages from the given subscription and allow
        messages to be pulled and acknowledged - effectively pausing
        the subscription if `Pull` or `StreamingPull` is not called.
        """
        pass
    def __init__(self,
        *,
        subscription : typing.Text = ...,
        push_config : typing.Optional[global___PushConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["push_config",b"push_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["push_config",b"push_config","subscription",b"subscription"]) -> None: ...
global___ModifyPushConfigRequest = ModifyPushConfigRequest

class PullRequest(google.protobuf.message.Message):
    """Request for the `Pull` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTION_FIELD_NUMBER: builtins.int
    RETURN_IMMEDIATELY_FIELD_NUMBER: builtins.int
    MAX_MESSAGES_FIELD_NUMBER: builtins.int
    subscription: typing.Text = ...
    """Required. The subscription from which messages should be pulled.
    Format is `projects/{project}/subscriptions/{sub}`.
    """

    return_immediately: builtins.bool = ...
    """Optional. If this field set to true, the system will respond immediately
    even if it there are no messages available to return in the `Pull`
    response. Otherwise, the system may wait (for a bounded amount of time)
    until at least one message is available, rather than returning no messages.
    Warning: setting this field to `true` is discouraged because it adversely
    impacts the performance of `Pull` operations. We recommend that users do
    not set this field.
    """

    max_messages: builtins.int = ...
    """Required. The maximum number of messages to return for this request. Must
    be a positive integer. The Pub/Sub system may return fewer than the number
    specified.
    """

    def __init__(self,
        *,
        subscription : typing.Text = ...,
        return_immediately : builtins.bool = ...,
        max_messages : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["max_messages",b"max_messages","return_immediately",b"return_immediately","subscription",b"subscription"]) -> None: ...
global___PullRequest = PullRequest

class PullResponse(google.protobuf.message.Message):
    """Response for the `Pull` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RECEIVED_MESSAGES_FIELD_NUMBER: builtins.int
    @property
    def received_messages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ReceivedMessage]:
        """Received Pub/Sub messages. The list will be empty if there are no more
        messages available in the backlog. For JSON, the response can be entirely
        empty. The Pub/Sub system may return fewer than the `maxMessages` requested
        even if there are more messages available in the backlog.
        """
        pass
    def __init__(self,
        *,
        received_messages : typing.Optional[typing.Iterable[global___ReceivedMessage]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["received_messages",b"received_messages"]) -> None: ...
global___PullResponse = PullResponse

class ModifyAckDeadlineRequest(google.protobuf.message.Message):
    """Request for the ModifyAckDeadline method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTION_FIELD_NUMBER: builtins.int
    ACK_IDS_FIELD_NUMBER: builtins.int
    ACK_DEADLINE_SECONDS_FIELD_NUMBER: builtins.int
    subscription: typing.Text = ...
    """Required. The name of the subscription.
    Format is `projects/{project}/subscriptions/{sub}`.
    """

    @property
    def ack_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Required. List of acknowledgment IDs."""
        pass
    ack_deadline_seconds: builtins.int = ...
    """Required. The new ack deadline with respect to the time this request was
    sent to the Pub/Sub system. For example, if the value is 10, the new ack
    deadline will expire 10 seconds after the `ModifyAckDeadline` call was
    made. Specifying zero might immediately make the message available for
    delivery to another subscriber client. This typically results in an
    increase in the rate of message redeliveries (that is, duplicates).
    The minimum deadline you can specify is 0 seconds.
    The maximum deadline you can specify is 600 seconds (10 minutes).
    """

    def __init__(self,
        *,
        subscription : typing.Text = ...,
        ack_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ack_deadline_seconds : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["ack_deadline_seconds",b"ack_deadline_seconds","ack_ids",b"ack_ids","subscription",b"subscription"]) -> None: ...
global___ModifyAckDeadlineRequest = ModifyAckDeadlineRequest

class AcknowledgeRequest(google.protobuf.message.Message):
    """Request for the Acknowledge method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTION_FIELD_NUMBER: builtins.int
    ACK_IDS_FIELD_NUMBER: builtins.int
    subscription: typing.Text = ...
    """Required. The subscription whose message is being acknowledged.
    Format is `projects/{project}/subscriptions/{sub}`.
    """

    @property
    def ack_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Required. The acknowledgment ID for the messages being acknowledged that
        was returned by the Pub/Sub system in the `Pull` response. Must not be
        empty.
        """
        pass
    def __init__(self,
        *,
        subscription : typing.Text = ...,
        ack_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["ack_ids",b"ack_ids","subscription",b"subscription"]) -> None: ...
global___AcknowledgeRequest = AcknowledgeRequest

class StreamingPullRequest(google.protobuf.message.Message):
    """Request for the `StreamingPull` streaming RPC method. This request is used to
    establish the initial stream as well as to stream acknowledgements and ack
    deadline modifications from the client to the server.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTION_FIELD_NUMBER: builtins.int
    ACK_IDS_FIELD_NUMBER: builtins.int
    MODIFY_DEADLINE_SECONDS_FIELD_NUMBER: builtins.int
    MODIFY_DEADLINE_ACK_IDS_FIELD_NUMBER: builtins.int
    STREAM_ACK_DEADLINE_SECONDS_FIELD_NUMBER: builtins.int
    CLIENT_ID_FIELD_NUMBER: builtins.int
    MAX_OUTSTANDING_MESSAGES_FIELD_NUMBER: builtins.int
    MAX_OUTSTANDING_BYTES_FIELD_NUMBER: builtins.int
    subscription: typing.Text = ...
    """Required. The subscription for which to initialize the new stream. This
    must be provided in the first request on the stream, and must not be set in
    subsequent requests from client to server.
    Format is `projects/{project}/subscriptions/{sub}`.
    """

    @property
    def ack_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """List of acknowledgement IDs for acknowledging previously received messages
        (received on this stream or a different stream). If an ack ID has expired,
        the corresponding message may be redelivered later. Acknowledging a message
        more than once will not result in an error. If the acknowledgement ID is
        malformed, the stream will be aborted with status `INVALID_ARGUMENT`.
        """
        pass
    @property
    def modify_deadline_seconds(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The list of new ack deadlines for the IDs listed in
        `modify_deadline_ack_ids`. The size of this list must be the same as the
        size of `modify_deadline_ack_ids`. If it differs the stream will be aborted
        with `INVALID_ARGUMENT`. Each element in this list is applied to the
        element in the same position in `modify_deadline_ack_ids`. The new ack
        deadline is with respect to the time this request was sent to the Pub/Sub
        system. Must be >= 0. For example, if the value is 10, the new ack deadline
        will expire 10 seconds after this request is received. If the value is 0,
        the message is immediately made available for another streaming or
        non-streaming pull request. If the value is < 0 (an error), the stream will
        be aborted with status `INVALID_ARGUMENT`.
        """
        pass
    @property
    def modify_deadline_ack_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """List of acknowledgement IDs whose deadline will be modified based on the
        corresponding element in `modify_deadline_seconds`. This field can be used
        to indicate that more time is needed to process a message by the
        subscriber, or to make the message available for redelivery if the
        processing was interrupted.
        """
        pass
    stream_ack_deadline_seconds: builtins.int = ...
    """Required. The ack deadline to use for the stream. This must be provided in
    the first request on the stream, but it can also be updated on subsequent
    requests from client to server. The minimum deadline you can specify is 10
    seconds. The maximum deadline you can specify is 600 seconds (10 minutes).
    """

    client_id: typing.Text = ...
    """A unique identifier that is used to distinguish client instances from each
    other. Only needs to be provided on the initial request. When a stream
    disconnects and reconnects for the same stream, the client_id should be set
    to the same value so that state associated with the old stream can be
    transferred to the new stream. The same client_id should not be used for
    different client instances.
    """

    max_outstanding_messages: builtins.int = ...
    """Flow control settings for the maximum number of outstanding messages. When
    there are `max_outstanding_messages` or more currently sent to the
    streaming pull client that have not yet been acked or nacked, the server
    stops sending more messages. The sending of messages resumes once the
    number of outstanding messages is less than this value. If the value is
    <= 0, there is no limit to the number of outstanding messages. This
    property can only be set on the initial StreamingPullRequest. If it is set
    on a subsequent request, the stream will be aborted with status
    `INVALID_ARGUMENT`.
    """

    max_outstanding_bytes: builtins.int = ...
    """Flow control settings for the maximum number of outstanding bytes. When
    there are `max_outstanding_bytes` or more worth of messages currently sent
    to the streaming pull client that have not yet been acked or nacked, the
    server will stop sending more messages. The sending of messages resumes
    once the number of outstanding bytes is less than this value. If the value
    is <= 0, there is no limit to the number of outstanding bytes. This
    property can only be set on the initial StreamingPullRequest. If it is set
    on a subsequent request, the stream will be aborted with status
    `INVALID_ARGUMENT`.
    """

    def __init__(self,
        *,
        subscription : typing.Text = ...,
        ack_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
        modify_deadline_seconds : typing.Optional[typing.Iterable[builtins.int]] = ...,
        modify_deadline_ack_ids : typing.Optional[typing.Iterable[typing.Text]] = ...,
        stream_ack_deadline_seconds : builtins.int = ...,
        client_id : typing.Text = ...,
        max_outstanding_messages : builtins.int = ...,
        max_outstanding_bytes : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["ack_ids",b"ack_ids","client_id",b"client_id","max_outstanding_bytes",b"max_outstanding_bytes","max_outstanding_messages",b"max_outstanding_messages","modify_deadline_ack_ids",b"modify_deadline_ack_ids","modify_deadline_seconds",b"modify_deadline_seconds","stream_ack_deadline_seconds",b"stream_ack_deadline_seconds","subscription",b"subscription"]) -> None: ...
global___StreamingPullRequest = StreamingPullRequest

class StreamingPullResponse(google.protobuf.message.Message):
    """Response for the `StreamingPull` method. This response is used to stream
    messages from the server to the client.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SubscriptionProperties(google.protobuf.message.Message):
        """Subscription properties sent as part of the response."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        MESSAGE_ORDERING_ENABLED_FIELD_NUMBER: builtins.int
        message_ordering_enabled: builtins.bool = ...
        """True iff message ordering is enabled for this subscription."""

        def __init__(self,
            *,
            message_ordering_enabled : builtins.bool = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["message_ordering_enabled",b"message_ordering_enabled"]) -> None: ...

    RECEIVED_MESSAGES_FIELD_NUMBER: builtins.int
    SUBSCRIPTION_PROPERTIES_FIELD_NUMBER: builtins.int
    @property
    def received_messages(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ReceivedMessage]:
        """Received Pub/Sub messages. This will not be empty."""
        pass
    @property
    def subscription_properties(self) -> global___StreamingPullResponse.SubscriptionProperties:
        """Properties associated with this subscription."""
        pass
    def __init__(self,
        *,
        received_messages : typing.Optional[typing.Iterable[global___ReceivedMessage]] = ...,
        subscription_properties : typing.Optional[global___StreamingPullResponse.SubscriptionProperties] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["subscription_properties",b"subscription_properties"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["received_messages",b"received_messages","subscription_properties",b"subscription_properties"]) -> None: ...
global___StreamingPullResponse = StreamingPullResponse

class CreateSnapshotRequest(google.protobuf.message.Message):
    """Request for the `CreateSnapshot` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    SUBSCRIPTION_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. User-provided name for this snapshot. If the name is not provided
    in the request, the server will assign a random name for this snapshot on
    the same project as the subscription. Note that for REST API requests, you
    must specify a name.  See the <a
    href="https://cloud.google.com/pubsub/docs/admin#resource_names"> resource
    name rules</a>. Format is `projects/{project}/snapshots/{snap}`.
    """

    subscription: typing.Text = ...
    """Required. The subscription whose backlog the snapshot retains.
    Specifically, the created snapshot is guaranteed to retain:
     (a) The existing backlog on the subscription. More precisely, this is
         defined as the messages in the subscription's backlog that are
         unacknowledged upon the successful completion of the
         `CreateSnapshot` request; as well as:
     (b) Any messages published to the subscription's topic following the
         successful completion of the CreateSnapshot request.
    Format is `projects/{project}/subscriptions/{sub}`.
    """

    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """See <a href="https://cloud.google.com/pubsub/docs/labels"> Creating and
        managing labels</a>.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        subscription : typing.Text = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["labels",b"labels","name",b"name","subscription",b"subscription"]) -> None: ...
global___CreateSnapshotRequest = CreateSnapshotRequest

class UpdateSnapshotRequest(google.protobuf.message.Message):
    """Request for the UpdateSnapshot method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SNAPSHOT_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    @property
    def snapshot(self) -> global___Snapshot:
        """Required. The updated snapshot object."""
        pass
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Required. Indicates which fields in the provided snapshot to update.
        Must be specified and non-empty.
        """
        pass
    def __init__(self,
        *,
        snapshot : typing.Optional[global___Snapshot] = ...,
        update_mask : typing.Optional[google.protobuf.field_mask_pb2.FieldMask] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot","update_mask",b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot","update_mask",b"update_mask"]) -> None: ...
global___UpdateSnapshotRequest = UpdateSnapshotRequest

class Snapshot(google.protobuf.message.Message):
    """A snapshot resource. Snapshots are used in
    [Seek](https://cloud.google.com/pubsub/docs/replay-overview)
    operations, which allow you to manage message acknowledgments in bulk. That
    is, you can set the acknowledgment state of messages in an existing
    subscription to the state captured by a snapshot.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    TOPIC_FIELD_NUMBER: builtins.int
    EXPIRE_TIME_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The name of the snapshot."""

    topic: typing.Text = ...
    """The name of the topic from which this snapshot is retaining messages."""

    @property
    def expire_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The snapshot is guaranteed to exist up until this time.
        A newly-created snapshot expires no later than 7 days from the time of its
        creation. Its exact lifetime is determined at creation by the existing
        backlog in the source subscription. Specifically, the lifetime of the
        snapshot is `7 days - (age of oldest unacked message in the subscription)`.
        For example, consider a subscription whose oldest unacked message is 3 days
        old. If a snapshot is created from this subscription, the snapshot -- which
        will always capture this 3-day-old backlog as long as the snapshot
        exists -- will expire in 4 days. The service will refuse to create a
        snapshot that would expire in less than 1 hour after creation.
        """
        pass
    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """See [Creating and managing labels]
        (https://cloud.google.com/pubsub/docs/labels).
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        topic : typing.Text = ...,
        expire_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["expire_time",b"expire_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["expire_time",b"expire_time","labels",b"labels","name",b"name","topic",b"topic"]) -> None: ...
global___Snapshot = Snapshot

class GetSnapshotRequest(google.protobuf.message.Message):
    """Request for the GetSnapshot method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SNAPSHOT_FIELD_NUMBER: builtins.int
    snapshot: typing.Text = ...
    """Required. The name of the snapshot to get.
    Format is `projects/{project}/snapshots/{snap}`.
    """

    def __init__(self,
        *,
        snapshot : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot"]) -> None: ...
global___GetSnapshotRequest = GetSnapshotRequest

class ListSnapshotsRequest(google.protobuf.message.Message):
    """Request for the `ListSnapshots` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    project: typing.Text = ...
    """Required. The name of the project in which to list snapshots.
    Format is `projects/{project-id}`.
    """

    page_size: builtins.int = ...
    """Maximum number of snapshots to return."""

    page_token: typing.Text = ...
    """The value returned by the last `ListSnapshotsResponse`; indicates that this
    is a continuation of a prior `ListSnapshots` call, and that the system
    should return the next page of data.
    """

    def __init__(self,
        *,
        project : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["page_size",b"page_size","page_token",b"page_token","project",b"project"]) -> None: ...
global___ListSnapshotsRequest = ListSnapshotsRequest

class ListSnapshotsResponse(google.protobuf.message.Message):
    """Response for the `ListSnapshots` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SNAPSHOTS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def snapshots(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Snapshot]:
        """The resulting snapshots."""
        pass
    next_page_token: typing.Text = ...
    """If not empty, indicates that there may be more snapshot that match the
    request; this value should be passed in a new `ListSnapshotsRequest`.
    """

    def __init__(self,
        *,
        snapshots : typing.Optional[typing.Iterable[global___Snapshot]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["next_page_token",b"next_page_token","snapshots",b"snapshots"]) -> None: ...
global___ListSnapshotsResponse = ListSnapshotsResponse

class DeleteSnapshotRequest(google.protobuf.message.Message):
    """Request for the `DeleteSnapshot` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SNAPSHOT_FIELD_NUMBER: builtins.int
    snapshot: typing.Text = ...
    """Required. The name of the snapshot to delete.
    Format is `projects/{project}/snapshots/{snap}`.
    """

    def __init__(self,
        *,
        snapshot : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot"]) -> None: ...
global___DeleteSnapshotRequest = DeleteSnapshotRequest

class SeekRequest(google.protobuf.message.Message):
    """Request for the `Seek` method."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUBSCRIPTION_FIELD_NUMBER: builtins.int
    TIME_FIELD_NUMBER: builtins.int
    SNAPSHOT_FIELD_NUMBER: builtins.int
    subscription: typing.Text = ...
    """Required. The subscription to affect."""

    @property
    def time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The time to seek to.
        Messages retained in the subscription that were published before this
        time are marked as acknowledged, and messages retained in the
        subscription that were published after this time are marked as
        unacknowledged. Note that this operation affects only those messages
        retained in the subscription (configured by the combination of
        `message_retention_duration` and `retain_acked_messages`). For example,
        if `time` corresponds to a point before the message retention
        window (or to a point before the system's notion of the subscription
        creation time), only retained messages will be marked as unacknowledged,
        and already-expunged messages will not be restored.
        """
        pass
    snapshot: typing.Text = ...
    """The snapshot to seek to. The snapshot's topic must be the same as that of
    the provided subscription.
    Format is `projects/{project}/snapshots/{snap}`.
    """

    def __init__(self,
        *,
        subscription : typing.Text = ...,
        time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        snapshot : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot","target",b"target","time",b"time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["snapshot",b"snapshot","subscription",b"subscription","target",b"target","time",b"time"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["target",b"target"]) -> typing.Optional[typing_extensions.Literal["time","snapshot"]]: ...
global___SeekRequest = SeekRequest

class SeekResponse(google.protobuf.message.Message):
    """Response for the `Seek` method (this response is empty)."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___SeekResponse = SeekResponse
