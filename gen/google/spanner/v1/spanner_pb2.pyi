"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import google.protobuf.timestamp_pb2
import google.rpc.status_pb2
import google.spanner.v1.keys_pb2
import google.spanner.v1.mutation_pb2
import google.spanner.v1.result_set_pb2
import google.spanner.v1.transaction_pb2
import google.spanner.v1.type_pb2
import typing
import typing_extensions
from google.spanner.v1.commit_response_pb2 import (
    CommitResponse as CommitResponse,
)


DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class CreateSessionRequest(google.protobuf.message.Message):
    """The request for [CreateSession][google.spanner.v1.Spanner.CreateSession]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATABASE_FIELD_NUMBER: builtins.int
    SESSION_FIELD_NUMBER: builtins.int
    database: typing.Text = ...
    """Required. The database in which the new session is created."""

    @property
    def session(self) -> global___Session:
        """The session to create."""
        pass
    def __init__(self,
        *,
        database : typing.Text = ...,
        session : typing.Optional[global___Session] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["session",b"session"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["database",b"database","session",b"session"]) -> None: ...
global___CreateSessionRequest = CreateSessionRequest

class BatchCreateSessionsRequest(google.protobuf.message.Message):
    """The request for [BatchCreateSessions][google.spanner.v1.Spanner.BatchCreateSessions]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATABASE_FIELD_NUMBER: builtins.int
    SESSION_TEMPLATE_FIELD_NUMBER: builtins.int
    SESSION_COUNT_FIELD_NUMBER: builtins.int
    database: typing.Text = ...
    """Required. The database in which the new sessions are created."""

    @property
    def session_template(self) -> global___Session:
        """Parameters to be applied to each created session."""
        pass
    session_count: builtins.int = ...
    """Required. The number of sessions to be created in this batch call.
    The API may return fewer than the requested number of sessions. If a
    specific number of sessions are desired, the client can make additional
    calls to BatchCreateSessions (adjusting
    [session_count][google.spanner.v1.BatchCreateSessionsRequest.session_count] as necessary).
    """

    def __init__(self,
        *,
        database : typing.Text = ...,
        session_template : typing.Optional[global___Session] = ...,
        session_count : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["session_template",b"session_template"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["database",b"database","session_count",b"session_count","session_template",b"session_template"]) -> None: ...
global___BatchCreateSessionsRequest = BatchCreateSessionsRequest

class BatchCreateSessionsResponse(google.protobuf.message.Message):
    """The response for [BatchCreateSessions][google.spanner.v1.Spanner.BatchCreateSessions]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SESSION_FIELD_NUMBER: builtins.int
    @property
    def session(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Session]:
        """The freshly created sessions."""
        pass
    def __init__(self,
        *,
        session : typing.Optional[typing.Iterable[global___Session]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["session",b"session"]) -> None: ...
global___BatchCreateSessionsResponse = BatchCreateSessionsResponse

class Session(google.protobuf.message.Message):
    """A session in the Cloud Spanner API."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    APPROXIMATE_LAST_USE_TIME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Output only. The name of the session. This is always system-assigned."""

    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """The labels for the session.

         * Label keys must be between 1 and 63 characters long and must conform to
           the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
         * Label values must be between 0 and 63 characters long and must conform
           to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
         * No more than 64 labels can be associated with a given session.

        See https://goo.gl/xmQnxf for more information on and examples of labels.
        """
        pass
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The timestamp when the session is created."""
        pass
    @property
    def approximate_last_use_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Output only. The approximate timestamp when the session is last used. It is
        typically earlier than the actual last use time.
        """
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        create_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        approximate_last_use_time : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["approximate_last_use_time",b"approximate_last_use_time","create_time",b"create_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["approximate_last_use_time",b"approximate_last_use_time","create_time",b"create_time","labels",b"labels","name",b"name"]) -> None: ...
global___Session = Session

class GetSessionRequest(google.protobuf.message.Message):
    """The request for [GetSession][google.spanner.v1.Spanner.GetSession]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the session to retrieve."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___GetSessionRequest = GetSessionRequest

class ListSessionsRequest(google.protobuf.message.Message):
    """The request for [ListSessions][google.spanner.v1.Spanner.ListSessions]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATABASE_FIELD_NUMBER: builtins.int
    PAGE_SIZE_FIELD_NUMBER: builtins.int
    PAGE_TOKEN_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    database: typing.Text = ...
    """Required. The database in which to list sessions."""

    page_size: builtins.int = ...
    """Number of sessions to be returned in the response. If 0 or less, defaults
    to the server's maximum allowed page size.
    """

    page_token: typing.Text = ...
    """If non-empty, `page_token` should contain a
    [next_page_token][google.spanner.v1.ListSessionsResponse.next_page_token] from a previous
    [ListSessionsResponse][google.spanner.v1.ListSessionsResponse].
    """

    filter: typing.Text = ...
    """An expression for filtering the results of the request. Filter rules are
    case insensitive. The fields eligible for filtering are:

      * `labels.key` where key is the name of a label

    Some examples of using filters are:

      * `labels.env:*` --> The session has the label "env".
      * `labels.env:dev` --> The session has the label "env" and the value of
                           the label contains the string "dev".
    """

    def __init__(self,
        *,
        database : typing.Text = ...,
        page_size : builtins.int = ...,
        page_token : typing.Text = ...,
        filter : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["database",b"database","filter",b"filter","page_size",b"page_size","page_token",b"page_token"]) -> None: ...
global___ListSessionsRequest = ListSessionsRequest

class ListSessionsResponse(google.protobuf.message.Message):
    """The response for [ListSessions][google.spanner.v1.Spanner.ListSessions]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SESSIONS_FIELD_NUMBER: builtins.int
    NEXT_PAGE_TOKEN_FIELD_NUMBER: builtins.int
    @property
    def sessions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Session]:
        """The list of requested sessions."""
        pass
    next_page_token: typing.Text = ...
    """`next_page_token` can be sent in a subsequent
    [ListSessions][google.spanner.v1.Spanner.ListSessions] call to fetch more of the matching
    sessions.
    """

    def __init__(self,
        *,
        sessions : typing.Optional[typing.Iterable[global___Session]] = ...,
        next_page_token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["next_page_token",b"next_page_token","sessions",b"sessions"]) -> None: ...
global___ListSessionsResponse = ListSessionsResponse

class DeleteSessionRequest(google.protobuf.message.Message):
    """The request for [DeleteSession][google.spanner.v1.Spanner.DeleteSession]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """Required. The name of the session to delete."""

    def __init__(self,
        *,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...
global___DeleteSessionRequest = DeleteSessionRequest

class RequestOptions(google.protobuf.message.Message):
    """Common request options for various APIs."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _Priority:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _PriorityEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Priority.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        PRIORITY_UNSPECIFIED: RequestOptions.Priority.ValueType = ...  # 0
        """`PRIORITY_UNSPECIFIED` is equivalent to `PRIORITY_HIGH`."""

        PRIORITY_LOW: RequestOptions.Priority.ValueType = ...  # 1
        """This specifies that the request is low priority."""

        PRIORITY_MEDIUM: RequestOptions.Priority.ValueType = ...  # 2
        """This specifies that the request is medium priority."""

        PRIORITY_HIGH: RequestOptions.Priority.ValueType = ...  # 3
        """This specifies that the request is high priority."""

    class Priority(_Priority, metaclass=_PriorityEnumTypeWrapper):
        """The relative priority for requests. Note that priority is not applicable
        for [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction].

        The priority acts as a hint to the Cloud Spanner scheduler and does not
        guarantee priority or order of execution. For example:

        * Some parts of a write operation always execute at `PRIORITY_HIGH`,
          regardless of the specified priority. This may cause you to see an
          increase in high priority workload even when executing a low priority
          request. This can also potentially cause a priority inversion where a
          lower priority request will be fulfilled ahead of a higher priority
          request.
        * If a transaction contains multiple operations with different priorities,
          Cloud Spanner does not guarantee to process the higher priority
          operations first. There may be other constraints to satisfy, such as
          order of operations.
        """
        pass

    PRIORITY_UNSPECIFIED: RequestOptions.Priority.ValueType = ...  # 0
    """`PRIORITY_UNSPECIFIED` is equivalent to `PRIORITY_HIGH`."""

    PRIORITY_LOW: RequestOptions.Priority.ValueType = ...  # 1
    """This specifies that the request is low priority."""

    PRIORITY_MEDIUM: RequestOptions.Priority.ValueType = ...  # 2
    """This specifies that the request is medium priority."""

    PRIORITY_HIGH: RequestOptions.Priority.ValueType = ...  # 3
    """This specifies that the request is high priority."""


    PRIORITY_FIELD_NUMBER: builtins.int
    REQUEST_TAG_FIELD_NUMBER: builtins.int
    TRANSACTION_TAG_FIELD_NUMBER: builtins.int
    priority: global___RequestOptions.Priority.ValueType = ...
    """Priority for the request."""

    request_tag: typing.Text = ...
    """A per-request tag which can be applied to queries or reads, used for
    statistics collection.
    Both request_tag and transaction_tag can be specified for a read or query
    that belongs to a transaction.
    This field is ignored for requests where it's not applicable (e.g.
    CommitRequest).
    Legal characters for `request_tag` values are all printable characters
    (ASCII 32 - 126) and the length of a request_tag is limited to 50
    characters. Values that exceed this limit are truncated.
    """

    transaction_tag: typing.Text = ...
    """A tag used for statistics collection about this transaction.
    Both request_tag and transaction_tag can be specified for a read or query
    that belongs to a transaction.
    The value of transaction_tag should be the same for all requests belonging
    to the same transaction.
    If this request doesn’t belong to any transaction, transaction_tag will be
    ignored.
    Legal characters for `transaction_tag` values are all printable characters
    (ASCII 32 - 126) and the length of a transaction_tag is limited to 50
    characters. Values that exceed this limit are truncated.
    """

    def __init__(self,
        *,
        priority : global___RequestOptions.Priority.ValueType = ...,
        request_tag : typing.Text = ...,
        transaction_tag : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["priority",b"priority","request_tag",b"request_tag","transaction_tag",b"transaction_tag"]) -> None: ...
global___RequestOptions = RequestOptions

class ExecuteSqlRequest(google.protobuf.message.Message):
    """The request for [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] and
    [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql].
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class _QueryMode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _QueryModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_QueryMode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        NORMAL: ExecuteSqlRequest.QueryMode.ValueType = ...  # 0
        """The default mode. Only the statement results are returned."""

        PLAN: ExecuteSqlRequest.QueryMode.ValueType = ...  # 1
        """This mode returns only the query plan, without any results or
        execution statistics information.
        """

        PROFILE: ExecuteSqlRequest.QueryMode.ValueType = ...  # 2
        """This mode returns both the query plan and the execution statistics along
        with the results.
        """

    class QueryMode(_QueryMode, metaclass=_QueryModeEnumTypeWrapper):
        """Mode in which the statement must be processed."""
        pass

    NORMAL: ExecuteSqlRequest.QueryMode.ValueType = ...  # 0
    """The default mode. Only the statement results are returned."""

    PLAN: ExecuteSqlRequest.QueryMode.ValueType = ...  # 1
    """This mode returns only the query plan, without any results or
    execution statistics information.
    """

    PROFILE: ExecuteSqlRequest.QueryMode.ValueType = ...  # 2
    """This mode returns both the query plan and the execution statistics along
    with the results.
    """


    class QueryOptions(google.protobuf.message.Message):
        """Query optimizer configuration."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        OPTIMIZER_VERSION_FIELD_NUMBER: builtins.int
        OPTIMIZER_STATISTICS_PACKAGE_FIELD_NUMBER: builtins.int
        optimizer_version: typing.Text = ...
        """An option to control the selection of optimizer version.

        This parameter allows individual queries to pick different query
        optimizer versions.

        Specifying `latest` as a value instructs Cloud Spanner to use the
        latest supported query optimizer version. If not specified, Cloud Spanner
        uses the optimizer version set at the database level options. Any other
        positive integer (from the list of supported optimizer versions)
        overrides the default optimizer version for query execution.

        The list of supported optimizer versions can be queried from
        SPANNER_SYS.SUPPORTED_OPTIMIZER_VERSIONS.

        Executing a SQL statement with an invalid optimizer version fails with
        an `INVALID_ARGUMENT` error.

        See
        https://cloud.google.com/spanner/docs/query-optimizer/manage-query-optimizer
        for more information on managing the query optimizer.

        The `optimizer_version` statement hint has precedence over this setting.
        """

        optimizer_statistics_package: typing.Text = ...
        """An option to control the selection of optimizer statistics package.

        This parameter allows individual queries to use a different query
        optimizer statistics package.

        Specifying `latest` as a value instructs Cloud Spanner to use the latest
        generated statistics package. If not specified, Cloud Spanner uses
        the statistics package set at the database level options, or the latest
        package if the database option is not set.

        The statistics package requested by the query has to be exempt from
        garbage collection. This can be achieved with the following DDL
        statement:

        ```
        ALTER STATISTICS <package_name> SET OPTIONS (allow_gc=false)
        ```

        The list of available statistics packages can be queried from
        `INFORMATION_SCHEMA.SPANNER_STATISTICS`.

        Executing a SQL statement with an invalid optimizer statistics package
        or with a statistics package that allows garbage collection fails with
        an `INVALID_ARGUMENT` error.
        """

        def __init__(self,
            *,
            optimizer_version : typing.Text = ...,
            optimizer_statistics_package : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["optimizer_statistics_package",b"optimizer_statistics_package","optimizer_version",b"optimizer_version"]) -> None: ...

    class ParamTypesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> google.spanner.v1.type_pb2.Type: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[google.spanner.v1.type_pb2.Type] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    SESSION_FIELD_NUMBER: builtins.int
    TRANSACTION_FIELD_NUMBER: builtins.int
    SQL_FIELD_NUMBER: builtins.int
    PARAMS_FIELD_NUMBER: builtins.int
    PARAM_TYPES_FIELD_NUMBER: builtins.int
    RESUME_TOKEN_FIELD_NUMBER: builtins.int
    QUERY_MODE_FIELD_NUMBER: builtins.int
    PARTITION_TOKEN_FIELD_NUMBER: builtins.int
    SEQNO_FIELD_NUMBER: builtins.int
    QUERY_OPTIONS_FIELD_NUMBER: builtins.int
    REQUEST_OPTIONS_FIELD_NUMBER: builtins.int
    session: typing.Text = ...
    """Required. The session in which the SQL query should be performed."""

    @property
    def transaction(self) -> google.spanner.v1.transaction_pb2.TransactionSelector:
        """The transaction to use.

        For queries, if none is provided, the default is a temporary read-only
        transaction with strong concurrency.

        Standard DML statements require a read-write transaction. To protect
        against replays, single-use transactions are not supported.  The caller
        must either supply an existing transaction ID or begin a new transaction.

        Partitioned DML requires an existing Partitioned DML transaction ID.
        """
        pass
    sql: typing.Text = ...
    """Required. The SQL string."""

    @property
    def params(self) -> google.protobuf.struct_pb2.Struct:
        """Parameter names and values that bind to placeholders in the SQL string.

        A parameter placeholder consists of the `@` character followed by the
        parameter name (for example, `@firstName`). Parameter names must conform
        to the naming requirements of identifiers as specified at
        https://cloud.google.com/spanner/docs/lexical#identifiers.

        Parameters can appear anywhere that a literal value is expected.  The same
        parameter name can be used more than once, for example:

        `"WHERE id > @msg_id AND id < @msg_id + 100"`

        It is an error to execute a SQL statement with unbound parameters.
        """
        pass
    @property
    def param_types(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.spanner.v1.type_pb2.Type]:
        """It is not always possible for Cloud Spanner to infer the right SQL type
        from a JSON value.  For example, values of type `BYTES` and values
        of type `STRING` both appear in [params][google.spanner.v1.ExecuteSqlRequest.params] as JSON strings.

        In these cases, `param_types` can be used to specify the exact
        SQL type for some or all of the SQL statement parameters. See the
        definition of [Type][google.spanner.v1.Type] for more information
        about SQL types.
        """
        pass
    resume_token: builtins.bytes = ...
    """If this request is resuming a previously interrupted SQL statement
    execution, `resume_token` should be copied from the last
    [PartialResultSet][google.spanner.v1.PartialResultSet] yielded before the interruption. Doing this
    enables the new SQL statement execution to resume where the last one left
    off. The rest of the request parameters must exactly match the
    request that yielded this token.
    """

    query_mode: global___ExecuteSqlRequest.QueryMode.ValueType = ...
    """Used to control the amount of debugging information returned in
    [ResultSetStats][google.spanner.v1.ResultSetStats]. If [partition_token][google.spanner.v1.ExecuteSqlRequest.partition_token] is set, [query_mode][google.spanner.v1.ExecuteSqlRequest.query_mode] can only
    be set to [QueryMode.NORMAL][google.spanner.v1.ExecuteSqlRequest.QueryMode.NORMAL].
    """

    partition_token: builtins.bytes = ...
    """If present, results will be restricted to the specified partition
    previously created using PartitionQuery().  There must be an exact
    match for the values of fields common to this message and the
    PartitionQueryRequest message used to create this partition_token.
    """

    seqno: builtins.int = ...
    """A per-transaction sequence number used to identify this request. This field
    makes each request idempotent such that if the request is received multiple
    times, at most one will succeed.

    The sequence number must be monotonically increasing within the
    transaction. If a request arrives for the first time with an out-of-order
    sequence number, the transaction may be aborted. Replays of previously
    handled requests will yield the same response as the first execution.

    Required for DML statements. Ignored for queries.
    """

    @property
    def query_options(self) -> global___ExecuteSqlRequest.QueryOptions:
        """Query optimizer configuration to use for the given query."""
        pass
    @property
    def request_options(self) -> global___RequestOptions:
        """Common options for this request."""
        pass
    def __init__(self,
        *,
        session : typing.Text = ...,
        transaction : typing.Optional[google.spanner.v1.transaction_pb2.TransactionSelector] = ...,
        sql : typing.Text = ...,
        params : typing.Optional[google.protobuf.struct_pb2.Struct] = ...,
        param_types : typing.Optional[typing.Mapping[typing.Text, google.spanner.v1.type_pb2.Type]] = ...,
        resume_token : builtins.bytes = ...,
        query_mode : global___ExecuteSqlRequest.QueryMode.ValueType = ...,
        partition_token : builtins.bytes = ...,
        seqno : builtins.int = ...,
        query_options : typing.Optional[global___ExecuteSqlRequest.QueryOptions] = ...,
        request_options : typing.Optional[global___RequestOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["params",b"params","query_options",b"query_options","request_options",b"request_options","transaction",b"transaction"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["param_types",b"param_types","params",b"params","partition_token",b"partition_token","query_mode",b"query_mode","query_options",b"query_options","request_options",b"request_options","resume_token",b"resume_token","seqno",b"seqno","session",b"session","sql",b"sql","transaction",b"transaction"]) -> None: ...
global___ExecuteSqlRequest = ExecuteSqlRequest

class ExecuteBatchDmlRequest(google.protobuf.message.Message):
    """The request for [ExecuteBatchDml][google.spanner.v1.Spanner.ExecuteBatchDml]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Statement(google.protobuf.message.Message):
        """A single DML statement."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class ParamTypesEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            @property
            def value(self) -> google.spanner.v1.type_pb2.Type: ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Optional[google.spanner.v1.type_pb2.Type] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        SQL_FIELD_NUMBER: builtins.int
        PARAMS_FIELD_NUMBER: builtins.int
        PARAM_TYPES_FIELD_NUMBER: builtins.int
        sql: typing.Text = ...
        """Required. The DML string."""

        @property
        def params(self) -> google.protobuf.struct_pb2.Struct:
            """Parameter names and values that bind to placeholders in the DML string.

            A parameter placeholder consists of the `@` character followed by the
            parameter name (for example, `@firstName`). Parameter names can contain
            letters, numbers, and underscores.

            Parameters can appear anywhere that a literal value is expected.  The
            same parameter name can be used more than once, for example:

            `"WHERE id > @msg_id AND id < @msg_id + 100"`

            It is an error to execute a SQL statement with unbound parameters.
            """
            pass
        @property
        def param_types(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.spanner.v1.type_pb2.Type]:
            """It is not always possible for Cloud Spanner to infer the right SQL type
            from a JSON value.  For example, values of type `BYTES` and values
            of type `STRING` both appear in [params][google.spanner.v1.ExecuteBatchDmlRequest.Statement.params] as JSON strings.

            In these cases, `param_types` can be used to specify the exact
            SQL type for some or all of the SQL statement parameters. See the
            definition of [Type][google.spanner.v1.Type] for more information
            about SQL types.
            """
            pass
        def __init__(self,
            *,
            sql : typing.Text = ...,
            params : typing.Optional[google.protobuf.struct_pb2.Struct] = ...,
            param_types : typing.Optional[typing.Mapping[typing.Text, google.spanner.v1.type_pb2.Type]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["params",b"params"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["param_types",b"param_types","params",b"params","sql",b"sql"]) -> None: ...

    SESSION_FIELD_NUMBER: builtins.int
    TRANSACTION_FIELD_NUMBER: builtins.int
    STATEMENTS_FIELD_NUMBER: builtins.int
    SEQNO_FIELD_NUMBER: builtins.int
    REQUEST_OPTIONS_FIELD_NUMBER: builtins.int
    session: typing.Text = ...
    """Required. The session in which the DML statements should be performed."""

    @property
    def transaction(self) -> google.spanner.v1.transaction_pb2.TransactionSelector:
        """Required. The transaction to use. Must be a read-write transaction.

        To protect against replays, single-use transactions are not supported. The
        caller must either supply an existing transaction ID or begin a new
        transaction.
        """
        pass
    @property
    def statements(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ExecuteBatchDmlRequest.Statement]:
        """Required. The list of statements to execute in this batch. Statements are executed
        serially, such that the effects of statement `i` are visible to statement
        `i+1`. Each statement must be a DML statement. Execution stops at the
        first failed statement; the remaining statements are not executed.

        Callers must provide at least one statement.
        """
        pass
    seqno: builtins.int = ...
    """Required. A per-transaction sequence number used to identify this request. This field
    makes each request idempotent such that if the request is received multiple
    times, at most one will succeed.

    The sequence number must be monotonically increasing within the
    transaction. If a request arrives for the first time with an out-of-order
    sequence number, the transaction may be aborted. Replays of previously
    handled requests will yield the same response as the first execution.
    """

    @property
    def request_options(self) -> global___RequestOptions:
        """Common options for this request."""
        pass
    def __init__(self,
        *,
        session : typing.Text = ...,
        transaction : typing.Optional[google.spanner.v1.transaction_pb2.TransactionSelector] = ...,
        statements : typing.Optional[typing.Iterable[global___ExecuteBatchDmlRequest.Statement]] = ...,
        seqno : builtins.int = ...,
        request_options : typing.Optional[global___RequestOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["request_options",b"request_options","transaction",b"transaction"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["request_options",b"request_options","seqno",b"seqno","session",b"session","statements",b"statements","transaction",b"transaction"]) -> None: ...
global___ExecuteBatchDmlRequest = ExecuteBatchDmlRequest

class ExecuteBatchDmlResponse(google.protobuf.message.Message):
    """The response for [ExecuteBatchDml][google.spanner.v1.Spanner.ExecuteBatchDml]. Contains a list
    of [ResultSet][google.spanner.v1.ResultSet] messages, one for each DML statement that has successfully
    executed, in the same order as the statements in the request. If a statement
    fails, the status in the response body identifies the cause of the failure.

    To check for DML statements that failed, use the following approach:

    1. Check the status in the response message. The [google.rpc.Code][google.rpc.Code] enum
       value `OK` indicates that all statements were executed successfully.
    2. If the status was not `OK`, check the number of result sets in the
       response. If the response contains `N` [ResultSet][google.spanner.v1.ResultSet] messages, then
       statement `N+1` in the request failed.

    Example 1:

    * Request: 5 DML statements, all executed successfully.
    * Response: 5 [ResultSet][google.spanner.v1.ResultSet] messages, with the status `OK`.

    Example 2:

    * Request: 5 DML statements. The third statement has a syntax error.
    * Response: 2 [ResultSet][google.spanner.v1.ResultSet] messages, and a syntax error (`INVALID_ARGUMENT`)
      status. The number of [ResultSet][google.spanner.v1.ResultSet] messages indicates that the third
      statement failed, and the fourth and fifth statements were not executed.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RESULT_SETS_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    @property
    def result_sets(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.spanner.v1.result_set_pb2.ResultSet]:
        """One [ResultSet][google.spanner.v1.ResultSet] for each statement in the request that ran successfully,
        in the same order as the statements in the request. Each [ResultSet][google.spanner.v1.ResultSet] does
        not contain any rows. The [ResultSetStats][google.spanner.v1.ResultSetStats] in each [ResultSet][google.spanner.v1.ResultSet] contain
        the number of rows modified by the statement.

        Only the first [ResultSet][google.spanner.v1.ResultSet] in the response contains valid
        [ResultSetMetadata][google.spanner.v1.ResultSetMetadata].
        """
        pass
    @property
    def status(self) -> google.rpc.status_pb2.Status:
        """If all DML statements are executed successfully, the status is `OK`.
        Otherwise, the error status of the first failed statement.
        """
        pass
    def __init__(self,
        *,
        result_sets : typing.Optional[typing.Iterable[google.spanner.v1.result_set_pb2.ResultSet]] = ...,
        status : typing.Optional[google.rpc.status_pb2.Status] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["status",b"status"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["result_sets",b"result_sets","status",b"status"]) -> None: ...
global___ExecuteBatchDmlResponse = ExecuteBatchDmlResponse

class PartitionOptions(google.protobuf.message.Message):
    """Options for a PartitionQueryRequest and
    PartitionReadRequest.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARTITION_SIZE_BYTES_FIELD_NUMBER: builtins.int
    MAX_PARTITIONS_FIELD_NUMBER: builtins.int
    partition_size_bytes: builtins.int = ...
    """**Note:** This hint is currently ignored by PartitionQuery and
    PartitionRead requests.

    The desired data size for each partition generated.  The default for this
    option is currently 1 GiB.  This is only a hint. The actual size of each
    partition may be smaller or larger than this size request.
    """

    max_partitions: builtins.int = ...
    """**Note:** This hint is currently ignored by PartitionQuery and
    PartitionRead requests.

    The desired maximum number of partitions to return.  For example, this may
    be set to the number of workers available.  The default for this option
    is currently 10,000. The maximum value is currently 200,000.  This is only
    a hint.  The actual number of partitions returned may be smaller or larger
    than this maximum count request.
    """

    def __init__(self,
        *,
        partition_size_bytes : builtins.int = ...,
        max_partitions : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["max_partitions",b"max_partitions","partition_size_bytes",b"partition_size_bytes"]) -> None: ...
global___PartitionOptions = PartitionOptions

class PartitionQueryRequest(google.protobuf.message.Message):
    """The request for [PartitionQuery][google.spanner.v1.Spanner.PartitionQuery]"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ParamTypesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> google.spanner.v1.type_pb2.Type: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[google.spanner.v1.type_pb2.Type] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    SESSION_FIELD_NUMBER: builtins.int
    TRANSACTION_FIELD_NUMBER: builtins.int
    SQL_FIELD_NUMBER: builtins.int
    PARAMS_FIELD_NUMBER: builtins.int
    PARAM_TYPES_FIELD_NUMBER: builtins.int
    PARTITION_OPTIONS_FIELD_NUMBER: builtins.int
    session: typing.Text = ...
    """Required. The session used to create the partitions."""

    @property
    def transaction(self) -> google.spanner.v1.transaction_pb2.TransactionSelector:
        """Read only snapshot transactions are supported, read/write and single use
        transactions are not.
        """
        pass
    sql: typing.Text = ...
    """Required. The query request to generate partitions for. The request will fail if
    the query is not root partitionable. The query plan of a root
    partitionable query has a single distributed union operator. A distributed
    union operator conceptually divides one or more tables into multiple
    splits, remotely evaluates a subquery independently on each split, and
    then unions all results.

    This must not contain DML commands, such as INSERT, UPDATE, or
    DELETE. Use [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql] with a
    PartitionedDml transaction for large, partition-friendly DML operations.
    """

    @property
    def params(self) -> google.protobuf.struct_pb2.Struct:
        """Parameter names and values that bind to placeholders in the SQL string.

        A parameter placeholder consists of the `@` character followed by the
        parameter name (for example, `@firstName`). Parameter names can contain
        letters, numbers, and underscores.

        Parameters can appear anywhere that a literal value is expected.  The same
        parameter name can be used more than once, for example:

        `"WHERE id > @msg_id AND id < @msg_id + 100"`

        It is an error to execute a SQL statement with unbound parameters.
        """
        pass
    @property
    def param_types(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, google.spanner.v1.type_pb2.Type]:
        """It is not always possible for Cloud Spanner to infer the right SQL type
        from a JSON value.  For example, values of type `BYTES` and values
        of type `STRING` both appear in [params][google.spanner.v1.PartitionQueryRequest.params] as JSON strings.

        In these cases, `param_types` can be used to specify the exact
        SQL type for some or all of the SQL query parameters. See the
        definition of [Type][google.spanner.v1.Type] for more information
        about SQL types.
        """
        pass
    @property
    def partition_options(self) -> global___PartitionOptions:
        """Additional options that affect how many partitions are created."""
        pass
    def __init__(self,
        *,
        session : typing.Text = ...,
        transaction : typing.Optional[google.spanner.v1.transaction_pb2.TransactionSelector] = ...,
        sql : typing.Text = ...,
        params : typing.Optional[google.protobuf.struct_pb2.Struct] = ...,
        param_types : typing.Optional[typing.Mapping[typing.Text, google.spanner.v1.type_pb2.Type]] = ...,
        partition_options : typing.Optional[global___PartitionOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["params",b"params","partition_options",b"partition_options","transaction",b"transaction"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["param_types",b"param_types","params",b"params","partition_options",b"partition_options","session",b"session","sql",b"sql","transaction",b"transaction"]) -> None: ...
global___PartitionQueryRequest = PartitionQueryRequest

class PartitionReadRequest(google.protobuf.message.Message):
    """The request for [PartitionRead][google.spanner.v1.Spanner.PartitionRead]"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SESSION_FIELD_NUMBER: builtins.int
    TRANSACTION_FIELD_NUMBER: builtins.int
    TABLE_FIELD_NUMBER: builtins.int
    INDEX_FIELD_NUMBER: builtins.int
    COLUMNS_FIELD_NUMBER: builtins.int
    KEY_SET_FIELD_NUMBER: builtins.int
    PARTITION_OPTIONS_FIELD_NUMBER: builtins.int
    session: typing.Text = ...
    """Required. The session used to create the partitions."""

    @property
    def transaction(self) -> google.spanner.v1.transaction_pb2.TransactionSelector:
        """Read only snapshot transactions are supported, read/write and single use
        transactions are not.
        """
        pass
    table: typing.Text = ...
    """Required. The name of the table in the database to be read."""

    index: typing.Text = ...
    """If non-empty, the name of an index on [table][google.spanner.v1.PartitionReadRequest.table]. This index is
    used instead of the table primary key when interpreting [key_set][google.spanner.v1.PartitionReadRequest.key_set]
    and sorting result rows. See [key_set][google.spanner.v1.PartitionReadRequest.key_set] for further information.
    """

    @property
    def columns(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """The columns of [table][google.spanner.v1.PartitionReadRequest.table] to be returned for each row matching
        this request.
        """
        pass
    @property
    def key_set(self) -> google.spanner.v1.keys_pb2.KeySet:
        """Required. `key_set` identifies the rows to be yielded. `key_set` names the
        primary keys of the rows in [table][google.spanner.v1.PartitionReadRequest.table] to be yielded, unless [index][google.spanner.v1.PartitionReadRequest.index]
        is present. If [index][google.spanner.v1.PartitionReadRequest.index] is present, then [key_set][google.spanner.v1.PartitionReadRequest.key_set] instead names
        index keys in [index][google.spanner.v1.PartitionReadRequest.index].

        It is not an error for the `key_set` to name rows that do not
        exist in the database. Read yields nothing for nonexistent rows.
        """
        pass
    @property
    def partition_options(self) -> global___PartitionOptions:
        """Additional options that affect how many partitions are created."""
        pass
    def __init__(self,
        *,
        session : typing.Text = ...,
        transaction : typing.Optional[google.spanner.v1.transaction_pb2.TransactionSelector] = ...,
        table : typing.Text = ...,
        index : typing.Text = ...,
        columns : typing.Optional[typing.Iterable[typing.Text]] = ...,
        key_set : typing.Optional[google.spanner.v1.keys_pb2.KeySet] = ...,
        partition_options : typing.Optional[global___PartitionOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key_set",b"key_set","partition_options",b"partition_options","transaction",b"transaction"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["columns",b"columns","index",b"index","key_set",b"key_set","partition_options",b"partition_options","session",b"session","table",b"table","transaction",b"transaction"]) -> None: ...
global___PartitionReadRequest = PartitionReadRequest

class Partition(google.protobuf.message.Message):
    """Information returned for each partition returned in a
    PartitionResponse.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARTITION_TOKEN_FIELD_NUMBER: builtins.int
    partition_token: builtins.bytes = ...
    """This token can be passed to Read, StreamingRead, ExecuteSql, or
    ExecuteStreamingSql requests to restrict the results to those identified by
    this partition token.
    """

    def __init__(self,
        *,
        partition_token : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["partition_token",b"partition_token"]) -> None: ...
global___Partition = Partition

class PartitionResponse(google.protobuf.message.Message):
    """The response for [PartitionQuery][google.spanner.v1.Spanner.PartitionQuery]
    or [PartitionRead][google.spanner.v1.Spanner.PartitionRead]
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PARTITIONS_FIELD_NUMBER: builtins.int
    TRANSACTION_FIELD_NUMBER: builtins.int
    @property
    def partitions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Partition]:
        """Partitions created by this request."""
        pass
    @property
    def transaction(self) -> google.spanner.v1.transaction_pb2.Transaction:
        """Transaction created by this request."""
        pass
    def __init__(self,
        *,
        partitions : typing.Optional[typing.Iterable[global___Partition]] = ...,
        transaction : typing.Optional[google.spanner.v1.transaction_pb2.Transaction] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["transaction",b"transaction"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["partitions",b"partitions","transaction",b"transaction"]) -> None: ...
global___PartitionResponse = PartitionResponse

class ReadRequest(google.protobuf.message.Message):
    """The request for [Read][google.spanner.v1.Spanner.Read] and
    [StreamingRead][google.spanner.v1.Spanner.StreamingRead].
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SESSION_FIELD_NUMBER: builtins.int
    TRANSACTION_FIELD_NUMBER: builtins.int
    TABLE_FIELD_NUMBER: builtins.int
    INDEX_FIELD_NUMBER: builtins.int
    COLUMNS_FIELD_NUMBER: builtins.int
    KEY_SET_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    RESUME_TOKEN_FIELD_NUMBER: builtins.int
    PARTITION_TOKEN_FIELD_NUMBER: builtins.int
    REQUEST_OPTIONS_FIELD_NUMBER: builtins.int
    session: typing.Text = ...
    """Required. The session in which the read should be performed."""

    @property
    def transaction(self) -> google.spanner.v1.transaction_pb2.TransactionSelector:
        """The transaction to use. If none is provided, the default is a
        temporary read-only transaction with strong concurrency.
        """
        pass
    table: typing.Text = ...
    """Required. The name of the table in the database to be read."""

    index: typing.Text = ...
    """If non-empty, the name of an index on [table][google.spanner.v1.ReadRequest.table]. This index is
    used instead of the table primary key when interpreting [key_set][google.spanner.v1.ReadRequest.key_set]
    and sorting result rows. See [key_set][google.spanner.v1.ReadRequest.key_set] for further information.
    """

    @property
    def columns(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Required. The columns of [table][google.spanner.v1.ReadRequest.table] to be returned for each row matching
        this request.
        """
        pass
    @property
    def key_set(self) -> google.spanner.v1.keys_pb2.KeySet:
        """Required. `key_set` identifies the rows to be yielded. `key_set` names the
        primary keys of the rows in [table][google.spanner.v1.ReadRequest.table] to be yielded, unless [index][google.spanner.v1.ReadRequest.index]
        is present. If [index][google.spanner.v1.ReadRequest.index] is present, then [key_set][google.spanner.v1.ReadRequest.key_set] instead names
        index keys in [index][google.spanner.v1.ReadRequest.index].

        If the [partition_token][google.spanner.v1.ReadRequest.partition_token] field is empty, rows are yielded
        in table primary key order (if [index][google.spanner.v1.ReadRequest.index] is empty) or index key order
        (if [index][google.spanner.v1.ReadRequest.index] is non-empty).  If the [partition_token][google.spanner.v1.ReadRequest.partition_token] field is not
        empty, rows will be yielded in an unspecified order.

        It is not an error for the `key_set` to name rows that do not
        exist in the database. Read yields nothing for nonexistent rows.
        """
        pass
    limit: builtins.int = ...
    """If greater than zero, only the first `limit` rows are yielded. If `limit`
    is zero, the default is no limit. A limit cannot be specified if
    `partition_token` is set.
    """

    resume_token: builtins.bytes = ...
    """If this request is resuming a previously interrupted read,
    `resume_token` should be copied from the last
    [PartialResultSet][google.spanner.v1.PartialResultSet] yielded before the interruption. Doing this
    enables the new read to resume where the last read left off. The
    rest of the request parameters must exactly match the request
    that yielded this token.
    """

    partition_token: builtins.bytes = ...
    """If present, results will be restricted to the specified partition
    previously created using PartitionRead().    There must be an exact
    match for the values of fields common to this message and the
    PartitionReadRequest message used to create this partition_token.
    """

    @property
    def request_options(self) -> global___RequestOptions:
        """Common options for this request."""
        pass
    def __init__(self,
        *,
        session : typing.Text = ...,
        transaction : typing.Optional[google.spanner.v1.transaction_pb2.TransactionSelector] = ...,
        table : typing.Text = ...,
        index : typing.Text = ...,
        columns : typing.Optional[typing.Iterable[typing.Text]] = ...,
        key_set : typing.Optional[google.spanner.v1.keys_pb2.KeySet] = ...,
        limit : builtins.int = ...,
        resume_token : builtins.bytes = ...,
        partition_token : builtins.bytes = ...,
        request_options : typing.Optional[global___RequestOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["key_set",b"key_set","request_options",b"request_options","transaction",b"transaction"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["columns",b"columns","index",b"index","key_set",b"key_set","limit",b"limit","partition_token",b"partition_token","request_options",b"request_options","resume_token",b"resume_token","session",b"session","table",b"table","transaction",b"transaction"]) -> None: ...
global___ReadRequest = ReadRequest

class BeginTransactionRequest(google.protobuf.message.Message):
    """The request for [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SESSION_FIELD_NUMBER: builtins.int
    OPTIONS_FIELD_NUMBER: builtins.int
    REQUEST_OPTIONS_FIELD_NUMBER: builtins.int
    session: typing.Text = ...
    """Required. The session in which the transaction runs."""

    @property
    def options(self) -> google.spanner.v1.transaction_pb2.TransactionOptions:
        """Required. Options for the new transaction."""
        pass
    @property
    def request_options(self) -> global___RequestOptions:
        """Common options for this request.
        Priority is ignored for this request. Setting the priority in this
        request_options struct will not do anything. To set the priority for a
        transaction, set it on the reads and writes that are part of this
        transaction instead.
        """
        pass
    def __init__(self,
        *,
        session : typing.Text = ...,
        options : typing.Optional[google.spanner.v1.transaction_pb2.TransactionOptions] = ...,
        request_options : typing.Optional[global___RequestOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["options",b"options","request_options",b"request_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["options",b"options","request_options",b"request_options","session",b"session"]) -> None: ...
global___BeginTransactionRequest = BeginTransactionRequest

class CommitRequest(google.protobuf.message.Message):
    """The request for [Commit][google.spanner.v1.Spanner.Commit]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SESSION_FIELD_NUMBER: builtins.int
    TRANSACTION_ID_FIELD_NUMBER: builtins.int
    SINGLE_USE_TRANSACTION_FIELD_NUMBER: builtins.int
    MUTATIONS_FIELD_NUMBER: builtins.int
    RETURN_COMMIT_STATS_FIELD_NUMBER: builtins.int
    REQUEST_OPTIONS_FIELD_NUMBER: builtins.int
    session: typing.Text = ...
    """Required. The session in which the transaction to be committed is running."""

    transaction_id: builtins.bytes = ...
    """Commit a previously-started transaction."""

    @property
    def single_use_transaction(self) -> google.spanner.v1.transaction_pb2.TransactionOptions:
        """Execute mutations in a temporary transaction. Note that unlike
        commit of a previously-started transaction, commit with a
        temporary transaction is non-idempotent. That is, if the
        `CommitRequest` is sent to Cloud Spanner more than once (for
        instance, due to retries in the application, or in the
        transport library), it is possible that the mutations are
        executed more than once. If this is undesirable, use
        [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction] and
        [Commit][google.spanner.v1.Spanner.Commit] instead.
        """
        pass
    @property
    def mutations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.spanner.v1.mutation_pb2.Mutation]:
        """The mutations to be executed when this transaction commits. All
        mutations are applied atomically, in the order they appear in
        this list.
        """
        pass
    return_commit_stats: builtins.bool = ...
    """If `true`, then statistics related to the transaction will be included in
    the [CommitResponse][google.spanner.v1.CommitResponse.commit_stats]. Default value is
    `false`.
    """

    @property
    def request_options(self) -> global___RequestOptions:
        """Common options for this request."""
        pass
    def __init__(self,
        *,
        session : typing.Text = ...,
        transaction_id : builtins.bytes = ...,
        single_use_transaction : typing.Optional[google.spanner.v1.transaction_pb2.TransactionOptions] = ...,
        mutations : typing.Optional[typing.Iterable[google.spanner.v1.mutation_pb2.Mutation]] = ...,
        return_commit_stats : builtins.bool = ...,
        request_options : typing.Optional[global___RequestOptions] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["request_options",b"request_options","single_use_transaction",b"single_use_transaction","transaction",b"transaction","transaction_id",b"transaction_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["mutations",b"mutations","request_options",b"request_options","return_commit_stats",b"return_commit_stats","session",b"session","single_use_transaction",b"single_use_transaction","transaction",b"transaction","transaction_id",b"transaction_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["transaction",b"transaction"]) -> typing.Optional[typing_extensions.Literal["transaction_id","single_use_transaction"]]: ...
global___CommitRequest = CommitRequest

class RollbackRequest(google.protobuf.message.Message):
    """The request for [Rollback][google.spanner.v1.Spanner.Rollback]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SESSION_FIELD_NUMBER: builtins.int
    TRANSACTION_ID_FIELD_NUMBER: builtins.int
    session: typing.Text = ...
    """Required. The session in which the transaction to roll back is running."""

    transaction_id: builtins.bytes = ...
    """Required. The transaction to roll back."""

    def __init__(self,
        *,
        session : typing.Text = ...,
        transaction_id : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["session",b"session","transaction_id",b"transaction_id"]) -> None: ...
global___RollbackRequest = RollbackRequest
