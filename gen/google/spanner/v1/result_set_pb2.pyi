"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import google.protobuf.struct_pb2
import google.spanner.v1.query_plan_pb2
import google.spanner.v1.transaction_pb2
import google.spanner.v1.type_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class ResultSet(google.protobuf.message.Message):
    """Results from [Read][google.spanner.v1.Spanner.Read] or
    [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql].
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    METADATA_FIELD_NUMBER: builtins.int
    ROWS_FIELD_NUMBER: builtins.int
    STATS_FIELD_NUMBER: builtins.int
    @property
    def metadata(self) -> global___ResultSetMetadata:
        """Metadata about the result set, such as row type information."""
        pass
    @property
    def rows(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.struct_pb2.ListValue]:
        """Each element in `rows` is a row whose format is defined by
        [metadata.row_type][google.spanner.v1.ResultSetMetadata.row_type]. The ith element
        in each row matches the ith field in
        [metadata.row_type][google.spanner.v1.ResultSetMetadata.row_type]. Elements are
        encoded based on type as described
        [here][google.spanner.v1.TypeCode].
        """
        pass
    @property
    def stats(self) -> global___ResultSetStats:
        """Query plan and execution statistics for the SQL statement that
        produced this result set. These can be requested by setting
        [ExecuteSqlRequest.query_mode][google.spanner.v1.ExecuteSqlRequest.query_mode].
        DML statements always produce stats containing the number of rows
        modified, unless executed using the
        [ExecuteSqlRequest.QueryMode.PLAN][google.spanner.v1.ExecuteSqlRequest.QueryMode.PLAN] [ExecuteSqlRequest.query_mode][google.spanner.v1.ExecuteSqlRequest.query_mode].
        Other fields may or may not be populated, based on the
        [ExecuteSqlRequest.query_mode][google.spanner.v1.ExecuteSqlRequest.query_mode].
        """
        pass
    def __init__(self,
        *,
        metadata : typing.Optional[global___ResultSetMetadata] = ...,
        rows : typing.Optional[typing.Iterable[google.protobuf.struct_pb2.ListValue]] = ...,
        stats : typing.Optional[global___ResultSetStats] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["metadata",b"metadata","stats",b"stats"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["metadata",b"metadata","rows",b"rows","stats",b"stats"]) -> None: ...
global___ResultSet = ResultSet

class PartialResultSet(google.protobuf.message.Message):
    """Partial results from a streaming read or SQL query. Streaming reads and
    SQL queries better tolerate large result sets, large rows, and large
    values, but are a little trickier to consume.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    METADATA_FIELD_NUMBER: builtins.int
    VALUES_FIELD_NUMBER: builtins.int
    CHUNKED_VALUE_FIELD_NUMBER: builtins.int
    RESUME_TOKEN_FIELD_NUMBER: builtins.int
    STATS_FIELD_NUMBER: builtins.int
    @property
    def metadata(self) -> global___ResultSetMetadata:
        """Metadata about the result set, such as row type information.
        Only present in the first response.
        """
        pass
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.struct_pb2.Value]:
        """A streamed result set consists of a stream of values, which might
        be split into many `PartialResultSet` messages to accommodate
        large rows and/or large values. Every N complete values defines a
        row, where N is equal to the number of entries in
        [metadata.row_type.fields][google.spanner.v1.StructType.fields].

        Most values are encoded based on type as described
        [here][google.spanner.v1.TypeCode].

        It is possible that the last value in values is "chunked",
        meaning that the rest of the value is sent in subsequent
        `PartialResultSet`(s). This is denoted by the [chunked_value][google.spanner.v1.PartialResultSet.chunked_value]
        field. Two or more chunked values can be merged to form a
        complete value as follows:

          * `bool/number/null`: cannot be chunked
          * `string`: concatenate the strings
          * `list`: concatenate the lists. If the last element in a list is a
            `string`, `list`, or `object`, merge it with the first element in
            the next list by applying these rules recursively.
          * `object`: concatenate the (field name, field value) pairs. If a
            field name is duplicated, then apply these rules recursively
            to merge the field values.

        Some examples of merging:

            # Strings are concatenated.
            "foo", "bar" => "foobar"

            # Lists of non-strings are concatenated.
            [2, 3], [4] => [2, 3, 4]

            # Lists are concatenated, but the last and first elements are merged
            # because they are strings.
            ["a", "b"], ["c", "d"] => ["a", "bc", "d"]

            # Lists are concatenated, but the last and first elements are merged
            # because they are lists. Recursively, the last and first elements
            # of the inner lists are merged because they are strings.
            ["a", ["b", "c"]], [["d"], "e"] => ["a", ["b", "cd"], "e"]

            # Non-overlapping object fields are combined.
            {"a": "1"}, {"b": "2"} => {"a": "1", "b": 2"}

            # Overlapping object fields are merged.
            {"a": "1"}, {"a": "2"} => {"a": "12"}

            # Examples of merging objects containing lists of strings.
            {"a": ["1"]}, {"a": ["2"]} => {"a": ["12"]}

        For a more complete example, suppose a streaming SQL query is
        yielding a result set whose rows contain a single string
        field. The following `PartialResultSet`s might be yielded:

            {
              "metadata": { ... }
              "values": ["Hello", "W"]
              "chunked_value": true
              "resume_token": "Af65..."
            }
            {
              "values": ["orl"]
              "chunked_value": true
              "resume_token": "Bqp2..."
            }
            {
              "values": ["d"]
              "resume_token": "Zx1B..."
            }

        This sequence of `PartialResultSet`s encodes two rows, one
        containing the field value `"Hello"`, and a second containing the
        field value `"World" = "W" + "orl" + "d"`.
        """
        pass
    chunked_value: builtins.bool = ...
    """If true, then the final value in [values][google.spanner.v1.PartialResultSet.values] is chunked, and must
    be combined with more values from subsequent `PartialResultSet`s
    to obtain a complete field value.
    """

    resume_token: builtins.bytes = ...
    """Streaming calls might be interrupted for a variety of reasons, such
    as TCP connection loss. If this occurs, the stream of results can
    be resumed by re-sending the original request and including
    `resume_token`. Note that executing any other transaction in the
    same session invalidates the token.
    """

    @property
    def stats(self) -> global___ResultSetStats:
        """Query plan and execution statistics for the statement that produced this
        streaming result set. These can be requested by setting
        [ExecuteSqlRequest.query_mode][google.spanner.v1.ExecuteSqlRequest.query_mode] and are sent
        only once with the last response in the stream.
        This field will also be present in the last response for DML
        statements.
        """
        pass
    def __init__(self,
        *,
        metadata : typing.Optional[global___ResultSetMetadata] = ...,
        values : typing.Optional[typing.Iterable[google.protobuf.struct_pb2.Value]] = ...,
        chunked_value : builtins.bool = ...,
        resume_token : builtins.bytes = ...,
        stats : typing.Optional[global___ResultSetStats] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["metadata",b"metadata","stats",b"stats"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["chunked_value",b"chunked_value","metadata",b"metadata","resume_token",b"resume_token","stats",b"stats","values",b"values"]) -> None: ...
global___PartialResultSet = PartialResultSet

class ResultSetMetadata(google.protobuf.message.Message):
    """Metadata about a [ResultSet][google.spanner.v1.ResultSet] or [PartialResultSet][google.spanner.v1.PartialResultSet]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ROW_TYPE_FIELD_NUMBER: builtins.int
    TRANSACTION_FIELD_NUMBER: builtins.int
    @property
    def row_type(self) -> google.spanner.v1.type_pb2.StructType:
        """Indicates the field names and types for the rows in the result
        set.  For example, a SQL query like `"SELECT UserId, UserName FROM
        Users"` could return a `row_type` value like:

            "fields": [
              { "name": "UserId", "type": { "code": "INT64" } },
              { "name": "UserName", "type": { "code": "STRING" } },
            ]
        """
        pass
    @property
    def transaction(self) -> google.spanner.v1.transaction_pb2.Transaction:
        """If the read or SQL query began a transaction as a side-effect, the
        information about the new transaction is yielded here.
        """
        pass
    def __init__(self,
        *,
        row_type : typing.Optional[google.spanner.v1.type_pb2.StructType] = ...,
        transaction : typing.Optional[google.spanner.v1.transaction_pb2.Transaction] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["row_type",b"row_type","transaction",b"transaction"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["row_type",b"row_type","transaction",b"transaction"]) -> None: ...
global___ResultSetMetadata = ResultSetMetadata

class ResultSetStats(google.protobuf.message.Message):
    """Additional statistics about a [ResultSet][google.spanner.v1.ResultSet] or [PartialResultSet][google.spanner.v1.PartialResultSet]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    QUERY_PLAN_FIELD_NUMBER: builtins.int
    QUERY_STATS_FIELD_NUMBER: builtins.int
    ROW_COUNT_EXACT_FIELD_NUMBER: builtins.int
    ROW_COUNT_LOWER_BOUND_FIELD_NUMBER: builtins.int
    @property
    def query_plan(self) -> google.spanner.v1.query_plan_pb2.QueryPlan:
        """[QueryPlan][google.spanner.v1.QueryPlan] for the query associated with this result."""
        pass
    @property
    def query_stats(self) -> google.protobuf.struct_pb2.Struct:
        """Aggregated statistics from the execution of the query. Only present when
        the query is profiled. For example, a query could return the statistics as
        follows:

            {
              "rows_returned": "3",
              "elapsed_time": "1.22 secs",
              "cpu_time": "1.19 secs"
            }
        """
        pass
    row_count_exact: builtins.int = ...
    """Standard DML returns an exact count of rows that were modified."""

    row_count_lower_bound: builtins.int = ...
    """Partitioned DML does not offer exactly-once semantics, so it
    returns a lower bound of the rows modified.
    """

    def __init__(self,
        *,
        query_plan : typing.Optional[google.spanner.v1.query_plan_pb2.QueryPlan] = ...,
        query_stats : typing.Optional[google.protobuf.struct_pb2.Struct] = ...,
        row_count_exact : builtins.int = ...,
        row_count_lower_bound : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["query_plan",b"query_plan","query_stats",b"query_stats","row_count",b"row_count","row_count_exact",b"row_count_exact","row_count_lower_bound",b"row_count_lower_bound"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["query_plan",b"query_plan","query_stats",b"query_stats","row_count",b"row_count","row_count_exact",b"row_count_exact","row_count_lower_bound",b"row_count_lower_bound"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["row_count",b"row_count"]) -> typing.Optional[typing_extensions.Literal["row_count_exact","row_count_lower_bound"]]: ...
global___ResultSetStats = ResultSetStats
