"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import google.protobuf.struct_pb2
import google.spanner.v1.keys_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Mutation(google.protobuf.message.Message):
    """A modification to one or more Cloud Spanner rows.  Mutations can be
    applied to a Cloud Spanner database by sending them in a
    [Commit][google.spanner.v1.Spanner.Commit] call.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Write(google.protobuf.message.Message):
        """Arguments to [insert][google.spanner.v1.Mutation.insert], [update][google.spanner.v1.Mutation.update], [insert_or_update][google.spanner.v1.Mutation.insert_or_update], and
        [replace][google.spanner.v1.Mutation.replace] operations.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TABLE_FIELD_NUMBER: builtins.int
        COLUMNS_FIELD_NUMBER: builtins.int
        VALUES_FIELD_NUMBER: builtins.int
        table: typing.Text = ...
        """Required. The table whose rows will be written."""

        @property
        def columns(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """The names of the columns in [table][google.spanner.v1.Mutation.Write.table] to be written.

            The list of columns must contain enough columns to allow
            Cloud Spanner to derive values for all primary key columns in the
            row(s) to be modified.
            """
            pass
        @property
        def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.protobuf.struct_pb2.ListValue]:
            """The values to be written. `values` can contain more than one
            list of values. If it does, then multiple rows are written, one
            for each entry in `values`. Each list in `values` must have
            exactly as many entries as there are entries in [columns][google.spanner.v1.Mutation.Write.columns]
            above. Sending multiple lists is equivalent to sending multiple
            `Mutation`s, each containing one `values` entry and repeating
            [table][google.spanner.v1.Mutation.Write.table] and [columns][google.spanner.v1.Mutation.Write.columns]. Individual values in each list are
            encoded as described [here][google.spanner.v1.TypeCode].
            """
            pass
        def __init__(self,
            *,
            table : typing.Text = ...,
            columns : typing.Optional[typing.Iterable[typing.Text]] = ...,
            values : typing.Optional[typing.Iterable[google.protobuf.struct_pb2.ListValue]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["columns",b"columns","table",b"table","values",b"values"]) -> None: ...

    class Delete(google.protobuf.message.Message):
        """Arguments to [delete][google.spanner.v1.Mutation.delete] operations."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        TABLE_FIELD_NUMBER: builtins.int
        KEY_SET_FIELD_NUMBER: builtins.int
        table: typing.Text = ...
        """Required. The table whose rows will be deleted."""

        @property
        def key_set(self) -> google.spanner.v1.keys_pb2.KeySet:
            """Required. The primary keys of the rows within [table][google.spanner.v1.Mutation.Delete.table] to delete.  The
            primary keys must be specified in the order in which they appear in the
            `PRIMARY KEY()` clause of the table's equivalent DDL statement (the DDL
            statement used to create the table).
            Delete is idempotent. The transaction will succeed even if some or all
            rows do not exist.
            """
            pass
        def __init__(self,
            *,
            table : typing.Text = ...,
            key_set : typing.Optional[google.spanner.v1.keys_pb2.KeySet] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["key_set",b"key_set"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key_set",b"key_set","table",b"table"]) -> None: ...

    INSERT_FIELD_NUMBER: builtins.int
    UPDATE_FIELD_NUMBER: builtins.int
    INSERT_OR_UPDATE_FIELD_NUMBER: builtins.int
    REPLACE_FIELD_NUMBER: builtins.int
    DELETE_FIELD_NUMBER: builtins.int
    @property
    def insert(self) -> global___Mutation.Write:
        """Insert new rows in a table. If any of the rows already exist,
        the write or transaction fails with error `ALREADY_EXISTS`.
        """
        pass
    @property
    def update(self) -> global___Mutation.Write:
        """Update existing rows in a table. If any of the rows does not
        already exist, the transaction fails with error `NOT_FOUND`.
        """
        pass
    @property
    def insert_or_update(self) -> global___Mutation.Write:
        """Like [insert][google.spanner.v1.Mutation.insert], except that if the row already exists, then
        its column values are overwritten with the ones provided. Any
        column values not explicitly written are preserved.

        When using [insert_or_update][google.spanner.v1.Mutation.insert_or_update], just as when using [insert][google.spanner.v1.Mutation.insert], all `NOT
        NULL` columns in the table must be given a value. This holds true
        even when the row already exists and will therefore actually be updated.
        """
        pass
    @property
    def replace(self) -> global___Mutation.Write:
        """Like [insert][google.spanner.v1.Mutation.insert], except that if the row already exists, it is
        deleted, and the column values provided are inserted
        instead. Unlike [insert_or_update][google.spanner.v1.Mutation.insert_or_update], this means any values not
        explicitly written become `NULL`.

        In an interleaved table, if you create the child table with the
        `ON DELETE CASCADE` annotation, then replacing a parent row
        also deletes the child rows. Otherwise, you must delete the
        child rows before you replace the parent row.
        """
        pass
    @property
    def delete(self) -> global___Mutation.Delete:
        """Delete rows from a table. Succeeds whether or not the named
        rows were present.
        """
        pass
    def __init__(self,
        *,
        insert : typing.Optional[global___Mutation.Write] = ...,
        update : typing.Optional[global___Mutation.Write] = ...,
        insert_or_update : typing.Optional[global___Mutation.Write] = ...,
        replace : typing.Optional[global___Mutation.Write] = ...,
        delete : typing.Optional[global___Mutation.Delete] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["delete",b"delete","insert",b"insert","insert_or_update",b"insert_or_update","operation",b"operation","replace",b"replace","update",b"update"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["delete",b"delete","insert",b"insert","insert_or_update",b"insert_or_update","operation",b"operation","replace",b"replace","update",b"update"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["operation",b"operation"]) -> typing.Optional[typing_extensions.Literal["insert","update","insert_or_update","replace","delete"]]: ...
global___Mutation = Mutation
