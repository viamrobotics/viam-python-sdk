"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Row(google.protobuf.message.Message):
    """Specifies the complete (requested) contents of a single row of a table.
    Rows which exceed 256MiB in size cannot be read in full.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_FIELD_NUMBER: builtins.int
    FAMILIES_FIELD_NUMBER: builtins.int
    key: builtins.bytes = ...
    """The unique key which identifies this row within its table. This is the same
    key that's used to identify the row in, for example, a MutateRowRequest.
    May contain any non-empty byte string up to 4KiB in length.
    """

    @property
    def families(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Family]:
        """May be empty, but only if the entire row is empty.
        The mutual ordering of column families is not specified.
        """
        pass
    def __init__(self,
        *,
        key : builtins.bytes = ...,
        families : typing.Optional[typing.Iterable[global___Family]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["families",b"families","key",b"key"]) -> None: ...
global___Row = Row

class Family(google.protobuf.message.Message):
    """Specifies (some of) the contents of a single row/column family intersection
    of a table.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    COLUMNS_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """The unique key which identifies this family within its row. This is the
    same key that's used to identify the family in, for example, a RowFilter
    which sets its "family_name_regex_filter" field.
    Must match `[-_.a-zA-Z0-9]+`, except that AggregatingRowProcessors may
    produce cells in a sentinel family with an empty name.
    Must be no greater than 64 characters in length.
    """

    @property
    def columns(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Column]:
        """Must not be empty. Sorted in order of increasing "qualifier"."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        columns : typing.Optional[typing.Iterable[global___Column]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["columns",b"columns","name",b"name"]) -> None: ...
global___Family = Family

class Column(google.protobuf.message.Message):
    """Specifies (some of) the contents of a single row/column intersection of a
    table.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    QUALIFIER_FIELD_NUMBER: builtins.int
    CELLS_FIELD_NUMBER: builtins.int
    qualifier: builtins.bytes = ...
    """The unique key which identifies this column within its family. This is the
    same key that's used to identify the column in, for example, a RowFilter
    which sets its `column_qualifier_regex_filter` field.
    May contain any byte string, including the empty string, up to 16kiB in
    length.
    """

    @property
    def cells(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Cell]:
        """Must not be empty. Sorted in order of decreasing "timestamp_micros"."""
        pass
    def __init__(self,
        *,
        qualifier : builtins.bytes = ...,
        cells : typing.Optional[typing.Iterable[global___Cell]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["cells",b"cells","qualifier",b"qualifier"]) -> None: ...
global___Column = Column

class Cell(google.protobuf.message.Message):
    """Specifies (some of) the contents of a single row/column/timestamp of a table."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    TIMESTAMP_MICROS_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    timestamp_micros: builtins.int = ...
    """The cell's stored timestamp, which also uniquely identifies it within
    its column.
    Values are always expressed in microseconds, but individual tables may set
    a coarser granularity to further restrict the allowed values. For
    example, a table which specifies millisecond granularity will only allow
    values of `timestamp_micros` which are multiples of 1000.
    """

    value: builtins.bytes = ...
    """The value stored in the cell.
    May contain any byte string, including the empty string, up to 100MiB in
    length.
    """

    @property
    def labels(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Labels applied to the cell by a [RowFilter][google.bigtable.v2.RowFilter]."""
        pass
    def __init__(self,
        *,
        timestamp_micros : builtins.int = ...,
        value : builtins.bytes = ...,
        labels : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["labels",b"labels","timestamp_micros",b"timestamp_micros","value",b"value"]) -> None: ...
global___Cell = Cell

class RowRange(google.protobuf.message.Message):
    """Specifies a contiguous range of rows."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    START_KEY_CLOSED_FIELD_NUMBER: builtins.int
    START_KEY_OPEN_FIELD_NUMBER: builtins.int
    END_KEY_OPEN_FIELD_NUMBER: builtins.int
    END_KEY_CLOSED_FIELD_NUMBER: builtins.int
    start_key_closed: builtins.bytes = ...
    """Used when giving an inclusive lower bound for the range."""

    start_key_open: builtins.bytes = ...
    """Used when giving an exclusive lower bound for the range."""

    end_key_open: builtins.bytes = ...
    """Used when giving an exclusive upper bound for the range."""

    end_key_closed: builtins.bytes = ...
    """Used when giving an inclusive upper bound for the range."""

    def __init__(self,
        *,
        start_key_closed : builtins.bytes = ...,
        start_key_open : builtins.bytes = ...,
        end_key_open : builtins.bytes = ...,
        end_key_closed : builtins.bytes = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_key",b"end_key","end_key_closed",b"end_key_closed","end_key_open",b"end_key_open","start_key",b"start_key","start_key_closed",b"start_key_closed","start_key_open",b"start_key_open"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["end_key",b"end_key","end_key_closed",b"end_key_closed","end_key_open",b"end_key_open","start_key",b"start_key","start_key_closed",b"start_key_closed","start_key_open",b"start_key_open"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["end_key",b"end_key"]) -> typing.Optional[typing_extensions.Literal["end_key_open","end_key_closed"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["start_key",b"start_key"]) -> typing.Optional[typing_extensions.Literal["start_key_closed","start_key_open"]]: ...
global___RowRange = RowRange

class RowSet(google.protobuf.message.Message):
    """Specifies a non-contiguous set of rows."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ROW_KEYS_FIELD_NUMBER: builtins.int
    ROW_RANGES_FIELD_NUMBER: builtins.int
    @property
    def row_keys(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]:
        """Single rows included in the set."""
        pass
    @property
    def row_ranges(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RowRange]:
        """Contiguous row ranges included in the set."""
        pass
    def __init__(self,
        *,
        row_keys : typing.Optional[typing.Iterable[builtins.bytes]] = ...,
        row_ranges : typing.Optional[typing.Iterable[global___RowRange]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["row_keys",b"row_keys","row_ranges",b"row_ranges"]) -> None: ...
global___RowSet = RowSet

class ColumnRange(google.protobuf.message.Message):
    """Specifies a contiguous range of columns within a single column family.
    The range spans from &lt;column_family&gt;:&lt;start_qualifier&gt; to
    &lt;column_family&gt;:&lt;end_qualifier&gt;, where both bounds can be either
    inclusive or exclusive.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FAMILY_NAME_FIELD_NUMBER: builtins.int
    START_QUALIFIER_CLOSED_FIELD_NUMBER: builtins.int
    START_QUALIFIER_OPEN_FIELD_NUMBER: builtins.int
    END_QUALIFIER_CLOSED_FIELD_NUMBER: builtins.int
    END_QUALIFIER_OPEN_FIELD_NUMBER: builtins.int
    family_name: typing.Text = ...
    """The name of the column family within which this range falls."""

    start_qualifier_closed: builtins.bytes = ...
    """Used when giving an inclusive lower bound for the range."""

    start_qualifier_open: builtins.bytes = ...
    """Used when giving an exclusive lower bound for the range."""

    end_qualifier_closed: builtins.bytes = ...
    """Used when giving an inclusive upper bound for the range."""

    end_qualifier_open: builtins.bytes = ...
    """Used when giving an exclusive upper bound for the range."""

    def __init__(self,
        *,
        family_name : typing.Text = ...,
        start_qualifier_closed : builtins.bytes = ...,
        start_qualifier_open : builtins.bytes = ...,
        end_qualifier_closed : builtins.bytes = ...,
        end_qualifier_open : builtins.bytes = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_qualifier",b"end_qualifier","end_qualifier_closed",b"end_qualifier_closed","end_qualifier_open",b"end_qualifier_open","start_qualifier",b"start_qualifier","start_qualifier_closed",b"start_qualifier_closed","start_qualifier_open",b"start_qualifier_open"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["end_qualifier",b"end_qualifier","end_qualifier_closed",b"end_qualifier_closed","end_qualifier_open",b"end_qualifier_open","family_name",b"family_name","start_qualifier",b"start_qualifier","start_qualifier_closed",b"start_qualifier_closed","start_qualifier_open",b"start_qualifier_open"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["end_qualifier",b"end_qualifier"]) -> typing.Optional[typing_extensions.Literal["end_qualifier_closed","end_qualifier_open"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["start_qualifier",b"start_qualifier"]) -> typing.Optional[typing_extensions.Literal["start_qualifier_closed","start_qualifier_open"]]: ...
global___ColumnRange = ColumnRange

class TimestampRange(google.protobuf.message.Message):
    """Specified a contiguous range of microsecond timestamps."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    START_TIMESTAMP_MICROS_FIELD_NUMBER: builtins.int
    END_TIMESTAMP_MICROS_FIELD_NUMBER: builtins.int
    start_timestamp_micros: builtins.int = ...
    """Inclusive lower bound. If left empty, interpreted as 0."""

    end_timestamp_micros: builtins.int = ...
    """Exclusive upper bound. If left empty, interpreted as infinity."""

    def __init__(self,
        *,
        start_timestamp_micros : builtins.int = ...,
        end_timestamp_micros : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["end_timestamp_micros",b"end_timestamp_micros","start_timestamp_micros",b"start_timestamp_micros"]) -> None: ...
global___TimestampRange = TimestampRange

class ValueRange(google.protobuf.message.Message):
    """Specifies a contiguous range of raw byte values."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    START_VALUE_CLOSED_FIELD_NUMBER: builtins.int
    START_VALUE_OPEN_FIELD_NUMBER: builtins.int
    END_VALUE_CLOSED_FIELD_NUMBER: builtins.int
    END_VALUE_OPEN_FIELD_NUMBER: builtins.int
    start_value_closed: builtins.bytes = ...
    """Used when giving an inclusive lower bound for the range."""

    start_value_open: builtins.bytes = ...
    """Used when giving an exclusive lower bound for the range."""

    end_value_closed: builtins.bytes = ...
    """Used when giving an inclusive upper bound for the range."""

    end_value_open: builtins.bytes = ...
    """Used when giving an exclusive upper bound for the range."""

    def __init__(self,
        *,
        start_value_closed : builtins.bytes = ...,
        start_value_open : builtins.bytes = ...,
        end_value_closed : builtins.bytes = ...,
        end_value_open : builtins.bytes = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_value",b"end_value","end_value_closed",b"end_value_closed","end_value_open",b"end_value_open","start_value",b"start_value","start_value_closed",b"start_value_closed","start_value_open",b"start_value_open"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["end_value",b"end_value","end_value_closed",b"end_value_closed","end_value_open",b"end_value_open","start_value",b"start_value","start_value_closed",b"start_value_closed","start_value_open",b"start_value_open"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["end_value",b"end_value"]) -> typing.Optional[typing_extensions.Literal["end_value_closed","end_value_open"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["start_value",b"start_value"]) -> typing.Optional[typing_extensions.Literal["start_value_closed","start_value_open"]]: ...
global___ValueRange = ValueRange

class RowFilter(google.protobuf.message.Message):
    """Takes a row as input and produces an alternate view of the row based on
    specified rules. For example, a RowFilter might trim down a row to include
    just the cells from columns matching a given regular expression, or might
    return all the cells of a row but not their values. More complicated filters
    can be composed out of these components to express requests such as, "within
    every column of a particular family, give just the two most recent cells
    which are older than timestamp X."

    There are two broad categories of RowFilters (true filters and transformers),
    as well as two ways to compose simple filters into more complex ones
    (chains and interleaves). They work as follows:

    * True filters alter the input row by excluding some of its cells wholesale
    from the output row. An example of a true filter is the `value_regex_filter`,
    which excludes cells whose values don't match the specified pattern. All
    regex true filters use RE2 syntax (https://github.com/google/re2/wiki/Syntax)
    in raw byte mode (RE2::Latin1), and are evaluated as full matches. An
    important point to keep in mind is that `RE2(.)` is equivalent by default to
    `RE2([^\\n])`, meaning that it does not match newlines. When attempting to
    match an arbitrary byte, you should therefore use the escape sequence `\\C`,
    which may need to be further escaped as `\\\\C` in your client language.

    * Transformers alter the input row by changing the values of some of its
    cells in the output, without excluding them completely. Currently, the only
    supported transformer is the `strip_value_transformer`, which replaces every
    cell's value with the empty string.

    * Chains and interleaves are described in more detail in the
    RowFilter.Chain and RowFilter.Interleave documentation.

    The total serialized size of a RowFilter message must not
    exceed 4096 bytes, and RowFilters may not be nested within each other
    (in Chains or Interleaves) to a depth of more than 20.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Chain(google.protobuf.message.Message):
        """A RowFilter which sends rows through several RowFilters in sequence."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FILTERS_FIELD_NUMBER: builtins.int
        @property
        def filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RowFilter]:
            """The elements of "filters" are chained together to process the input row:
            in row -> f(0) -> intermediate row -> f(1) -> ... -> f(N) -> out row
            The full chain is executed atomically.
            """
            pass
        def __init__(self,
            *,
            filters : typing.Optional[typing.Iterable[global___RowFilter]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["filters",b"filters"]) -> None: ...

    class Interleave(google.protobuf.message.Message):
        """A RowFilter which sends each row to each of several component
        RowFilters and interleaves the results.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FILTERS_FIELD_NUMBER: builtins.int
        @property
        def filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RowFilter]:
            """The elements of "filters" all process a copy of the input row, and the
            results are pooled, sorted, and combined into a single output row.
            If multiple cells are produced with the same column and timestamp,
            they will all appear in the output row in an unspecified mutual order.
            Consider the following example, with three filters:

                                             input row
                                                 |
                       -----------------------------------------------------
                       |                         |                         |
                      f(0)                      f(1)                      f(2)
                       |                         |                         |
                1: foo,bar,10,x             foo,bar,10,z              far,bar,7,a
                2: foo,blah,11,z            far,blah,5,x              far,blah,5,x
                       |                         |                         |
                       -----------------------------------------------------
                                                 |
                1:                      foo,bar,10,z   // could have switched with #2
                2:                      foo,bar,10,x   // could have switched with #1
                3:                      foo,blah,11,z
                4:                      far,bar,7,a
                5:                      far,blah,5,x   // identical to #6
                6:                      far,blah,5,x   // identical to #5

            All interleaved filters are executed atomically.
            """
            pass
        def __init__(self,
            *,
            filters : typing.Optional[typing.Iterable[global___RowFilter]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["filters",b"filters"]) -> None: ...

    class Condition(google.protobuf.message.Message):
        """A RowFilter which evaluates one of two possible RowFilters, depending on
        whether or not a predicate RowFilter outputs any cells from the input row.

        IMPORTANT NOTE: The predicate filter does not execute atomically with the
        true and false filters, which may lead to inconsistent or unexpected
        results. Additionally, Condition filters have poor performance, especially
        when filters are set for the false condition.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        PREDICATE_FILTER_FIELD_NUMBER: builtins.int
        TRUE_FILTER_FIELD_NUMBER: builtins.int
        FALSE_FILTER_FIELD_NUMBER: builtins.int
        @property
        def predicate_filter(self) -> global___RowFilter:
            """If `predicate_filter` outputs any cells, then `true_filter` will be
            evaluated on the input row. Otherwise, `false_filter` will be evaluated.
            """
            pass
        @property
        def true_filter(self) -> global___RowFilter:
            """The filter to apply to the input row if `predicate_filter` returns any
            results. If not provided, no results will be returned in the true case.
            """
            pass
        @property
        def false_filter(self) -> global___RowFilter:
            """The filter to apply to the input row if `predicate_filter` does not
            return any results. If not provided, no results will be returned in the
            false case.
            """
            pass
        def __init__(self,
            *,
            predicate_filter : typing.Optional[global___RowFilter] = ...,
            true_filter : typing.Optional[global___RowFilter] = ...,
            false_filter : typing.Optional[global___RowFilter] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["false_filter",b"false_filter","predicate_filter",b"predicate_filter","true_filter",b"true_filter"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["false_filter",b"false_filter","predicate_filter",b"predicate_filter","true_filter",b"true_filter"]) -> None: ...

    CHAIN_FIELD_NUMBER: builtins.int
    INTERLEAVE_FIELD_NUMBER: builtins.int
    CONDITION_FIELD_NUMBER: builtins.int
    SINK_FIELD_NUMBER: builtins.int
    PASS_ALL_FILTER_FIELD_NUMBER: builtins.int
    BLOCK_ALL_FILTER_FIELD_NUMBER: builtins.int
    ROW_KEY_REGEX_FILTER_FIELD_NUMBER: builtins.int
    ROW_SAMPLE_FILTER_FIELD_NUMBER: builtins.int
    FAMILY_NAME_REGEX_FILTER_FIELD_NUMBER: builtins.int
    COLUMN_QUALIFIER_REGEX_FILTER_FIELD_NUMBER: builtins.int
    COLUMN_RANGE_FILTER_FIELD_NUMBER: builtins.int
    TIMESTAMP_RANGE_FILTER_FIELD_NUMBER: builtins.int
    VALUE_REGEX_FILTER_FIELD_NUMBER: builtins.int
    VALUE_RANGE_FILTER_FIELD_NUMBER: builtins.int
    CELLS_PER_ROW_OFFSET_FILTER_FIELD_NUMBER: builtins.int
    CELLS_PER_ROW_LIMIT_FILTER_FIELD_NUMBER: builtins.int
    CELLS_PER_COLUMN_LIMIT_FILTER_FIELD_NUMBER: builtins.int
    STRIP_VALUE_TRANSFORMER_FIELD_NUMBER: builtins.int
    APPLY_LABEL_TRANSFORMER_FIELD_NUMBER: builtins.int
    @property
    def chain(self) -> global___RowFilter.Chain:
        """Applies several RowFilters to the data in sequence, progressively
        narrowing the results.
        """
        pass
    @property
    def interleave(self) -> global___RowFilter.Interleave:
        """Applies several RowFilters to the data in parallel and combines the
        results.
        """
        pass
    @property
    def condition(self) -> global___RowFilter.Condition:
        """Applies one of two possible RowFilters to the data based on the output of
        a predicate RowFilter.
        """
        pass
    sink: builtins.bool = ...
    """ADVANCED USE ONLY.
    Hook for introspection into the RowFilter. Outputs all cells directly to
    the output of the read rather than to any parent filter. Consider the
    following example:

        Chain(
          FamilyRegex("A"),
          Interleave(
            All(),
            Chain(Label("foo"), Sink())
          ),
          QualifierRegex("B")
        )

                            A,A,1,w
                            A,B,2,x
                            B,B,4,z
                               |
                        FamilyRegex("A")
                               |
                            A,A,1,w
                            A,B,2,x
                               |
                  +------------+-------------+
                  |                          |
                All()                    Label(foo)
                  |                          |
               A,A,1,w              A,A,1,w,labels:[foo]
               A,B,2,x              A,B,2,x,labels:[foo]
                  |                          |
                  |                        Sink() --------------+
                  |                          |                  |
                  +------------+      x------+          A,A,1,w,labels:[foo]
                               |                        A,B,2,x,labels:[foo]
                            A,A,1,w                             |
                            A,B,2,x                             |
                               |                                |
                       QualifierRegex("B")                      |
                               |                                |
                            A,B,2,x                             |
                               |                                |
                               +--------------------------------+
                               |
                            A,A,1,w,labels:[foo]
                            A,B,2,x,labels:[foo]  // could be switched
                            A,B,2,x               // could be switched

    Despite being excluded by the qualifier filter, a copy of every cell
    that reaches the sink is present in the final result.

    As with an [Interleave][google.bigtable.v2.RowFilter.Interleave],
    duplicate cells are possible, and appear in an unspecified mutual order.
    In this case we have a duplicate with column "A:B" and timestamp 2,
    because one copy passed through the all filter while the other was
    passed through the label and sink. Note that one copy has label "foo",
    while the other does not.

    Cannot be used within the `predicate_filter`, `true_filter`, or
    `false_filter` of a [Condition][google.bigtable.v2.RowFilter.Condition].
    """

    pass_all_filter: builtins.bool = ...
    """Matches all cells, regardless of input. Functionally equivalent to
    leaving `filter` unset, but included for completeness.
    """

    block_all_filter: builtins.bool = ...
    """Does not match any cells, regardless of input. Useful for temporarily
    disabling just part of a filter.
    """

    row_key_regex_filter: builtins.bytes = ...
    """Matches only cells from rows whose keys satisfy the given RE2 regex. In
    other words, passes through the entire row when the key matches, and
    otherwise produces an empty row.
    Note that, since row keys can contain arbitrary bytes, the `\\C` escape
    sequence must be used if a true wildcard is desired. The `.` character
    will not match the new line character `\\n`, which may be present in a
    binary key.
    """

    row_sample_filter: builtins.float = ...
    """Matches all cells from a row with probability p, and matches no cells
    from the row with probability 1-p.
    """

    family_name_regex_filter: typing.Text = ...
    """Matches only cells from columns whose families satisfy the given RE2
    regex. For technical reasons, the regex must not contain the `:`
    character, even if it is not being used as a literal.
    Note that, since column families cannot contain the new line character
    `\\n`, it is sufficient to use `.` as a full wildcard when matching
    column family names.
    """

    column_qualifier_regex_filter: builtins.bytes = ...
    """Matches only cells from columns whose qualifiers satisfy the given RE2
    regex.
    Note that, since column qualifiers can contain arbitrary bytes, the `\\C`
    escape sequence must be used if a true wildcard is desired. The `.`
    character will not match the new line character `\\n`, which may be
    present in a binary qualifier.
    """

    @property
    def column_range_filter(self) -> global___ColumnRange:
        """Matches only cells from columns within the given range."""
        pass
    @property
    def timestamp_range_filter(self) -> global___TimestampRange:
        """Matches only cells with timestamps within the given range."""
        pass
    value_regex_filter: builtins.bytes = ...
    """Matches only cells with values that satisfy the given regular expression.
    Note that, since cell values can contain arbitrary bytes, the `\\C` escape
    sequence must be used if a true wildcard is desired. The `.` character
    will not match the new line character `\\n`, which may be present in a
    binary value.
    """

    @property
    def value_range_filter(self) -> global___ValueRange:
        """Matches only cells with values that fall within the given range."""
        pass
    cells_per_row_offset_filter: builtins.int = ...
    """Skips the first N cells of each row, matching all subsequent cells.
    If duplicate cells are present, as is possible when using an Interleave,
    each copy of the cell is counted separately.
    """

    cells_per_row_limit_filter: builtins.int = ...
    """Matches only the first N cells of each row.
    If duplicate cells are present, as is possible when using an Interleave,
    each copy of the cell is counted separately.
    """

    cells_per_column_limit_filter: builtins.int = ...
    """Matches only the most recent N cells within each column. For example,
    if N=2, this filter would match column `foo:bar` at timestamps 10 and 9,
    skip all earlier cells in `foo:bar`, and then begin matching again in
    column `foo:bar2`.
    If duplicate cells are present, as is possible when using an Interleave,
    each copy of the cell is counted separately.
    """

    strip_value_transformer: builtins.bool = ...
    """Replaces each cell's value with the empty string."""

    apply_label_transformer: typing.Text = ...
    """Applies the given label to all cells in the output row. This allows
    the client to determine which results were produced from which part of
    the filter.

    Values must be at most 15 characters in length, and match the RE2
    pattern `[a-z0-9\\\\-]+`

    Due to a technical limitation, it is not currently possible to apply
    multiple labels to a cell. As a result, a Chain may have no more than
    one sub-filter which contains a `apply_label_transformer`. It is okay for
    an Interleave to contain multiple `apply_label_transformers`, as they
    will be applied to separate copies of the input. This may be relaxed in
    the future.
    """

    def __init__(self,
        *,
        chain : typing.Optional[global___RowFilter.Chain] = ...,
        interleave : typing.Optional[global___RowFilter.Interleave] = ...,
        condition : typing.Optional[global___RowFilter.Condition] = ...,
        sink : builtins.bool = ...,
        pass_all_filter : builtins.bool = ...,
        block_all_filter : builtins.bool = ...,
        row_key_regex_filter : builtins.bytes = ...,
        row_sample_filter : builtins.float = ...,
        family_name_regex_filter : typing.Text = ...,
        column_qualifier_regex_filter : builtins.bytes = ...,
        column_range_filter : typing.Optional[global___ColumnRange] = ...,
        timestamp_range_filter : typing.Optional[global___TimestampRange] = ...,
        value_regex_filter : builtins.bytes = ...,
        value_range_filter : typing.Optional[global___ValueRange] = ...,
        cells_per_row_offset_filter : builtins.int = ...,
        cells_per_row_limit_filter : builtins.int = ...,
        cells_per_column_limit_filter : builtins.int = ...,
        strip_value_transformer : builtins.bool = ...,
        apply_label_transformer : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["apply_label_transformer",b"apply_label_transformer","block_all_filter",b"block_all_filter","cells_per_column_limit_filter",b"cells_per_column_limit_filter","cells_per_row_limit_filter",b"cells_per_row_limit_filter","cells_per_row_offset_filter",b"cells_per_row_offset_filter","chain",b"chain","column_qualifier_regex_filter",b"column_qualifier_regex_filter","column_range_filter",b"column_range_filter","condition",b"condition","family_name_regex_filter",b"family_name_regex_filter","filter",b"filter","interleave",b"interleave","pass_all_filter",b"pass_all_filter","row_key_regex_filter",b"row_key_regex_filter","row_sample_filter",b"row_sample_filter","sink",b"sink","strip_value_transformer",b"strip_value_transformer","timestamp_range_filter",b"timestamp_range_filter","value_range_filter",b"value_range_filter","value_regex_filter",b"value_regex_filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["apply_label_transformer",b"apply_label_transformer","block_all_filter",b"block_all_filter","cells_per_column_limit_filter",b"cells_per_column_limit_filter","cells_per_row_limit_filter",b"cells_per_row_limit_filter","cells_per_row_offset_filter",b"cells_per_row_offset_filter","chain",b"chain","column_qualifier_regex_filter",b"column_qualifier_regex_filter","column_range_filter",b"column_range_filter","condition",b"condition","family_name_regex_filter",b"family_name_regex_filter","filter",b"filter","interleave",b"interleave","pass_all_filter",b"pass_all_filter","row_key_regex_filter",b"row_key_regex_filter","row_sample_filter",b"row_sample_filter","sink",b"sink","strip_value_transformer",b"strip_value_transformer","timestamp_range_filter",b"timestamp_range_filter","value_range_filter",b"value_range_filter","value_regex_filter",b"value_regex_filter"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["filter",b"filter"]) -> typing.Optional[typing_extensions.Literal["chain","interleave","condition","sink","pass_all_filter","block_all_filter","row_key_regex_filter","row_sample_filter","family_name_regex_filter","column_qualifier_regex_filter","column_range_filter","timestamp_range_filter","value_regex_filter","value_range_filter","cells_per_row_offset_filter","cells_per_row_limit_filter","cells_per_column_limit_filter","strip_value_transformer","apply_label_transformer"]]: ...
global___RowFilter = RowFilter

class Mutation(google.protobuf.message.Message):
    """Specifies a particular change to be made to the contents of a row."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class SetCell(google.protobuf.message.Message):
        """A Mutation which sets the value of the specified cell."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FAMILY_NAME_FIELD_NUMBER: builtins.int
        COLUMN_QUALIFIER_FIELD_NUMBER: builtins.int
        TIMESTAMP_MICROS_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        family_name: typing.Text = ...
        """The name of the family into which new data should be written.
        Must match `[-_.a-zA-Z0-9]+`
        """

        column_qualifier: builtins.bytes = ...
        """The qualifier of the column into which new data should be written.
        Can be any byte string, including the empty string.
        """

        timestamp_micros: builtins.int = ...
        """The timestamp of the cell into which new data should be written.
        Use -1 for current Bigtable server time.
        Otherwise, the client should set this value itself, noting that the
        default value is a timestamp of zero if the field is left unspecified.
        Values must match the granularity of the table (e.g. micros, millis).
        """

        value: builtins.bytes = ...
        """The value to be written into the specified cell."""

        def __init__(self,
            *,
            family_name : typing.Text = ...,
            column_qualifier : builtins.bytes = ...,
            timestamp_micros : builtins.int = ...,
            value : builtins.bytes = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["column_qualifier",b"column_qualifier","family_name",b"family_name","timestamp_micros",b"timestamp_micros","value",b"value"]) -> None: ...

    class DeleteFromColumn(google.protobuf.message.Message):
        """A Mutation which deletes cells from the specified column, optionally
        restricting the deletions to a given timestamp range.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FAMILY_NAME_FIELD_NUMBER: builtins.int
        COLUMN_QUALIFIER_FIELD_NUMBER: builtins.int
        TIME_RANGE_FIELD_NUMBER: builtins.int
        family_name: typing.Text = ...
        """The name of the family from which cells should be deleted.
        Must match `[-_.a-zA-Z0-9]+`
        """

        column_qualifier: builtins.bytes = ...
        """The qualifier of the column from which cells should be deleted.
        Can be any byte string, including the empty string.
        """

        @property
        def time_range(self) -> global___TimestampRange:
            """The range of timestamps within which cells should be deleted."""
            pass
        def __init__(self,
            *,
            family_name : typing.Text = ...,
            column_qualifier : builtins.bytes = ...,
            time_range : typing.Optional[global___TimestampRange] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["time_range",b"time_range"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["column_qualifier",b"column_qualifier","family_name",b"family_name","time_range",b"time_range"]) -> None: ...

    class DeleteFromFamily(google.protobuf.message.Message):
        """A Mutation which deletes all cells from the specified column family."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        FAMILY_NAME_FIELD_NUMBER: builtins.int
        family_name: typing.Text = ...
        """The name of the family from which cells should be deleted.
        Must match `[-_.a-zA-Z0-9]+`
        """

        def __init__(self,
            *,
            family_name : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["family_name",b"family_name"]) -> None: ...

    class DeleteFromRow(google.protobuf.message.Message):
        """A Mutation which deletes all cells from the containing row."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        def __init__(self,
            ) -> None: ...

    SET_CELL_FIELD_NUMBER: builtins.int
    DELETE_FROM_COLUMN_FIELD_NUMBER: builtins.int
    DELETE_FROM_FAMILY_FIELD_NUMBER: builtins.int
    DELETE_FROM_ROW_FIELD_NUMBER: builtins.int
    @property
    def set_cell(self) -> global___Mutation.SetCell:
        """Set a cell's value."""
        pass
    @property
    def delete_from_column(self) -> global___Mutation.DeleteFromColumn:
        """Deletes cells from a column."""
        pass
    @property
    def delete_from_family(self) -> global___Mutation.DeleteFromFamily:
        """Deletes cells from a column family."""
        pass
    @property
    def delete_from_row(self) -> global___Mutation.DeleteFromRow:
        """Deletes cells from the entire row."""
        pass
    def __init__(self,
        *,
        set_cell : typing.Optional[global___Mutation.SetCell] = ...,
        delete_from_column : typing.Optional[global___Mutation.DeleteFromColumn] = ...,
        delete_from_family : typing.Optional[global___Mutation.DeleteFromFamily] = ...,
        delete_from_row : typing.Optional[global___Mutation.DeleteFromRow] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["delete_from_column",b"delete_from_column","delete_from_family",b"delete_from_family","delete_from_row",b"delete_from_row","mutation",b"mutation","set_cell",b"set_cell"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["delete_from_column",b"delete_from_column","delete_from_family",b"delete_from_family","delete_from_row",b"delete_from_row","mutation",b"mutation","set_cell",b"set_cell"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["mutation",b"mutation"]) -> typing.Optional[typing_extensions.Literal["set_cell","delete_from_column","delete_from_family","delete_from_row"]]: ...
global___Mutation = Mutation

class ReadModifyWriteRule(google.protobuf.message.Message):
    """Specifies an atomic read/modify/write operation on the latest value of the
    specified column.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FAMILY_NAME_FIELD_NUMBER: builtins.int
    COLUMN_QUALIFIER_FIELD_NUMBER: builtins.int
    APPEND_VALUE_FIELD_NUMBER: builtins.int
    INCREMENT_AMOUNT_FIELD_NUMBER: builtins.int
    family_name: typing.Text = ...
    """The name of the family to which the read/modify/write should be applied.
    Must match `[-_.a-zA-Z0-9]+`
    """

    column_qualifier: builtins.bytes = ...
    """The qualifier of the column to which the read/modify/write should be
    applied.
    Can be any byte string, including the empty string.
    """

    append_value: builtins.bytes = ...
    """Rule specifying that `append_value` be appended to the existing value.
    If the targeted cell is unset, it will be treated as containing the
    empty string.
    """

    increment_amount: builtins.int = ...
    """Rule specifying that `increment_amount` be added to the existing value.
    If the targeted cell is unset, it will be treated as containing a zero.
    Otherwise, the targeted cell must contain an 8-byte value (interpreted
    as a 64-bit big-endian signed integer), or the entire request will fail.
    """

    def __init__(self,
        *,
        family_name : typing.Text = ...,
        column_qualifier : builtins.bytes = ...,
        append_value : builtins.bytes = ...,
        increment_amount : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["append_value",b"append_value","increment_amount",b"increment_amount","rule",b"rule"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["append_value",b"append_value","column_qualifier",b"column_qualifier","family_name",b"family_name","increment_amount",b"increment_amount","rule",b"rule"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["rule",b"rule"]) -> typing.Optional[typing_extensions.Literal["append_value","increment_amount"]]: ...
global___ReadModifyWriteRule = ReadModifyWriteRule
