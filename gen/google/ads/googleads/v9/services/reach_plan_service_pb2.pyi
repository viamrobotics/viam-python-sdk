"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.ads.googleads.v9.common.criteria_pb2
import google.ads.googleads.v9.common.dates_pb2
import google.ads.googleads.v9.enums.frequency_cap_time_unit_pb2
import google.ads.googleads.v9.enums.reach_plan_ad_length_pb2
import google.ads.googleads.v9.enums.reach_plan_age_range_pb2
import google.ads.googleads.v9.enums.reach_plan_network_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class ListPlannableLocationsRequest(google.protobuf.message.Message):
    """Request message for [ReachPlanService.ListPlannableLocations][google.ads.googleads.v9.services.ReachPlanService.ListPlannableLocations]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___ListPlannableLocationsRequest = ListPlannableLocationsRequest

class ListPlannableLocationsResponse(google.protobuf.message.Message):
    """The list of plannable locations."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PLANNABLE_LOCATIONS_FIELD_NUMBER: builtins.int
    @property
    def plannable_locations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PlannableLocation]:
        """The list of locations available for planning (Countries, DMAs,
        sub-countries).
        For locations like Countries and DMAs see
        https://developers.google.com/google-ads/api/reference/data/geotargets for
        more information.
        """
        pass
    def __init__(self,
        *,
        plannable_locations : typing.Optional[typing.Iterable[global___PlannableLocation]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["plannable_locations",b"plannable_locations"]) -> None: ...
global___ListPlannableLocationsResponse = ListPlannableLocationsResponse

class PlannableLocation(google.protobuf.message.Message):
    """A plannable location: a country, a DMA, a metro region, a tv region,
    a province.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    PARENT_COUNTRY_ID_FIELD_NUMBER: builtins.int
    COUNTRY_CODE_FIELD_NUMBER: builtins.int
    LOCATION_TYPE_FIELD_NUMBER: builtins.int
    id: typing.Text = ...
    """The location identifier."""

    name: typing.Text = ...
    """The unique location name in english."""

    parent_country_id: builtins.int = ...
    """The parent country, not present if location is a country.
    If present will always be a GeoTargetConstant ID. Additional information,
    such as country name is provided by
    [ReachPlanService.ListPlannableLocations][google.ads.googleads.v9.services.ReachPlanService.ListPlannableLocations] or directly by accessing
    [GeoTargetConstantService.GetGeoTargetConstant][google.ads.googleads.v9.services.GeoTargetConstantService.GetGeoTargetConstant].
    """

    country_code: typing.Text = ...
    """The ISO-3166-1 alpha-2 country code that is associated with the location."""

    location_type: typing.Text = ...
    """The location's type. Location types correspond to target_type returned by
    [GeoTargetConstantService.GetGeoTargetConstant][google.ads.googleads.v9.services.GeoTargetConstantService.GetGeoTargetConstant].
    """

    def __init__(self,
        *,
        id : typing.Optional[typing.Text] = ...,
        name : typing.Optional[typing.Text] = ...,
        parent_country_id : typing.Optional[builtins.int] = ...,
        country_code : typing.Optional[typing.Text] = ...,
        location_type : typing.Optional[typing.Text] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_country_code",b"_country_code","_id",b"_id","_location_type",b"_location_type","_name",b"_name","_parent_country_id",b"_parent_country_id","country_code",b"country_code","id",b"id","location_type",b"location_type","name",b"name","parent_country_id",b"parent_country_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_country_code",b"_country_code","_id",b"_id","_location_type",b"_location_type","_name",b"_name","_parent_country_id",b"_parent_country_id","country_code",b"country_code","id",b"id","location_type",b"location_type","name",b"name","parent_country_id",b"parent_country_id"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_country_code",b"_country_code"]) -> typing.Optional[typing_extensions.Literal["country_code"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_id",b"_id"]) -> typing.Optional[typing_extensions.Literal["id"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_location_type",b"_location_type"]) -> typing.Optional[typing_extensions.Literal["location_type"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_name",b"_name"]) -> typing.Optional[typing_extensions.Literal["name"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_parent_country_id",b"_parent_country_id"]) -> typing.Optional[typing_extensions.Literal["parent_country_id"]]: ...
global___PlannableLocation = PlannableLocation

class ListPlannableProductsRequest(google.protobuf.message.Message):
    """Request to list available products in a given location."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PLANNABLE_LOCATION_ID_FIELD_NUMBER: builtins.int
    plannable_location_id: typing.Text = ...
    """Required. The ID of the selected location for planning. To list the available
    plannable location ids use [ReachPlanService.ListPlannableLocations][google.ads.googleads.v9.services.ReachPlanService.ListPlannableLocations].
    """

    def __init__(self,
        *,
        plannable_location_id : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["plannable_location_id",b"plannable_location_id"]) -> None: ...
global___ListPlannableProductsRequest = ListPlannableProductsRequest

class ListPlannableProductsResponse(google.protobuf.message.Message):
    """A response with all available products."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PRODUCT_METADATA_FIELD_NUMBER: builtins.int
    @property
    def product_metadata(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ProductMetadata]:
        """The list of products available for planning and related targeting metadata."""
        pass
    def __init__(self,
        *,
        product_metadata : typing.Optional[typing.Iterable[global___ProductMetadata]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["product_metadata",b"product_metadata"]) -> None: ...
global___ListPlannableProductsResponse = ListPlannableProductsResponse

class ProductMetadata(google.protobuf.message.Message):
    """The metadata associated with an available plannable product."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PLANNABLE_PRODUCT_CODE_FIELD_NUMBER: builtins.int
    PLANNABLE_PRODUCT_NAME_FIELD_NUMBER: builtins.int
    PLANNABLE_TARGETING_FIELD_NUMBER: builtins.int
    plannable_product_code: typing.Text = ...
    """The code associated with the ad product. E.g. BUMPER, TRUEVIEW_IN_STREAM
    To list the available plannable product codes use ListPlannableProducts.
    """

    plannable_product_name: typing.Text = ...
    """The name associated with the ad product."""

    @property
    def plannable_targeting(self) -> global___PlannableTargeting:
        """The allowed plannable targeting for this product."""
        pass
    def __init__(self,
        *,
        plannable_product_code : typing.Optional[typing.Text] = ...,
        plannable_product_name : typing.Text = ...,
        plannable_targeting : typing.Optional[global___PlannableTargeting] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_plannable_product_code",b"_plannable_product_code","plannable_product_code",b"plannable_product_code","plannable_targeting",b"plannable_targeting"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_plannable_product_code",b"_plannable_product_code","plannable_product_code",b"plannable_product_code","plannable_product_name",b"plannable_product_name","plannable_targeting",b"plannable_targeting"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_plannable_product_code",b"_plannable_product_code"]) -> typing.Optional[typing_extensions.Literal["plannable_product_code"]]: ...
global___ProductMetadata = ProductMetadata

class PlannableTargeting(google.protobuf.message.Message):
    """The targeting for which traffic metrics will be reported."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    AGE_RANGES_FIELD_NUMBER: builtins.int
    GENDERS_FIELD_NUMBER: builtins.int
    DEVICES_FIELD_NUMBER: builtins.int
    NETWORKS_FIELD_NUMBER: builtins.int
    @property
    def age_ranges(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[google.ads.googleads.v9.enums.reach_plan_age_range_pb2.ReachPlanAgeRangeEnum.ReachPlanAgeRange.ValueType]:
        """Allowed plannable age ranges for the product for which metrics will be
        reported. Actual targeting is computed by mapping this age range onto
        standard Google common.AgeRangeInfo values.
        """
        pass
    @property
    def genders(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.ads.googleads.v9.common.criteria_pb2.GenderInfo]:
        """Targetable genders for the ad product."""
        pass
    @property
    def devices(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.ads.googleads.v9.common.criteria_pb2.DeviceInfo]:
        """Targetable devices for the ad product.
        TABLET device targeting is automatically applied to reported metrics
        when MOBILE targeting is selected for CPM_MASTHEAD,
        GOOGLE_PREFERRED_BUMPER and GOOGLE_PREFERRED_SHORT products.
        """
        pass
    @property
    def networks(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[google.ads.googleads.v9.enums.reach_plan_network_pb2.ReachPlanNetworkEnum.ReachPlanNetwork.ValueType]:
        """Targetable networks for the ad product."""
        pass
    def __init__(self,
        *,
        age_ranges : typing.Optional[typing.Iterable[google.ads.googleads.v9.enums.reach_plan_age_range_pb2.ReachPlanAgeRangeEnum.ReachPlanAgeRange.ValueType]] = ...,
        genders : typing.Optional[typing.Iterable[google.ads.googleads.v9.common.criteria_pb2.GenderInfo]] = ...,
        devices : typing.Optional[typing.Iterable[google.ads.googleads.v9.common.criteria_pb2.DeviceInfo]] = ...,
        networks : typing.Optional[typing.Iterable[google.ads.googleads.v9.enums.reach_plan_network_pb2.ReachPlanNetworkEnum.ReachPlanNetwork.ValueType]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["age_ranges",b"age_ranges","devices",b"devices","genders",b"genders","networks",b"networks"]) -> None: ...
global___PlannableTargeting = PlannableTargeting

class GenerateProductMixIdeasRequest(google.protobuf.message.Message):
    """Request message for [ReachPlanService.GenerateProductMixIdeas][google.ads.googleads.v9.services.ReachPlanService.GenerateProductMixIdeas]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CUSTOMER_ID_FIELD_NUMBER: builtins.int
    PLANNABLE_LOCATION_ID_FIELD_NUMBER: builtins.int
    CURRENCY_CODE_FIELD_NUMBER: builtins.int
    BUDGET_MICROS_FIELD_NUMBER: builtins.int
    PREFERENCES_FIELD_NUMBER: builtins.int
    customer_id: typing.Text = ...
    """Required. The ID of the customer."""

    plannable_location_id: typing.Text = ...
    """Required. The ID of the location, this is one of the ids returned by
    [ReachPlanService.ListPlannableLocations][google.ads.googleads.v9.services.ReachPlanService.ListPlannableLocations].
    """

    currency_code: typing.Text = ...
    """Required. Currency code.
    Three-character ISO 4217 currency code.
    """

    budget_micros: builtins.int = ...
    """Required. Total budget.
    Amount in micros. One million is equivalent to one unit.
    """

    @property
    def preferences(self) -> global___Preferences:
        """The preferences of the suggested product mix.
        An unset preference is interpreted as all possible values are allowed,
        unless explicitly specified.
        """
        pass
    def __init__(self,
        *,
        customer_id : typing.Text = ...,
        plannable_location_id : typing.Text = ...,
        currency_code : typing.Text = ...,
        budget_micros : builtins.int = ...,
        preferences : typing.Optional[global___Preferences] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["preferences",b"preferences"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["budget_micros",b"budget_micros","currency_code",b"currency_code","customer_id",b"customer_id","plannable_location_id",b"plannable_location_id","preferences",b"preferences"]) -> None: ...
global___GenerateProductMixIdeasRequest = GenerateProductMixIdeasRequest

class Preferences(google.protobuf.message.Message):
    """Set of preferences about the planned mix."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    IS_SKIPPABLE_FIELD_NUMBER: builtins.int
    STARTS_WITH_SOUND_FIELD_NUMBER: builtins.int
    AD_LENGTH_FIELD_NUMBER: builtins.int
    TOP_CONTENT_ONLY_FIELD_NUMBER: builtins.int
    HAS_GUARANTEED_PRICE_FIELD_NUMBER: builtins.int
    is_skippable: builtins.bool = ...
    """True if ad skippable.
    If not set, default is any value.
    """

    starts_with_sound: builtins.bool = ...
    """True if ad start with sound.
    If not set, default is any value.
    """

    ad_length: google.ads.googleads.v9.enums.reach_plan_ad_length_pb2.ReachPlanAdLengthEnum.ReachPlanAdLength.ValueType = ...
    """The length of the ad.
    If not set, default is any value.
    """

    top_content_only: builtins.bool = ...
    """True if ad will only show on the top content.
    If not set, default is false.
    """

    has_guaranteed_price: builtins.bool = ...
    """True if the price guaranteed. The cost of serving the ad is agreed upfront
    and not subject to an auction.
    If not set, default is any value.
    """

    def __init__(self,
        *,
        is_skippable : typing.Optional[builtins.bool] = ...,
        starts_with_sound : typing.Optional[builtins.bool] = ...,
        ad_length : google.ads.googleads.v9.enums.reach_plan_ad_length_pb2.ReachPlanAdLengthEnum.ReachPlanAdLength.ValueType = ...,
        top_content_only : typing.Optional[builtins.bool] = ...,
        has_guaranteed_price : typing.Optional[builtins.bool] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_has_guaranteed_price",b"_has_guaranteed_price","_is_skippable",b"_is_skippable","_starts_with_sound",b"_starts_with_sound","_top_content_only",b"_top_content_only","has_guaranteed_price",b"has_guaranteed_price","is_skippable",b"is_skippable","starts_with_sound",b"starts_with_sound","top_content_only",b"top_content_only"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_has_guaranteed_price",b"_has_guaranteed_price","_is_skippable",b"_is_skippable","_starts_with_sound",b"_starts_with_sound","_top_content_only",b"_top_content_only","ad_length",b"ad_length","has_guaranteed_price",b"has_guaranteed_price","is_skippable",b"is_skippable","starts_with_sound",b"starts_with_sound","top_content_only",b"top_content_only"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_has_guaranteed_price",b"_has_guaranteed_price"]) -> typing.Optional[typing_extensions.Literal["has_guaranteed_price"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_is_skippable",b"_is_skippable"]) -> typing.Optional[typing_extensions.Literal["is_skippable"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_starts_with_sound",b"_starts_with_sound"]) -> typing.Optional[typing_extensions.Literal["starts_with_sound"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_top_content_only",b"_top_content_only"]) -> typing.Optional[typing_extensions.Literal["top_content_only"]]: ...
global___Preferences = Preferences

class GenerateProductMixIdeasResponse(google.protobuf.message.Message):
    """The suggested product mix."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PRODUCT_ALLOCATION_FIELD_NUMBER: builtins.int
    @property
    def product_allocation(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ProductAllocation]:
        """A list of products (ad formats) and the associated budget allocation idea."""
        pass
    def __init__(self,
        *,
        product_allocation : typing.Optional[typing.Iterable[global___ProductAllocation]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["product_allocation",b"product_allocation"]) -> None: ...
global___GenerateProductMixIdeasResponse = GenerateProductMixIdeasResponse

class ProductAllocation(google.protobuf.message.Message):
    """An allocation of a part of the budget on a given product."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PLANNABLE_PRODUCT_CODE_FIELD_NUMBER: builtins.int
    BUDGET_MICROS_FIELD_NUMBER: builtins.int
    plannable_product_code: typing.Text = ...
    """Selected product for planning. The product codes returned are within the
    set of the ones returned by ListPlannableProducts when using the same
    location ID.
    """

    budget_micros: builtins.int = ...
    """The value to be allocated for the suggested product in requested currency.
    Amount in micros. One million is equivalent to one unit.
    """

    def __init__(self,
        *,
        plannable_product_code : typing.Optional[typing.Text] = ...,
        budget_micros : typing.Optional[builtins.int] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_budget_micros",b"_budget_micros","_plannable_product_code",b"_plannable_product_code","budget_micros",b"budget_micros","plannable_product_code",b"plannable_product_code"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_budget_micros",b"_budget_micros","_plannable_product_code",b"_plannable_product_code","budget_micros",b"budget_micros","plannable_product_code",b"plannable_product_code"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_budget_micros",b"_budget_micros"]) -> typing.Optional[typing_extensions.Literal["budget_micros"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_plannable_product_code",b"_plannable_product_code"]) -> typing.Optional[typing_extensions.Literal["plannable_product_code"]]: ...
global___ProductAllocation = ProductAllocation

class GenerateReachForecastRequest(google.protobuf.message.Message):
    """Request message for [ReachPlanService.GenerateReachForecast][google.ads.googleads.v9.services.ReachPlanService.GenerateReachForecast]."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CUSTOMER_ID_FIELD_NUMBER: builtins.int
    CURRENCY_CODE_FIELD_NUMBER: builtins.int
    CAMPAIGN_DURATION_FIELD_NUMBER: builtins.int
    COOKIE_FREQUENCY_CAP_FIELD_NUMBER: builtins.int
    COOKIE_FREQUENCY_CAP_SETTING_FIELD_NUMBER: builtins.int
    MIN_EFFECTIVE_FREQUENCY_FIELD_NUMBER: builtins.int
    EFFECTIVE_FREQUENCY_LIMIT_FIELD_NUMBER: builtins.int
    TARGETING_FIELD_NUMBER: builtins.int
    PLANNED_PRODUCTS_FIELD_NUMBER: builtins.int
    customer_id: typing.Text = ...
    """Required. The ID of the customer."""

    currency_code: typing.Text = ...
    """The currency code.
    Three-character ISO 4217 currency code.
    """

    @property
    def campaign_duration(self) -> global___CampaignDuration:
        """Required. Campaign duration."""
        pass
    cookie_frequency_cap: builtins.int = ...
    """Desired cookie frequency cap that will be applied to each planned product.
    This is equivalent to the frequency cap exposed in Google Ads when creating
    a campaign, it represents the maximum number of times an ad can be shown to
    the same user.
    If not specified no cap is applied.

    This field is deprecated in v4 and will eventually be removed.
    Please use cookie_frequency_cap_setting instead.
    """

    @property
    def cookie_frequency_cap_setting(self) -> global___FrequencyCap:
        """Desired cookie frequency cap that will be applied to each planned product.
        This is equivalent to the frequency cap exposed in Google Ads when creating
        a campaign, it represents the maximum number of times an ad can be shown to
        the same user during a specified time interval.
        If not specified, a default of 0 (no cap) is applied.

        This field replaces the deprecated cookie_frequency_cap field.
        """
        pass
    min_effective_frequency: builtins.int = ...
    """Desired minimum effective frequency (the number of times a person was
    exposed to the ad) for the reported reach metrics [1-10].
    This won't affect the targeting, but just the reporting.
    If not specified, a default of 1 is applied.

    This field cannot be combined with the effective_frequency_limit field.
    """

    @property
    def effective_frequency_limit(self) -> global___EffectiveFrequencyLimit:
        """The highest minimum effective frequency (the number of times a person was
        exposed to the ad) value [1-10] to include in
        Forecast.effective_frequency_breakdowns.
        If not specified, Forecast.effective_frequency_breakdowns will not be
        provided.

        The effective frequency value provided here will also be used as the
        minimum effective frequency for the reported reach metrics.

        This field cannot be combined with the min_effective_frequency field.
        """
        pass
    @property
    def targeting(self) -> global___Targeting:
        """The targeting to be applied to all products selected in the product mix.

        This is planned targeting: execution details might vary based on the
        advertising product, please consult an implementation specialist.

        See specific metrics for details on how targeting affects them.
        """
        pass
    @property
    def planned_products(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PlannedProduct]:
        """Required. The products to be forecast.
        The max number of allowed planned products is 15.
        """
        pass
    def __init__(self,
        *,
        customer_id : typing.Text = ...,
        currency_code : typing.Optional[typing.Text] = ...,
        campaign_duration : typing.Optional[global___CampaignDuration] = ...,
        cookie_frequency_cap : typing.Optional[builtins.int] = ...,
        cookie_frequency_cap_setting : typing.Optional[global___FrequencyCap] = ...,
        min_effective_frequency : typing.Optional[builtins.int] = ...,
        effective_frequency_limit : typing.Optional[global___EffectiveFrequencyLimit] = ...,
        targeting : typing.Optional[global___Targeting] = ...,
        planned_products : typing.Optional[typing.Iterable[global___PlannedProduct]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_cookie_frequency_cap",b"_cookie_frequency_cap","_currency_code",b"_currency_code","_effective_frequency_limit",b"_effective_frequency_limit","_min_effective_frequency",b"_min_effective_frequency","campaign_duration",b"campaign_duration","cookie_frequency_cap",b"cookie_frequency_cap","cookie_frequency_cap_setting",b"cookie_frequency_cap_setting","currency_code",b"currency_code","effective_frequency_limit",b"effective_frequency_limit","min_effective_frequency",b"min_effective_frequency","targeting",b"targeting"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_cookie_frequency_cap",b"_cookie_frequency_cap","_currency_code",b"_currency_code","_effective_frequency_limit",b"_effective_frequency_limit","_min_effective_frequency",b"_min_effective_frequency","campaign_duration",b"campaign_duration","cookie_frequency_cap",b"cookie_frequency_cap","cookie_frequency_cap_setting",b"cookie_frequency_cap_setting","currency_code",b"currency_code","customer_id",b"customer_id","effective_frequency_limit",b"effective_frequency_limit","min_effective_frequency",b"min_effective_frequency","planned_products",b"planned_products","targeting",b"targeting"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_cookie_frequency_cap",b"_cookie_frequency_cap"]) -> typing.Optional[typing_extensions.Literal["cookie_frequency_cap"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_currency_code",b"_currency_code"]) -> typing.Optional[typing_extensions.Literal["currency_code"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_effective_frequency_limit",b"_effective_frequency_limit"]) -> typing.Optional[typing_extensions.Literal["effective_frequency_limit"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_min_effective_frequency",b"_min_effective_frequency"]) -> typing.Optional[typing_extensions.Literal["min_effective_frequency"]]: ...
global___GenerateReachForecastRequest = GenerateReachForecastRequest

class EffectiveFrequencyLimit(google.protobuf.message.Message):
    """Effective frequency limit."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EFFECTIVE_FREQUENCY_BREAKDOWN_LIMIT_FIELD_NUMBER: builtins.int
    effective_frequency_breakdown_limit: builtins.int = ...
    """The highest effective frequency value to include in
    Forecast.effective_frequency_breakdowns.
    This field supports frequencies 1-10, inclusive.
    """

    def __init__(self,
        *,
        effective_frequency_breakdown_limit : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["effective_frequency_breakdown_limit",b"effective_frequency_breakdown_limit"]) -> None: ...
global___EffectiveFrequencyLimit = EffectiveFrequencyLimit

class FrequencyCap(google.protobuf.message.Message):
    """A rule specifying the maximum number of times an ad can be shown to a user
    over a particular time period.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    IMPRESSIONS_FIELD_NUMBER: builtins.int
    TIME_UNIT_FIELD_NUMBER: builtins.int
    impressions: builtins.int = ...
    """Required. The number of impressions, inclusive."""

    time_unit: google.ads.googleads.v9.enums.frequency_cap_time_unit_pb2.FrequencyCapTimeUnitEnum.FrequencyCapTimeUnit.ValueType = ...
    """Required. The type of time unit."""

    def __init__(self,
        *,
        impressions : builtins.int = ...,
        time_unit : google.ads.googleads.v9.enums.frequency_cap_time_unit_pb2.FrequencyCapTimeUnitEnum.FrequencyCapTimeUnit.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["impressions",b"impressions","time_unit",b"time_unit"]) -> None: ...
global___FrequencyCap = FrequencyCap

class Targeting(google.protobuf.message.Message):
    """The targeting for which traffic metrics will be reported."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PLANNABLE_LOCATION_ID_FIELD_NUMBER: builtins.int
    AGE_RANGE_FIELD_NUMBER: builtins.int
    GENDERS_FIELD_NUMBER: builtins.int
    DEVICES_FIELD_NUMBER: builtins.int
    NETWORK_FIELD_NUMBER: builtins.int
    plannable_location_id: typing.Text = ...
    """Required. The ID of the selected location. Plannable location IDs can be
    obtained from [ReachPlanService.ListPlannableLocations][google.ads.googleads.v9.services.ReachPlanService.ListPlannableLocations].
    """

    age_range: google.ads.googleads.v9.enums.reach_plan_age_range_pb2.ReachPlanAgeRangeEnum.ReachPlanAgeRange.ValueType = ...
    """Targeted age range.
    An unset value is equivalent to targeting all ages.
    """

    @property
    def genders(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.ads.googleads.v9.common.criteria_pb2.GenderInfo]:
        """Targeted genders.
        An unset value is equivalent to targeting MALE and FEMALE.
        """
        pass
    @property
    def devices(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[google.ads.googleads.v9.common.criteria_pb2.DeviceInfo]:
        """Targeted devices.
        If not specified, targets all applicable devices. Applicable devices vary
        by product and region and can be obtained from
        [ReachPlanService.ListPlannableProducts][google.ads.googleads.v9.services.ReachPlanService.ListPlannableProducts].
        """
        pass
    network: google.ads.googleads.v9.enums.reach_plan_network_pb2.ReachPlanNetworkEnum.ReachPlanNetwork.ValueType = ...
    """Targetable network for the ad product.
    If not specified, targets all applicable networks. Applicable networks vary
    by product and region and can be obtained from
    [ReachPlanService.ListPlannableProducts][google.ads.googleads.v9.services.ReachPlanService.ListPlannableProducts].
    """

    def __init__(self,
        *,
        plannable_location_id : typing.Optional[typing.Text] = ...,
        age_range : google.ads.googleads.v9.enums.reach_plan_age_range_pb2.ReachPlanAgeRangeEnum.ReachPlanAgeRange.ValueType = ...,
        genders : typing.Optional[typing.Iterable[google.ads.googleads.v9.common.criteria_pb2.GenderInfo]] = ...,
        devices : typing.Optional[typing.Iterable[google.ads.googleads.v9.common.criteria_pb2.DeviceInfo]] = ...,
        network : google.ads.googleads.v9.enums.reach_plan_network_pb2.ReachPlanNetworkEnum.ReachPlanNetwork.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_plannable_location_id",b"_plannable_location_id","plannable_location_id",b"plannable_location_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_plannable_location_id",b"_plannable_location_id","age_range",b"age_range","devices",b"devices","genders",b"genders","network",b"network","plannable_location_id",b"plannable_location_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_plannable_location_id",b"_plannable_location_id"]) -> typing.Optional[typing_extensions.Literal["plannable_location_id"]]: ...
global___Targeting = Targeting

class CampaignDuration(google.protobuf.message.Message):
    """The duration of a planned campaign."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DURATION_IN_DAYS_FIELD_NUMBER: builtins.int
    DATE_RANGE_FIELD_NUMBER: builtins.int
    duration_in_days: builtins.int = ...
    """The duration value in days.

    This field cannot be combined with the date_range field.
    """

    @property
    def date_range(self) -> google.ads.googleads.v9.common.dates_pb2.DateRange:
        """Date range of the campaign.
        Dates are in the yyyy-mm-dd format and inclusive.
        The end date must be < 1 year in the future and the
        date range must be <= 92 days long.

        This field cannot be combined with the duration_in_days field.
        """
        pass
    def __init__(self,
        *,
        duration_in_days : typing.Optional[builtins.int] = ...,
        date_range : typing.Optional[google.ads.googleads.v9.common.dates_pb2.DateRange] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_duration_in_days",b"_duration_in_days","date_range",b"date_range","duration_in_days",b"duration_in_days"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_duration_in_days",b"_duration_in_days","date_range",b"date_range","duration_in_days",b"duration_in_days"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_duration_in_days",b"_duration_in_days"]) -> typing.Optional[typing_extensions.Literal["duration_in_days"]]: ...
global___CampaignDuration = CampaignDuration

class PlannedProduct(google.protobuf.message.Message):
    """A product being planned for reach."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PLANNABLE_PRODUCT_CODE_FIELD_NUMBER: builtins.int
    BUDGET_MICROS_FIELD_NUMBER: builtins.int
    plannable_product_code: typing.Text = ...
    """Required. Selected product for planning.
    The code associated with the ad product. E.g. Trueview, Bumper
    To list the available plannable product codes use
    [ReachPlanService.ListPlannableProducts][google.ads.googleads.v9.services.ReachPlanService.ListPlannableProducts].
    """

    budget_micros: builtins.int = ...
    """Required. Maximum budget allocation in micros for the selected product.
    The value is specified in the selected planning currency_code.
    E.g. 1 000 000$ = 1 000 000 000 000 micros.
    """

    def __init__(self,
        *,
        plannable_product_code : typing.Optional[typing.Text] = ...,
        budget_micros : typing.Optional[builtins.int] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_budget_micros",b"_budget_micros","_plannable_product_code",b"_plannable_product_code","budget_micros",b"budget_micros","plannable_product_code",b"plannable_product_code"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_budget_micros",b"_budget_micros","_plannable_product_code",b"_plannable_product_code","budget_micros",b"budget_micros","plannable_product_code",b"plannable_product_code"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_budget_micros",b"_budget_micros"]) -> typing.Optional[typing_extensions.Literal["budget_micros"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_plannable_product_code",b"_plannable_product_code"]) -> typing.Optional[typing_extensions.Literal["plannable_product_code"]]: ...
global___PlannedProduct = PlannedProduct

class GenerateReachForecastResponse(google.protobuf.message.Message):
    """Response message containing the generated reach curve."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ON_TARGET_AUDIENCE_METRICS_FIELD_NUMBER: builtins.int
    REACH_CURVE_FIELD_NUMBER: builtins.int
    @property
    def on_target_audience_metrics(self) -> global___OnTargetAudienceMetrics:
        """Reference on target audiences for this curve."""
        pass
    @property
    def reach_curve(self) -> global___ReachCurve:
        """The generated reach curve for the planned product mix."""
        pass
    def __init__(self,
        *,
        on_target_audience_metrics : typing.Optional[global___OnTargetAudienceMetrics] = ...,
        reach_curve : typing.Optional[global___ReachCurve] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["on_target_audience_metrics",b"on_target_audience_metrics","reach_curve",b"reach_curve"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["on_target_audience_metrics",b"on_target_audience_metrics","reach_curve",b"reach_curve"]) -> None: ...
global___GenerateReachForecastResponse = GenerateReachForecastResponse

class ReachCurve(google.protobuf.message.Message):
    """The reach curve for the planned products."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    REACH_FORECASTS_FIELD_NUMBER: builtins.int
    @property
    def reach_forecasts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ReachForecast]:
        """All points on the reach curve."""
        pass
    def __init__(self,
        *,
        reach_forecasts : typing.Optional[typing.Iterable[global___ReachForecast]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["reach_forecasts",b"reach_forecasts"]) -> None: ...
global___ReachCurve = ReachCurve

class ReachForecast(google.protobuf.message.Message):
    """A point on reach curve."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    COST_MICROS_FIELD_NUMBER: builtins.int
    FORECAST_FIELD_NUMBER: builtins.int
    PLANNED_PRODUCT_REACH_FORECASTS_FIELD_NUMBER: builtins.int
    cost_micros: builtins.int = ...
    """The cost in micros."""

    @property
    def forecast(self) -> global___Forecast:
        """Forecasted traffic metrics for this point."""
        pass
    @property
    def planned_product_reach_forecasts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___PlannedProductReachForecast]:
        """The forecasted allocation and traffic metrics for each planned product
        at this point on the reach curve.
        """
        pass
    def __init__(self,
        *,
        cost_micros : builtins.int = ...,
        forecast : typing.Optional[global___Forecast] = ...,
        planned_product_reach_forecasts : typing.Optional[typing.Iterable[global___PlannedProductReachForecast]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["forecast",b"forecast"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cost_micros",b"cost_micros","forecast",b"forecast","planned_product_reach_forecasts",b"planned_product_reach_forecasts"]) -> None: ...
global___ReachForecast = ReachForecast

class Forecast(google.protobuf.message.Message):
    """Forecasted traffic metrics for the planned products and targeting."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ON_TARGET_REACH_FIELD_NUMBER: builtins.int
    TOTAL_REACH_FIELD_NUMBER: builtins.int
    ON_TARGET_IMPRESSIONS_FIELD_NUMBER: builtins.int
    TOTAL_IMPRESSIONS_FIELD_NUMBER: builtins.int
    VIEWABLE_IMPRESSIONS_FIELD_NUMBER: builtins.int
    EFFECTIVE_FREQUENCY_BREAKDOWNS_FIELD_NUMBER: builtins.int
    on_target_reach: builtins.int = ...
    """Number of unique people reached at least
    GenerateReachForecastRequest.min_effective_frequency or
    GenerateReachForecastRequest.effective_frequency_limit times that exactly
    matches the Targeting.

    Note that a minimum number of unique people must be reached in order for
    data to be reported. If the minimum number is not met, the on_target_reach
    value will be rounded to 0.
    """

    total_reach: builtins.int = ...
    """Total number of unique people reached at least
    GenerateReachForecastRequest.min_effective_frequency or
    GenerateReachForecastRequest.effective_frequency_limit times. This includes
    people that may fall outside the specified Targeting.

    Note that a minimum number of unique people must be reached in order for
    data to be reported. If the minimum number is not met, the total_reach
    value will be rounded to 0.
    """

    on_target_impressions: builtins.int = ...
    """Number of ad impressions that exactly matches the Targeting."""

    total_impressions: builtins.int = ...
    """Total number of ad impressions. This includes impressions that may fall
    outside the specified Targeting, due to insufficient information on
    signed-in users.
    """

    viewable_impressions: builtins.int = ...
    """Number of times the ad's impressions were considered viewable.
    See https://support.google.com/google-ads/answer/7029393 for
    more information about what makes an ad viewable and how
    viewability is measured.
    """

    @property
    def effective_frequency_breakdowns(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EffectiveFrequencyBreakdown]:
        """A list of effective frequency forecasts. The list is ordered starting with
        1+ and ending with the value set in
        GenerateReachForecastRequest.effective_frequency_limit. If no
        effective_frequency_limit was set, this list will be empty.
        """
        pass
    def __init__(self,
        *,
        on_target_reach : typing.Optional[builtins.int] = ...,
        total_reach : typing.Optional[builtins.int] = ...,
        on_target_impressions : typing.Optional[builtins.int] = ...,
        total_impressions : typing.Optional[builtins.int] = ...,
        viewable_impressions : typing.Optional[builtins.int] = ...,
        effective_frequency_breakdowns : typing.Optional[typing.Iterable[global___EffectiveFrequencyBreakdown]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_on_target_impressions",b"_on_target_impressions","_on_target_reach",b"_on_target_reach","_total_impressions",b"_total_impressions","_total_reach",b"_total_reach","_viewable_impressions",b"_viewable_impressions","on_target_impressions",b"on_target_impressions","on_target_reach",b"on_target_reach","total_impressions",b"total_impressions","total_reach",b"total_reach","viewable_impressions",b"viewable_impressions"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_on_target_impressions",b"_on_target_impressions","_on_target_reach",b"_on_target_reach","_total_impressions",b"_total_impressions","_total_reach",b"_total_reach","_viewable_impressions",b"_viewable_impressions","effective_frequency_breakdowns",b"effective_frequency_breakdowns","on_target_impressions",b"on_target_impressions","on_target_reach",b"on_target_reach","total_impressions",b"total_impressions","total_reach",b"total_reach","viewable_impressions",b"viewable_impressions"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_on_target_impressions",b"_on_target_impressions"]) -> typing.Optional[typing_extensions.Literal["on_target_impressions"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_on_target_reach",b"_on_target_reach"]) -> typing.Optional[typing_extensions.Literal["on_target_reach"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_total_impressions",b"_total_impressions"]) -> typing.Optional[typing_extensions.Literal["total_impressions"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_total_reach",b"_total_reach"]) -> typing.Optional[typing_extensions.Literal["total_reach"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_viewable_impressions",b"_viewable_impressions"]) -> typing.Optional[typing_extensions.Literal["viewable_impressions"]]: ...
global___Forecast = Forecast

class PlannedProductReachForecast(google.protobuf.message.Message):
    """The forecasted allocation and traffic metrics for a specific product
    at a point on the reach curve.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PLANNABLE_PRODUCT_CODE_FIELD_NUMBER: builtins.int
    COST_MICROS_FIELD_NUMBER: builtins.int
    PLANNED_PRODUCT_FORECAST_FIELD_NUMBER: builtins.int
    plannable_product_code: typing.Text = ...
    """Selected product for planning. The product codes returned are within the
    set of the ones returned by ListPlannableProducts when using the same
    location ID.
    """

    cost_micros: builtins.int = ...
    """The cost in micros. This may differ from the product's input allocation
    if one or more planned products cannot fulfill the budget because of
    limited inventory.
    """

    @property
    def planned_product_forecast(self) -> global___PlannedProductForecast:
        """Forecasted traffic metrics for this product."""
        pass
    def __init__(self,
        *,
        plannable_product_code : typing.Text = ...,
        cost_micros : builtins.int = ...,
        planned_product_forecast : typing.Optional[global___PlannedProductForecast] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["planned_product_forecast",b"planned_product_forecast"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cost_micros",b"cost_micros","plannable_product_code",b"plannable_product_code","planned_product_forecast",b"planned_product_forecast"]) -> None: ...
global___PlannedProductReachForecast = PlannedProductReachForecast

class PlannedProductForecast(google.protobuf.message.Message):
    """Forecasted traffic metrics for a planned product."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ON_TARGET_REACH_FIELD_NUMBER: builtins.int
    TOTAL_REACH_FIELD_NUMBER: builtins.int
    ON_TARGET_IMPRESSIONS_FIELD_NUMBER: builtins.int
    TOTAL_IMPRESSIONS_FIELD_NUMBER: builtins.int
    VIEWABLE_IMPRESSIONS_FIELD_NUMBER: builtins.int
    on_target_reach: builtins.int = ...
    """Number of unique people reached that exactly matches the Targeting.

    Note that a minimum number of unique people must be reached in order for
    data to be reported. If the minimum number is not met, the on_target_reach
    value will be rounded to 0.
    """

    total_reach: builtins.int = ...
    """Number of unique people reached. This includes people that may fall
    outside the specified Targeting.

    Note that a minimum number of unique people must be reached in order for
    data to be reported. If the minimum number is not met, the total_reach
    value will be rounded to 0.
    """

    on_target_impressions: builtins.int = ...
    """Number of ad impressions that exactly matches the Targeting."""

    total_impressions: builtins.int = ...
    """Total number of ad impressions. This includes impressions that may fall
    outside the specified Targeting, due to insufficient information on
    signed-in users.
    """

    viewable_impressions: builtins.int = ...
    """Number of times the ad's impressions were considered viewable.
    See https://support.google.com/google-ads/answer/7029393 for
    more information about what makes an ad viewable and how
    viewability is measured.
    """

    def __init__(self,
        *,
        on_target_reach : builtins.int = ...,
        total_reach : builtins.int = ...,
        on_target_impressions : builtins.int = ...,
        total_impressions : builtins.int = ...,
        viewable_impressions : typing.Optional[builtins.int] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_viewable_impressions",b"_viewable_impressions","viewable_impressions",b"viewable_impressions"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_viewable_impressions",b"_viewable_impressions","on_target_impressions",b"on_target_impressions","on_target_reach",b"on_target_reach","total_impressions",b"total_impressions","total_reach",b"total_reach","viewable_impressions",b"viewable_impressions"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_viewable_impressions",b"_viewable_impressions"]) -> typing.Optional[typing_extensions.Literal["viewable_impressions"]]: ...
global___PlannedProductForecast = PlannedProductForecast

class OnTargetAudienceMetrics(google.protobuf.message.Message):
    """Audience metrics for the planned products.
    These metrics consider the following targeting dimensions:

    - Location
    - PlannableAgeRange
    - Gender
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    YOUTUBE_AUDIENCE_SIZE_FIELD_NUMBER: builtins.int
    CENSUS_AUDIENCE_SIZE_FIELD_NUMBER: builtins.int
    youtube_audience_size: builtins.int = ...
    """Reference audience size matching the considered targeting for YouTube."""

    census_audience_size: builtins.int = ...
    """Reference audience size matching the considered targeting for Census."""

    def __init__(self,
        *,
        youtube_audience_size : typing.Optional[builtins.int] = ...,
        census_audience_size : typing.Optional[builtins.int] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_census_audience_size",b"_census_audience_size","_youtube_audience_size",b"_youtube_audience_size","census_audience_size",b"census_audience_size","youtube_audience_size",b"youtube_audience_size"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_census_audience_size",b"_census_audience_size","_youtube_audience_size",b"_youtube_audience_size","census_audience_size",b"census_audience_size","youtube_audience_size",b"youtube_audience_size"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_census_audience_size",b"_census_audience_size"]) -> typing.Optional[typing_extensions.Literal["census_audience_size"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_youtube_audience_size",b"_youtube_audience_size"]) -> typing.Optional[typing_extensions.Literal["youtube_audience_size"]]: ...
global___OnTargetAudienceMetrics = OnTargetAudienceMetrics

class EffectiveFrequencyBreakdown(google.protobuf.message.Message):
    """A breakdown of the number of unique people reached at a given effective
    frequency.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EFFECTIVE_FREQUENCY_FIELD_NUMBER: builtins.int
    ON_TARGET_REACH_FIELD_NUMBER: builtins.int
    TOTAL_REACH_FIELD_NUMBER: builtins.int
    effective_frequency: builtins.int = ...
    """The effective frequency [1-10]."""

    on_target_reach: builtins.int = ...
    """The number of unique people reached at least effective_frequency times that
    exactly matches the Targeting.

    Note that a minimum number of unique people must be reached in order for
    data to be reported. If the minimum number is not met, the on_target_reach
    value will be rounded to 0.
    """

    total_reach: builtins.int = ...
    """Total number of unique people reached at least effective_frequency times.
    This includes people that may fall outside the specified Targeting.

    Note that a minimum number of unique people must be reached in order for
    data to be reported. If the minimum number is not met, the total_reach
    value will be rounded to 0.
    """

    def __init__(self,
        *,
        effective_frequency : builtins.int = ...,
        on_target_reach : builtins.int = ...,
        total_reach : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["effective_frequency",b"effective_frequency","on_target_reach",b"on_target_reach","total_reach",b"total_reach"]) -> None: ...
global___EffectiveFrequencyBreakdown = EffectiveFrequencyBreakdown
